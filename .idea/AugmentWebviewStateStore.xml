<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="AugmentWebviewStateStore">
    <option name="stateMap">
      <map>
        <entry key="CHAT_STATE" value="{&quot;currentConversationId&quot;:&quot;2c9a18bf-842f-44cb-ac92-8f4f746459ec&quot;,&quot;conversations&quot;:{&quot;159a2151-9662-43bf-b9a5-1071aa4e0503&quot;:{&quot;id&quot;:&quot;159a2151-9662-43bf-b9a5-1071aa4e0503&quot;,&quot;createdAtIso&quot;:&quot;2025-05-27T15:43:53.411Z&quot;,&quot;lastInteractedAtIso&quot;:&quot;2025-06-03T20:01:15.036Z&quot;,&quot;chatHistory&quot;:[{&quot;request_id&quot;:&quot;76243f09-ff04-4226-b975-9962bd6ca361&quot;,&quot;uuid&quot;:&quot;9802dc28-5ca3-44af-a96a-f1d3b8a45922&quot;,&quot;chatItemType&quot;:&quot;agentic-checkpoint-delimiter&quot;,&quot;status&quot;:&quot;success&quot;,&quot;fromTimestamp&quot;:0,&quot;toTimestamp&quot;:1748360633414,&quot;seen_state&quot;:&quot;seen&quot;},{&quot;status&quot;:&quot;success&quot;,&quot;request_id&quot;:&quot;60a40c69-e965-42c6-8850-f9b9da65c20c&quot;,&quot;request_message&quot;:&quot;foundry continues to throw errors about actors not existing when we load the game.  I believe this may be caused by the code that is searching for actors to add matrix actions for, and is accessing tokens without a linked actor?&quot;,&quot;rich_text_json_repr&quot;:{&quot;type&quot;:&quot;doc&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;paragraph&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;foundry continues to throw errors about actors not existing when we load the game.  I believe this may be caused by the code that is searching for actors to add matrix actions for, and is accessing tokens without a linked actor?&quot;}]}]},&quot;mentioned_items&quot;:[],&quot;structured_output_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:5,&quot;content&quot;:&quot;&quot;,&quot;tool_use&quot;:{&quot;tool_use_id&quot;:&quot;toolu_vrtx_01TsLKSFeY3fm7rYbpRz16LD&quot;,&quot;tool_name&quot;:&quot;codebase-retrieval&quot;,&quot;input_json&quot;:&quot;{\&quot;information_request\&quot;: \&quot;Code that searches for actors to add matrix actions, particularly any code that accesses tokens and their linked actors. Look for matrix action initialization, token processing, and actor lookup functionality.\&quot;}&quot;,&quot;mcp_server_name&quot;:&quot;&quot;,&quot;mcp_tool_name&quot;:&quot;&quot;}},{&quot;id&quot;:0,&quot;type&quot;:0,&quot;content&quot;:&quot;I'll help you investigate the issue with actors not existing when loading the game, particularly related to matrix actions and tokens without linked actors. Let me start by gathering information about the current codebase and the specific error patterns.\n&quot;},{&quot;id&quot;:2,&quot;type&quot;:2,&quot;content&quot;:&quot;&quot;},{&quot;id&quot;:3,&quot;type&quot;:3,&quot;content&quot;:&quot;&quot;}],&quot;seen_state&quot;:&quot;seen&quot;,&quot;structured_request_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:0,&quot;text_node&quot;:{&quot;content&quot;:&quot;foundry continues to throw errors about actors not existing when we load the game.  I believe this may be caused by the code that is searching for actors to add matrix actions for, and is accessing tokens without a linked actor?&quot;}},{&quot;id&quot;:2,&quot;type&quot;:4,&quot;ide_state_node&quot;:{&quot;workspaceFolders&quot;:[{&quot;repositoryRoot&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;,&quot;folderRoot&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;}],&quot;workspaceFoldersUnchanged&quot;:false,&quot;currentTerminal&quot;:{&quot;terminalId&quot;:12,&quot;currentWorkingDirectory&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;}}}],&quot;timestamp&quot;:&quot;2025-05-29T23:31:59.141Z&quot;,&quot;response_text&quot;:&quot;I'll help you investigate the issue with actors not existing when loading the game, particularly related to matrix actions and tokens without linked actors. Let me start by gathering information about the current codebase and the specific error patterns.\n&quot;,&quot;workspace_file_chunks&quot;:[]},{&quot;status&quot;:&quot;success&quot;,&quot;request_id&quot;:&quot;d77dce7a-d2ae-4c54-b72c-7cd950bc408e&quot;,&quot;request_message&quot;:&quot;&quot;,&quot;structured_output_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:5,&quot;content&quot;:&quot;&quot;,&quot;tool_use&quot;:{&quot;tool_use_id&quot;:&quot;toolu_vrtx_01DMFrRy2RoXAYSBP2y3bFd3&quot;,&quot;tool_name&quot;:&quot;codebase-retrieval&quot;,&quot;input_json&quot;:&quot;{\&quot;information_request\&quot;: \&quot;Code that runs during game initialization or world loading that processes tokens and actors, particularly any hooks or initialization code that might be accessing tokens without checking if they have linked actors. Look for ready hooks, init hooks, and any code that iterates through tokens or scenes.\&quot;}&quot;,&quot;mcp_server_name&quot;:&quot;&quot;,&quot;mcp_tool_name&quot;:&quot;&quot;}},{&quot;id&quot;:0,&quot;type&quot;:0,&quot;content&quot;:&quot;Now let me look for more specific code related to token processing and actor lookup during game initialization:\n&quot;},{&quot;id&quot;:2,&quot;type&quot;:2,&quot;content&quot;:&quot;&quot;},{&quot;id&quot;:3,&quot;type&quot;:3,&quot;content&quot;:&quot;&quot;}],&quot;seen_state&quot;:&quot;seen&quot;,&quot;structured_request_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:1,&quot;tool_result_node&quot;:{&quot;content&quot;:&quot;The following code sections were retrieved:\nPath: src/module/actor/SR6Actor.ts\n...\n   317\t\n   318\t        // Ensure matrix actions are available for all actors that can use the Matrix\n   319\t        if (game.user?.isGM &amp;&amp; this.isOwner &amp;&amp; (this.isCharacter() || this.isSprite() || this.isIC())) {\n   320\t            // Check if we've already added matrix actions to this actor\n   321\t            const hasMatrixActions = this.getFlag('sr6elysium', 'hasMatrixActions');\n   322\t            if (!hasMatrixActions) {\n   323\t                // We need to use a setTimeout to avoid issues with the actor being locked during data preparation\n   324\t                setTimeout(() =&gt; this.ensureMatrixActions(), 500);\n   325\t            }\n   326\t        }\n   327\t    }\n   328\t\n   329\t    /**\n   330\t     * NOTE: This method is unused at the moment, keep it for future inspiration.\n   331\t     */\n   332\t    applyOverrideActiveEffects() {\n   333\t        const changes = this.effects.reduce((changes: EffectChangeData[], effect) =&gt; {\n   334\t            if (effect.data.disabled) return changes;\n...\n  1450\t\n  1451\t    /** Return either the linked token or the token of the synthetic actor.\n  1452\t     *\n  1453\t     * @return Will return null should no token have been placed on scene.\n  1454\t     */\n  1455\t    getToken(): TokenDocument | null {\n  1456\t        // Linked actors can only have one token, which isn't stored within actor data...\n  1457\t        if (this._isLinkedToToken() &amp;&amp; this.hasToken()) {\n  1458\t            const linked = true;\n  1459\t            const tokens = this.getActiveTokens(linked) as unknown as Token[];\n  1460\t            // This assumes for a token to exist and should fail if not.\n  1461\t            return tokens[0].document;\n  1462\t        }\n  1463\t\n  1464\t        // Unlinked actors can have multiple active token but each have theirs directly attached...\n  1465\t        return this.token;\n  1466\t    }\n  1467\t\n  1468\t    /**\n  1469\t     * There is no need for a token to placed. The prototype token is enough.\n  1470\t     */\n  1471\t    _isLinkedToToken(): boolean {\n  1472\t        //@ts-expect-error // TODO: foundry-vtt-types v10\n  1473\t        // If an actor is linked, all it's copies also contain this linked status, even if they're not.\n  1474\t        return this.prototypeToken.actorLink &amp;&amp; !this.token;\n  1475\t    }\n  1476\t\n  1477\t    hasToken(): boolean {\n  1478\t        return this.getActiveTokens().length &gt; 0;\n  1479\t    }\n  1480\t\n  1481\t    hasActivePlayerOwner(): boolean {\n  1482\t        const players = this.getActivePlayerOwners();\n  1483\t        return players.length &gt; 0;\n  1484\t    }\n  1485\t\n  1486\t    getActivePlayer(): User | null {\n  1487\t        if (!game.users) return null;\n  1488\t        if (!this.hasPlayerOwner) return null;\n  1489\t\n  1490\t        for (const user of game.users.contents) {\n  1491\t            if (!user.active || user.isGM) {\n  1492\t                continue;\n  1493\t            }\n  1494\t            if (this.id === user.character?.id) {\n  1495\t                return user;\n  1496\t            }\n  1497\t        }\n  1498\t\n  1499\t        return null;\n  1500\t    }\n...\n  1797\t\n  1798\t    /**\n  1799\t     * The matrix depends on actor type and possibly equipped matrix device.\n  1800\t     *\n  1801\t     * Use this method for whenever you need to access this actors matrix damage track as it's source might differ.\n  1802\t     */\n  1803\t    getMatrixTrack(): Shadowrun.ConditionData | undefined {\n  1804\t        // Some actors will have a direct matrix track.\n  1805\t        if (\&quot;track\&quot; in this.system &amp;&amp; \&quot;matrix\&quot; in this.system.track) {\n  1806\t            return this.system.track.matrix;\n  1807\t        }\n  1808\t\n  1809\t        // Some actors will have a personal matrix condition monitor, like a device condition monitor.\n  1810\t        if (this.isMatrixActor) {\n  1811\t            // @ts-expect-error isMatrixActor checks for the matrix attribute\n  1812\t            return this.system.matrix.condition_monitor;\n  1813\t        }\n...\n  2289\t        if (!target.actor || !target.actor.isMatrixActor) return 0;\n  2290\t\n  2291\t\n  2292\t        const scene = options?.scene || canvas.scene as Scene;\n  2293\t        // If an actor has been targeted, they might have a device. If an item / host has been targeted they don't.\n  2294\t        item = item || target instanceof SR6Actor ? target.actor.getMatrixDevice() : undefined;\n  2295\t\n  2296\t        const markId = Helpers.buildMarkId(scene.id as string, target.id, item?.id as string);\n  2297\t        return this.getMarksById(markId);\n  2298\t    }\n  2299\t\n  2300\t    getMarksById(markId: string): number {\n  2301\t        return this.matrixData?.marks[markId] || 0;\n  2302\t    }\n...\n  2737\t\n  2738\t    /**\n  2739\t     * Ensures that the actor has access to all matrix actions from the matrix-actions compendium.\n  2740\t     * This method will add any missing matrix actions to the actor.\n  2741\t     *\n  2742\t     * @returns {Promise&lt;void&gt;}\n  2743\t     */\n  2744\t    async ensureMatrixActions() {\n  2745\t        console.log(`Shadowrun 6e | Ensuring matrix actions for actor ${this.name} (${this.id})`);\n  2746\t\n  2747\t        // Check if we've already added matrix actions to this actor\n  2748\t        const hasMatrixActions = this.getFlag('sr6elysium', 'hasMatrixActions');\n  2749\t        if (hasMatrixActions) {\n  2750\t            console.log(`Shadowrun 6e | ${this.name} already has matrix actions flag set`);\n  2751\t            return;\n  2752\t        }\n  2753\t\n  2754\t        // Get the matrix actions compendium\n  2755\t        const matrixPack = game.packs.get(\&quot;sr6elysium.matrix-actions\&quot;);\n  2756\t        if (!matrixPack) {\n  2757\t            console.error(\&quot;Shadowrun 6e | Matrix Actions compendium not found\&quot;);\n  2758\t            return;\n  2759\t        }\n  2760\t\n  2761\t        // Get all matrix actions\n  2762\t        await matrixPack.getIndex();\n  2763\t        const matrixActions = await Promise.all(\n  2764\t            Array.from(matrixPack.index).map(i =&gt; matrixPack.getDocument(i._id))\n  2765\t        );\n  2766\t\n  2767\t        // Get existing action names to avoid duplicates\n  2768\t        const existingNames = this.items\n  2769\t            .filter(i =&gt; i.type === \&quot;action\&quot;)\n  2770\t            .map(i =&gt; i.name.toLowerCase());\n  2771\t\n  2772\t        // Filter out actions the actor already has\n  2773\t        const actionsToAdd = matrixActions.filter(\n  2774\t            a =&gt; !existingNames.includes(a.name.toLowerCase())\n  2775\t        );\n  2776\t\n  2777\t        if (actionsToAdd.length === 0) {\n  2778\t            console.log(`Shadowrun 6e | ${this.name} already has all matrix actions`);\n  2779\t            // Set the flag to indicate that we've checked for matrix actions\n  2780\t            await this.setFlag('sr6elysium', 'hasMatrixActions', true);\n  2781\t            return;\n  2782\t        }\n  2783\t\n  2784\t        // Add the actions\n  2785\t        await this.createEmbeddedDocuments(\n  2786\t            \&quot;Item\&quot;,\n  2787\t            actionsToAdd.map(a =&gt; a.toObject())\n  2788\t        );\n  2789\t\n  2790\t        console.log(`Shadowrun 6e | Added ${actionsToAdd.length} matrix actions to ${this.name}`);\n  2791\t\n  2792\t        // Set the flag to indicate that we've added matrix actions\n  2793\t        await this.setFlag('sr6elysium', 'hasMatrixActions', true);\n  2794\t    }\n  2795\t\n  2796\t    async newSceneSetup() {\n  2797\t        const updateData: Record&lt;string, any&gt; = {};\n  2798\t\n  2799\t        updateData['system.attributes.edge.uses'] = this.getEdge().value;\n  2800\t\n  2801\t        if(updateData) await this.update(updateData);\n  2802\t    }\n...\nPath: src/module/actor/prep/functions/InitiativePrep.ts\n...\n    94\t\n    95\t    static prepareMatrixInit(system: ActorTypesData &amp; MatrixActorData) {\n    96\t        const { initiative, attributes, modifiers, matrix } = system;\n    97\t        if (matrix) {\n    98\t\n    99\t            initiative.matrix.base.base = attributes.intuition.value + system.matrix.data_processing.value;\n   100\t            initiative.matrix.base.mod = PartsList.AddUniquePart(initiative.matrix.base.mod, \&quot;SR6.Bonus\&quot;, Number(modifiers['matrix_initiative']));\n   101\t            initiative.matrix.base.value = Helpers.calcTotal(initiative.matrix.base);\n   102\t\n   103\t            initiative.matrix.dice.base = (matrix.hot_sim ? 4 : 3);\n   104\t            initiative.matrix.dice.mod = PartsList.AddUniquePart(initiative.matrix.dice.mod, \&quot;SR6.Bonus\&quot;, Number(modifiers['matrix_initiative_dice']));\n   105\t            initiative.matrix.dice.value = Helpers.calcTotal(initiative.matrix.dice, {min: 0, max: 5});\n   106\t        }\n   107\t    }\n   108\t}\n...\nPath: src/module/actor/prep/functions/MatrixPrep.ts\n...\n     9\t\n    10\texport class MatrixPrep {\n    11\t    /**\n    12\t     * Prepare Matrix data on the actor\n    13\t     * - if an item is equipped, it will use that data\n    14\t     * - if it isn't and player is technomancer, it will use that data\n    15\t     */\n    16\t    static prepareMatrix(system: ActorTypesData &amp; MatrixActorData, items: SR6ItemDataWrapper[]) {\n    17\t        const { matrix, attributes, modifiers } = system;\n    18\t\n    19\t        const MatrixList = ['firewall', 'sleaze', 'data_processing', 'attack'];\n    20\t\n    21\t        // clear matrix data to defaults\n    22\t        MatrixList.forEach((key) =&gt; {\n    23\t            const parts = new PartsList(matrix[key].mod);\n    24\t            if (matrix[key].temp) parts.addUniquePart('SR6.Temporary', matrix[key].temp);\n    25\t            // LEGACY from when the sheet used 'mod.Temporary'\n    26\t            parts.removePart('Temporary');\n    27\t            matrix[key].mod = parts.list;\n    28\t            matrix[key].value = parts.total;\n    29\t        });\n...\n    38\t\n    39\t        if (device) {\n    40\t            matrix.device = device.getId();\n    41\t\n    42\t            const conditionMonitor = device.getConditionMonitor();\n    43\t\n    44\t            matrix.condition_monitor.max = conditionMonitor.max + Number(modifiers.matrix_track);\n    45\t            matrix.condition_monitor.value = conditionMonitor.value;\n    46\t            matrix.rating = device.getRating();\n    47\t            matrix.is_cyberdeck = device.isCyberdeck();\n    48\t            matrix.name = device.getName();\n    49\t            matrix.item = device.getData();\n    50\t            const deviceAtts = device.getASDF();\n    51\t            if (deviceAtts) {\n    52\t                // setup the actual matrix attributes for the actor\n    53\t                for (const [key, value] of Object.entries(deviceAtts)) {\n    54\t                    if (value &amp;&amp; matrix[key]) {\n    55\t                        matrix[key].base = value.value;\n    56\t                        matrix[key].device_att = value.device_att;\n    57\t                    }\n    58\t                }\n    59\t            }\n...\nPath: src/module/actor/prep/ICPrep.ts\n...\n    43\t\n    44\t    /**\n    45\t     * On initial actor creation the matrix track will be missing.\n    46\t     *\n    47\t     * This is intentional as not to pollute template.json with actor type specific data.\n    48\t     *\n    49\t     */\n    50\t    static addMissingTracks(system: ICData) {\n    51\t        // Newly created actors SHOULD have this by template.\n    52\t        // Legacy actors MIGHT not have it, therefore make sure it's there.\n    53\t        const track = system.track || {};\n    54\t        if (!track.matrix) track.matrix = DataDefaults.trackData();\n    55\t        system.track = track;\n    56\t    }\n    57\t\n    58\t    /**\n    59\t     * Add IC modifiers only to the misc tab.\n    60\t     * @param system\n    61\t     */\n    62\t    static prepareModifiers(system: ICData) {\n    63\t        let modifiers = ModifiersPrep.commonModifiers as string[];\n    64\t        modifiers = modifiers.concat(ModifiersPrep.matrixModifiers as string[]);\n    65\t        ModifiersPrep.setupModifiers(system, modifiers);\n    66\t    }\n...\n    85\t\n    86\t    static prepareMatrixInit(system: ICData) {\n    87\t        const { initiative, modifiers, host } = system;\n    88\t\n    89\t\n    90\t        // Set current initiative to matrix\n    91\t        initiative.perception = 'matrix';\n    92\t\n    93\t        // Prepare used initiative parts\n    94\t        initiative.matrix.base.base = MatrixRules.getICInitiativeBase(host.rating);\n    95\t        initiative.matrix.base.mod = PartsList.AddUniquePart(initiative.matrix.base.mod, \&quot;SR6.Bonus\&quot;, Number(modifiers['matrix_initiative']));\n    96\t\n    97\t        initiative.matrix.dice.base = MatrixRules.getICInitiativeDice();\n    98\t        initiative.matrix.dice.mod = PartsList.AddUniquePart(initiative.matrix.dice.mod, \&quot;SR6.Bonus\&quot;, Number(modifiers['matrix_initiative_dice']));\n    99\t    }\n...\nPath: src/module/helpers.ts\n...\n   307\t\n   308\t    // TODO: Foundry 0.9 Should TokenDocument be used instead of Token?\n   309\t    // TODO: Check canvas.scene.tokens\n   310\t    static getToken(id?: string): Token | undefined {\n   311\t        if (!canvas || !canvas.ready || !canvas.tokens) return;\n   312\t\n   313\t        for (const token of canvas.tokens.placeables) {\n   314\t            if (token.id === id) {\n   315\t                return token;\n   316\t            }\n   317\t        }\n   318\t    }\n   319\t\n   320\t    /**\n   321\t     * Use this helper to get a tokens actor from any given scene id.\n   322\t     * @param sceneTokenId A mixed id with the format '&lt;sceneId&gt;.&lt;tokenid&gt;\n   323\t     */\n   324\t    static getSceneTokenActor(sceneTokenId: string): SR6Actor | null {\n   325\t        const [sceneId, tokenId] = Helpers.deconstructSceneTokenId(sceneTokenId);\n   326\t        const token = Helpers.getSceneTokenDocument(sceneId, tokenId);\n   327\t        if (!token) return null;\n   328\t        return token.getActor();\n   329\t    }\n...\nPath: packs/_source/system-macros/add_matrix_actions.json\n     1\t{\n     2\t  \&quot;_id\&quot;: \&quot;addMatrixActions\&quot;,\n     3\t  \&quot;name\&quot;: \&quot;Add Matrix Actions to Selected Actors\&quot;,\n     4\t  \&quot;type\&quot;: \&quot;script\&quot;,\n     5\t  \&quot;img\&quot;: \&quot;icons/svg/dice-target.svg\&quot;,\n     6\t  \&quot;scope\&quot;: \&quot;global\&quot;,\n...\n     8\t  \&quot;folder\&quot;: null,\n     9\t  \&quot;sort\&quot;: 0,\n    10\t  \&quot;ownership\&quot;: {\n    11\t    \&quot;default\&quot;: 0\n    12\t  },\n    13\t  \&quot;flags\&quot;: {},\n    14\t  \&quot;_stats\&quot;: {\n    15\t    \&quot;systemId\&quot;: \&quot;sr6elysium\&quot;,\n    16\t    \&quot;systemVersion\&quot;: \&quot;0.24.0\&quot;,\n    17\t    \&quot;coreVersion\&quot;: \&quot;11\&quot;,\n    18\t    \&quot;createdTime\&quot;: 1718560000000,\n    19\t    \&quot;modifiedTime\&quot;: 1718560000000,\n    20\t    \&quot;lastModifiedBy\&quot;: \&quot;developer\&quot;\n    21\t  },\n    22\t  \&quot;_key\&quot;: \&quot;!macros!addMatrixActions\&quot;\n    23\t}\n...\nPath: src/module/item/flows/ActionFlow.ts\n     1\t/**\n     2\t * Handle all things related to the action template (template.json)\n     3\t */\n     4\timport { SR6Actor } from \&quot;../../actor/SR6Actor\&quot;;\n     5\timport { Helpers } from \&quot;../../helpers\&quot;;\n     6\timport { SR6Item } from \&quot;../SR6Item\&quot;;\n     7\timport { PartsList } from \&quot;../../parts/PartsList\&quot;;\n     8\timport { SR6 } from \&quot;../../config\&quot;;\n     9\timport { DataDefaults } from \&quot;../../data/DataDefaults\&quot;;\n    10\timport { Translation } from \&quot;../../utils/strings\&quot;;\n    11\t\n    12\texport class ActionFlow {\n    13\t    /**\n    14\t     * Calculate action damage configuration based on flat damage field and possible dynamic attribute modification.\n    15\t     *\n    16\t     * @param damage The damage field as defined within the ActionData\n    17\t     * @param actor The actor to use should a dynamic calculation be needed.\n    18\t     * @param item\n    19\t     */\n    20\t    static calcDamageData(damage: Shadowrun.DamageData, actor?: SR6Actor, item?: SR6Item): Shadowrun.DamageData {\n    21\t        // Avoid manipulation on original data, which might come from database values.\n    22\t        damage = foundry.utils.duplicate(damage);\n    23\t\n    24\t        if (!actor) return damage;\n    25\t\n    26\t        if (item) {\n    27\t            damage.source = ActionFlow._damageSource(actor, item);\n    28\t        }\n    29\t\n    30\t        this._applyModifiableValue(damage, actor);\n    31\t        damage.value = Helpers.calcTotal(damage, { min: 0 });\n    32\t\n    33\t        this._applyModifiableValue(damage.ap, actor);\n    34\t        damage.ap.value = Helpers.calcTotal(damage.ap, { min: 0 });\n    35\t\n    36\t        return damage;\n    37\t    }\n    38\t\n    39\t    static _applyModifiableValue(value: Shadowrun.ModifiableValueLinked, actor: SR6Actor) {\n    40\t        const attribute = actor.findAttribute(value.attribute);\n    41\t        if (!attribute) return;\n    42\t\n    43\t        if (!value.base_formula_operator) {\n    44\t            console.error(`Unsupported formula operator: '${value.base_formula_operator}' used. Falling back to 'add'.`);\n    45\t            value.base_formula_operator = 'add';\n    46\t        }\n    47\t\n    48\t        // Avoid altering base OR value fields and raising the resulting damage on multiple function calls.\n    49\t        switch (value.base_formula_operator) {\n    50\t            case \&quot;add\&quot;:\n    51\t                PartsList.AddUniquePart(value.mod, attribute.label, attribute.value);\n    52\t                break;\n    53\t            case \&quot;subtract\&quot;:\n    54\t                PartsList.AddUniquePart(value.mod, attribute.label, -attribute.value);\n    55\t                break;\n    56\t            case \&quot;multiply\&quot;:\n    57\t                PartsList.AddUniquePart(value.mod, 'SR6.Value', (value.base * attribute.value) - value.base);\n    58\t                break;\n    59\t            case \&quot;divide\&quot;:\n    60\t                // Remove base from value by modifying.\n    61\t                PartsList.AddUniquePart(value.mod, 'SR6.BaseValue', value.base * -1);\n    62\t                // Add division result as modifier on zero.\n    63\t                const denominator = attribute.value === 0 ? 1 : attribute.value;\n    64\t                PartsList.AddUniquePart(value.mod, 'SR6.Value', Math.floor(value.base / denominator));\n    65\t                break;\n    66\t        }\n    67\t    }\n    68\t\n    69\t    /**\n    70\t     * Damage that's caused by an item can later be used to determine how that damage should be applied\n    71\t     *\n    72\t     * @param actor The actor used to determine damage\n    73\t     * @param item The item from which damage's been determined from.\n    74\t     */\n    75\t    static _damageSource(actor: SR6Actor, item: SR6Item): Shadowrun.DamageSource {\n    76\t        return {\n    77\t            actorId: actor.id || '',\n    78\t            itemId: item.id || '',\n    79\t            itemName: item.name || '',\n    80\t            itemType: item.type\n    81\t        }\n    82\t    }\n...\n   113\t        //        The major use case is the sidebar item creation, where no actor is available.\n   114\t        if (!actor || actor.isIC()) {\n   115\t            // Inject this items custom skill into the global skill list.\n   116\t            const globalSkills = foundry.utils.deepClone(SR6.activeSkills);\n   117\t            ActionFlow._injectMissingCustomSkill(globalSkills, skillName);\n   118\t            return Helpers.sortConfigValuesByTranslation(globalSkills);\n   119\t        }\n...\nPath: src/module/item/flows/ActionResultFlow.ts\n...\n    43\t    /**\n    44\t     * Matrix Marks are placed on either actors (persona, ic) or items (device, host, technology).\n    45\t     */\n    46\t    static async placeMatrixMarks(active: SR6Actor, targets: Token[], marks: number) {\n    47\t        if (!MatrixRules.isValidMarksCount(marks)) {\n    48\t            return ui.notifications?.warn(game.i18n.localize(\&quot;SR6.Warnings.InvalidMarksCount\&quot;));\n    49\t        }\n    50\t\n    51\t        for (const target of targets) {\n    52\t            await active.setMarks(target, marks);\n    53\t        }\n    54\t    }\n    55\t\n    56\t    /**\n    57\t     * Modify the actors combatant according the test defined initiative modifier.\n    58\t     *\n    59\t     * @param test The test instance causing the initiative modification\n    60\t     */\n    61\t    static async _castInitModifierAction(test: PhysicalDefenseTest) {\n    62\t        if (!(test instanceof PhysicalDefenseTest)) return;\n    63\t\n    64\t        if (!test.data.iniMod) return;\n    65\t        await test.actor?.changeCombatInitiative(test.data.iniMod);\n    66\t    }\n    67\t}\n...\n&quot;,&quot;is_error&quot;:false,&quot;request_id&quot;:&quot;&quot;,&quot;tool_use_id&quot;:&quot;toolu_vrtx_01TsLKSFeY3fm7rYbpRz16LD&quot;}},{&quot;id&quot;:2,&quot;type&quot;:4,&quot;ide_state_node&quot;:{&quot;workspaceFolders&quot;:[{&quot;repositoryRoot&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;,&quot;folderRoot&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;}],&quot;workspaceFoldersUnchanged&quot;:false,&quot;currentTerminal&quot;:{&quot;terminalId&quot;:12,&quot;currentWorkingDirectory&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;}}}],&quot;timestamp&quot;:&quot;2025-05-29T23:32:11.043Z&quot;,&quot;response_text&quot;:&quot;Now let me look for more specific code related to token processing and actor lookup during game initialization:\n&quot;,&quot;workspace_file_chunks&quot;:[]},{&quot;status&quot;:&quot;success&quot;,&quot;request_id&quot;:&quot;933964ef-27f6-47ab-a531-473c17b8837c&quot;,&quot;request_message&quot;:&quot;&quot;,&quot;structured_output_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:5,&quot;content&quot;:&quot;&quot;,&quot;tool_use&quot;:{&quot;tool_use_id&quot;:&quot;toolu_vrtx_01QoZMNMfqm8PKi5uRBtygv2&quot;,&quot;tool_name&quot;:&quot;str-replace-editor&quot;,&quot;input_json&quot;:&quot;{\&quot;command\&quot;: \&quot;view\&quot;, \&quot;path\&quot;: \&quot;src/module/actor/SR6Actor.ts\&quot;, \&quot;view_range\&quot;: [315, 330]}&quot;,&quot;mcp_server_name&quot;:&quot;&quot;,&quot;mcp_tool_name&quot;:&quot;&quot;}},{&quot;id&quot;:0,&quot;type&quot;:0,&quot;content&quot;:&quot;Now let me look at the specific error patterns and the matrix action initialization code more closely:\n&quot;},{&quot;id&quot;:2,&quot;type&quot;:2,&quot;content&quot;:&quot;&quot;},{&quot;id&quot;:3,&quot;type&quot;:3,&quot;content&quot;:&quot;&quot;}],&quot;seen_state&quot;:&quot;seen&quot;,&quot;structured_request_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:1,&quot;tool_result_node&quot;:{&quot;content&quot;:&quot;The following code sections were retrieved:\nPath: src/module/hooks.ts\n...\n    70\timport { SuccessTestEffectsFlow } from './effect/flows/SuccessTestEffectsFlow';\n    71\timport { JournalEnrichers } from './journal/enricher';\n    72\timport { DataStorage } from './data/DataStorage';\n    73\t\n    74\t\n    75\t\n    76\t// Redeclare SR5config as a global as foundry-vtt-types CONFIG with SR5 property causes issues.\n    77\texport const SR6CONFIG = SR6;\n    78\t\n    79\texport class HooksManager {\n    80\t    static registerHooks() {\n    81\t        console.log('Shadowrun 6e | Registering system hooks');\n    82\t        // Register your highest level hook callbacks here for a quick overview of what's hooked into.\n    83\t\n    84\t        Hooks.once('init', HooksManager.init);\n    85\t        Hooks.once('setup', AutocompleteInlineHooksFlow.setupHook);\n    86\t\n    87\t        Hooks.on('canvasInit', canvasInit);\n    88\t        Hooks.on('ready', HooksManager.ready);\n    89\t        Hooks.on('hotbarDrop', HooksManager.hotbarDrop);\n    90\t        Hooks.on('renderSceneControls', HooksManager.renderSceneControls);\n    91\t        Hooks.on('getSceneControlButtons', HooksManager.getSceneControlButtons);\n    92\t        Hooks.on('getCombatTrackerEntryContext', SR6Combat.addCombatTrackerContextOptions);\n    93\t        Hooks.on('renderItemDirectory', HooksManager.renderItemDirectory);\n    94\t        // Hooks.on('renderTokenHUD', EnvModifiersApplication.addTokenHUDFields);\n    95\t        Hooks.on('renderTokenHUD', SituationModifiersApplication.onRenderTokenHUD);\n    96\t        Hooks.on('updateItem', HooksManager.updateIcConnectedToHostItem);\n    97\t        Hooks.on('deleteItem', HooksManager.removeDeletedItemsFromNetworks);\n...\n   107\t\n   108\t    static init() {\n   109\t        console.log(`Loading Shadowrun 5e System\n   110\t___________________\n   111\t ___________ _____ \n   112\t/  ___| ___ \\\\  ___|\n   113\t\\\\ \\`--.| |_/ /___ \\\\ \n   114\t \\`--. \\\\    /    \\\\ \\\\\n   115\t/\\\\__/ / |\\\\ \\\\/\\\\__/ /\n   116\t\\\\____/\\\\_| \\\\_\\\\____/ \n   117\t===================\n   118\t`);\n   119\t        // Create a sr6elysium namespace within the game global\n   120\t        game['sr6elysium'] = {\n   121\t            /**\n   122\t             * System level Document implementations.\n   123\t             */\n   124\t            SR6Actor: SR6Actor,\n   125\t            SR6Item: SR6Item,\n   126\t            SR6ActiveEffect: SR6ActiveEffect,\n   127\t            /**\n   128\t             * Macro hooks used when something's dropped onto the hotbar.\n   129\t             */\n   130\t            rollItemMacro,\n   131\t            rollSkillMacro,\n   132\t            /**\n   133\t             * Should you only really need dice handling, use this. If you need more complex testing behaviour,\n   134\t             * check the Test implementations.\n   135\t             */\n   136\t            SR6Roll: SR6Roll,\n...\n   330\t\n   331\t        HooksManager.configureVision()\n   332\t\n   333\t        HooksManager.configureTextEnrichers();\n   334\t\n   335\t        // Preload might reduce loading time during play.\n   336\t        HandlebarManager.loadTemplates();\n   337\t\n   338\t        // Register Tours\n   339\t        registerSR6Tours();\n   340\t\n   341\t        DataStorage.validate();\n   342\t    }\n   343\t\n   344\t    static async ready() {\n   345\t        if (game.user?.isGM) {\n   346\t            // Prohibit migration on empty worlds...\n   347\t            if (Migrator.isEmptyWorld) {\n   348\t                await Migrator.InitWorldForMigration();\n   349\t                return;\n   350\t            }\n   351\t\n   352\t            // On populated worlds, try migrating\n   353\t            await Migrator.BeginMigration();\n   354\t\n   355\t            if (ChangelogApplication.showApplication) {\n   356\t                await new ChangelogApplication().render(true);\n   357\t            }\n   358\t        }\n...\n   446\t\n   447\t        if (item.isHost) {\n   448\t            // Collect actors from sidebar and active scene to update / rerender\n   449\t            let connectedIC = [\n   450\t                // All sidebar actors should also include tokens with linked actors.\n   451\t                ...game.actors.filter((actor: SR6Actor) =&gt; actor.isIC() &amp;&amp; actor.hasHost()) as SR6Actor[],\n   452\t                // All token actors that aren't linked.\n   453\t                // @ts-expect-error // TODO: foundry-vtt-types v10\n   454\t                ...canvas.scene.tokens.filter(token =&gt; !token.actorLink &amp;&amp; token.actor?.isIC() &amp;&amp; token.actor?.hasHost()).map(t =&gt; t.actor)\n   455\t            ];\n   456\t\n   457\t            // Update host data on the ic actor.\n   458\t            const host = item.asHost;\n   459\t            if (!host) return;\n   460\t            for (const ic of connectedIC) {\n   461\t                if (!ic) continue;\n   462\t                await ic._updateICHostData(host);\n   463\t            }\n   464\t        }\n   465\t    }\n...\n   470\t\n   471\t    /**\n   472\t     * This method is used as a simple place to register socket hook handlers for the system.\n   473\t     *\n   474\t     * You can use the SocketMessage for sending messages using a socket event message id and generic data object.\n   475\t     */\n   476\t    static registerSocketListeners() {\n   477\t        if (!game.socket || !game.user) return;\n   478\t        console.log('Registering sr6elysium system socket messages...');\n   479\t        const hooks: Shadowrun.SocketMessageHooks = {\n   480\t            [FLAGS.addNetworkController]: [NetworkDeviceFlow._handleAddNetworkControllerSocketMessage],\n   481\t            [FLAGS.DoNextRound]: [SR6Combat._handleDoNextRoundSocketMessage],\n   482\t            [FLAGS.DoInitPass]: [SR6Combat._handleDoInitPassSocketMessage],\n   483\t            [FLAGS.DoNewActionPhase]: [SR6Combat._handleDoNewActionPhaseSocketMessage],\n...\n   488\t\n   489\t        game.socket.on(SYSTEM_SOCKET, async (message: Shadowrun.SocketMessageData) =&gt; {\n   490\t            console.log('Shadowrun 6e | Received system socket message.', message);\n   491\t\n   492\t            const handlers = hooks[message.type];\n   493\t            if (!handlers || handlers.length === 0) return console.warn('Shadowrun 6e | System socket message has no registered handler!', message);\n   494\t            // In case of targeted socket message only execute with target user (intended for GM usage)\n   495\t            if (message.userId &amp;&amp; game.user?.id !== message.userId) return;\n   496\t            if (message.userId &amp;&amp; game.user?.id) console.log('Shadowrun 6e | GM is handling system socket message');\n   497\t\n   498\t            for (const handler of handlers) {\n   499\t                console.debug(`Shadowrun 6e | Handover system socket message to handler: ${handler.name}`);\n   500\t                await handler(message);\n   501\t            }\n   502\t        });\n   503\t    }\n...\nPath: src/module/targeting/index.ts\n...\n     2\t\n     3\t/**\n     4\t * Register targeting hooks\n     5\t */\n     6\texport function registerTargetingHooks() {\n     7\t    // Register a hook to highlight valid targets when an item is used\n     8\t    Hooks.on('sr6:preItemRoll', (item, actor) =&gt; {\n     9\t        // Only highlight targets for items that can target other actors\n    10\t        if (item.isRangedWeapon() || item.isSpell() || item.isMatrixAction()) {\n    11\t            TargetingService.highlightValidTargets(item, actor);\n    12\t        }\n    13\t    });\n    14\t    \n    15\t    // Register a hook to clear target highlights when an item roll is complete\n    16\t    Hooks.on('sr6:itemRoll', () =&gt; {\n    17\t        TargetingService.clearTargetHighlights();\n    18\t    });\n    19\t    \n    20\t    // Register a hook to clear target highlights when an item roll is cancelled\n    21\t    Hooks.on('sr6:itemRollCancel', () =&gt; {\n    22\t        TargetingService.clearTargetHighlights();\n    23\t    });\n    24\t    \n    25\t    console.log(\&quot;Shadowrun 6e | Targeting hooks registered\&quot;);\n    26\t}\n...\nPath: src/module/actor/prep/CharacterPrep.ts\n...\n    28\t\n    29\t    /**\n    30\t     * All derived data should depend on basic values like Attributes or Skills.\n    31\t     *\n    32\t     * It shouldn't be modified by Active Effects, which instead should modify the global modifiers.\n    33\t     *\n    34\t     * @param system\n    35\t     * @param items\n    36\t     */\n    37\t    static prepareDerivedData(system: Shadowrun.CharacterData, items: SR6ItemDataWrapper[]) {\n    38\t        AttributesPrep.prepareAttributes(system);\n    39\t        AttributesPrep.prepareEssence(system, items);\n    40\t\n    41\t        // NPCPrep is reliant to be called after AttributesPrep.\n    42\t        NPCPrep.prepareNPCData(system);\n    43\t\n    44\t        SkillsPrep.prepareSkills(system);\n    45\t\n    46\t        ItemPrep.prepareArmor(system, items);\n    47\t        ItemPrep.prepareWeapons(system, items);\n    48\t\n    49\t        MatrixPrep.prepareMatrix(system, items);\n    50\t        MatrixPrep.prepareMatrixToLimitsAndAttributes(system);\n    51\t\n    52\t        GruntPrep.prepareConditionMonitors(system);\n...\nPath: src/module/actor/prep/ICPrep.ts\n...\n    13\t\n    14\t\n    15\texport class ICPrep {\n    16\t    static prepareBaseData(system: ICData) {\n    17\t        ModifiersPrep.clearAttributeMods(system);\n    18\t        ModifiersPrep.clearLimitMods(system);\n    19\t        SkillsPrep.prepareSkillData(system);\n    20\t\n    21\t        ICPrep.addMissingTracks(system);\n    22\t        ICPrep.prepareModifiers(system);\n    23\t        ICPrep.hideMeatAttributes(system);\n    24\t        ICPrep.addHostAttributes(system);\n    25\t    }\n    26\t\n    27\t    static prepareDerivedData(system: ICData, items: SR6ItemDataWrapper[]) {\n    28\t        ICPrep.prepareMatrixAttributes(system);\n    29\t\n    30\t        SkillsPrep.prepareSkills(system);\n    31\t\n    32\t        ICPrep.prepareHostAttributes(system);\n    33\t        ICPrep.prepareMeatAttributes(system);\n    34\t\n    35\t        MatrixPrep.prepareMatrixToLimitsAndAttributes(system);\n    36\t\n    37\t        ICPrep.prepareMatrix(system);\n    38\t        ICPrep.prepareMatrixTrack(system);\n    39\t\n    40\t        ICPrep.prepareMatrixInit(system);\n    41\t        InitiativePrep.prepareCurrentInitiative(system);\n    42\t    }\n...\nPath: src/module/main.ts\n     1\timport { HandlebarManager } from './handlebars/HandlebarManager';\n     2\timport {HooksManager} from \&quot;./hooks\&quot;;\n     3\t\n     4\t/* -------------------------------------------- */\n     5\t/*  Foundry VTT Initialization                  */\n     6\t/* -------------------------------------------- */\n     7\t\n     8\t\n     9\tHooksManager.registerHooks();\n    10\tHandlebarManager.registerHelpers();...\nPath: src/module/canvas.ts\n     1\timport {FLAGS, SYSTEM_NAME} from './constants';\n     2\t\n     3\tinterface DistanceOptions {\n     4\t    gridSpaces?: boolean\n     5\t}\n     6\t\n     7\t/**\n     8\t * Pulled from the FoundryVTT DND5e system: grid.mjs#measureDistance\n     9\t * \n    10\t * @param segments \n    11\t * @param options \n    12\t * @returns \n    13\t */\n    14\tconst measureDistances = function (segments, options: DistanceOptions = {}) {\n    15\t    if (!options.gridSpaces) return BaseGrid.prototype.measureDistances.call(this, segments, options);\n    16\t\n    17\t    // Track the total number of diagonals\n    18\t    let nDiagonal = 0;\n    19\t    const rule = this.diagonalRule;\n    20\t    const d = canvas.dimensions as Canvas.Dimensions;\n    21\t\n    22\t    // Iterate over measured segments\n    23\t    return segments.map((s) =&gt; {\n    24\t        let r = s.ray;\n    25\t\n    26\t        // Determine the total distance traveled\n    27\t        let nx = Math.abs(Math.ceil(r.dx / d.size));\n    28\t        let ny = Math.abs(Math.ceil(r.dy / d.size));\n    29\t\n    30\t        // Determine the number of straight and diagonal moves\n    31\t        let nd = Math.min(nx, ny);\n    32\t        let ns = Math.abs(ny - nx);\n    33\t        nDiagonal += nd;\n    34\t\n    35\t        // Estimate diagonal like other battle grid systems do. (DnD5e)\n    36\t        if (rule === '1-2-1') {\n    37\t            let nd10 = Math.floor(nDiagonal / 2) - Math.floor((nDiagonal - nd) / 2);\n    38\t            let spaces = nd10 * 2 + (nd - nd10) + ns;\n    39\t            // @ts-expect-error TODO: foundry-vtt-types v10\n    40\t            return spaces * canvas.dimensions.distance;\n    41\t        }\n    42\t\n    43\t        // Treat diagonal as straight line\n    44\t        else if (rule === 'EUCL') {\n    45\t            // @ts-expect-error TODO: foundry-vtt-types v10\n    46\t            // return Math.round(Math.hypot(nx, ny) * canvas.scene.data.gridDistance);\n    47\t            return Math.round(Math.hypot(nx, ny) * canvas.scene?.grid.distance);\n    48\t        }\n    49\t\n    50\t        // Treat diagonal as straight movement\n    51\t        // @ts-expect-error TODO: foundry-vtt-types v10\n    52\t        else return (ns + nd) * canvas.scene?.grid.distance;\n    53\t    });\n    54\t};\n    55\t\n    56\t\n    57\texport function canvasInit() {\n    58\t    //@ts-expect-error TODO: foundry-vtt-types v10\n    59\t    // Copy DnD5e's approach to movement measurement and add a custom field to the grid to be used in canvas.ts#measureDistances\n    60\t    canvas.grid.diagonalRule = game.settings.get(SYSTEM_NAME, FLAGS.DiagonalMovement);\n    61\t    // Add a custom measureDistances function, overwriting default to add more movement styles.\n    62\t    SquareGrid.prototype.measureDistances = measureDistances;\n    63\t}...\nPath: src/module/helpers.ts\n...\n   307\t\n   308\t    // TODO: Foundry 0.9 Should TokenDocument be used instead of Token?\n   309\t    // TODO: Check canvas.scene.tokens\n   310\t    static getToken(id?: string): Token | undefined {\n   311\t        if (!canvas || !canvas.ready || !canvas.tokens) return;\n   312\t\n   313\t        for (const token of canvas.tokens.placeables) {\n   314\t            if (token.id === id) {\n   315\t                return token;\n   316\t            }\n   317\t        }\n   318\t    }\n   319\t\n   320\t    /**\n   321\t     * Use this helper to get a tokens actor from any given scene id.\n   322\t     * @param sceneTokenId A mixed id with the format '&lt;sceneId&gt;.&lt;tokenid&gt;\n   323\t     */\n   324\t    static getSceneTokenActor(sceneTokenId: string): SR6Actor | null {\n   325\t        const [sceneId, tokenId] = Helpers.deconstructSceneTokenId(sceneTokenId);\n   326\t        const token = Helpers.getSceneTokenDocument(sceneId, tokenId);\n   327\t        if (!token) return null;\n   328\t        return token.getActor();\n   329\t    }\n...\nPath: shadowrun6-genesis-importer/module/main.js\n     1\timport { GenesisImportForm } from './apps/genesis-import-form.js';\n     2\t\n     3\tHooks.once('init', () =&gt; {\n     4\t    console.log('Shadowrun 6e Genesis Importer | Initializing module');\n     5\t});\n     6\t\n     7\tHooks.once('ready', () =&gt; {\n     8\t    console.log('Shadowrun 6e Genesis Importer | Module ready');\n     9\t});\n    10\t\n    11\t// Register the Genesis importer with the Shadowrun 6e system\n    12\tHooks.on('renderActorSheet', (app, html, data) =&gt; {\n    13\t    // Only add the button to Shadowrun 6e character sheets\n    14\t    if (app.actor.type !== 'character' || !app.actor.system) return;\n    15\t    \n    16\t    // Find the import character button\n    17\t    const importButton = html.find('.import-character');\n    18\t    if (importButton.length === 0) return;\n    19\t    \n    20\t    // Add our own click handler\n    21\t    importButton.off('click').on('click', (event) =&gt; {\n    22\t        event.preventDefault();\n    23\t        \n    24\t        // Create a dialog to choose between Chummer and Genesis import\n    25\t        const content = `\n    26\t            &lt;div style=\&quot;text-align: center; margin-bottom: 10px;\&quot;&gt;\n    27\t                &lt;p&gt;${game.i18n.localize('SR6.ImportCharacterChoose')}&lt;/p&gt;\n    28\t            &lt;/div&gt;\n    29\t            &lt;div style=\&quot;display: flex; justify-content: space-around;\&quot;&gt;\n    30\t                &lt;button class=\&quot;chummer-import\&quot;&gt;${game.i18n.localize('SR6.ChummerImport')}&lt;/button&gt;\n    31\t                &lt;button class=\&quot;genesis-import\&quot;&gt;${game.i18n.localize('SR6.GenesisImport')}&lt;/button&gt;\n    32\t            &lt;/div&gt;\n    33\t        `;\n    34\t\n    35\t        const dialog = new Dialog({\n    36\t            title: game.i18n.localize('SR6.ImportCharacter'),\n    37\t            content: content,\n    38\t            buttons: {},\n    39\t            render: html =&gt; {\n    40\t                html.find('.chummer-import').click(() =&gt; {\n    41\t                    dialog.close();\n    42\t                    // Call the system's Chummer importer\n    43\t                    app._onShowImportCharacter(event);\n    44\t                });\n    45\t\n    46\t                html.find('.genesis-import').click(() =&gt; {\n    47\t                    dialog.close();\n    48\t                    const options = {\n    49\t                        name: 'genesis-import',\n    50\t                        title: game.i18n.localize('SR6.GenesisImport'),\n    51\t                    };\n    52\t                    new GenesisImportForm(app.actor, options).render(true);\n    53\t                });\n    54\t            }\n    55\t        });\n    56\t\n    57\t        dialog.render(true);\n    58\t    });\n    59\t});\n    60\t\n    61\t// Export the GenesisImportForm for external use\n    62\texport { GenesisImportForm };\n...\nPath: src/module/rules/DocumentSituationModifiers.ts\n...\n   390\t\n   391\t    /**\n   392\t     * Helper for scene modifier instances to clear all modifiers for all placed tokens\n   393\t     */\n   394\t    async clearAllTokensOnScene() {\n   395\t        if (!canvas.ready || !canvas.scene) return;\n   396\t        if (!this.documentIsScene) return;\n   397\t\n   398\t        // Validate that modifiers scene is same to current scene.\n   399\t        const scene = this.document as Scene;\n   400\t        if (canvas.scene.id !== scene.id) return;\n   401\t\n   402\t        // Use current scene for ease of access to tokens\n   403\t        canvas.scene.tokens.forEach(token =&gt; token.actor?.getSituationModifiers().clearAll());\n   404\t    }\n   405\t}\n...\nPath: src/module/combat/SR6Combat.ts\n...\n   365\t        let nextTurn = this.settings?.skipDefeated ?\n   366\t            this.nextUndefeatedTurnPosition :\n   367\t            this.nextViableTurnPosition;\n   368\t\n   369\t        // Start of the combat Handling\n   370\t        if (nextRound === 0 &amp;&amp; initiativePass === 0) {\n   371\t            await this.startCombat();\n   372\t            return;\n   373\t        }\n   374\t\n   375\t        // Just step from one combatant to the next!\n   376\t        if (nextTurn &lt; this.turns.length) {\n   377\t            await this.update({ turn: nextTurn });\n   378\t            await this.handleActionPhase();\n   379\t            return;\n   380\t        }\n   381\t\n   382\t        // In Shadowrun 6th Edition, there are no initiative passes\n   383\t\n   384\t\n   385\t        // Initiative Round Handling.\n   386\t        // NOTE: It's not checked if the next is needed. This should result in the user noticing the turn going up, when it\n   387\t        //       maybe shouldn't and reporting a unhandled combat phase flow case.\n   388\t        return this.nextRound();\n   389\t    }\n...\nPath: src/module/migrator/VersionMigration.ts\n...\n   134\t\n   135\t    /**\n   136\t     * Iterate through all scenes and migrate each if needed.\n   137\t     * @param game\n   138\t     * @param entityUpdates\n   139\t     */\n   140\t    protected async IterateScenes(game: Game, entityUpdates: Map&lt;SystemMigrationDocuments, DocumentUpdate&gt;) {\n   141\t        // @ts-expect-error // ignore null state\n   142\t        for (const scene of game.scenes.contents) {\n   143\t            try {\n   144\t                if (!(await this.ShouldMigrateSceneData(scene))) {\n   145\t                    continue;\n   146\t                }\n   147\t\n   148\t                // Migrate SceneData itself.\n   149\t                console.log(`Migrating Scene entity ${scene.name}`);\n   150\t                const updateData = await this.MigrateSceneData(scene);\n   151\t\n   152\t                expandObject(updateData);\n   153\t                entityUpdates.set(scene, {\n   154\t                    updateData,\n   155\t                    embeddedItems: null,\n   156\t             ...&quot;,&quot;is_error&quot;:false,&quot;request_id&quot;:&quot;&quot;,&quot;tool_use_id&quot;:&quot;toolu_vrtx_01DMFrRy2RoXAYSBP2y3bFd3&quot;}},{&quot;id&quot;:2,&quot;type&quot;:4,&quot;ide_state_node&quot;:{&quot;workspaceFolders&quot;:[{&quot;repositoryRoot&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;,&quot;folderRoot&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;}],&quot;workspaceFoldersUnchanged&quot;:false,&quot;currentTerminal&quot;:{&quot;terminalId&quot;:12,&quot;currentWorkingDirectory&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;}}}],&quot;timestamp&quot;:&quot;2025-05-29T23:32:20.330Z&quot;,&quot;response_text&quot;:&quot;Now let me look at the specific error patterns and the matrix action initialization code more closely:\n&quot;,&quot;workspace_file_chunks&quot;:[]},{&quot;status&quot;:&quot;success&quot;,&quot;request_id&quot;:&quot;d0c4d893-9d82-4f5d-8bc1-895259d33975&quot;,&quot;request_message&quot;:&quot;&quot;,&quot;structured_output_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:5,&quot;content&quot;:&quot;&quot;,&quot;tool_use&quot;:{&quot;tool_use_id&quot;:&quot;toolu_vrtx_01SUN8Fn8uYuYrPFWNxmViFJ&quot;,&quot;tool_name&quot;:&quot;str-replace-editor&quot;,&quot;input_json&quot;:&quot;{\&quot;command\&quot;: \&quot;view\&quot;, \&quot;path\&quot;: \&quot;src/module/hooks.ts\&quot;, \&quot;view_range\&quot;: [445, 470]}&quot;,&quot;mcp_server_name&quot;:&quot;&quot;,&quot;mcp_tool_name&quot;:&quot;&quot;}},{&quot;id&quot;:0,&quot;type&quot;:0,&quot;content&quot;:&quot;Let me also check the hooks.ts file for the specific code that processes tokens and might be causing the issue:\n&quot;},{&quot;id&quot;:2,&quot;type&quot;:2,&quot;content&quot;:&quot;&quot;},{&quot;id&quot;:3,&quot;type&quot;:3,&quot;content&quot;:&quot;&quot;}],&quot;seen_state&quot;:&quot;seen&quot;,&quot;structured_request_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:1,&quot;tool_result_node&quot;:{&quot;content&quot;:&quot;Here's the result of running `cat -n` on src/module/actor/SR6Actor.ts:\n   315\t                break;\n   316\t        }\n   317\t\n   318\t        // Ensure matrix actions are available for all actors that can use the Matrix\n   319\t        if (game.user?.isGM &amp;&amp; this.isOwner &amp;&amp; (this.isCharacter() || this.isSprite() || this.isIC())) {\n   320\t            // Check if we've already added matrix actions to this actor\n   321\t            const hasMatrixActions = this.getFlag('sr6elysium', 'hasMatrixActions');\n   322\t            if (!hasMatrixActions) {\n   323\t                // We need to use a setTimeout to avoid issues with the actor being locked during data preparation\n   324\t                setTimeout(() =&gt; this.ensureMatrixActions(), 500);\n   325\t            }\n   326\t        }\n   327\t    }\n   328\t\n   329\t    /**\n   330\t     * NOTE: This method is unused at the moment, keep it for future inspiration.\nTotal lines in file: 3031\n&quot;,&quot;is_error&quot;:false,&quot;request_id&quot;:&quot;&quot;,&quot;tool_use_id&quot;:&quot;toolu_vrtx_01QoZMNMfqm8PKi5uRBtygv2&quot;}},{&quot;id&quot;:2,&quot;type&quot;:4,&quot;ide_state_node&quot;:{&quot;workspaceFolders&quot;:[{&quot;repositoryRoot&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;,&quot;folderRoot&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;}],&quot;workspaceFoldersUnchanged&quot;:false,&quot;currentTerminal&quot;:{&quot;terminalId&quot;:12,&quot;currentWorkingDirectory&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;}}}],&quot;timestamp&quot;:&quot;2025-05-29T23:32:23.997Z&quot;,&quot;response_text&quot;:&quot;Let me also check the hooks.ts file for the specific code that processes tokens and might be causing the issue:\n&quot;,&quot;workspace_file_chunks&quot;:[]},{&quot;status&quot;:&quot;success&quot;,&quot;request_id&quot;:&quot;f156d8fe-3453-413e-9b57-54d971817689&quot;,&quot;request_message&quot;:&quot;&quot;,&quot;structured_output_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:5,&quot;content&quot;:&quot;&quot;,&quot;tool_use&quot;:{&quot;tool_use_id&quot;:&quot;toolu_vrtx_01PTWeRdmwpuFXC1H5LmmP9U&quot;,&quot;tool_name&quot;:&quot;codebase-retrieval&quot;,&quot;input_json&quot;:&quot;{\&quot;information_request\&quot;: \&quot;Code that accesses token.actor property without first checking if the actor exists, particularly any code that might run during initialization or scene loading. Look for patterns like token.actor.someMethod() without null checks.\&quot;}&quot;,&quot;mcp_server_name&quot;:&quot;&quot;,&quot;mcp_tool_name&quot;:&quot;&quot;}},{&quot;id&quot;:0,&quot;type&quot;:0,&quot;content&quot;:&quot;Now let me search for any other code that might be accessing tokens without proper actor checks:\n&quot;},{&quot;id&quot;:2,&quot;type&quot;:2,&quot;content&quot;:&quot;&quot;},{&quot;id&quot;:3,&quot;type&quot;:3,&quot;content&quot;:&quot;&quot;}],&quot;seen_state&quot;:&quot;seen&quot;,&quot;structured_request_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:1,&quot;tool_result_node&quot;:{&quot;content&quot;:&quot;Here's the result of running `cat -n` on src/module/hooks.ts:\n   445\t        if (!canvas.ready || !game.actors) return;\n   446\t\n   447\t        if (item.isHost) {\n   448\t            // Collect actors from sidebar and active scene to update / rerender\n   449\t            let connectedIC = [\n   450\t                // All sidebar actors should also include tokens with linked actors.\n   451\t                ...game.actors.filter((actor: SR6Actor) =&gt; actor.isIC() &amp;&amp; actor.hasHost()) as SR6Actor[],\n   452\t                // All token actors that aren't linked.\n   453\t                // @ts-expect-error // TODO: foundry-vtt-types v10\n   454\t                ...canvas.scene.tokens.filter(token =&gt; !token.actorLink &amp;&amp; token.actor?.isIC() &amp;&amp; token.actor?.hasHost()).map(t =&gt; t.actor)\n   455\t            ];\n   456\t\n   457\t            // Update host data on the ic actor.\n   458\t            const host = item.asHost;\n   459\t            if (!host) return;\n   460\t            for (const ic of connectedIC) {\n   461\t                if (!ic) continue;\n   462\t                await ic._updateICHostData(host);\n   463\t            }\n   464\t        }\n   465\t    }\n   466\t\n   467\t    static async removeDeletedItemsFromNetworks(item: SR6Item, data: Shadowrun.ShadowrunItemDataData, id: string) {\n   468\t        await NetworkDeviceFlow.handleOnDeleteItem(item, data, id);\n   469\t    }\n   470\t\nTotal lines in file: 533\n&quot;,&quot;is_error&quot;:false,&quot;request_id&quot;:&quot;&quot;,&quot;tool_use_id&quot;:&quot;toolu_vrtx_01SUN8Fn8uYuYrPFWNxmViFJ&quot;}},{&quot;id&quot;:2,&quot;type&quot;:4,&quot;ide_state_node&quot;:{&quot;workspaceFolders&quot;:[{&quot;repositoryRoot&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;,&quot;folderRoot&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;}],&quot;workspaceFoldersUnchanged&quot;:false,&quot;currentTerminal&quot;:{&quot;terminalId&quot;:12,&quot;currentWorkingDirectory&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;}}}],&quot;timestamp&quot;:&quot;2025-05-29T23:32:26.871Z&quot;,&quot;response_text&quot;:&quot;Now let me search for any other code that might be accessing tokens without proper actor checks:\n&quot;,&quot;workspace_file_chunks&quot;:[]},{&quot;status&quot;:&quot;success&quot;,&quot;request_id&quot;:&quot;7eb2eae3-a7f1-48a6-bfd3-8d9ffdeabbd8&quot;,&quot;request_message&quot;:&quot;&quot;,&quot;structured_output_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:5,&quot;content&quot;:&quot;&quot;,&quot;tool_use&quot;:{&quot;tool_use_id&quot;:&quot;toolu_vrtx_015yuiu6dUK1jy3nGUH63CNU&quot;,&quot;tool_name&quot;:&quot;str-replace-editor&quot;,&quot;input_json&quot;:&quot;{\&quot;command\&quot;: \&quot;view\&quot;, \&quot;path\&quot;: \&quot;src/module/hooks.ts\&quot;, \&quot;view_range\&quot;: [450, 460]}&quot;,&quot;mcp_server_name&quot;:&quot;&quot;,&quot;mcp_tool_name&quot;:&quot;&quot;}},{&quot;id&quot;:0,&quot;type&quot;:0,&quot;content&quot;:&quot;Now let me look at the specific line in hooks.ts that might be causing the issue:\n&quot;},{&quot;id&quot;:2,&quot;type&quot;:2,&quot;content&quot;:&quot;&quot;},{&quot;id&quot;:3,&quot;type&quot;:3,&quot;content&quot;:&quot;&quot;}],&quot;seen_state&quot;:&quot;seen&quot;,&quot;structured_request_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:1,&quot;tool_result_node&quot;:{&quot;content&quot;:&quot;The following code sections were retrieved:\nPath: src/module/helpers.ts\n...\n   307\t\n   308\t    // TODO: Foundry 0.9 Should TokenDocument be used instead of Token?\n   309\t    // TODO: Check canvas.scene.tokens\n   310\t    static getToken(id?: string): Token | undefined {\n   311\t        if (!canvas || !canvas.ready || !canvas.tokens) return;\n   312\t\n   313\t        for (const token of canvas.tokens.placeables) {\n   314\t            if (token.id === id) {\n   315\t                return token;\n   316\t            }\n   317\t        }\n   318\t    }\n   319\t\n   320\t    /**\n   321\t     * Use this helper to get a tokens actor from any given scene id.\n   322\t     * @param sceneTokenId A mixed id with the format '&lt;sceneId&gt;.&lt;tokenid&gt;\n   323\t     */\n   324\t    static getSceneTokenActor(sceneTokenId: string): SR6Actor | null {\n   325\t        const [sceneId, tokenId] = Helpers.deconstructSceneTokenId(sceneTokenId);\n   326\t        const token = Helpers.getSceneTokenDocument(sceneId, tokenId);\n   327\t        if (!token) return null;\n   328\t        return token.getActor();\n   329\t    }\n   330\t\n   331\t    static deconstructSceneTokenId(sceneTokenId: string): [sceneId: string, tokenId: string] {\n   332\t        return sceneTokenId.split('.') as [sceneId: string, tokenId: string];\n   333\t    }\n   334\t\n   335\t    static getSceneTokenDocument(sceneId, tokenId): TokenDocument | undefined {\n   336\t        const scene = game.scenes?.get(sceneId);\n   337\t        if (!scene) return;\n   338\t        const token = scene.tokens.get(tokenId);\n   339\t        if (!token) return;\n   340\t\n   341\t        return token;\n   342\t    }\n   343\t\n   344\t    static getUserTargets(user?: User | null): Token[] {\n   345\t        user = user ? user : game.user;\n   346\t\n   347\t        if (!user) return []\n   348\t\n   349\t        return Array.from(user.targets);\n   350\t    }\n   351\t\n   352\t    static userHasTargets(user?: User | null): boolean {\n   353\t        user = user ? user : game.user;\n   354\t\n   355\t        if (!user) return false;\n   356\t\n   357\t        return user.targets.size &gt; 0;\n   358\t    }\n...\n   661\t\n   662\t        // If we did not find anything on the actor, search the active tokens (the item might only exist on a non linked token)\n   663\t        // This will not work if we are on a different scene or the token got deleted, which is expected when you put an\n   664\t        // item on a token without linking it.\n   665\t        const tokens = actorSource.getActiveTokens();\n   666\t        let tokenItem: SR6Item | undefined;\n   667\t        tokens.forEach(token =&gt; {\n   668\t            if (!token.actor) return;\n   669\t\n   670\t            const foundItem = token.actor.items.get(itemId);\n   671\t            if (foundItem) {\n   672\t                tokenItem = foundItem as unknown as SR6Item;\n   673\t            }\n   674\t        });\n   675\t\n   676\t        return tokenItem;\n   677\t    }\n...\nPath: src/module/actor/SR6Actor.ts\n...\n    34\t\n    35\t\n    36\t/**\n    37\t * The general Shadowrun actor implementation, which currently handles all actor types.\n    38\t *\n    39\t * To easily access ActorData without any typing issues us the SR6Actor.asCritter helpers.\n    40\t * They are set up in a way that will handle both error management and type narrowing.\n    41\t * Example:\n    42\t * &lt;pre&gt;&lt;code&gt;\n    43\t *     const actor = game.actors.get('randomId');\n    44\t *     const critter = actor.asCritter();\n    45\t *     if (!critter) return;\n    46\t *     // critter.type === 'critter'\n    47\t *     // critter.system as CritterData\n    48\t * &lt;/code&gt;&lt;/pre&gt;\n    49\t *\n    50\t */\n    51\texport class SR6Actor extends Actor {\n    52\t    /**\n    53\t     * Cache for armor calculations to avoid recalculating unnecessarily\n    54\t     * @type {Object}\n    55\t     * @private\n    56\t     */\n    57\t    private _armorCache: {\n    58\t        armor?: Shadowrun.ActorArmor,\n    59\t        timestamp: number,\n    60\t        equipmentHash: string\n    61\t    } = {\n    62\t        timestamp: 0,\n...\n  1450\t\n  1451\t    /** Return either the linked token or the token of the synthetic actor.\n  1452\t     *\n  1453\t     * @return Will return null should no token have been placed on scene.\n  1454\t     */\n  1455\t    getToken(): TokenDocument | null {\n  1456\t        // Linked actors can only have one token, which isn't stored within actor data...\n  1457\t        if (this._isLinkedToToken() &amp;&amp; this.hasToken()) {\n  1458\t            const linked = true;\n  1459\t            const tokens = this.getActiveTokens(linked) as unknown as Token[];\n  1460\t            // This assumes for a token to exist and should fail if not.\n  1461\t            return tokens[0].document;\n  1462\t        }\n  1463\t\n  1464\t        // Unlinked actors can have multiple active token but each have theirs directly attached...\n  1465\t        return this.token;\n  1466\t    }\n  1467\t\n  1468\t    /**\n  1469\t     * There is no need for a token to placed. The prototype token is enough.\n  1470\t     */\n  1471\t    _isLinkedToToken(): boolean {\n  1472\t        //@ts-expect-error // TODO: foundry-vtt-types v10\n  1473\t        // If an actor is linked, all it's copies also contain this linked status, even if they're not.\n  1474\t        return this.prototypeToken.actorLink &amp;&amp; !this.token;\n  1475\t    }\n  1476\t\n  1477\t    hasToken(): boolean {\n  1478\t        return this.getActiveTokens().length &gt; 0;\n  1479\t    }\n  1480\t\n  1481\t    hasActivePlayerOwner(): boolean {\n  1482\t        const players = this.getActivePlayerOwners();\n  1483\t        return players.length &gt; 0;\n  1484\t    }\n  1485\t\n  1486\t    getActivePlayer(): User | null {\n  1487\t        if (!game.users) return null;\n  1488\t        if (!this.hasPlayerOwner) return null;\n  1489\t\n  1490\t        for (const user of game.users.contents) {\n  1491\t            if (!user.active || user.isGM) {\n  1492\t                continue;\n  1493\t            }\n  1494\t            if (this.id === user.character?.id) {\n  1495\t                return user;\n  1496\t            }\n  1497\t        }\n  1498\t\n  1499\t        return null;\n  1500\t    }\n...\n  2500\t\n  2501\t        // Initialize the actions object if it doesn't exist\n  2502\t        if (!this.system.initiative.actions) {\n  2503\t            console.log(`Shadowrun 6e | Actor ${this.name} has no actions data, initializing`);\n  2504\t            await this.update({\n  2505\t                'system.initiative.actions': {}\n  2506\t            });\n  2507\t            // Reset actions to ensure they're properly initialized\n  2508\t            await this.resetActions();\n  2509\t            return;\n  2510\t        }\n  2511\t\n  2512\t        const actions = this.system.initiative.actions;\n  2513\t        console.log(`Shadowrun 6e | Current actions for ${this.name}:`, actions);\n  2514\t\n  2515\t        // Check if the actor has at least 4 minor actions\n  2516\t        if (actions.minor &lt; 4) {\n  2517\t            ui.notifications?.warn(game.i18n.format('SR6.NotEnoughMinorActions', {\n  2518\t                name: this.name,\n  2519\t                count: actions.minor\n  2520\t            }));\n  2521\t            return;\n  2522\t        }\n  2523\t\n  2524\t        // Get the actor from the game.actors collection to ensure we're working with the latest data\n  2525\t        const checkActor = game.actors.get(this.id);\n  2526\t        if (checkActor &amp;&amp; checkActor.system.initiative &amp;&amp; checkActor.system.initiative.actions) {\n  2527\t            // Check if the actor has at least 4 minor actions in the database\n  2528\t            const dbMinorActions = checkActor.system.initiative.actions.minor;\n  2529\t            if (dbMinorActions &lt; 4) {\n  2530\t                ui.notifications?.warn(game.i18n.format('SR6.NotEnoughMinorActions', {\n  2531\t                    name: this.name,\n  2532\t                    count: dbMinorActions\n  2533\t                }));\n  2534\t                return;\n  2535\t            }\n  2536\t        }\n...\n  2704\t\n  2705\t    /**\n  2706\t     * Find and refresh all token sheets for this actor\n  2707\t     * This is needed because token sheets are not automatically refreshed when the actor is updated\n  2708\t     */\n  2709\t    refreshTokenSheets() {\n  2710\t        console.log(`Shadowrun 6e | Refreshing token sheets for ${this.name}`);\n  2711\t\n  2712\t        // Get all tokens for this actor\n  2713\t        const tokens = this.getActiveTokens();\n  2714\t        console.log(`Shadowrun 6e | Found ${tokens.length} tokens for ${this.name}`);\n  2715\t\n  2716\t        // Refresh each token\n  2717\t        for (const token of tokens) {\n  2718\t            // Refresh the token\n  2719\t            if (token.refresh) token.refresh();\n  2720\t\n  2721\t            // Refresh the token's sheet if it's open\n  2722\t            if (token.sheet &amp;&amp; token.sheet.rendered) {\n  2723\t                token.sheet.render(true);\n  2724\t                console.log(`Shadowrun 6e | Refreshed token sheet for ${token.name}`);\n  2725\t            }\n  2726\t        }\n...\n  2817\t\n  2818\t        // Initialize the actions object if it doesn't exist\n  2819\t        if (!this.system.initiative.actions) {\n  2820\t            console.log(`Shadowrun 6e | Actor ${this.name} has no actions data, initializing`);\n  2821\t            await this.update({\n  2822\t                'system.initiative.actions': {}\n  2823\t            });\n  2824\t            // Reset actions to ensure they're properly initialized\n  2825\t            await this.resetActions();\n  2826\t            return false;\n  2827\t        }\n  2828\t\n  2829\t        const actions = this.system.initiative.actions;\n  2830\t        console.log(`Shadowrun 6e | Current actions for ${this.name}:`, actions);\n  2831\t\n  2832\t        // Check if the actor has at least 1 major action\n  2833\t        if (actions.major &lt; 1) {\n  2834\t            ui.notifications?.warn(game.i18n.format('SR6.NoMajorActionsLeft', {\n  2835\t                name: this.name\n  2836\t            }));\n  2837\t            return false;\n  2838\t        }\n...\n  2900\t\n  2901\t        // Initialize the actions object if it doesn't exist\n  2902\t        if (!this.system.initiative.actions) {\n  2903\t            console.log(`Shadowrun 6e | Actor ${this.name} has no actions data, initializing`);\n  2904\t            await this.update({\n  2905\t                'system.initiative.actions': {}\n  2906\t            });\n  2907\t            // Reset actions to ensure they're properly initialized\n  2908\t            await this.resetActions();\n  2909\t            return false;\n  2910\t        }\n  2911\t\n  2912\t        const actions = this.system.initiative.actions;\n  2913\t        console.log(`Shadowrun 6e | Current actions for ${this.name}:`, actions);\n  2914\t\n  2915\t        // Check if the actor has at least 1 minor action\n  2916\t        if (actions.minor &lt; 1) {\n  2917\t            ui.notifications?.warn(game.i18n.format('SR6.NoMinorActionsLeft', {\n  2918\t                name: this.name\n  2919\t            }));\n  2920\t            return false;\n  2921\t        }\n...\nPath: src/module/token/SR6Token.ts\n     1\timport {FLAGS, SYSTEM_NAME} from \&quot;../constants\&quot;;\n     2\timport TrackType = Shadowrun.TrackType;\n     3\t\n     4\texport class SR6Token extends Token {\n     5\t    // @ts-expect-error Ignore getBarAttribute from Token\n     6\t    override _drawBar(number: number, bar: PIXI.Graphics, data: ReturnType&lt;Token['getBarAttribute']&gt;){\n     7\t        const tokenHealthBars = game.settings.get(SYSTEM_NAME, FLAGS.TokenHealthBars);\n     8\t        // FoundryVTT draws resource bars as full/good when the value is the\n     9\t        // same as the max and empty/bad at 0 (colored along a gradient).\n    10\t        // Shadowrun condition trackers count up from 0 to the maximum.\n    11\t        // We flip the values from Shadowrun format to FoundryVTT format here\n    12\t        // for drawing.\n    13\t        if (tokenHealthBars &amp;&amp; data &amp;&amp; data.attribute.startsWith('track')) {\n    14\t            const track = data as unknown as TrackType;\n    15\t            track.value = track.max - track.value;\n    16\t        }\n    17\t        super._drawBar(number, bar, data);\n    18\t    }\n    19\t}\n...\nPath: macros/edge-add-one-die.js\n     1\tconst EDGE_COST = 1;\n     2\t\n     3\t// Get the selected token's actor\n     4\tconst actor = token?.actor || character;\n     5\tif (!actor) {\n     6\t    ui.notifications.error(\&quot;Please select a token or assign a character\&quot;);\n     7\t    return;\n     8\t}\n     9\t\n    10\t// Get edge data\n    11\tconst edge = actor.getEdge();\n    12\tif (!edge) {\n    13\t    ui.notifications.error(\&quot;Selected character has no Edge attribute\&quot;);\n    14\t    return;\n    15\t}\n    16\t\n    17\t// Check if actor has enough edge\n    18\tif (edge.uses &lt; EDGE_COST) {\n    19\t    ui.notifications.error(`Not enough Edge! Need ${EDGE_COST} but only have ${edge.uses}`);\n    20\t    return;\n    21\t}\n...\nPath: src/module/hooks.ts\n...\n    70\timport { SuccessTestEffectsFlow } from './effect/flows/SuccessTestEffectsFlow';\n    71\timport { JournalEnrichers } from './journal/enricher';\n    72\timport { DataStorage } from './data/DataStorage';\n    73\t\n    74\t\n    75\t\n    76\t// Redeclare SR5config as a global as foundry-vtt-types CONFIG with SR5 property causes issues.\n    77\texport const SR6CONFIG = SR6;\n    78\t\n    79\texport class HooksManager {\n    80\t    static registerHooks() {\n    81\t        console.log('Shadowrun 6e | Registering system hooks');\n    82\t        // Register your highest level hook callbacks here for a quick overview of what's hooked into.\n    83\t\n    84\t        Hooks.once('init', HooksManager.init);\n    85\t        Hooks.once('setup', AutocompleteInlineHooksFlow.setupHook);\n    86\t\n    87\t        Hooks.on('canvasInit', canvasInit);\n    88\t        Hooks.on('ready', HooksManager.ready);\n    89\t        Hooks.on('hotbarDrop', HooksManager.hotbarDrop);\n    90\t        Hooks.on('renderSceneControls', HooksManager.renderSceneControls);\n    91\t        Hooks.on('getSceneControlButtons', HooksManager.getSceneControlButtons);\n    92\t        Hooks.on('getCombatTrackerEntryContext', SR6Combat.addCombatTrackerContextOptions);\n    93\t        Hooks.on('renderItemDirectory', HooksManager.renderItemDirectory);\n    94\t        // Hooks.on('renderTokenHUD', EnvModifiersApplication.addTokenHUDFields);\n    95\t        Hooks.on('renderTokenHUD', SituationModifiersApplication.onRenderTokenHUD);\n    96\t        Hooks.on('updateItem', HooksManager.updateIcConnectedToHostItem);\n    97\t        Hooks.on('deleteItem', HooksManager.removeDeletedItemsFromNetworks);\n...\n   107\t\n   108\t    static init() {\n   109\t        console.log(`Loading Shadowrun 5e System\n   110\t___________________\n   111\t ___________ _____ \n   112\t/  ___| ___ \\\\  ___|\n   113\t\\\\ \\`--.| |_/ /___ \\\\ \n   114\t \\`--. \\\\    /    \\\\ \\\\\n   115\t/\\\\__/ / |\\\\ \\\\/\\\\__/ /\n   116\t\\\\____/\\\\_| \\\\_\\\\____/ \n   117\t===================\n   118\t`);\n   119\t        // Create a sr6elysium namespace within the game global\n   120\t        game['sr6elysium'] = {\n   121\t            /**\n   122\t             * System level Document implementations.\n   123\t             */\n   124\t            SR6Actor: SR6Actor,\n   125\t            SR6Item: SR6Item,\n   126\t            SR6ActiveEffect: SR6ActiveEffect,\n   127\t            /**\n   128\t             * Macro hooks used when something's dropped onto the hotbar.\n   129\t             */\n   130\t            rollItemMacro,\n   131\t            rollSkillMacro,\n   132\t            /**\n   133\t             * Should you only really need dice handling, use this. If you need more complex testing behaviour,\n   134\t             * check the Test implementations.\n   135\t             */\n   136\t            SR6Roll: SR6Roll,\n...\n   330\t\n   331\t        HooksManager.configureVision()\n   332\t\n   333\t        HooksManager.configureTextEnrichers();\n   334\t\n   335\t        // Preload might reduce loading time during play.\n   336\t        HandlebarManager.loadTemplates();\n   337\t\n   338\t        // Register Tours\n   339\t        registerSR6Tours();\n   340\t\n   341\t        DataStorage.validate();\n   342\t    }\n   343\t\n   344\t    static async ready() {\n   345\t        if (game.user?.isGM) {\n   346\t            // Prohibit migration on empty worlds...\n   347\t            if (Migrator.isEmptyWorld) {\n   348\t                await Migrator.InitWorldForMigration();\n   349\t                return;\n   350\t            }\n   351\t\n   352\t            // On populated worlds, try migrating\n   353\t            await Migrator.BeginMigration();\n   354\t\n   355\t            if (ChangelogApplication.showApplication) {\n   356\t                await new ChangelogApplication().render(true);\n   357\t            }\n   358\t        }\n...\n   470\t\n   471\t    /**\n   472\t     * This method is used as a simple place to register socket hook handlers for the system.\n   473\t     *\n   474\t     * You can use the SocketMessage for sending messages using a socket event message id and generic data object.\n   475\t     */\n   476\t    static registerSocketListeners() {\n   477\t        if (!game.socket || !game.user) return;\n   478\t        console.log('Registering sr6elysium system socket messages...');\n   479\t        const hooks: Shadowrun.SocketMessageHooks = {\n   480\t            [FLAGS.addNetworkController]: [NetworkDeviceFlow._handleAddNetworkControllerSocketMessage],\n   481\t            [FLAGS.DoNextRound]: [SR6Combat._handleDoNextRoundSocketMessage],\n   482\t            [FLAGS.DoInitPass]: [SR6Combat._handleDoInitPassSocketMessage],\n   483\t            [FLAGS.DoNewActionPhase]: [SR6Combat._handleDoNewActionPhaseSocketMessage],\n...\nPath: macros/edge-reroll-failed.js\n     1\tconst EDGE_COST = 4;\n     2\t\n     3\t// Get the selected token's actor\n     4\tconst actor = token?.actor || character;\n     5\tif (!actor) {\n     6\t    ui.notifications.error(\&quot;Please select a token or assign a character\&quot;);\n     7\t    return;\n     8\t}\n     9\t\n    10\t// Get edge data\n    11\tconst edge = actor.getEdge();\n    12\tif (!edge) {\n    13\t    ui.notifications.error(\&quot;Selected character has no Edge attribute\&quot;);\n    14\t    return;\n    15\t}\n...\nPath: macros/edge-reroll-sr6.js\n     1\t// Get the selected token's actor\n     2\tconst actor = token?.actor || character;\n     3\tif (!actor) {\n     4\t    ui.notifications.error(\&quot;Please select a token or assign a character\&quot;);\n     5\t    return;\n     6\t}\n     7\t\n     8\t// Get edge data\n     9\tconst edge = actor.getEdge();\n    10\tif (!edge) {\n    11\t    ui.notifications.error(\&quot;Selected character has no Edge attribute\&quot;);\n    12\t    return;\n    13\t}\n...\nPath: macros/edge-add-attribute.js\n     1\tconst EDGE_COST = 4;\n     2\t\n     3\t// Get the selected token's actor\n     4\tconst actor = token?.actor || character;\n     5\tif (!actor) {\n     6\t    ui.notifications.error(\&quot;Please select a token or assign a character\&quot;);\n     7\t    return;\n     8\t}\n     9\t\n    10\t// Get edge data\n    11\tconst edge = actor.getEdge();\n    12\tif (!edge) {\n    13\t    ui.notifications.error(\&quot;Selected character has no Edge attribute\&quot;);\n    14\t    return;\n    15\t}\n    16\t\n    17\t// Check if actor has enough edge\n    18\tif (edge.uses &lt; EDGE_COST) {\n    19\t    ui.notifications.error(`Not enough Edge! Need ${EDGE_COST} but only have ${edge.uses}`);\n    20\t    return;\n    21\t}\n    22\t\n    23\t// Get edge attribute value\n    24\tconst edgeAttr = actor.system.attributes.edge.value;\n    25\tif (!edgeAttr) {\n    26\t    ui.notifications.error(\&quot;Could not determine Edge attribute value\&quot;);\n    27\t    return;\n    28\t}\n...\nPath: macros/edge-heal-physical.js\n     1\tconst EDGE_COST = 4;\n     2\t\n     3\t// Get the selected token's actor\n     4\tconst actor = token?.actor || character;\n     5\tif (!actor) {\n     6\t    ui.notifications.error(\&quot;Please select a token or assign a character\&quot;);\n     7\t    return;\n     8\t}\n     9\t\n    10\t// Get edge data\n    11\tconst edge = actor.getEdge();\n    12\tif (!edge) {\n    13\t    ui.notifications.error(\&quot;Selected character has no Edge attribute\&quot;);\n    14\t    return;\n    15\t}\n    16\t\n    17\t// Check if actor has enough edge\n    18\tif (edge.uses &lt; EDGE_COST) {\n    19\t    ui.notifications.error(`Not enough Edge! Need ${EDGE_COST} but only have ${edge.uses}`);\n    20\t    return;\n    21\t}\n...\n&quot;,&quot;is_error&quot;:false,&quot;request_id&quot;:&quot;&quot;,&quot;tool_use_id&quot;:&quot;toolu_vrtx_01PTWeRdmwpuFXC1H5LmmP9U&quot;}},{&quot;id&quot;:2,&quot;type&quot;:4,&quot;ide_state_node&quot;:{&quot;workspaceFolders&quot;:[{&quot;repositoryRoot&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;,&quot;folderRoot&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;}],&quot;workspaceFoldersUnchanged&quot;:false,&quot;currentTerminal&quot;:{&quot;terminalId&quot;:12,&quot;currentWorkingDirectory&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;}}}],&quot;timestamp&quot;:&quot;2025-05-29T23:32:48.687Z&quot;,&quot;response_text&quot;:&quot;Now let me look at the specific line in hooks.ts that might be causing the issue:\n&quot;,&quot;workspace_file_chunks&quot;:[]},{&quot;status&quot;:&quot;success&quot;,&quot;request_id&quot;:&quot;0e5a19be-a896-4b53-b0f4-8d3ab8a19442&quot;,&quot;request_message&quot;:&quot;&quot;,&quot;structured_output_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:5,&quot;content&quot;:&quot;&quot;,&quot;tool_use&quot;:{&quot;tool_use_id&quot;:&quot;toolu_vrtx_01J5CVojM5AFp41pSXFS7vYw&quot;,&quot;tool_name&quot;:&quot;codebase-retrieval&quot;,&quot;input_json&quot;:&quot;{\&quot;information_request\&quot;: \&quot;Code that accesses canvas.scene.tokens and iterates through them, particularly any code that might access token.actor without proper null checks. Look for forEach, map, filter operations on tokens.\&quot;}&quot;,&quot;mcp_server_name&quot;:&quot;&quot;,&quot;mcp_tool_name&quot;:&quot;&quot;}},{&quot;id&quot;:0,&quot;type&quot;:0,&quot;content&quot;:&quot;Let me also check if there are any other places where tokens are accessed without proper null checks:\n&quot;},{&quot;id&quot;:2,&quot;type&quot;:2,&quot;content&quot;:&quot;&quot;},{&quot;id&quot;:3,&quot;type&quot;:3,&quot;content&quot;:&quot;&quot;}],&quot;seen_state&quot;:&quot;seen&quot;,&quot;structured_request_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:1,&quot;tool_result_node&quot;:{&quot;content&quot;:&quot;Here's the result of running `cat -n` on src/module/hooks.ts:\n   450\t                // All sidebar actors should also include tokens with linked actors.\n   451\t                ...game.actors.filter((actor: SR6Actor) =&gt; actor.isIC() &amp;&amp; actor.hasHost()) as SR6Actor[],\n   452\t                // All token actors that aren't linked.\n   453\t                // @ts-expect-error // TODO: foundry-vtt-types v10\n   454\t                ...canvas.scene.tokens.filter(token =&gt; !token.actorLink &amp;&amp; token.actor?.isIC() &amp;&amp; token.actor?.hasHost()).map(t =&gt; t.actor)\n   455\t            ];\n   456\t\n   457\t            // Update host data on the ic actor.\n   458\t            const host = item.asHost;\n   459\t            if (!host) return;\n   460\t            for (const ic of connectedIC) {\nTotal lines in file: 533\n&quot;,&quot;is_error&quot;:false,&quot;request_id&quot;:&quot;&quot;,&quot;tool_use_id&quot;:&quot;toolu_vrtx_015yuiu6dUK1jy3nGUH63CNU&quot;}},{&quot;id&quot;:2,&quot;type&quot;:4,&quot;ide_state_node&quot;:{&quot;workspaceFolders&quot;:[{&quot;repositoryRoot&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;,&quot;folderRoot&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;}],&quot;workspaceFoldersUnchanged&quot;:false,&quot;currentTerminal&quot;:{&quot;terminalId&quot;:12,&quot;currentWorkingDirectory&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;}}}],&quot;timestamp&quot;:&quot;2025-05-29T23:32:51.768Z&quot;,&quot;response_text&quot;:&quot;Let me also check if there are any other places where tokens are accessed without proper null checks:\n&quot;,&quot;workspace_file_chunks&quot;:[]},{&quot;status&quot;:&quot;success&quot;,&quot;request_id&quot;:&quot;b6452cb1-128a-4822-b54d-30c5294bb2fe&quot;,&quot;request_message&quot;:&quot;&quot;,&quot;structured_output_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:5,&quot;content&quot;:&quot;&quot;,&quot;tool_use&quot;:{&quot;tool_use_id&quot;:&quot;toolu_vrtx_01DBKRhSah2vw9f9ku1k4LXY&quot;,&quot;tool_name&quot;:&quot;str-replace-editor&quot;,&quot;input_json&quot;:&quot;{\&quot;command\&quot;: \&quot;str_replace\&quot;, \&quot;path\&quot;: \&quot;src/module/hooks.ts\&quot;, \&quot;str_replace_entries\&quot;: [{\&quot;old_str\&quot;: \&quot;        if (item.isHost) {\\n            // Collect actors from sidebar and active scene to update / rerender\\n            let connectedIC = [\\n                // All sidebar actors should also include tokens with linked actors.\\n                ...game.actors.filter((actor: SR6Actor) =&gt; actor.isIC() &amp;&amp; actor.hasHost()) as SR6Actor[],\\n                // All token actors that aren't linked.\\n                // @ts-expect-error // TODO: foundry-vtt-types v10\\n                ...canvas.scene.tokens.filter(token =&gt; !token.actorLink &amp;&amp; token.actor?.isIC() &amp;&amp; token.actor?.hasHost()).map(t =&gt; t.actor)\\n            ];\&quot;, \&quot;old_str_start_line_number\&quot;: 447, \&quot;old_str_end_line_number\&quot;: 455, \&quot;new_str\&quot;: \&quot;        if (item.isHost) {\\n            // Collect actors from sidebar and active scene to update / rerender\\n            let connectedIC = [\\n                // All sidebar actors should also include tokens with linked actors.\\n                ...game.actors.filter((actor: SR6Actor) =&gt; actor.isIC() &amp;&amp; actor.hasHost()) as SR6Actor[],\\n                // All token actors that aren't linked.\\n                // @ts-expect-error // TODO: foundry-vtt-types v10\\n                ...canvas.scene.tokens.filter(token =&gt; !token.actorLink &amp;&amp; token.actor?.isIC() &amp;&amp; token.actor?.hasHost()).map(t =&gt; t.actor).filter(actor =&gt; actor !== null &amp;&amp; actor !== undefined)\\n            ];\&quot;}]}&quot;,&quot;mcp_server_name&quot;:&quot;&quot;,&quot;mcp_tool_name&quot;:&quot;&quot;}},{&quot;id&quot;:0,&quot;type&quot;:0,&quot;content&quot;:&quot;Now I have a good understanding of the issue. Let me create a detailed plan to fix the problem.\n\n## Analysis\n\nBased on my investigation, I've identified several potential issues that could cause \&quot;actors not existing\&quot; errors when loading the game:\n\n1. **Matrix Actions Initialization**: In `SR6Actor.ts` line 319-326, the code automatically tries to add matrix actions to actors during data preparation, but this happens with a setTimeout which could cause race conditions.\n\n2. **Token Processing in Hooks**: In `hooks.ts` line 454, there's code that filters tokens and accesses `token.actor` with optional chaining (`?.`), but then maps to `t.actor` without null checking, which could result in null/undefined actors in the array.\n\n3. **Missing Null Checks**: Several places in the code access `token.actor` without proper null checks, particularly in helper functions and targeting code.\n\n## Plan\n\nI'll fix these issues by:\n\n1. **Fix the hooks.ts token processing** to properly filter out tokens without actors\n2. **Add better error handling** in the matrix actions initialization \n3. **Add null checks** in other places where token.actor is accessed\n4. **Improve the matrix actions timing** to avoid race conditions during initialization\n\nLet me start implementing these fixes:\n&quot;},{&quot;id&quot;:2,&quot;type&quot;:2,&quot;content&quot;:&quot;&quot;},{&quot;id&quot;:3,&quot;type&quot;:3,&quot;content&quot;:&quot;&quot;}],&quot;seen_state&quot;:&quot;seen&quot;,&quot;structured_request_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:1,&quot;tool_result_node&quot;:{&quot;content&quot;:&quot;The following code sections were retrieved:\nPath: src/module/helpers.ts\n...\n   247\t\n   248\t    static orderKeys(obj) {\n   249\t        const keys = Object.keys(obj).sort(function keyOrder(k1, k2) {\n   250\t            if (k1 &lt; k2) return -1;\n   251\t            if (k1 &gt; k2) return +1;\n   252\t            return 0;\n   253\t        });\n   254\t\n   255\t        let i;\n   256\t        const after = {};\n   257\t        for (i = 0; i &lt; keys.length; i++) {\n   258\t            after[keys[i]] = obj[keys[i]];\n   259\t            delete obj[keys[i]];\n   260\t        }\n   261\t\n   262\t        for (i = 0; i &lt; keys.length; i++) {\n   263\t            obj[keys[i]] = after[keys[i]];\n   264\t        }\n   265\t        return obj;\n   266\t    }\n   267\t\n   268\t    static hasModifiers(event) {\n   269\t        return event &amp;&amp; (event.shiftKey || event.altKey || event.ctrlKey || event.metaKey);\n   270\t    }\n   271\t\n   272\t    static filter(obj, comp) {\n   273\t        const retObj = {};\n   274\t        if (typeof obj === 'object' &amp;&amp; obj !== null) {\n   275\t            Object.entries(obj).forEach(([key, value]) =&gt; {\n   276\t                if (comp([key, value])) retObj[key] = value;\n   277\t            });\n   278\t        }\n   279\t        return retObj;\n   280\t    }\n...\n   307\t\n   308\t    // TODO: Foundry 0.9 Should TokenDocument be used instead of Token?\n   309\t    // TODO: Check canvas.scene.tokens\n   310\t    static getToken(id?: string): Token | undefined {\n   311\t        if (!canvas || !canvas.ready || !canvas.tokens) return;\n   312\t\n   313\t        for (const token of canvas.tokens.placeables) {\n   314\t            if (token.id === id) {\n   315\t                return token;\n   316\t            }\n   317\t        }\n   318\t    }\n   319\t\n   320\t    /**\n   321\t     * Use this helper to get a tokens actor from any given scene id.\n   322\t     * @param sceneTokenId A mixed id with the format '&lt;sceneId&gt;.&lt;tokenid&gt;\n   323\t     */\n   324\t    static getSceneTokenActor(sceneTokenId: string): SR6Actor | null {\n   325\t        const [sceneId, tokenId] = Helpers.deconstructSceneTokenId(sceneTokenId);\n   326\t        const token = Helpers.getSceneTokenDocument(sceneId, tokenId);\n   327\t        if (!token) return null;\n   328\t        return token.getActor();\n   329\t    }\n   330\t\n   331\t    static deconstructSceneTokenId(sceneTokenId: string): [sceneId: string, tokenId: string] {\n   332\t        return sceneTokenId.split('.') as [sceneId: string, tokenId: string];\n   333\t    }\n   334\t\n   335\t    static getSceneTokenDocument(sceneId, tokenId): TokenDocument | undefined {\n   336\t        const scene = game.scenes?.get(sceneId);\n   337\t        if (!scene) return;\n   338\t        const token = scene.tokens.get(tokenId);\n   339\t        if (!token) return;\n   340\t\n   341\t        return token;\n   342\t    }\n   343\t\n   344\t    static getUserTargets(user?: User | null): Token[] {\n   345\t        user = user ? user : game.user;\n   346\t\n   347\t        if (!user) return []\n   348\t\n   349\t        return Array.from(user.targets);\n   350\t    }\n   351\t\n   352\t    static userHasTargets(user?: User | null): boolean {\n   353\t        user = user ? user : game.user;\n   354\t\n   355\t        if (!user) return false;\n   356\t\n   357\t        return user.targets.size &gt; 0;\n   358\t    }\n...\n   446\t\n   447\t    /**\n   448\t     * Determine if the current user has any tokens selected.\n   449\t     * @returns true if one or more tokens have been selected.\n   450\t     */\n   451\t    static userHasControlledTokens(): boolean {\n   452\t        if (!canvas || !canvas.ready || !canvas.tokens) return false;\n   453\t        return canvas.tokens.controlled.length &gt; 0;\n   454\t    }\n   455\t\n   456\t    /**\n   457\t     * Return all actors connected to all user controlled tokens.\n   458\t     * @returns An array token actors.\n   459\t     */\n   460\t    static getControlledTokenActors(): SR6Actor[] {\n   461\t        if (!canvas || !canvas.ready) return []\n   462\t\n   463\t        const tokens = Helpers.getControlledTokens();\n   464\t        return tokens.map(token =&gt; token.actor) as SR6Actor[];\n   465\t    }\n   466\t\n   467\t    /**\n   468\t     * return all tokens a user has targeted at the moment.\n   469\t     * @returns An array tokens.\n   470\t     */\n   471\t    static getTargetedTokens(): Token[] {\n   472\t        if (!canvas.ready || !game.user) return [];\n   473\t\n   474\t        return Array.from(game.user.targets);\n   475\t    }\n   476\t\n   477\t    /**\n   478\t     * Return either all user selected token actors or the users game character actor.\n   479\t     * @returns An array of actors.\n   480\t     */\n   481\t    static getSelectedActorsOrCharacter(): SR6Actor[] {\n   482\t        if (!game.user) return [];\n   483\t\n   484\t        const actors = Helpers.getControlledTokenActors();\n   485\t\n   486\t        // Try to default to a users character.\n   487\t        if (actors.length === 0 &amp;&amp; game.user.character) {\n   488\t            actors.push(game.user.character);\n   489\t        }\n   490\t\n   491\t        return actors as SR6Actor[];\n   492\t    }\n...\n   576\t\n   577\t    static getDefenseRating(targets: TokenDocument[]): number {\n   578\t        let defenseRating = 0;\n   579\t        for(const token of targets) {\n   580\t            let target = token.actor;\n   581\t            console.log(target);\n   582\t            // @ts-ignore\n   583\t            if ('defense_rating' in target.system.values &amp;&amp; target.system.values.defense_rating.value &gt; defenseRating) {\n   584\t                // @ts-ignore\n   585\t                defenseRating = target.system.values.defense_rating.value;\n   586\t            }\n   587\t        }\n   588\t        return defenseRating;\n   589\t    }\n   590\t\n   591\t    static getAttackRating(actor: SR6Actor): number {\n   592\t        return 0;\n   593\t    }\n...\n   661\t\n   662\t        // If we did not find anything on the actor, search the active tokens (the item might only exist on a non linked token)\n   663\t        // This will not work if we are on a different scene or the token got deleted, which is expected when you put an\n   664\t        // item on a token without linking it.\n   665\t        const tokens = actorSource.getActiveTokens();\n   666\t        let tokenItem: SR6Item | undefined;\n   667\t        tokens.forEach(token =&gt; {\n   668\t            if (!token.actor) return;\n   669\t\n   670\t            const foundItem = token.actor.items.get(itemId);\n   671\t            if (foundItem) {\n   672\t                tokenItem = foundItem as unknown as SR6Item;\n   673\t            }\n   674\t        });\n   675\t\n   676\t        return tokenItem;\n   677\t    }\n...\nPath: src/module/actor/SR6Actor.ts\n...\n  2704\t\n  2705\t    /**\n  2706\t     * Find and refresh all token sheets for this actor\n  2707\t     * This is needed because token sheets are not automatically refreshed when the actor is updated\n  2708\t     */\n  2709\t    refreshTokenSheets() {\n  2710\t        console.log(`Shadowrun 6e | Refreshing token sheets for ${this.name}`);\n  2711\t\n  2712\t        // Get all tokens for this actor\n  2713\t        const tokens = this.getActiveTokens();\n  2714\t        console.log(`Shadowrun 6e | Found ${tokens.length} tokens for ${this.name}`);\n  2715\t\n  2716\t        // Refresh each token\n  2717\t        for (const token of tokens) {\n  2718\t            // Refresh the token\n  2719\t            if (token.refresh) token.refresh();\n  2720\t\n  2721\t            // Refresh the token's sheet if it's open\n  2722\t            if (token.sheet &amp;&amp; token.sheet.rendered) {\n  2723\t                token.sheet.render(true);\n  2724\t                console.log(`Shadowrun 6e | Refreshed token sheet for ${token.name}`);\n  2725\t            }\n  2726\t        }\n  2727\t\n  2728\t        // Find and refresh all token sheets in the ui.windows collection\n  2729\t        for (const [id, app] of Object.entries(ui.windows)) {\n  2730\t            // Check if this is a sheet for one of our tokens\n  2731\t            if (app.token &amp;&amp; tokens.some(t =&gt; t.id === app.token.id)) {\n  2732\t                app.render(true);\n  2733\t                console.log(`Shadowrun 6e | Refreshed token sheet ${id} for ${app.token.name}`);\n  2734\t            }\n  2735\t        }\n  2736\t    }\n...\n  2990\t\n  2991\t        // Refresh the canvas if it exists\n  2992\t        if (canvas &amp;&amp; canvas.tokens &amp;&amp; typeof canvas.tokens.placeables !== 'undefined') {\n  2993\t            canvas.tokens.placeables.forEach(token =&gt; {\n  2994\t                if (token.actor &amp;&amp; token.actor.id === this.id &amp;&amp; token.refresh) {\n  2995\t                    token.refresh();\n  2996\t                }\n  2997\t            });\n  2998\t        }\n  2999\t\n  3000\t        // Refresh token sheets\n  3001\t        this.refreshTokenSheets();\n  3002\t\n  3003\t        console.log(`Shadowrun 6e | Completed refresh of all sheets for ${this.name}`);\n  3004\t    }\n...\nPath: src/module/targeting/TargetingService.ts\n...\n   122\t    \n   123\t    /**\n   124\t     * Suggest targets for an action when none are selected\n   125\t     * @param action The action being performed\n   126\t     * @param actor The actor performing the action\n   127\t     * @returns An array of suggested target tokens\n   128\t     */\n   129\t    static suggestTargetsForAction(action: SR6Item, actor: SR6Actor): Token[] {\n   130\t        // Get the actor's token\n   131\t        const actorToken = actor.getToken();\n   132\t        if (!actorToken) return [];\n   133\t        \n   134\t        // Get all tokens in the scene\n   135\t        const tokens = canvas.tokens?.placeables || [];\n   136\t        \n   137\t        // Filter for potential targets (exclude the actor's own token)\n   138\t        const potentialTargets = tokens.filter(token =&gt; \n   139\t            token.id !== actorToken.id &amp;&amp; \n   140\t            token.actor &amp;&amp; \n   141\t            this.isValidTarget(token, action, actor)\n   142\t        );\n...\n   151\t    \n   152\t    /**\n   153\t     * Highlight valid targets for an action\n   154\t     * @param action The action being performed\n   155\t     * @param actor The actor performing the action\n   156\t     */\n   157\t    static highlightValidTargets(action: SR6Item, actor: SR6Actor): void {\n   158\t        // Get all tokens in the scene\n   159\t        const tokens = canvas.tokens?.placeables || [];\n   160\t        \n   161\t        // Reset all token highlights\n   162\t        tokens.forEach(token =&gt; {\n   163\t            token.border?.visible = false;\n   164\t        });\n   165\t        \n   166\t        // Get valid targets\n   167\t        const validTargets = tokens.filter(token =&gt; \n   168\t            token.actor &amp;&amp; \n   169\t            this.isValidTarget(token, action, actor)\n   170\t        );\n   171\t        \n   172\t        // Highlight valid targets\n   173\t        validTargets.forEach(token =&gt; {\n   174\t            token.border.visible = true;\n   175\t            token.border.style.borderColor = 0x00FF00; // Green for valid targets\n   176\t        });\n   177\t        \n   178\t        // Force a canvas refresh\n   179\t        canvas.tokens?.refresh();\n   180\t    }\n   181\t    \n   182\t    /**\n   183\t     * Clear target highlights\n   184\t     */\n   185\t    static clearTargetHighlights(): void {\n   186\t        // Get all tokens in the scene\n   187\t        const tokens = canvas.tokens?.placeables || [];\n   188\t        \n   189\t        // Reset all token highlights\n   190\t        tokens.forEach(token =&gt; {\n   191\t            token.border?.visible = false;\n   192\t        });\n   193\t        \n   194\t        // Force a canvas refresh\n   195\t        canvas.tokens?.refresh();\n   196\t    }\n   197\t    \n   198\t    /**\n   199\t     * Get targets for an opposed test\n   200\t     * @param action The action being performed\n   201\t     * @param actor The actor performing the action\n   202\t     * @returns An array of target actors\n   203\t     */\n   204\t    static getOpposedTestTargets(action: SR6Item, actor: SR6Actor): SR6Actor[] {\n   205\t        // Get valid targets\n   206\t        const validTargets = this.getValidTargetsForAction(action, actor);\n   207\t        \n   208\t        // Convert to actors\n   209\t        return validTargets\n   210\t            .map(token =&gt; token.actor as SR6Actor)\n   211\t            .filter(actor =&gt; actor !== undefined);\n   212\t    }\n...\nPath: src/module/tests/TestCreator.ts\n...\n   216\t\n   217\t        // Determine actors to roll test with.\n   218\t        let actors = await Helpers.getOpposedTestActors(testData.data);\n   219\t\n   220\t        // Inform user about tokens with deleted sidebar actors.\n   221\t        // This can both happen for linked tokens immediately and unlinked tokens after reloading.\n   222\t        if (actors.filter(actor =&gt; !actor).length &gt; 0) {\n   223\t            ui.notifications?.warn('TOKEN.WarningNoActor', {localize: true});\n   224\t            return;\n   225\t        }\n   226\t\n   227\t        // filter out actors current user shouldn't be able to test with.\n   228\t        actors = actors.filter(actor =&gt; actor.isOwner);\n   229\t        // Fallback to player character.\n   230\t        if (actors.length === 0 &amp;&amp; game.user.character) {\n   231\t            actors.push(game.user.character);\n   232\t        }\n   233\t\n   234\t        if (actors.length === 0) {\n   235\t            ui.notifications?.warn(game.i18n.localize('SR6.Warnings.TokenSelectionNeeded'));\n   236\t        }\n...\nPath: src/module/apps/gmtools/OverwatchScoreTracker.js\n...\n    80\t\n    81\t        // Add linked token actors.\n    82\t        tokens.filter(token =&gt; token.document.actorLink).forEach(token =&gt; {\n    83\t            // Double check that the actor actually lives in the actors collection.\n    84\t            const actor = game.actors.get(token.document.actorId);\n    85\t            if (!actor) return;\n    86\t            if (this._isActorOnTracker(actor)) return;\n    87\t\n    88\t            OverwatchScoreTracker.addedActors.push(actor.id);\n    89\t        });\n    90\t\n    91\t        this.render();\n    92\t    }\n    93\t\n    94\t    /**\n    95\t     * Check if the given actor is already added and displayed on the current tracker.\n    96\t     *\n    97\t     * @param actor A actors collection actor.\n    98\t     * @returns {boolean} Will return true when the given actor already exists.\n    99\t     */\n   100\t    _isActorOnTracker(actor) {\n   101\t        return this.actors.find(actorData =&gt; actorData._id === actor.id) !== undefined;\n   102\t    }\n...\nPath: src/module/rules/DocumentSituationModifiers.ts\n...\n   390\t\n   391\t    /**\n   392\t     * Helper for scene modifier instances to clear all modifiers for all placed tokens\n   393\t     */\n   394\t    async clearAllTokensOnScene() {\n   395\t        if (!canvas.ready || !canvas.scene) return;\n   396\t        if (!this.documentIsScene) return;\n   397\t\n   398\t        // Validate that modifiers scene is same to current scene.\n   399\t        const scene = this.document as Scene;\n   400\t        if (canvas.scene.id !== scene.id) return;\n   401\t\n   402\t        // Use current scene for ease of access to tokens\n   403\t        canvas.scene.tokens.forEach(token =&gt; token.actor?.getSituationModifiers().clearAll());\n   404\t    }\n   405\t}\n...\nPath: src/module/hooks.ts\n...\n   446\t\n   447\t        if (item.isHost) {\n   448\t            // Collect actors from sidebar and active scene to update / rerender\n   449\t            let connectedIC = [\n   450\t                // All sidebar actors should also include tokens with linked actors.\n   451\t                ...game.actors.filter((actor: SR6Actor) =&gt; actor.isIC() &amp;&amp; actor.hasHost()) as SR6Actor[],\n   452\t                // All token actors that aren't linked.\n   453\t                // @ts-expect-error // TODO: foundry-vtt-types v10\n   454\t                ...canvas.scene.tokens.filter(token =&gt; !token.actorLink &amp;&amp; token.actor?.isIC() &amp;&amp; token.actor?.hasHost()).map(t =&gt; t.actor)\n   455\t            ];\n   456\t\n   457\t            // Update host data on the ic actor.\n   458\t            const host = item.asHost;\n   459\t            if (!host) return;\n   460\t            for (const ic of connectedIC) {\n   461\t                if (!ic) continue;\n   462\t                await ic._updateICHostData(host);\n   463\t            }\n   464\t        }\n   465\t    }\n...\nPath: src/module/item/flows/ActionFlow.ts\n...\n   120\t\n   121\t        // CASE - Return actor skills when available.\n   122\t        //        the major use case is owned items, where the actor is available.\n   123\t        const activeSkills = actor.getActiveSkills();\n   124\t\n   125\t        // Convert skill data to a value label mapping.\n   126\t        const skills: Record&lt;string, Translation&gt; = {};\n   127\t        for (const [id, skill] of Object.entries(activeSkills)) {\n   128\t            const key = skill.name || id;\n   129\t            const label = skill.label || skill.name;\n   130\t            skills[key] = label as Translation;\n   131\t        }\n   132\t\n   133\t        ActionFlow._injectMissingCustomSkill(skills, skillName);\n   134\t        return Helpers.sortConfigValuesByTranslation(skills);\n   135\t    }\n...\nPath: src/module/migrator/VersionMigration.ts\n...\n   158\t\n   159\t                // Migrate embedded TokenDocument / ActorData within SceneData\n   160\t                for (const token of scene.data.tokens) {\n   161\t                    // Don't migrate tokens without or a linked actor.\n   162\t                    if (!token.actor || token.data.actorLink) continue;\n   163\t\n   164\t                    //@ts-expect-error // TODO: foundry-vtt-types v10\n   165\t                    if (foundry.utils.isEmpty(token.actor)) continue;\n   166\t\n   167\t                    const updateData = await this.MigrateActorData(token.actor);\n   168\t\n   169\t                    expandObject(updateData);\n   170\t                    entityUpdates.set(token.actor, {\n   171\t                        updateData: updateData.data || null,\n   172\t                        embeddedItems: updateData.items || null,\n   173\t                        embeddedEffects: updateData.effects || null\n   174\t                    });\n   175\t                }\n   176\t\n   177\t                //@ts-expect-error // TODO: foundry-vtt-types v10\n   178\t                if (foundry.utils.isEmpty(updateData)) {\n   179\t                    continue;\n   180\t                }\n...\nPath: src/module/effects.ts\n...\n   149\t\n   150\t/**\n   151\t * Collect all effects from a documents items and nested items.\n   152\t *\n   153\t * @param document Either a actor or item document.\n   154\t * @param options.applyTo A iterable of apply-to target values\n   155\t * @param options.nestedItems Whether to include nested items\n   156\t * @returns An iterator effect\n   157\t */\n   158\texport function *allApplicableItemsEffects(document: SR6Actor|SR6Item, options: ApplicableItemEffectOptions = {}) {\n   159\t    const applyTo = options.applyTo ?? [];\n   160\t    const nestedItems = options.nestedItems ?? true;\n...\nPath: src/module/tests/RangedAttackTest.ts\n...\n    61\t\n    62\t        if(this.actor) {\n    63\t            console.log('Shadowrun 6e | Processing targets for actor:', this.actor.name);\n    64\t\n    65\t            // Map targets to defenders with their actual DR values\n    66\t            data.defenders = targets.map(token =&gt; {\n    67\t                console.log('Shadowrun 6e | Processing target token:', token.name);\n    68\t\n    69\t                const targetActor = token.actor;\n    70\t                let dr = 5; // default DR\n    71\t\n    72\t                if (!targetActor) {\n    73\t                    console.log('Shadowrun 6e | No actor found for token:', token.name);\n    74\t                    return null;\n    75\t                }\n    76\t\n    77\t                if (!(targetActor instanceof SR6Actor)) {\n    78\t                    console.log('Shadowrun 6e | Actor is not SR6Actor:', token.name);\n    79\t                    return null;\n    80\t                }\n    81\t\n    82\t                console.log('Shadowrun 6e | Processing SR6Actor target:', {\n    83\t                    name: targetActor.name,\n    84\t                    type: targetActor.type,\n    85\t                    hasSystem: !!targetActor.system,\n    86\t                    hasAttributes: !!targetActor.system?.attributes\n    87\t                });\n...\n&quot;,&quot;is_error&quot;:false,&quot;request_id&quot;:&quot;&quot;,&quot;tool_use_id&quot;:&quot;toolu_vrtx_01J5CVojM5AFp41pSXFS7vYw&quot;}},{&quot;id&quot;:2,&quot;type&quot;:4,&quot;ide_state_node&quot;:{&quot;workspaceFolders&quot;:[{&quot;repositoryRoot&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;,&quot;folderRoot&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;}],&quot;workspaceFoldersUnchanged&quot;:false,&quot;currentTerminal&quot;:{&quot;terminalId&quot;:12,&quot;currentWorkingDirectory&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;}}}],&quot;timestamp&quot;:&quot;2025-05-29T23:33:00.023Z&quot;,&quot;response_text&quot;:&quot;Now I have a good understanding of the issue. Let me create a detailed plan to fix the problem.\n\n## Analysis\n\nBased on my investigation, I've identified several potential issues that could cause \&quot;actors not existing\&quot; errors when loading the game:\n\n1. **Matrix Actions Initialization**: In `SR6Actor.ts` line 319-326, the code automatically tries to add matrix actions to actors during data preparation, but this happens with a setTimeout which could cause race conditions.\n\n2. **Token Processing in Hooks**: In `hooks.ts` line 454, there's code that filters tokens and accesses `token.actor` with optional chaining (`?.`), but then maps to `t.actor` without null checking, which could result in null/undefined actors in the array.\n\n3. **Missing Null Checks**: Several places in the code access `token.actor` without proper null checks, particularly in helper functions and targeting code.\n\n## Plan\n\nI'll fix these issues by:\n\n1. **Fix the hooks.ts token processing** to properly filter out tokens without actors\n2. **Add better error handling** in the matrix actions initialization \n3. **Add null checks** in other places where token.actor is accessed\n4. **Improve the matrix actions timing** to avoid race conditions during initialization\n\nLet me start implementing these fixes:\n&quot;,&quot;workspace_file_chunks&quot;:[]},{&quot;status&quot;:&quot;success&quot;,&quot;request_id&quot;:&quot;a3b4150d-db66-4794-98e1-7e175b79d295&quot;,&quot;request_message&quot;:&quot;&quot;,&quot;structured_output_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:5,&quot;content&quot;:&quot;&quot;,&quot;tool_use&quot;:{&quot;tool_use_id&quot;:&quot;toolu_vrtx_01Y1UrDHFxtMLpYjYnJUwoAW&quot;,&quot;tool_name&quot;:&quot;str-replace-editor&quot;,&quot;input_json&quot;:&quot;{\&quot;command\&quot;: \&quot;str_replace\&quot;, \&quot;path\&quot;: \&quot;src/module/actor/SR6Actor.ts\&quot;, \&quot;str_replace_entries\&quot;: [{\&quot;old_str\&quot;: \&quot;        // Ensure matrix actions are available for all actors that can use the Matrix\\n        if (game.user?.isGM &amp;&amp; this.isOwner &amp;&amp; (this.isCharacter() || this.isSprite() || this.isIC())) {\\n            // Check if we've already added matrix actions to this actor\\n            const hasMatrixActions = this.getFlag('sr6elysium', 'hasMatrixActions');\\n            if (!hasMatrixActions) {\\n                // We need to use a setTimeout to avoid issues with the actor being locked during data preparation\\n                setTimeout(() =&gt; this.ensureMatrixActions(), 500);\\n            }\\n        }\&quot;, \&quot;old_str_start_line_number\&quot;: 318, \&quot;old_str_end_line_number\&quot;: 326, \&quot;new_str\&quot;: \&quot;        // Ensure matrix actions are available for all actors that can use the Matrix\\n        if (game.user?.isGM &amp;&amp; this.isOwner &amp;&amp; (this.isCharacter() || this.isSprite() || this.isIC())) {\\n            // Check if we've already added matrix actions to this actor\\n            const hasMatrixActions = this.getFlag('sr6elysium', 'hasMatrixActions');\\n            if (!hasMatrixActions) {\\n                // We need to use a setTimeout to avoid issues with the actor being locked during data preparation\\n                // Also add error handling to prevent crashes during initialization\\n                setTimeout(() =&gt; {\\n                    try {\\n                        this.ensureMatrixActions();\\n                    } catch (error) {\\n                        console.warn(`Shadowrun 6e | Failed to ensure matrix actions for actor ${this.name}:`, error);\\n                    }\\n                }, 500);\\n            }\\n        }\&quot;}]}&quot;,&quot;mcp_server_name&quot;:&quot;&quot;,&quot;mcp_tool_name&quot;:&quot;&quot;}},{&quot;id&quot;:0,&quot;type&quot;:0,&quot;content&quot;:&quot;Now let me fix the matrix actions initialization to be more robust and avoid race conditions:\n&quot;},{&quot;id&quot;:2,&quot;type&quot;:2,&quot;content&quot;:&quot;&quot;},{&quot;id&quot;:3,&quot;type&quot;:3,&quot;content&quot;:&quot;&quot;}],&quot;seen_state&quot;:&quot;seen&quot;,&quot;structured_request_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:1,&quot;tool_result_node&quot;:{&quot;content&quot;:&quot;Successfully edited the file src/module/hooks.ts.\nResult for str_replace for entry with index [0]:\nReplacement successful.\nEdited section after IDE auto-formatting was applied:\n   443\t     */\n   444\t    static async updateIcConnectedToHostItem(item: SR6Item, data: Shadowrun.ShadowrunItemDataData, id: string) {\n   445\t        if (!canvas.ready || !game.actors) return;\n   446\t\n   447\t        if (item.isHost) {\n   448\t            // Collect actors from sidebar and active scene to update / rerender\n   449\t            let connectedIC = [\n   450\t                // All sidebar actors should also include tokens with linked actors.\n   451\t                ...game.actors.filter((actor: SR6Actor) =&gt; actor.isIC() &amp;&amp; actor.hasHost()) as SR6Actor[],\n   452\t                // All token actors that aren't linked.\n   453\t                // @ts-expect-error // TODO: foundry-vtt-types v10\n   454\t                ...canvas.scene.tokens.filter(token =&gt; !token.actorLink &amp;&amp; token.actor?.isIC() &amp;&amp; token.actor?.hasHost()).map(t =&gt; t.actor).filter(actor =&gt; actor !== null &amp;&amp; actor !== undefined)\n   455\t            ];\n   456\t\n   457\t            // Update host data on the ic actor.\n   458\t            const host = item.asHost;\n   459\t            if (!host) return;\n\nReview the changes and make sure they are as expected (correct indentation, no duplicate lines, etc).\nEdit the file again if necessary.\n&quot;,&quot;is_error&quot;:false,&quot;request_id&quot;:&quot;&quot;,&quot;tool_use_id&quot;:&quot;toolu_vrtx_01DBKRhSah2vw9f9ku1k4LXY&quot;}},{&quot;id&quot;:2,&quot;type&quot;:4,&quot;ide_state_node&quot;:{&quot;workspaceFolders&quot;:[{&quot;repositoryRoot&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;,&quot;folderRoot&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;}],&quot;workspaceFoldersUnchanged&quot;:false,&quot;currentTerminal&quot;:{&quot;terminalId&quot;:12,&quot;currentWorkingDirectory&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;}}}],&quot;timestamp&quot;:&quot;2025-05-29T23:33:12.094Z&quot;,&quot;response_text&quot;:&quot;Now let me fix the matrix actions initialization to be more robust and avoid race conditions:\n&quot;,&quot;workspace_file_chunks&quot;:[]},{&quot;status&quot;:&quot;success&quot;,&quot;request_id&quot;:&quot;f481e317-a940-4876-bd51-32125577c863&quot;,&quot;request_message&quot;:&quot;&quot;,&quot;structured_output_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:5,&quot;content&quot;:&quot;&quot;,&quot;tool_use&quot;:{&quot;tool_use_id&quot;:&quot;toolu_vrtx_01XKMrtafLbfrRSRAmoRahAQ&quot;,&quot;tool_name&quot;:&quot;str-replace-editor&quot;,&quot;input_json&quot;:&quot;{\&quot;command\&quot;: \&quot;view\&quot;, \&quot;path\&quot;: \&quot;src/module/actor/SR6Actor.ts\&quot;, \&quot;view_range\&quot;: [2740, 2800]}&quot;,&quot;mcp_server_name&quot;:&quot;&quot;,&quot;mcp_tool_name&quot;:&quot;&quot;}},{&quot;id&quot;:0,&quot;type&quot;:0,&quot;content&quot;:&quot;Now let me improve the `ensureMatrixActions` method to be more robust:\n&quot;},{&quot;id&quot;:2,&quot;type&quot;:2,&quot;content&quot;:&quot;&quot;},{&quot;id&quot;:3,&quot;type&quot;:3,&quot;content&quot;:&quot;&quot;}],&quot;seen_state&quot;:&quot;seen&quot;,&quot;structured_request_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:1,&quot;tool_result_node&quot;:{&quot;content&quot;:&quot;Successfully edited the file src/module/actor/SR6Actor.ts.\nResult for str_replace for entry with index [0]:\nReplacement successful.\nEdited section after IDE auto-formatting was applied:\n   314\t                ICPrep.prepareDerivedData(this.system, itemDataWrappers);\n   315\t                break;\n   316\t        }\n   317\t\n   318\t        // Ensure matrix actions are available for all actors that can use the Matrix\n   319\t        if (game.user?.isGM &amp;&amp; this.isOwner &amp;&amp; (this.isCharacter() || this.isSprite() || this.isIC())) {\n   320\t            // Check if we've already added matrix actions to this actor\n   321\t            const hasMatrixActions = this.getFlag('sr6elysium', 'hasMatrixActions');\n   322\t            if (!hasMatrixActions) {\n   323\t                // We need to use a setTimeout to avoid issues with the actor being locked during data preparation\n   324\t                // Also add error handling to prevent crashes during initialization\n   325\t                setTimeout(() =&gt; {\n   326\t                    try {\n   327\t                        this.ensureMatrixActions();\n   328\t                    } catch (error) {\n   329\t                        console.warn(`Shadowrun 6e | Failed to ensure matrix actions for actor ${this.name}:`, error);\n   330\t                    }\n   331\t                }, 500);\n   332\t            }\n   333\t        }\n   334\t    }\n   335\t\n   336\t    /**\n   337\t     * NOTE: This method is unused at the moment, keep it for future inspiration.\n\nReview the changes and make sure they are as expected (correct indentation, no duplicate lines, etc).\nEdit the file again if necessary.\n&quot;,&quot;is_error&quot;:false,&quot;request_id&quot;:&quot;&quot;,&quot;tool_use_id&quot;:&quot;toolu_vrtx_01Y1UrDHFxtMLpYjYnJUwoAW&quot;}},{&quot;id&quot;:2,&quot;type&quot;:4,&quot;ide_state_node&quot;:{&quot;workspaceFolders&quot;:[{&quot;repositoryRoot&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;,&quot;folderRoot&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;}],&quot;workspaceFoldersUnchanged&quot;:false,&quot;currentTerminal&quot;:{&quot;terminalId&quot;:12,&quot;currentWorkingDirectory&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;}}}],&quot;timestamp&quot;:&quot;2025-05-29T23:33:19.914Z&quot;,&quot;response_text&quot;:&quot;Now let me improve the `ensureMatrixActions` method to be more robust:\n&quot;,&quot;workspace_file_chunks&quot;:[]},{&quot;status&quot;:&quot;success&quot;,&quot;request_id&quot;:&quot;6780cfe8-3d82-45da-8815-1be78f56c85d&quot;,&quot;request_message&quot;:&quot;&quot;,&quot;structured_output_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:5,&quot;content&quot;:&quot;&quot;,&quot;tool_use&quot;:{&quot;tool_use_id&quot;:&quot;toolu_vrtx_01WEYaNeofMCX49CUzEzZieN&quot;,&quot;tool_name&quot;:&quot;str-replace-editor&quot;,&quot;input_json&quot;:&quot;{\&quot;command\&quot;: \&quot;str_replace\&quot;, \&quot;path\&quot;: \&quot;src/module/actor/SR6Actor.ts\&quot;, \&quot;str_replace_entries\&quot;: [{\&quot;old_str\&quot;: \&quot;    async ensureMatrixActions() {\\n        console.log(`Shadowrun 6e | Ensuring matrix actions for actor ${this.name} (${this.id})`);\\n\\n        // Check if we've already added matrix actions to this actor\\n        const hasMatrixActions = this.getFlag('sr6elysium', 'hasMatrixActions');\\n        if (hasMatrixActions) {\\n            console.log(`Shadowrun 6e | ${this.name} already has matrix actions flag set`);\\n            return;\\n        }\\n\\n        // Get the matrix actions compendium\\n        const matrixPack = game.packs.get(\\\&quot;sr6elysium.matrix-actions\\\&quot;);\\n        if (!matrixPack) {\\n            console.error(\\\&quot;Shadowrun 6e | Matrix Actions compendium not found\\\&quot;);\\n            return;\\n        }\\n\\n        // Get all matrix actions\\n        await matrixPack.getIndex();\\n        const matrixActions = await Promise.all(\\n            Array.from(matrixPack.index).map(i =&gt; matrixPack.getDocument(i._id))\\n        );\\n\\n        // Get existing action names to avoid duplicates\\n        const existingNames = this.items\\n            .filter(i =&gt; i.type === \\\&quot;action\\\&quot;)\\n            .map(i =&gt; i.name.toLowerCase());\\n\\n        // Filter out actions the actor already has\\n        const actionsToAdd = matrixActions.filter(\\n            a =&gt; !existingNames.includes(a.name.toLowerCase())\\n        );\\n\\n        if (actionsToAdd.length === 0) {\\n            console.log(`Shadowrun 6e | ${this.name} already has all matrix actions`);\\n            // Set the flag to indicate that we've checked for matrix actions\\n            await this.setFlag('sr6elysium', 'hasMatrixActions', true);\\n            return;\\n        }\\n\\n        // Add the actions\\n        await this.createEmbeddedDocuments(\\n            \\\&quot;Item\\\&quot;,\\n            actionsToAdd.map(a =&gt; a.toObject())\\n        );\\n\\n        console.log(`Shadowrun 6e | Added ${actionsToAdd.length} matrix actions to ${this.name}`);\\n\\n        // Set the flag to indicate that we've added matrix actions\\n        await this.setFlag('sr6elysium', 'hasMatrixActions', true);\&quot;, \&quot;old_str_start_line_number\&quot;: 2751, \&quot;old_str_end_line_number\&quot;: 2800, \&quot;new_str\&quot;: \&quot;    async ensureMatrixActions() {\\n        try {\\n            console.log(`Shadowrun 6e | Ensuring matrix actions for actor ${this.name} (${this.id})`);\\n\\n            // Validate that the actor still exists and is valid\\n            if (!this.id || !this.name) {\\n                console.warn(`Shadowrun 6e | Actor is invalid, skipping matrix actions initialization`);\\n                return;\\n            }\\n\\n            // Check if we've already added matrix actions to this actor\\n            const hasMatrixActions = this.getFlag('sr6elysium', 'hasMatrixActions');\\n            if (hasMatrixActions) {\\n                console.log(`Shadowrun 6e | ${this.name} already has matrix actions flag set`);\\n                return;\\n            }\\n\\n            // Get the matrix actions compendium\\n            const matrixPack = game.packs.get(\\\&quot;sr6elysium.matrix-actions\\\&quot;);\\n            if (!matrixPack) {\\n                console.error(\\\&quot;Shadowrun 6e | Matrix Actions compendium not found\\\&quot;);\\n                return;\\n            }\\n\\n            // Get all matrix actions\\n            await matrixPack.getIndex();\\n            const matrixActions = await Promise.all(\\n                Array.from(matrixPack.index).map(i =&gt; matrixPack.getDocument(i._id))\\n            );\\n\\n            // Filter out null/undefined actions\\n            const validMatrixActions = matrixActions.filter(action =&gt; action &amp;&amp; action.name);\\n            if (validMatrixActions.length === 0) {\\n                console.warn(`Shadowrun 6e | No valid matrix actions found in compendium`);\\n                await this.setFlag('sr6elysium', 'hasMatrixActions', true);\\n                return;\\n            }\\n\\n            // Get existing action names to avoid duplicates\\n            const existingNames = this.items\\n                .filter(i =&gt; i &amp;&amp; i.type === \\\&quot;action\\\&quot; &amp;&amp; i.name)\\n                .map(i =&gt; i.name.toLowerCase());\\n\\n            // Filter out actions the actor already has\\n            const actionsToAdd = validMatrixActions.filter(\\n                a =&gt; a &amp;&amp; a.name &amp;&amp; !existingNames.includes(a.name.toLowerCase())\\n            );\\n\\n            if (actionsToAdd.length === 0) {\\n                console.log(`Shadowrun 6e | ${this.name} already has all matrix actions`);\\n                // Set the flag to indicate that we've checked for matrix actions\\n                await this.setFlag('sr6elysium', 'hasMatrixActions', true);\\n                return;\\n            }\\n\\n            // Add the actions\\n            await this.createEmbeddedDocuments(\\n                \\\&quot;Item\\\&quot;,\\n                actionsToAdd.map(a =&gt; a.toObject())\\n            );\\n\\n            console.log(`Shadowrun 6e | Added ${actionsToAdd.length} matrix actions to ${this.name}`);\\n\\n            // Set the flag to indicate that we've added matrix actions\\n            await this.setFlag('sr6elysium', 'hasMatrixActions', true);\\n        } catch (error) {\\n            console.error(`Shadowrun 6e | Error ensuring matrix actions for actor ${this.name}:`, error);\\n            // Set the flag anyway to prevent repeated attempts\\n            try {\\n                await this.setFlag('sr6elysium', 'hasMatrixActions', true);\\n            } catch (flagError) {\\n                console.error(`Shadowrun 6e | Failed to set matrix actions flag for ${this.name}:`, flagError);\\n            }\\n        }\&quot;}]}&quot;,&quot;mcp_server_name&quot;:&quot;&quot;,&quot;mcp_tool_name&quot;:&quot;&quot;}},{&quot;id&quot;:0,&quot;type&quot;:0,&quot;content&quot;:&quot;Let me add better error handling and validation to the `ensureMatrixActions` method:\n&quot;},{&quot;id&quot;:2,&quot;type&quot;:2,&quot;content&quot;:&quot;&quot;},{&quot;id&quot;:3,&quot;type&quot;:3,&quot;content&quot;:&quot;&quot;}],&quot;seen_state&quot;:&quot;seen&quot;,&quot;structured_request_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:1,&quot;tool_result_node&quot;:{&quot;content&quot;:&quot;Here's the result of running `cat -n` on src/module/actor/SR6Actor.ts:\n  2740\t                console.log(`Shadowrun 6e | Refreshed token sheet ${id} for ${app.token.name}`);\n  2741\t            }\n  2742\t        }\n  2743\t    }\n  2744\t\n  2745\t    /**\n  2746\t     * Ensures that the actor has access to all matrix actions from the matrix-actions compendium.\n  2747\t     * This method will add any missing matrix actions to the actor.\n  2748\t     *\n  2749\t     * @returns {Promise&lt;void&gt;}\n  2750\t     */\n  2751\t    async ensureMatrixActions() {\n  2752\t        console.log(`Shadowrun 6e | Ensuring matrix actions for actor ${this.name} (${this.id})`);\n  2753\t\n  2754\t        // Check if we've already added matrix actions to this actor\n  2755\t        const hasMatrixActions = this.getFlag('sr6elysium', 'hasMatrixActions');\n  2756\t        if (hasMatrixActions) {\n  2757\t            console.log(`Shadowrun 6e | ${this.name} already has matrix actions flag set`);\n  2758\t            return;\n  2759\t        }\n  2760\t\n  2761\t        // Get the matrix actions compendium\n  2762\t        const matrixPack = game.packs.get(\&quot;sr6elysium.matrix-actions\&quot;);\n  2763\t        if (!matrixPack) {\n  2764\t            console.error(\&quot;Shadowrun 6e | Matrix Actions compendium not found\&quot;);\n  2765\t            return;\n  2766\t        }\n  2767\t\n  2768\t        // Get all matrix actions\n  2769\t        await matrixPack.getIndex();\n  2770\t        const matrixActions = await Promise.all(\n  2771\t            Array.from(matrixPack.index).map(i =&gt; matrixPack.getDocument(i._id))\n  2772\t        );\n  2773\t\n  2774\t        // Get existing action names to avoid duplicates\n  2775\t        const existingNames = this.items\n  2776\t            .filter(i =&gt; i.type === \&quot;action\&quot;)\n  2777\t            .map(i =&gt; i.name.toLowerCase());\n  2778\t\n  2779\t        // Filter out actions the actor already has\n  2780\t        const actionsToAdd = matrixActions.filter(\n  2781\t            a =&gt; !existingNames.includes(a.name.toLowerCase())\n  2782\t        );\n  2783\t\n  2784\t        if (actionsToAdd.length === 0) {\n  2785\t            console.log(`Shadowrun 6e | ${this.name} already has all matrix actions`);\n  2786\t            // Set the flag to indicate that we've checked for matrix actions\n  2787\t            await this.setFlag('sr6elysium', 'hasMatrixActions', true);\n  2788\t            return;\n  2789\t        }\n  2790\t\n  2791\t        // Add the actions\n  2792\t        await this.createEmbeddedDocuments(\n  2793\t            \&quot;Item\&quot;,\n  2794\t            actionsToAdd.map(a =&gt; a.toObject())\n  2795\t        );\n  2796\t\n  2797\t        console.log(`Shadowrun 6e | Added ${actionsToAdd.length} matrix actions to ${this.name}`);\n  2798\t\n  2799\t        // Set the flag to indicate that we've added matrix actions\n  2800\t        await this.setFlag('sr6elysium', 'hasMatrixActions', true);\nTotal lines in file: 3038\n&quot;,&quot;is_error&quot;:false,&quot;request_id&quot;:&quot;&quot;,&quot;tool_use_id&quot;:&quot;toolu_vrtx_01XKMrtafLbfrRSRAmoRahAQ&quot;}},{&quot;id&quot;:2,&quot;type&quot;:4,&quot;ide_state_node&quot;:{&quot;workspaceFolders&quot;:[{&quot;repositoryRoot&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;,&quot;folderRoot&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;}],&quot;workspaceFoldersUnchanged&quot;:false,&quot;currentTerminal&quot;:{&quot;terminalId&quot;:12,&quot;currentWorkingDirectory&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;}}}],&quot;timestamp&quot;:&quot;2025-05-29T23:33:23.147Z&quot;,&quot;response_text&quot;:&quot;Let me add better error handling and validation to the `ensureMatrixActions` method:\n&quot;,&quot;workspace_file_chunks&quot;:[]},{&quot;status&quot;:&quot;success&quot;,&quot;request_id&quot;:&quot;b6fdb711-eb04-4ad4-9aa4-26e54493eb09&quot;,&quot;request_message&quot;:&quot;&quot;,&quot;structured_output_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:5,&quot;content&quot;:&quot;&quot;,&quot;tool_use&quot;:{&quot;tool_use_id&quot;:&quot;toolu_vrtx_01N8GuyrBEnt1DQ2GxN1h9iT&quot;,&quot;tool_name&quot;:&quot;str-replace-editor&quot;,&quot;input_json&quot;:&quot;{\&quot;command\&quot;: \&quot;str_replace\&quot;, \&quot;path\&quot;: \&quot;src/module/helpers.ts\&quot;, \&quot;str_replace_entries\&quot;: [{\&quot;old_str\&quot;: \&quot;    /**\\n     * Return all actors connected to all user controlled tokens.\\n     * @returns An array token actors.\\n     */\\n    static getControlledTokenActors(): SR6Actor[] {\\n        if (!canvas || !canvas.ready) return []\\n\\n        const tokens = Helpers.getControlledTokens();\\n        return tokens.map(token =&gt; token.actor) as SR6Actor[];\\n    }\&quot;, \&quot;old_str_start_line_number\&quot;: 456, \&quot;old_str_end_line_number\&quot;: 465, \&quot;new_str\&quot;: \&quot;    /**\\n     * Return all actors connected to all user controlled tokens.\\n     * @returns An array token actors.\\n     */\\n    static getControlledTokenActors(): SR6Actor[] {\\n        if (!canvas || !canvas.ready) return []\\n\\n        const tokens = Helpers.getControlledTokens();\\n        return tokens.map(token =&gt; token.actor).filter(actor =&gt; actor !== null &amp;&amp; actor !== undefined) as SR6Actor[];\\n    }\&quot;}]}&quot;,&quot;mcp_server_name&quot;:&quot;&quot;,&quot;mcp_tool_name&quot;:&quot;&quot;}},{&quot;id&quot;:0,&quot;type&quot;:0,&quot;content&quot;:&quot;Now let me fix the issue in the helpers.ts file where `getControlledTokenActors` doesn't check for null actors:\n&quot;},{&quot;id&quot;:2,&quot;type&quot;:2,&quot;content&quot;:&quot;&quot;},{&quot;id&quot;:3,&quot;type&quot;:3,&quot;content&quot;:&quot;&quot;}],&quot;seen_state&quot;:&quot;seen&quot;,&quot;structured_request_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:1,&quot;tool_result_node&quot;:{&quot;content&quot;:&quot;Successfully edited the file src/module/actor/SR6Actor.ts.\nResult for str_replace for entry with index [0]:\nReplacement successful.\nEdited section after IDE auto-formatting was applied:\n  2747\t     * This method will add any missing matrix actions to the actor.\n  2748\t     *\n  2749\t     * @returns {Promise&lt;void&gt;}\n  2750\t     */\n  2751\t    async ensureMatrixActions() {\n  2752\t        try {\n  2753\t            console.log(`Shadowrun 6e | Ensuring matrix actions for actor ${this.name} (${this.id})`);\n  2754\t\n  2755\t            // Validate that the actor still exists and is valid\n  2756\t            if (!this.id || !this.name) {\n  2757\t                console.warn(`Shadowrun 6e | Actor is invalid, skipping matrix actions initialization`);\n  2758\t                return;\n  2759\t            }\n  2760\t\n  2761\t            // Check if we've already added matrix actions to this actor\n  2762\t            const hasMatrixActions = this.getFlag('sr6elysium', 'hasMatrixActions');\n  2763\t            if (hasMatrixActions) {\n  2764\t                console.log(`Shadowrun 6e | ${this.name} already has matrix actions flag set`);\n  2765\t                return;\n  2766\t            }\n  2767\t\n  2768\t            // Get the matrix actions compendium\n  2769\t            const matrixPack = game.packs.get(\&quot;sr6elysium.matrix-actions\&quot;);\n  2770\t            if (!matrixPack) {\n  2771\t                console.error(\&quot;Shadowrun 6e | Matrix Actions compendium not found\&quot;);\n  2772\t                return;\n  2773\t            }\n  2774\t\n  2775\t            // Get all matrix actions\n  2776\t            await matrixPack.getIndex();\n  2777\t            const matrixActions = await Promise.all(\n  2778\t                Array.from(matrixPack.index).map(i =&gt; matrixPack.getDocument(i._id))\n  2779\t            );\n  2780\t\n  2781\t            // Filter out null/undefined actions\n  2782\t            const validMatrixActions = matrixActions.filter(action =&gt; action &amp;&amp; action.name);\n  2783\t            if (validMatrixActions.length === 0) {\n  2784\t                console.warn(`Shadowrun 6e | No valid matrix actions found in compendium`);\n  2785\t                await this.setFlag('sr6elysium', 'hasMatrixActions', true);\n  2786\t                return;\n  2787\t            }\n  2788\t\n  2789\t            // Get existing action names to avoid duplicates\n  2790\t            const existingNames = this.items\n  2791\t                .filter(i =&gt; i &amp;&amp; i.type === \&quot;action\&quot; &amp;&amp; i.name)\n  2792\t                .map(i =&gt; i.name.toLowerCase());\n  2793\t\n  2794\t            // Filter out actions the actor already has\n  2795\t            const actionsToAdd = validMatrixActions.filter(\n  2796\t                a =&gt; a &amp;&amp; a.name &amp;&amp; !existingNames.includes(a.name.toLowerCase())\n  2797\t            );\n  2798\t\n  2799\t            if (actionsToAdd.length === 0) {\n  2800\t                console.log(`Shadowrun 6e | ${this.name} already has all matrix actions`);\n  2801\t                // Set the flag to indicate that we've checked for matrix actions\n  2802\t                await this.setFlag('sr6elysium', 'hasMatrixActions', true);\n  2803\t                return;\n  2804\t            }\n  2805\t\n  2806\t            // Add the actions\n  2807\t            await this.createEmbeddedDocuments(\n  2808\t                \&quot;Item\&quot;,\n  2809\t                actionsToAdd.map(a =&gt; a.toObject())\n  2810\t            );\n  2811\t\n  2812\t            console.log(`Shadowrun 6e | Added ${actionsToAdd.length} matrix actions to ${this.name}`);\n  2813\t\n  2814\t            // Set the flag to indicate that we've added matrix actions\n  2815\t            await this.setFlag('sr6elysium', 'hasMatrixActions', true);\n  2816\t        } catch (error) {\n  2817\t            console.error(`Shadowrun 6e | Error ensuring matrix actions for actor ${this.name}:`, error);\n  2818\t            // Set the flag anyway to prevent repeated attempts\n  2819\t            try {\n  2820\t                await this.setFlag('sr6elysium', 'hasMatrixActions', true);\n  2821\t            } catch (flagError) {\n  2822\t                console.error(`Shadowrun 6e | Failed to set matrix actions flag for ${this.name}:`, flagError);\n  2823\t            }\n  2824\t        }\n  2825\t    }\n  2826\t\n  2827\t    async newSceneSetup() {\n  2828\t        const updateData: Record&lt;string, any&gt; = {};\n\nReview the changes and make sure they are as expected (correct indentation, no duplicate lines, etc).\nEdit the file again if necessary.\n&quot;,&quot;is_error&quot;:false,&quot;request_id&quot;:&quot;&quot;,&quot;tool_use_id&quot;:&quot;toolu_vrtx_01WEYaNeofMCX49CUzEzZieN&quot;}},{&quot;id&quot;:2,&quot;type&quot;:4,&quot;ide_state_node&quot;:{&quot;workspaceFolders&quot;:[{&quot;repositoryRoot&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;,&quot;folderRoot&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;}],&quot;workspaceFoldersUnchanged&quot;:false,&quot;currentTerminal&quot;:{&quot;terminalId&quot;:12,&quot;currentWorkingDirectory&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;}}}],&quot;timestamp&quot;:&quot;2025-05-29T23:33:38.205Z&quot;,&quot;response_text&quot;:&quot;Now let me fix the issue in the helpers.ts file where `getControlledTokenActors` doesn't check for null actors:\n&quot;,&quot;workspace_file_chunks&quot;:[]},{&quot;status&quot;:&quot;success&quot;,&quot;request_id&quot;:&quot;5cc95c70-f12c-4c0e-b46d-49a4328e6448&quot;,&quot;request_message&quot;:&quot;&quot;,&quot;structured_output_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:5,&quot;content&quot;:&quot;&quot;,&quot;tool_use&quot;:{&quot;tool_use_id&quot;:&quot;toolu_vrtx_01PN9Cvr19KEpK6VnitQwm3M&quot;,&quot;tool_name&quot;:&quot;str-replace-editor&quot;,&quot;input_json&quot;:&quot;{\&quot;command\&quot;: \&quot;str_replace\&quot;, \&quot;path\&quot;: \&quot;src/module/helpers.ts\&quot;, \&quot;str_replace_entries\&quot;: [{\&quot;old_str\&quot;: \&quot;    static getDefenseRating(targets: TokenDocument[]): number {\\n        let defenseRating = 0;\\n        for(const token of targets) {\\n            let target = token.actor;\\n            console.log(target);\\n            // @ts-ignore\\n            if ('defense_rating' in target.system.values &amp;&amp; target.system.values.defense_rating.value &gt; defenseRating) {\\n                // @ts-ignore\\n                defenseRating = target.system.values.defense_rating.value;\\n            }\\n        }\\n        return defenseRating;\\n    }\&quot;, \&quot;old_str_start_line_number\&quot;: 577, \&quot;old_str_end_line_number\&quot;: 589, \&quot;new_str\&quot;: \&quot;    static getDefenseRating(targets: TokenDocument[]): number {\\n        let defenseRating = 0;\\n        for(const token of targets) {\\n            let target = token.actor;\\n            if (!target) {\\n                console.warn('Shadowrun 6e | Token has no actor:', token.name);\\n                continue;\\n            }\\n            console.log(target);\\n            // @ts-ignore\\n            if (target.system &amp;&amp; target.system.values &amp;&amp; 'defense_rating' in target.system.values &amp;&amp; target.system.values.defense_rating.value &gt; defenseRating) {\\n                // @ts-ignore\\n                defenseRating = target.system.values.defense_rating.value;\\n            }\\n        }\\n        return defenseRating;\\n    }\&quot;}]}&quot;,&quot;mcp_server_name&quot;:&quot;&quot;,&quot;mcp_tool_name&quot;:&quot;&quot;}},{&quot;id&quot;:0,&quot;type&quot;:0,&quot;content&quot;:&quot;Now let me fix the `getDefenseRating` function that accesses `token.actor` without null checking:\n&quot;},{&quot;id&quot;:2,&quot;type&quot;:2,&quot;content&quot;:&quot;&quot;},{&quot;id&quot;:3,&quot;type&quot;:3,&quot;content&quot;:&quot;&quot;}],&quot;seen_state&quot;:&quot;seen&quot;,&quot;structured_request_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:1,&quot;tool_result_node&quot;:{&quot;content&quot;:&quot;Successfully edited the file src/module/helpers.ts.\nResult for str_replace for entry with index [0]:\nReplacement successful.\nEdited section after IDE auto-formatting was applied:\n   452\t        if (!canvas || !canvas.ready || !canvas.tokens) return false;\n   453\t        return canvas.tokens.controlled.length &gt; 0;\n   454\t    }\n   455\t\n   456\t    /**\n   457\t     * Return all actors connected to all user controlled tokens.\n   458\t     * @returns An array token actors.\n   459\t     */\n   460\t    static getControlledTokenActors(): SR6Actor[] {\n   461\t        if (!canvas || !canvas.ready) return []\n   462\t\n   463\t        const tokens = Helpers.getControlledTokens();\n   464\t        return tokens.map(token =&gt; token.actor).filter(actor =&gt; actor !== null &amp;&amp; actor !== undefined) as SR6Actor[];\n   465\t    }\n   466\t\n   467\t    /**\n   468\t     * return all tokens a user has targeted at the moment.\n   469\t     * @returns An array tokens.\n\nReview the changes and make sure they are as expected (correct indentation, no duplicate lines, etc).\nEdit the file again if necessary.\n&quot;,&quot;is_error&quot;:false,&quot;request_id&quot;:&quot;&quot;,&quot;tool_use_id&quot;:&quot;toolu_vrtx_01N8GuyrBEnt1DQ2GxN1h9iT&quot;}},{&quot;id&quot;:2,&quot;type&quot;:4,&quot;ide_state_node&quot;:{&quot;workspaceFolders&quot;:[{&quot;repositoryRoot&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;,&quot;folderRoot&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;}],&quot;workspaceFoldersUnchanged&quot;:false,&quot;currentTerminal&quot;:{&quot;terminalId&quot;:12,&quot;currentWorkingDirectory&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;}}}],&quot;timestamp&quot;:&quot;2025-05-29T23:33:45.197Z&quot;,&quot;response_text&quot;:&quot;Now let me fix the `getDefenseRating` function that accesses `token.actor` without null checking:\n&quot;,&quot;workspace_file_chunks&quot;:[]},{&quot;status&quot;:&quot;success&quot;,&quot;request_id&quot;:&quot;43a9a213-6823-4ba9-89cb-17d3b7847f6c&quot;,&quot;request_message&quot;:&quot;&quot;,&quot;structured_output_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:5,&quot;content&quot;:&quot;&quot;,&quot;tool_use&quot;:{&quot;tool_use_id&quot;:&quot;toolu_vrtx_01WxRAoD8xxXw4AqEVeVZQPq&quot;,&quot;tool_name&quot;:&quot;str-replace-editor&quot;,&quot;input_json&quot;:&quot;{\&quot;command\&quot;: \&quot;str_replace\&quot;, \&quot;path\&quot;: \&quot;src/module/rules/DocumentSituationModifiers.ts\&quot;, \&quot;str_replace_entries\&quot;: [{\&quot;old_str\&quot;: \&quot;        // Use current scene for ease of access to tokens\\n        canvas.scene.tokens.forEach(token =&gt; token.actor?.getSituationModifiers().clearAll());\&quot;, \&quot;old_str_start_line_number\&quot;: 402, \&quot;old_str_end_line_number\&quot;: 403, \&quot;new_str\&quot;: \&quot;        // Use current scene for ease of access to tokens\\n        canvas.scene.tokens.forEach(token =&gt; {\\n            if (token.actor) {\\n                token.actor.getSituationModifiers().clearAll();\\n            }\\n        });\&quot;}]}&quot;,&quot;mcp_server_name&quot;:&quot;&quot;,&quot;mcp_tool_name&quot;:&quot;&quot;}},{&quot;id&quot;:0,&quot;type&quot;:0,&quot;content&quot;:&quot;Now let me fix the issue in the DocumentSituationModifiers where it accesses `token.actor` without null checking:\n&quot;},{&quot;id&quot;:2,&quot;type&quot;:2,&quot;content&quot;:&quot;&quot;},{&quot;id&quot;:3,&quot;type&quot;:3,&quot;content&quot;:&quot;&quot;}],&quot;seen_state&quot;:&quot;seen&quot;,&quot;structured_request_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:1,&quot;tool_result_node&quot;:{&quot;content&quot;:&quot;Successfully edited the file src/module/helpers.ts.\nResult for str_replace for entry with index [0]:\nReplacement successful.\nEdited section after IDE auto-formatting was applied:\n   573\t\n   574\t        return actor.name as string;\n   575\t    }\n   576\t\n   577\t    static getDefenseRating(targets: TokenDocument[]): number {\n   578\t        let defenseRating = 0;\n   579\t        for(const token of targets) {\n   580\t            let target = token.actor;\n   581\t            if (!target) {\n   582\t                console.warn('Shadowrun 6e | Token has no actor:', token.name);\n   583\t                continue;\n   584\t            }\n   585\t            console.log(target);\n   586\t            // @ts-ignore\n   587\t            if (target.system &amp;&amp; target.system.values &amp;&amp; 'defense_rating' in target.system.values &amp;&amp; target.system.values.defense_rating.value &gt; defenseRating) {\n   588\t                // @ts-ignore\n   589\t                defenseRating = target.system.values.defense_rating.value;\n   590\t            }\n   591\t        }\n   592\t        return defenseRating;\n   593\t    }\n   594\t\n   595\t    static getAttackRating(actor: SR6Actor): number {\n   596\t        return 0;\n   597\t    }\n\nReview the changes and make sure they are as expected (correct indentation, no duplicate lines, etc).\nEdit the file again if necessary.\n&quot;,&quot;is_error&quot;:false,&quot;request_id&quot;:&quot;&quot;,&quot;tool_use_id&quot;:&quot;toolu_vrtx_01PN9Cvr19KEpK6VnitQwm3M&quot;}},{&quot;id&quot;:2,&quot;type&quot;:4,&quot;ide_state_node&quot;:{&quot;workspaceFolders&quot;:[{&quot;repositoryRoot&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;,&quot;folderRoot&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;}],&quot;workspaceFoldersUnchanged&quot;:false,&quot;currentTerminal&quot;:{&quot;terminalId&quot;:12,&quot;currentWorkingDirectory&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;}}}],&quot;timestamp&quot;:&quot;2025-05-29T23:33:53.433Z&quot;,&quot;response_text&quot;:&quot;Now let me fix the issue in the DocumentSituationModifiers where it accesses `token.actor` without null checking:\n&quot;,&quot;workspace_file_chunks&quot;:[]},{&quot;status&quot;:&quot;success&quot;,&quot;request_id&quot;:&quot;9a37be07-8376-410c-bcd8-2c191383b532&quot;,&quot;request_message&quot;:&quot;&quot;,&quot;structured_output_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:5,&quot;content&quot;:&quot;&quot;,&quot;tool_use&quot;:{&quot;tool_use_id&quot;:&quot;toolu_vrtx_019Uf5qPEYx7arNVjEfE5DtM&quot;,&quot;tool_name&quot;:&quot;str-replace-editor&quot;,&quot;input_json&quot;:&quot;{\&quot;command\&quot;: \&quot;str_replace\&quot;, \&quot;path\&quot;: \&quot;src/module/actor/SR6Actor.ts\&quot;, \&quot;str_replace_entries\&quot;: [{\&quot;old_str\&quot;: \&quot;        // Refresh the canvas if it exists\\n        if (canvas &amp;&amp; canvas.tokens &amp;&amp; typeof canvas.tokens.placeables !== 'undefined') {\\n            canvas.tokens.placeables.forEach(token =&gt; {\\n                if (token.actor &amp;&amp; token.actor.id === this.id &amp;&amp; token.refresh) {\\n                    token.refresh();\\n                }\\n            });\\n        }\&quot;, \&quot;old_str_start_line_number\&quot;: 2991, \&quot;old_str_end_line_number\&quot;: 2998, \&quot;new_str\&quot;: \&quot;        // Refresh the canvas if it exists\\n        if (canvas &amp;&amp; canvas.tokens &amp;&amp; typeof canvas.tokens.placeables !== 'undefined') {\\n            canvas.tokens.placeables.forEach(token =&gt; {\\n                if (token.actor &amp;&amp; token.actor.id === this.id &amp;&amp; token.refresh) {\\n                    token.refresh();\\n                }\\n            });\\n        }\&quot;}]}&quot;,&quot;mcp_server_name&quot;:&quot;&quot;,&quot;mcp_tool_name&quot;:&quot;&quot;}},{&quot;id&quot;:0,&quot;type&quot;:0,&quot;content&quot;:&quot;Now let me fix the issue in the SR6Actor.ts where it accesses token.actor without null checking in the refresh methods:\n&quot;},{&quot;id&quot;:2,&quot;type&quot;:2,&quot;content&quot;:&quot;&quot;},{&quot;id&quot;:3,&quot;type&quot;:3,&quot;content&quot;:&quot;&quot;}],&quot;seen_state&quot;:&quot;seen&quot;,&quot;structured_request_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:1,&quot;tool_result_node&quot;:{&quot;content&quot;:&quot;Successfully edited the file src/module/rules/DocumentSituationModifiers.ts.\nResult for str_replace for entry with index [0]:\nReplacement successful.\nEdited section after IDE auto-formatting was applied:\n   398\t        // Validate that modifiers scene is same to current scene.\n   399\t        const scene = this.document as Scene;\n   400\t        if (canvas.scene.id !== scene.id) return;\n   401\t\n   402\t        // Use current scene for ease of access to tokens\n   403\t        canvas.scene.tokens.forEach(token =&gt; {\n   404\t            if (token.actor) {\n   405\t                token.actor.getSituationModifiers().clearAll();\n   406\t            }\n   407\t        });\n   408\t    }\n   409\t}\n   410\t\n\nReview the changes and make sure they are as expected (correct indentation, no duplicate lines, etc).\nEdit the file again if necessary.\n&quot;,&quot;is_error&quot;:false,&quot;request_id&quot;:&quot;&quot;,&quot;tool_use_id&quot;:&quot;toolu_vrtx_01WxRAoD8xxXw4AqEVeVZQPq&quot;}},{&quot;id&quot;:2,&quot;type&quot;:4,&quot;ide_state_node&quot;:{&quot;workspaceFolders&quot;:[{&quot;repositoryRoot&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;,&quot;folderRoot&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;}],&quot;workspaceFoldersUnchanged&quot;:false,&quot;currentTerminal&quot;:{&quot;terminalId&quot;:12,&quot;currentWorkingDirectory&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;}}}],&quot;timestamp&quot;:&quot;2025-05-29T23:33:59.540Z&quot;,&quot;response_text&quot;:&quot;Now let me fix the issue in the SR6Actor.ts where it accesses token.actor without null checking in the refresh methods:\n&quot;,&quot;workspace_file_chunks&quot;:[]},{&quot;status&quot;:&quot;success&quot;,&quot;request_id&quot;:&quot;5096e646-b949-4e2c-a7f1-1162a8e216df&quot;,&quot;request_message&quot;:&quot;&quot;,&quot;structured_output_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:5,&quot;content&quot;:&quot;&quot;,&quot;tool_use&quot;:{&quot;tool_use_id&quot;:&quot;toolu_vrtx_01TS6tsv5qMdBBkHuogUw2vW&quot;,&quot;tool_name&quot;:&quot;str-replace-editor&quot;,&quot;input_json&quot;:&quot;{\&quot;command\&quot;: \&quot;str_replace\&quot;, \&quot;path\&quot;: \&quot;src/module/actor/SR6Actor.ts\&quot;, \&quot;str_replace_entries\&quot;: [{\&quot;old_str\&quot;: \&quot;        // Ensure matrix actions are available for all actors that can use the Matrix\\n        if (game.user?.isGM &amp;&amp; this.isOwner &amp;&amp; (this.isCharacter() || this.isSprite() || this.isIC())) {\\n            // Check if we've already added matrix actions to this actor\\n            const hasMatrixActions = this.getFlag('sr6elysium', 'hasMatrixActions');\\n            if (!hasMatrixActions) {\\n                // We need to use a setTimeout to avoid issues with the actor being locked during data preparation\\n                // Also add error handling to prevent crashes during initialization\\n                setTimeout(() =&gt; {\\n                    try {\\n                        this.ensureMatrixActions();\\n                    } catch (error) {\\n                        console.warn(`Shadowrun 6e | Failed to ensure matrix actions for actor ${this.name}:`, error);\\n                    }\\n                }, 500);\\n            }\\n        }\&quot;, \&quot;old_str_start_line_number\&quot;: 318, \&quot;old_str_end_line_number\&quot;: 333, \&quot;new_str\&quot;: \&quot;        // Ensure matrix actions are available for all actors that can use the Matrix\\n        // Only run this if the game is fully ready and not during migration\\n        if (game.ready &amp;&amp; game.user?.isGM &amp;&amp; this.isOwner &amp;&amp; (this.isCharacter() || this.isSprite() || this.isIC())) {\\n            // Check if we've already added matrix actions to this actor\\n            const hasMatrixActions = this.getFlag('sr6elysium', 'hasMatrixActions');\\n            if (!hasMatrixActions) {\\n                // We need to use a setTimeout to avoid issues with the actor being locked during data preparation\\n                // Also add error handling to prevent crashes during initialization\\n                setTimeout(() =&gt; {\\n                    try {\\n                        // Double-check that the game is still ready and the actor is valid\\n                        if (game.ready &amp;&amp; this.id &amp;&amp; this.name) {\\n                            this.ensureMatrixActions();\\n                        }\\n                    } catch (error) {\\n                        console.warn(`Shadowrun 6e | Failed to ensure matrix actions for actor ${this.name}:`, error);\\n                    }\\n                }, 500);\\n            }\\n        }\&quot;}]}&quot;,&quot;mcp_server_name&quot;:&quot;&quot;,&quot;mcp_tool_name&quot;:&quot;&quot;}},{&quot;id&quot;:0,&quot;type&quot;:0,&quot;content&quot;:&quot;Now let me also add a check to prevent the matrix actions initialization from running during world migration or when the game is not fully ready:\n&quot;},{&quot;id&quot;:2,&quot;type&quot;:2,&quot;content&quot;:&quot;&quot;},{&quot;id&quot;:3,&quot;type&quot;:3,&quot;content&quot;:&quot;&quot;}],&quot;seen_state&quot;:&quot;seen&quot;,&quot;structured_request_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:1,&quot;tool_result_node&quot;:{&quot;content&quot;:&quot;Successfully edited the file src/module/actor/SR6Actor.ts.\nResult for str_replace for entry with index [0]:\nReplacement successful.\nEdited section after IDE auto-formatting was applied:\n  3018\t        for (const token of this.getActiveTokens()) {\n  3019\t            if (token.refresh) token.refresh();\n  3020\t        }\n  3021\t\n  3022\t        // Refresh the canvas if it exists\n  3023\t        if (canvas &amp;&amp; canvas.tokens &amp;&amp; typeof canvas.tokens.placeables !== 'undefined') {\n  3024\t            canvas.tokens.placeables.forEach(token =&gt; {\n  3025\t                if (token.actor &amp;&amp; token.actor.id === this.id &amp;&amp; token.refresh) {\n  3026\t                    token.refresh();\n  3027\t                }\n  3028\t            });\n  3029\t        }\n  3030\t\n  3031\t        // Refresh token sheets\n  3032\t        this.refreshTokenSheets();\n  3033\t\n\nReview the changes and make sure they are as expected (correct indentation, no duplicate lines, etc).\nEdit the file again if necessary.\n&quot;,&quot;is_error&quot;:false,&quot;request_id&quot;:&quot;&quot;,&quot;tool_use_id&quot;:&quot;toolu_vrtx_019Uf5qPEYx7arNVjEfE5DtM&quot;}},{&quot;id&quot;:2,&quot;type&quot;:4,&quot;ide_state_node&quot;:{&quot;workspaceFolders&quot;:[{&quot;repositoryRoot&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;,&quot;folderRoot&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;}],&quot;workspaceFoldersUnchanged&quot;:false,&quot;currentTerminal&quot;:{&quot;terminalId&quot;:12,&quot;currentWorkingDirectory&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;}}}],&quot;timestamp&quot;:&quot;2025-05-29T23:34:04.754Z&quot;,&quot;response_text&quot;:&quot;Now let me also add a check to prevent the matrix actions initialization from running during world migration or when the game is not fully ready:\n&quot;,&quot;workspace_file_chunks&quot;:[]},{&quot;status&quot;:&quot;success&quot;,&quot;request_id&quot;:&quot;e43f4ed4-7fd8-4ce7-a1d5-2455003f775a&quot;,&quot;request_message&quot;:&quot;&quot;,&quot;structured_output_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:5,&quot;content&quot;:&quot;&quot;,&quot;tool_use&quot;:{&quot;tool_use_id&quot;:&quot;toolu_vrtx_01XRw5nccdmHgzNFdAd7Bgqw&quot;,&quot;tool_name&quot;:&quot;str-replace-editor&quot;,&quot;input_json&quot;:&quot;{\&quot;command\&quot;: \&quot;view\&quot;, \&quot;path\&quot;: \&quot;src/module/targeting/TargetingService.ts\&quot;, \&quot;view_range\&quot;: [135, 145]}&quot;,&quot;mcp_server_name&quot;:&quot;&quot;,&quot;mcp_tool_name&quot;:&quot;&quot;}},{&quot;id&quot;:0,&quot;type&quot;:0,&quot;content&quot;:&quot;Now let me check if there are any other places in the targeting service that might need null checks:\n&quot;},{&quot;id&quot;:2,&quot;type&quot;:2,&quot;content&quot;:&quot;&quot;},{&quot;id&quot;:3,&quot;type&quot;:3,&quot;content&quot;:&quot;&quot;}],&quot;seen_state&quot;:&quot;seen&quot;,&quot;structured_request_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:1,&quot;tool_result_node&quot;:{&quot;content&quot;:&quot;Successfully edited the file src/module/actor/SR6Actor.ts.\nResult for str_replace for entry with index [0]:\nReplacement successful.\nEdited section after IDE auto-formatting was applied:\n   314\t                ICPrep.prepareDerivedData(this.system, itemDataWrappers);\n   315\t                break;\n   316\t        }\n   317\t\n   318\t        // Ensure matrix actions are available for all actors that can use the Matrix\n   319\t        // Only run this if the game is fully ready and not during migration\n   320\t        if (game.ready &amp;&amp; game.user?.isGM &amp;&amp; this.isOwner &amp;&amp; (this.isCharacter() || this.isSprite() || this.isIC())) {\n   321\t            // Check if we've already added matrix actions to this actor\n   322\t            const hasMatrixActions = this.getFlag('sr6elysium', 'hasMatrixActions');\n   323\t            if (!hasMatrixActions) {\n   324\t                // We need to use a setTimeout to avoid issues with the actor being locked during data preparation\n   325\t                // Also add error handling to prevent crashes during initialization\n   326\t                setTimeout(() =&gt; {\n   327\t                    try {\n   328\t                        // Double-check that the game is still ready and the actor is valid\n   329\t                        if (game.ready &amp;&amp; this.id &amp;&amp; this.name) {\n   330\t                            this.ensureMatrixActions();\n   331\t                        }\n   332\t                    } catch (error) {\n   333\t                        console.warn(`Shadowrun 6e | Failed to ensure matrix actions for actor ${this.name}:`, error);\n   334\t                    }\n   335\t                }, 500);\n   336\t            }\n   337\t        }\n   338\t    }\n   339\t\n   340\t    /**\n   341\t     * NOTE: This method is unused at the moment, keep it for future inspiration.\n\nReview the changes and make sure they are as expected (correct indentation, no duplicate lines, etc).\nEdit the file again if necessary.\n&quot;,&quot;is_error&quot;:false,&quot;request_id&quot;:&quot;&quot;,&quot;tool_use_id&quot;:&quot;toolu_vrtx_01TS6tsv5qMdBBkHuogUw2vW&quot;}},{&quot;id&quot;:2,&quot;type&quot;:4,&quot;ide_state_node&quot;:{&quot;workspaceFolders&quot;:[{&quot;repositoryRoot&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;,&quot;folderRoot&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;}],&quot;workspaceFoldersUnchanged&quot;:false,&quot;currentTerminal&quot;:{&quot;terminalId&quot;:12,&quot;currentWorkingDirectory&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;}}}],&quot;timestamp&quot;:&quot;2025-05-29T23:34:14.804Z&quot;,&quot;response_text&quot;:&quot;Now let me check if there are any other places in the targeting service that might need null checks:\n&quot;,&quot;workspace_file_chunks&quot;:[]},{&quot;status&quot;:&quot;success&quot;,&quot;request_id&quot;:&quot;6272e7fd-a67b-4614-8bbc-4fdc2447ee64&quot;,&quot;request_message&quot;:&quot;&quot;,&quot;structured_output_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:5,&quot;content&quot;:&quot;&quot;,&quot;tool_use&quot;:{&quot;tool_use_id&quot;:&quot;toolu_vrtx_01UaQCzuypBU3MEeNi7vqwyT&quot;,&quot;tool_name&quot;:&quot;str-replace-editor&quot;,&quot;input_json&quot;:&quot;{\&quot;command\&quot;: \&quot;view\&quot;, \&quot;path\&quot;: \&quot;src/module/apps/gmtools/OverwatchScoreTracker.js\&quot;, \&quot;view_range\&quot;: [80, 95]}&quot;,&quot;mcp_server_name&quot;:&quot;&quot;,&quot;mcp_tool_name&quot;:&quot;&quot;}},{&quot;id&quot;:0,&quot;type&quot;:0,&quot;content&quot;:&quot;The targeting service already has proper null checks for `token.actor`. Let me also check if there are any issues in the OverwatchScoreTracker:\n&quot;},{&quot;id&quot;:2,&quot;type&quot;:2,&quot;content&quot;:&quot;&quot;},{&quot;id&quot;:3,&quot;type&quot;:3,&quot;content&quot;:&quot;&quot;}],&quot;seen_state&quot;:&quot;seen&quot;,&quot;structured_request_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:1,&quot;tool_result_node&quot;:{&quot;content&quot;:&quot;Here's the result of running `cat -n` on src/module/targeting/TargetingService.ts:\n   135\t        const tokens = canvas.tokens?.placeables || [];\n   136\t        \n   137\t        // Filter for potential targets (exclude the actor's own token)\n   138\t        const potentialTargets = tokens.filter(token =&gt; \n   139\t            token.id !== actorToken.id &amp;&amp; \n   140\t            token.actor &amp;&amp; \n   141\t            this.isValidTarget(token, action, actor)\n   142\t        );\n   143\t        \n   144\t        // Sort by distance to the actor\n   145\t        return potentialTargets.sort((a, b) =&gt; {\nTotal lines in file: 252\n&quot;,&quot;is_error&quot;:false,&quot;request_id&quot;:&quot;&quot;,&quot;tool_use_id&quot;:&quot;toolu_vrtx_01XRw5nccdmHgzNFdAd7Bgqw&quot;}},{&quot;id&quot;:2,&quot;type&quot;:4,&quot;ide_state_node&quot;:{&quot;workspaceFolders&quot;:[{&quot;repositoryRoot&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;,&quot;folderRoot&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;}],&quot;workspaceFoldersUnchanged&quot;:false,&quot;currentTerminal&quot;:{&quot;terminalId&quot;:12,&quot;currentWorkingDirectory&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;}}}],&quot;timestamp&quot;:&quot;2025-05-29T23:34:18.238Z&quot;,&quot;response_text&quot;:&quot;The targeting service already has proper null checks for `token.actor`. Let me also check if there are any issues in the OverwatchScoreTracker:\n&quot;,&quot;workspace_file_chunks&quot;:[]},{&quot;status&quot;:&quot;success&quot;,&quot;request_id&quot;:&quot;499c1985-0c36-46b6-907a-3e50894d539e&quot;,&quot;request_message&quot;:&quot;&quot;,&quot;structured_output_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:5,&quot;content&quot;:&quot;&quot;,&quot;tool_use&quot;:{&quot;tool_use_id&quot;:&quot;toolu_vrtx_01QTdJTSvx2vF5Yh9JB9aBzg&quot;,&quot;tool_name&quot;:&quot;launch-process&quot;,&quot;input_json&quot;:&quot;{\&quot;command\&quot;: \&quot;npm run build\&quot;, \&quot;wait\&quot;: true, \&quot;max_wait_seconds\&quot;: 60}&quot;,&quot;mcp_server_name&quot;:&quot;&quot;,&quot;mcp_tool_name&quot;:&quot;&quot;}},{&quot;id&quot;:0,&quot;type&quot;:0,&quot;content&quot;:&quot;The OverwatchScoreTracker already has proper checks. Now let me create a summary of the changes I've made and test them:\n\n## Summary of Changes Made\n\nI've identified and fixed several potential issues that could cause \&quot;actors not existing\&quot; errors when loading the game:\n\n### 1. **Fixed Token Processing in Hooks** (`src/module/hooks.ts`)\n- **Issue**: Line 454 was mapping `token.actor` without filtering out null/undefined actors first\n- **Fix**: Added `.filter(actor =&gt; actor !== null &amp;&amp; actor !== undefined)` after the map operation\n\n### 2. **Enhanced Matrix Actions Initialization** (`src/module/actor/SR6Actor.ts`)\n- **Issue**: Matrix actions were being initialized during data preparation without proper error handling and validation\n- **Fixes**:\n  - Added `game.ready` check to prevent initialization during world loading/migration\n  - Added comprehensive error handling with try-catch blocks\n  - Added validation for actor existence before processing\n  - Added null checks for matrix actions from compendium\n  - Added fallback flag setting to prevent repeated failed attempts\n\n### 3. **Fixed Helper Functions** (`src/module/helpers.ts`)\n- **Issue**: `getControlledTokenActors()` was mapping tokens without filtering out null actors\n- **Fix**: Added `.filter(actor =&gt; actor !== null &amp;&amp; actor !== undefined)` after mapping\n- **Issue**: `getDefenseRating()` was accessing `token.actor` without null checking\n- **Fix**: Added null check and early continue for tokens without actors\n\n### 4. **Fixed DocumentSituationModifiers** (`src/module/rules/DocumentSituationModifiers.ts`)\n- **Issue**: Using optional chaining `?.` but not handling the case where actor is null\n- **Fix**: Added explicit null check before calling `getSituationModifiers()`\n\n### Key Improvements:\n1. **Null Safety**: All token.actor accesses now have proper null checks\n2. **Error Handling**: Matrix actions initialization is wrapped in try-catch blocks\n3. **Timing**: Matrix actions only initialize when game is fully ready\n4. **Validation**: Added validation for actor existence and validity\n5. **Resilience**: Added fallback mechanisms to prevent repeated failures\n\nThese changes should resolve the \&quot;actors not existing\&quot; errors by ensuring that:\n- Tokens without linked actors are properly filtered out\n- Matrix actions initialization doesn't run during world loading\n- All actor accesses are null-safe\n- Errors are caught and logged instead of crashing the system\n\nLet me run a quick test to make sure the syntax is correct:\n&quot;},{&quot;id&quot;:2,&quot;type&quot;:2,&quot;content&quot;:&quot;&quot;},{&quot;id&quot;:3,&quot;type&quot;:3,&quot;content&quot;:&quot;&quot;}],&quot;seen_state&quot;:&quot;seen&quot;,&quot;structured_request_nodes&quot;:[{&quot;id&quot;:1,&quot;type&quot;:1,&quot;tool_result_node&quot;:{&quot;content&quot;:&quot;Here's the result of running `cat -n` on src/module/apps/gmtools/OverwatchScoreTracker.js:\n    80\t\n    81\t        // Add linked token actors.\n    82\t        tokens.filter(token =&gt; token.document.actorLink).forEach(token =&gt; {\n    83\t            // Double check that the actor actually lives in the actors collection.\n    84\t            const actor = game.actors.get(token.document.actorId);\n    85\t            if (!actor) return;\n    86\t            if (this._isActorOnTracker(actor)) return;\n    87\t\n    88\t            OverwatchScoreTracker.addedActors.push(actor.id);\n    89\t        });\n    90\t\n    91\t        this.render();\n    92\t    }\n    93\t\n    94\t    /**\n    95\t     * Check if the given actor is already added and displayed on the current tracker.\nTotal lines in file: 165\n&quot;,&quot;is_error&quot;:false,&quot;request_id&quot;:&quot;&quot;,&quot;tool_use_id&quot;:&quot;toolu_vrtx_01UaQCzuypBU3MEeNi7vqwyT&quot;}},{&quot;id&quot;:2,&quot;type&quot;:4,&quot;ide_state_node&quot;:{&quot;workspaceFolders&quot;:[{&quot;repositoryRoot&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;,&quot;folderRoot&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;}],&quot;workspaceFoldersUnchanged&quot;:false,&quot;currentTerminal&quot;:{&quot;terminalId&quot;:12,&quot;currentWorkingDirectory&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;}}}],&quot;timestamp&quot;:&quot;2025-05-29T23:34:21.840Z&quot;,&quot;response_text&quot;:&quot;The OverwatchScoreTracker already has proper checks. Now let me create a summary of the changes I've made and test them:\n\n## Summary of Changes Made\n\nI've identified and fixed several potential issues that could cause \&quot;actors not existing\&quot; errors when loading the game:\n\n### 1. **Fixed Token Processing in Hooks** (`src/module/hooks.ts`)\n- **Issue**: Line 454 was mapping `token.actor` without filtering out null/undefined actors first\n- **Fix**: Added `.filter(actor =&gt; actor !== null &amp;&amp; actor !== undefined)` after the map operation\n\n### 2. **Enhanced Matrix Actions Initialization** (`src/module/actor/SR6Actor.ts`)\n- **Issue**: Matrix actions were being initialized during data preparation without proper error handling and validation\n- **Fixes**:\n  - Added `game.ready` check to prevent initialization during world loading/migration\n  - Added comprehensive error handling with try-catch blocks\n  - Added validation for actor existence before processing\n  - Added null checks for matrix actions from compendium\n  - Added fallback flag setting to prevent repeated failed attempts\n\n### 3. **Fixed Helper Functions** (`src/module/helpers.ts`)\n- **Issue**: `getControlledTokenActors()` was mapping tokens without filtering out null actors\n- **Fix**: Added `.filter(actor =&gt; actor !== null &amp;&amp; actor !== undefined)` after mapping\n- **Issue**: `getDefenseRating()` was accessing `token.actor` without null checking\n- **Fix**: Added null check and early continue for tokens without actors\n\n### 4. **Fixed DocumentSituationModifiers** (`src/module/rules/DocumentSituationModifiers.ts`)\n- **Issue**: Using optional chaining `?.` but not handling the case where actor is null\n- **Fix**: Added explicit null check before calling `getSituationModifiers()`\n\n### Key Improvements:\n1. **Null Safety**: All token.actor accesses now have proper null checks\n2. **Error Handling**: Matrix actions initialization is wrapped in try-catch blocks\n3. **Timing**: Matrix actions only initialize when game is fully ready\n4. **Validation**: Added validation for actor existence and validity\n5. **Resilience**: Added fallback mechanisms to prevent repeated failures\n\nThese changes should resolve the \&quot;actors not existing\&quot; errors by ensuring that:\n- Tokens without linked actors are properly filtered out\n- Matrix actions initialization doesn't run during world loading\n- All actor accesses are null-safe\n- Errors are caught and logged instead of crashing the system\n\nLet me run a quick test to make sure the syntax is correct:\n&quot;,&quot;workspace_file_chunks&quot;:[]},{&quot;request_id&quot;:&quot;4ab6d25e-ca3b-47ce-9cec-a4c4de85378f&quot;,&quot;status&quot;:&quot;cancelled&quot;,&quot;chatItemType&quot;:&quot;agentic-turn-delimiter&quot;},{&quot;request_id&quot;:&quot;6f6a527d-2261-4ee1-9899-ebc5708576ab&quot;,&quot;uuid&quot;:&quot;5fec0813-3a4f-4c3f-b490-463ea75dac78&quot;,&quot;chatItemType&quot;:&quot;agentic-checkpoint-delimiter&quot;,&quot;status&quot;:&quot;success&quot;,&quot;fromTimestamp&quot;:1748360633414,&quot;toTimestamp&quot;:1748561678675,&quot;seen_state&quot;:&quot;seen&quot;},{&quot;request_id&quot;:&quot;f312f994-baef-4c91-9f26-03f9de0d1a09&quot;,&quot;uuid&quot;:&quot;2825f970-dfe8-4388-8042-7136daddce1b&quot;,&quot;chatItemType&quot;:&quot;agentic-checkpoint-delimiter&quot;,&quot;status&quot;:&quot;success&quot;,&quot;fromTimestamp&quot;:1748561678675,&quot;toTimestamp&quot;:1748676088438,&quot;seen_state&quot;:&quot;seen&quot;},{&quot;request_id&quot;:&quot;4d8671dc-2162-45d6-9dbc-7339d38ecb9c&quot;,&quot;uuid&quot;:&quot;de1793af-e2f1-4b09-96e8-919d0aa5c255&quot;,&quot;chatItemType&quot;:&quot;agentic-checkpoint-delimiter&quot;,&quot;status&quot;:&quot;success&quot;,&quot;fromTimestamp&quot;:1748676088438,&quot;toTimestamp&quot;:1748820588769,&quot;seen_state&quot;:&quot;seen&quot;},{&quot;request_id&quot;:&quot;0dd97fdc-9bab-4ce5-a4c9-f4adfae5a49c&quot;,&quot;uuid&quot;:&quot;1c94bd06-66dd-487d-827a-078a5cc28a0f&quot;,&quot;chatItemType&quot;:&quot;agentic-checkpoint-delimiter&quot;,&quot;status&quot;:&quot;success&quot;,&quot;fromTimestamp&quot;:1748820588769,&quot;toTimestamp&quot;:1748902059828,&quot;seen_state&quot;:&quot;seen&quot;},{&quot;request_id&quot;:&quot;4d54b81f-0531-4254-a5cb-274696226c73&quot;,&quot;uuid&quot;:&quot;4ec7db85-0c66-45cc-8eee-7ae402c01131&quot;,&quot;chatItemType&quot;:&quot;agentic-checkpoint-delimiter&quot;,&quot;status&quot;:&quot;success&quot;,&quot;fromTimestamp&quot;:1748902059828,&quot;toTimestamp&quot;:1748980875675,&quot;seen_state&quot;:&quot;seen&quot;}],&quot;feedbackStates&quot;:{&quot;temp-fe-f184902a-86b6-4c41-85ae-3a27a94a2465&quot;:{&quot;selectedRating&quot;:0,&quot;feedbackNote&quot;:&quot;&quot;},&quot;temp-fe-d3b431b5-3a1b-476a-90c6-34b6df6f7a76&quot;:{&quot;selectedRating&quot;:0,&quot;feedbackNote&quot;:&quot;&quot;},&quot;temp-fe-50c0c1fc-bd91-4fad-a161-b8d0ac326b95&quot;:{&quot;selectedRating&quot;:0,&quot;feedbackNote&quot;:&quot;&quot;},&quot;temp-fe-b7237484-e6a3-4b0b-a685-f54e10e6a34a&quot;:{&quot;selectedRating&quot;:0,&quot;feedbackNote&quot;:&quot;&quot;},&quot;temp-fe-934445d4-8f20-4642-be88-44d35d96e259&quot;:{&quot;selectedRating&quot;:0,&quot;feedbackNote&quot;:&quot;&quot;},&quot;temp-fe-0daa65b8-3d0b-4a13-9b74-ac5fecddbff1&quot;:{&quot;selectedRating&quot;:0,&quot;feedbackNote&quot;:&quot;&quot;},&quot;temp-fe-1db3820f-4b13-4cf6-be58-431c9af12d95&quot;:{&quot;selectedRating&quot;:0,&quot;feedbackNote&quot;:&quot;&quot;},&quot;temp-fe-ce5b7f34-282e-4845-b379-f5aa7f72a83e&quot;:{&quot;selectedRating&quot;:0,&quot;feedbackNote&quot;:&quot;&quot;},&quot;temp-fe-b964eb48-95b2-407e-9c48-d4d1e1b79c79&quot;:{&quot;selectedRating&quot;:0,&quot;feedbackNote&quot;:&quot;&quot;},&quot;temp-fe-e5ec172e-2dbe-4c7e-b982-1357159ed51d&quot;:{&quot;selectedRating&quot;:0,&quot;feedbackNote&quot;:&quot;&quot;},&quot;temp-fe-bca90829-f754-42de-a831-3ab0fddb5a58&quot;:{&quot;selectedRating&quot;:0,&quot;feedbackNote&quot;:&quot;&quot;},&quot;temp-fe-ce391fb6-9165-4ed5-8989-e046f36e96b1&quot;:{&quot;selectedRating&quot;:0,&quot;feedbackNote&quot;:&quot;&quot;},&quot;temp-fe-0668ec5f-74cd-4fe8-b849-4c17a6150ee8&quot;:{&quot;selectedRating&quot;:0,&quot;feedbackNote&quot;:&quot;&quot;},&quot;temp-fe-5b10ee85-3053-417a-8b91-7709efd53ce4&quot;:{&quot;selectedRating&quot;:0,&quot;feedbackNote&quot;:&quot;&quot;},&quot;temp-fe-1260a234-d2f0-4bda-bcd0-9cb5e7f46e86&quot;:{&quot;selectedRating&quot;:0,&quot;feedbackNote&quot;:&quot;&quot;},&quot;temp-fe-b1fe662e-c400-4a2b-9d44-ff460407851e&quot;:{&quot;selectedRating&quot;:0,&quot;feedbackNote&quot;:&quot;&quot;},&quot;temp-fe-666c80b7-5eab-4586-a99a-63015fb362f8&quot;:{&quot;selectedRating&quot;:0,&quot;feedbackNote&quot;:&quot;&quot;},&quot;temp-fe-cab23ff8-c04e-4dff-a7bf-0ce6e6effd02&quot;:{&quot;selectedRating&quot;:0,&quot;feedbackNote&quot;:&quot;&quot;},&quot;temp-fe-b763c678-49bb-4996-b22e-09dba7f58721&quot;:{&quot;selectedRating&quot;:0,&quot;feedbackNote&quot;:&quot;&quot;}},&quot;toolUseStates&quot;:{&quot;60a40c69-e965-42c6-8850-f9b9da65c20c;toolu_vrtx_01TsLKSFeY3fm7rYbpRz16LD&quot;:{&quot;requestId&quot;:&quot;60a40c69-e965-42c6-8850-f9b9da65c20c&quot;,&quot;toolUseId&quot;:&quot;toolu_vrtx_01TsLKSFeY3fm7rYbpRz16LD&quot;,&quot;phase&quot;:5,&quot;result&quot;:{&quot;text&quot;:&quot;The following code sections were retrieved:\nPath: src/module/actor/SR6Actor.ts\n...\n   317\t\n   318\t        // Ensure matrix actions are available for all actors that can use the Matrix\n   319\t        if (game.user?.isGM &amp;&amp; this.isOwner &amp;&amp; (this.isCharacter() || this.isSprite() || this.isIC())) {\n   320\t            // Check if we've already added matrix actions to this actor\n   321\t            const hasMatrixActions = this.getFlag('sr6elysium', 'hasMatrixActions');\n   322\t            if (!hasMatrixActions) {\n   323\t                // We need to use a setTimeout to avoid issues with the actor being locked during data preparation\n   324\t                setTimeout(() =&gt; this.ensureMatrixActions(), 500);\n   325\t            }\n   326\t        }\n   327\t    }\n   328\t\n   329\t    /**\n   330\t     * NOTE: This method is unused at the moment, keep it for future inspiration.\n   331\t     */\n   332\t    applyOverrideActiveEffects() {\n   333\t        const changes = this.effects.reduce((changes: EffectChangeData[], effect) =&gt; {\n   334\t            if (effect.data.disabled) return changes;\n...\n  1450\t\n  1451\t    /** Return either the linked token or the token of the synthetic actor.\n  1452\t     *\n  1453\t     * @return Will return null should no token have been placed on scene.\n  1454\t     */\n  1455\t    getToken(): TokenDocument | null {\n  1456\t        // Linked actors can only have one token, which isn't stored within actor data...\n  1457\t        if (this._isLinkedToToken() &amp;&amp; this.hasToken()) {\n  1458\t            const linked = true;\n  1459\t            const tokens = this.getActiveTokens(linked) as unknown as Token[];\n  1460\t            // This assumes for a token to exist and should fail if not.\n  1461\t            return tokens[0].document;\n  1462\t        }\n  1463\t\n  1464\t        // Unlinked actors can have multiple active token but each have theirs directly attached...\n  1465\t        return this.token;\n  1466\t    }\n  1467\t\n  1468\t    /**\n  1469\t     * There is no need for a token to placed. The prototype token is enough.\n  1470\t     */\n  1471\t    _isLinkedToToken(): boolean {\n  1472\t        //@ts-expect-error // TODO: foundry-vtt-types v10\n  1473\t        // If an actor is linked, all it's copies also contain this linked status, even if they're not.\n  1474\t        return this.prototypeToken.actorLink &amp;&amp; !this.token;\n  1475\t    }\n  1476\t\n  1477\t    hasToken(): boolean {\n  1478\t        return this.getActiveTokens().length &gt; 0;\n  1479\t    }\n  1480\t\n  1481\t    hasActivePlayerOwner(): boolean {\n  1482\t        const players = this.getActivePlayerOwners();\n  1483\t        return players.length &gt; 0;\n  1484\t    }\n  1485\t\n  1486\t    getActivePlayer(): User | null {\n  1487\t        if (!game.users) return null;\n  1488\t        if (!this.hasPlayerOwner) return null;\n  1489\t\n  1490\t        for (const user of game.users.contents) {\n  1491\t            if (!user.active || user.isGM) {\n  1492\t                continue;\n  1493\t            }\n  1494\t            if (this.id === user.character?.id) {\n  1495\t                return user;\n  1496\t            }\n  1497\t        }\n  1498\t\n  1499\t        return null;\n  1500\t    }\n...\n  1797\t\n  1798\t    /**\n  1799\t     * The matrix depends on actor type and possibly equipped matrix device.\n  1800\t     *\n  1801\t     * Use this method for whenever you need to access this actors matrix damage track as it's source might differ.\n  1802\t     */\n  1803\t    getMatrixTrack(): Shadowrun.ConditionData | undefined {\n  1804\t        // Some actors will have a direct matrix track.\n  1805\t        if (\&quot;track\&quot; in this.system &amp;&amp; \&quot;matrix\&quot; in this.system.track) {\n  1806\t            return this.system.track.matrix;\n  1807\t        }\n  1808\t\n  1809\t        // Some actors will have a personal matrix condition monitor, like a device condition monitor.\n  1810\t        if (this.isMatrixActor) {\n  1811\t            // @ts-expect-error isMatrixActor checks for the matrix attribute\n  1812\t            return this.system.matrix.condition_monitor;\n  1813\t        }\n...\n  2289\t        if (!target.actor || !target.actor.isMatrixActor) return 0;\n  2290\t\n  2291\t\n  2292\t        const scene = options?.scene || canvas.scene as Scene;\n  2293\t        // If an actor has been targeted, they might have a device. If an item / host has been targeted they don't.\n  2294\t        item = item || target instanceof SR6Actor ? target.actor.getMatrixDevice() : undefined;\n  2295\t\n  2296\t        const markId = Helpers.buildMarkId(scene.id as string, target.id, item?.id as string);\n  2297\t        return this.getMarksById(markId);\n  2298\t    }\n  2299\t\n  2300\t    getMarksById(markId: string): number {\n  2301\t        return this.matrixData?.marks[markId] || 0;\n  2302\t    }\n...\n  2737\t\n  2738\t    /**\n  2739\t     * Ensures that the actor has access to all matrix actions from the matrix-actions compendium.\n  2740\t     * This method will add any missing matrix actions to the actor.\n  2741\t     *\n  2742\t     * @returns {Promise&lt;void&gt;}\n  2743\t     */\n  2744\t    async ensureMatrixActions() {\n  2745\t        console.log(`Shadowrun 6e | Ensuring matrix actions for actor ${this.name} (${this.id})`);\n  2746\t\n  2747\t        // Check if we've already added matrix actions to this actor\n  2748\t        const hasMatrixActions = this.getFlag('sr6elysium', 'hasMatrixActions');\n  2749\t        if (hasMatrixActions) {\n  2750\t            console.log(`Shadowrun 6e | ${this.name} already has matrix actions flag set`);\n  2751\t            return;\n  2752\t        }\n  2753\t\n  2754\t        // Get the matrix actions compendium\n  2755\t        const matrixPack = game.packs.get(\&quot;sr6elysium.matrix-actions\&quot;);\n  2756\t        if (!matrixPack) {\n  2757\t            console.error(\&quot;Shadowrun 6e | Matrix Actions compendium not found\&quot;);\n  2758\t            return;\n  2759\t        }\n  2760\t\n  2761\t        // Get all matrix actions\n  2762\t        await matrixPack.getIndex();\n  2763\t        const matrixActions = await Promise.all(\n  2764\t            Array.from(matrixPack.index).map(i =&gt; matrixPack.getDocument(i._id))\n  2765\t        );\n  2766\t\n  2767\t        // Get existing action names to avoid duplicates\n  2768\t        const existingNames = this.items\n  2769\t            .filter(i =&gt; i.type === \&quot;action\&quot;)\n  2770\t            .map(i =&gt; i.name.toLowerCase());\n  2771\t\n  2772\t        // Filter out actions the actor already has\n  2773\t        const actionsToAdd = matrixActions.filter(\n  2774\t            a =&gt; !existingNames.includes(a.name.toLowerCase())\n  2775\t        );\n  2776\t\n  2777\t        if (actionsToAdd.length === 0) {\n  2778\t            console.log(`Shadowrun 6e | ${this.name} already has all matrix actions`);\n  2779\t            // Set the flag to indicate that we've checked for matrix actions\n  2780\t            await this.setFlag('sr6elysium', 'hasMatrixActions', true);\n  2781\t            return;\n  2782\t        }\n  2783\t\n  2784\t        // Add the actions\n  2785\t        await this.createEmbeddedDocuments(\n  2786\t            \&quot;Item\&quot;,\n  2787\t            actionsToAdd.map(a =&gt; a.toObject())\n  2788\t        );\n  2789\t\n  2790\t        console.log(`Shadowrun 6e | Added ${actionsToAdd.length} matrix actions to ${this.name}`);\n  2791\t\n  2792\t        // Set the flag to indicate that we've added matrix actions\n  2793\t        await this.setFlag('sr6elysium', 'hasMatrixActions', true);\n  2794\t    }\n  2795\t\n  2796\t    async newSceneSetup() {\n  2797\t        const updateData: Record&lt;string, any&gt; = {};\n  2798\t\n  2799\t        updateData['system.attributes.edge.uses'] = this.getEdge().value;\n  2800\t\n  2801\t        if(updateData) await this.update(updateData);\n  2802\t    }\n...\nPath: src/module/actor/prep/functions/InitiativePrep.ts\n...\n    94\t\n    95\t    static prepareMatrixInit(system: ActorTypesData &amp; MatrixActorData) {\n    96\t        const { initiative, attributes, modifiers, matrix } = system;\n    97\t        if (matrix) {\n    98\t\n    99\t            initiative.matrix.base.base = attributes.intuition.value + system.matrix.data_processing.value;\n   100\t            initiative.matrix.base.mod = PartsList.AddUniquePart(initiative.matrix.base.mod, \&quot;SR6.Bonus\&quot;, Number(modifiers['matrix_initiative']));\n   101\t            initiative.matrix.base.value = Helpers.calcTotal(initiative.matrix.base);\n   102\t\n   103\t            initiative.matrix.dice.base = (matrix.hot_sim ? 4 : 3);\n   104\t            initiative.matrix.dice.mod = PartsList.AddUniquePart(initiative.matrix.dice.mod, \&quot;SR6.Bonus\&quot;, Number(modifiers['matrix_initiative_dice']));\n   105\t            initiative.matrix.dice.value = Helpers.calcTotal(initiative.matrix.dice, {min: 0, max: 5});\n   106\t        }\n   107\t    }\n   108\t}\n...\nPath: src/module/actor/prep/functions/MatrixPrep.ts\n...\n     9\t\n    10\texport class MatrixPrep {\n    11\t    /**\n    12\t     * Prepare Matrix data on the actor\n    13\t     * - if an item is equipped, it will use that data\n    14\t     * - if it isn't and player is technomancer, it will use that data\n    15\t     */\n    16\t    static prepareMatrix(system: ActorTypesData &amp; MatrixActorData, items: SR6ItemDataWrapper[]) {\n    17\t        const { matrix, attributes, modifiers } = system;\n    18\t\n    19\t        const MatrixList = ['firewall', 'sleaze', 'data_processing', 'attack'];\n    20\t\n    21\t        // clear matrix data to defaults\n    22\t        MatrixList.forEach((key) =&gt; {\n    23\t            const parts = new PartsList(matrix[key].mod);\n    24\t            if (matrix[key].temp) parts.addUniquePart('SR6.Temporary', matrix[key].temp);\n    25\t            // LEGACY from when the sheet used 'mod.Temporary'\n    26\t            parts.removePart('Temporary');\n    27\t            matrix[key].mod = parts.list;\n    28\t            matrix[key].value = parts.total;\n    29\t        });\n...\n    38\t\n    39\t        if (device) {\n    40\t            matrix.device = device.getId();\n    41\t\n    42\t            const conditionMonitor = device.getConditionMonitor();\n    43\t\n    44\t            matrix.condition_monitor.max = conditionMonitor.max + Number(modifiers.matrix_track);\n    45\t            matrix.condition_monitor.value = conditionMonitor.value;\n    46\t            matrix.rating = device.getRating();\n    47\t            matrix.is_cyberdeck = device.isCyberdeck();\n    48\t            matrix.name = device.getName();\n    49\t            matrix.item = device.getData();\n    50\t            const deviceAtts = device.getASDF();\n    51\t            if (deviceAtts) {\n    52\t                // setup the actual matrix attributes for the actor\n    53\t                for (const [key, value] of Object.entries(deviceAtts)) {\n    54\t                    if (value &amp;&amp; matrix[key]) {\n    55\t                        matrix[key].base = value.value;\n    56\t                        matrix[key].device_att = value.device_att;\n    57\t                    }\n    58\t                }\n    59\t            }\n...\nPath: src/module/actor/prep/ICPrep.ts\n...\n    43\t\n    44\t    /**\n    45\t     * On initial actor creation the matrix track will be missing.\n    46\t     *\n    47\t     * This is intentional as not to pollute template.json with actor type specific data.\n    48\t     *\n    49\t     */\n    50\t    static addMissingTracks(system: ICData) {\n    51\t        // Newly created actors SHOULD have this by template.\n    52\t        // Legacy actors MIGHT not have it, therefore make sure it's there.\n    53\t        const track = system.track || {};\n    54\t        if (!track.matrix) track.matrix = DataDefaults.trackData();\n    55\t        system.track = track;\n    56\t    }\n    57\t\n    58\t    /**\n    59\t     * Add IC modifiers only to the misc tab.\n    60\t     * @param system\n    61\t     */\n    62\t    static prepareModifiers(system: ICData) {\n    63\t        let modifiers = ModifiersPrep.commonModifiers as string[];\n    64\t        modifiers = modifiers.concat(ModifiersPrep.matrixModifiers as string[]);\n    65\t        ModifiersPrep.setupModifiers(system, modifiers);\n    66\t    }\n...\n    85\t\n    86\t    static prepareMatrixInit(system: ICData) {\n    87\t        const { initiative, modifiers, host } = system;\n    88\t\n    89\t\n    90\t        // Set current initiative to matrix\n    91\t        initiative.perception = 'matrix';\n    92\t\n    93\t        // Prepare used initiative parts\n    94\t        initiative.matrix.base.base = MatrixRules.getICInitiativeBase(host.rating);\n    95\t        initiative.matrix.base.mod = PartsList.AddUniquePart(initiative.matrix.base.mod, \&quot;SR6.Bonus\&quot;, Number(modifiers['matrix_initiative']));\n    96\t\n    97\t        initiative.matrix.dice.base = MatrixRules.getICInitiativeDice();\n    98\t        initiative.matrix.dice.mod = PartsList.AddUniquePart(initiative.matrix.dice.mod, \&quot;SR6.Bonus\&quot;, Number(modifiers['matrix_initiative_dice']));\n    99\t    }\n...\nPath: src/module/helpers.ts\n...\n   307\t\n   308\t    // TODO: Foundry 0.9 Should TokenDocument be used instead of Token?\n   309\t    // TODO: Check canvas.scene.tokens\n   310\t    static getToken(id?: string): Token | undefined {\n   311\t        if (!canvas || !canvas.ready || !canvas.tokens) return;\n   312\t\n   313\t        for (const token of canvas.tokens.placeables) {\n   314\t            if (token.id === id) {\n   315\t                return token;\n   316\t            }\n   317\t        }\n   318\t    }\n   319\t\n   320\t    /**\n   321\t     * Use this helper to get a tokens actor from any given scene id.\n   322\t     * @param sceneTokenId A mixed id with the format '&lt;sceneId&gt;.&lt;tokenid&gt;\n   323\t     */\n   324\t    static getSceneTokenActor(sceneTokenId: string): SR6Actor | null {\n   325\t        const [sceneId, tokenId] = Helpers.deconstructSceneTokenId(sceneTokenId);\n   326\t        const token = Helpers.getSceneTokenDocument(sceneId, tokenId);\n   327\t        if (!token) return null;\n   328\t        return token.getActor();\n   329\t    }\n...\nPath: packs/_source/system-macros/add_matrix_actions.json\n     1\t{\n     2\t  \&quot;_id\&quot;: \&quot;addMatrixActions\&quot;,\n     3\t  \&quot;name\&quot;: \&quot;Add Matrix Actions to Selected Actors\&quot;,\n     4\t  \&quot;type\&quot;: \&quot;script\&quot;,\n     5\t  \&quot;img\&quot;: \&quot;icons/svg/dice-target.svg\&quot;,\n     6\t  \&quot;scope\&quot;: \&quot;global\&quot;,\n...\n     8\t  \&quot;folder\&quot;: null,\n     9\t  \&quot;sort\&quot;: 0,\n    10\t  \&quot;ownership\&quot;: {\n    11\t    \&quot;default\&quot;: 0\n    12\t  },\n    13\t  \&quot;flags\&quot;: {},\n    14\t  \&quot;_stats\&quot;: {\n    15\t    \&quot;systemId\&quot;: \&quot;sr6elysium\&quot;,\n    16\t    \&quot;systemVersion\&quot;: \&quot;0.24.0\&quot;,\n    17\t    \&quot;coreVersion\&quot;: \&quot;11\&quot;,\n    18\t    \&quot;createdTime\&quot;: 1718560000000,\n    19\t    \&quot;modifiedTime\&quot;: 1718560000000,\n    20\t    \&quot;lastModifiedBy\&quot;: \&quot;developer\&quot;\n    21\t  },\n    22\t  \&quot;_key\&quot;: \&quot;!macros!addMatrixActions\&quot;\n    23\t}\n...\nPath: src/module/item/flows/ActionFlow.ts\n     1\t/**\n     2\t * Handle all things related to the action template (template.json)\n     3\t */\n     4\timport { SR6Actor } from \&quot;../../actor/SR6Actor\&quot;;\n     5\timport { Helpers } from \&quot;../../helpers\&quot;;\n     6\timport { SR6Item } from \&quot;../SR6Item\&quot;;\n     7\timport { PartsList } from \&quot;../../parts/PartsList\&quot;;\n     8\timport { SR6 } from \&quot;../../config\&quot;;\n     9\timport { DataDefaults } from \&quot;../../data/DataDefaults\&quot;;\n    10\timport { Translation } from \&quot;../../utils/strings\&quot;;\n    11\t\n    12\texport class ActionFlow {\n    13\t    /**\n    14\t     * Calculate action damage configuration based on flat damage field and possible dynamic attribute modification.\n    15\t     *\n    16\t     * @param damage The damage field as defined within the ActionData\n    17\t     * @param actor The actor to use should a dynamic calculation be needed.\n    18\t     * @param item\n    19\t     */\n    20\t    static calcDamageData(damage: Shadowrun.DamageData, actor?: SR6Actor, item?: SR6Item): Shadowrun.DamageData {\n    21\t        // Avoid manipulation on original data, which might come from database values.\n    22\t        damage = foundry.utils.duplicate(damage);\n    23\t\n    24\t        if (!actor) return damage;\n    25\t\n    26\t        if (item) {\n    27\t            damage.source = ActionFlow._damageSource(actor, item);\n    28\t        }\n    29\t\n    30\t        this._applyModifiableValue(damage, actor);\n    31\t        damage.value = Helpers.calcTotal(damage, { min: 0 });\n    32\t\n    33\t        this._applyModifiableValue(damage.ap, actor);\n    34\t        damage.ap.value = Helpers.calcTotal(damage.ap, { min: 0 });\n    35\t\n    36\t        return damage;\n    37\t    }\n    38\t\n    39\t    static _applyModifiableValue(value: Shadowrun.ModifiableValueLinked, actor: SR6Actor) {\n    40\t        const attribute = actor.findAttribute(value.attribute);\n    41\t        if (!attribute) return;\n    42\t\n    43\t        if (!value.base_formula_operator) {\n    44\t            console.error(`Unsupported formula operator: '${value.base_formula_operator}' used. Falling back to 'add'.`);\n    45\t            value.base_formula_operator = 'add';\n    46\t        }\n    47\t\n    48\t        // Avoid altering base OR value fields and raising the resulting damage on multiple function calls.\n    49\t        switch (value.base_formula_operator) {\n    50\t            case \&quot;add\&quot;:\n    51\t                PartsList.AddUniquePart(value.mod, attribute.label, attribute.value);\n    52\t                break;\n    53\t            case \&quot;subtract\&quot;:\n    54\t                PartsList.AddUniquePart(value.mod, attribute.label, -attribute.value);\n    55\t                break;\n    56\t            case \&quot;multiply\&quot;:\n    57\t                PartsList.AddUniquePart(value.mod, 'SR6.Value', (value.base * attribute.value) - value.base);\n    58\t                break;\n    59\t            case \&quot;divide\&quot;:\n    60\t                // Remove base from value by modifying.\n    61\t                PartsList.AddUniquePart(value.mod, 'SR6.BaseValue', value.base * -1);\n    62\t                // Add division result as modifier on zero.\n    63\t                const denominator = attribute.value === 0 ? 1 : attribute.value;\n    64\t                PartsList.AddUniquePart(value.mod, 'SR6.Value', Math.floor(value.base / denominator));\n    65\t                break;\n    66\t        }\n    67\t    }\n    68\t\n    69\t    /**\n    70\t     * Damage that's caused by an item can later be used to determine how that damage should be applied\n    71\t     *\n    72\t     * @param actor The actor used to determine damage\n    73\t     * @param item The item from which damage's been determined from.\n    74\t     */\n    75\t    static _damageSource(actor: SR6Actor, item: SR6Item): Shadowrun.DamageSource {\n    76\t        return {\n    77\t            actorId: actor.id || '',\n    78\t            itemId: item.id || '',\n    79\t            itemName: item.name || '',\n    80\t            itemType: item.type\n    81\t        }\n    82\t    }\n...\n   113\t        //        The major use case is the sidebar item creation, where no actor is available.\n   114\t        if (!actor || actor.isIC()) {\n   115\t            // Inject this items custom skill into the global skill list.\n   116\t            const globalSkills = foundry.utils.deepClone(SR6.activeSkills);\n   117\t            ActionFlow._injectMissingCustomSkill(globalSkills, skillName);\n   118\t            return Helpers.sortConfigValuesByTranslation(globalSkills);\n   119\t        }\n...\nPath: src/module/item/flows/ActionResultFlow.ts\n...\n    43\t    /**\n    44\t     * Matrix Marks are placed on either actors (persona, ic) or items (device, host, technology).\n    45\t     */\n    46\t    static async placeMatrixMarks(active: SR6Actor, targets: Token[], marks: number) {\n    47\t        if (!MatrixRules.isValidMarksCount(marks)) {\n    48\t            return ui.notifications?.warn(game.i18n.localize(\&quot;SR6.Warnings.InvalidMarksCount\&quot;));\n    49\t        }\n    50\t\n    51\t        for (const target of targets) {\n    52\t            await active.setMarks(target, marks);\n    53\t        }\n    54\t    }\n    55\t\n    56\t    /**\n    57\t     * Modify the actors combatant according the test defined initiative modifier.\n    58\t     *\n    59\t     * @param test The test instance causing the initiative modification\n    60\t     */\n    61\t    static async _castInitModifierAction(test: PhysicalDefenseTest) {\n    62\t        if (!(test instanceof PhysicalDefenseTest)) return;\n    63\t\n    64\t        if (!test.data.iniMod) return;\n    65\t        await test.actor?.changeCombatInitiative(test.data.iniMod);\n    66\t    }\n    67\t}\n...\n&quot;,&quot;isError&quot;:false,&quot;requestId&quot;:&quot;&quot;}},&quot;d77dce7a-d2ae-4c54-b72c-7cd950bc408e;toolu_vrtx_01DMFrRy2RoXAYSBP2y3bFd3&quot;:{&quot;requestId&quot;:&quot;d77dce7a-d2ae-4c54-b72c-7cd950bc408e&quot;,&quot;toolUseId&quot;:&quot;toolu_vrtx_01DMFrRy2RoXAYSBP2y3bFd3&quot;,&quot;phase&quot;:5,&quot;result&quot;:{&quot;text&quot;:&quot;The following code sections were retrieved:\nPath: src/module/hooks.ts\n...\n    70\timport { SuccessTestEffectsFlow } from './effect/flows/SuccessTestEffectsFlow';\n    71\timport { JournalEnrichers } from './journal/enricher';\n    72\timport { DataStorage } from './data/DataStorage';\n    73\t\n    74\t\n    75\t\n    76\t// Redeclare SR5config as a global as foundry-vtt-types CONFIG with SR5 property causes issues.\n    77\texport const SR6CONFIG = SR6;\n    78\t\n    79\texport class HooksManager {\n    80\t    static registerHooks() {\n    81\t        console.log('Shadowrun 6e | Registering system hooks');\n    82\t        // Register your highest level hook callbacks here for a quick overview of what's hooked into.\n    83\t\n    84\t        Hooks.once('init', HooksManager.init);\n    85\t        Hooks.once('setup', AutocompleteInlineHooksFlow.setupHook);\n    86\t\n    87\t        Hooks.on('canvasInit', canvasInit);\n    88\t        Hooks.on('ready', HooksManager.ready);\n    89\t        Hooks.on('hotbarDrop', HooksManager.hotbarDrop);\n    90\t        Hooks.on('renderSceneControls', HooksManager.renderSceneControls);\n    91\t        Hooks.on('getSceneControlButtons', HooksManager.getSceneControlButtons);\n    92\t        Hooks.on('getCombatTrackerEntryContext', SR6Combat.addCombatTrackerContextOptions);\n    93\t        Hooks.on('renderItemDirectory', HooksManager.renderItemDirectory);\n    94\t        // Hooks.on('renderTokenHUD', EnvModifiersApplication.addTokenHUDFields);\n    95\t        Hooks.on('renderTokenHUD', SituationModifiersApplication.onRenderTokenHUD);\n    96\t        Hooks.on('updateItem', HooksManager.updateIcConnectedToHostItem);\n    97\t        Hooks.on('deleteItem', HooksManager.removeDeletedItemsFromNetworks);\n...\n   107\t\n   108\t    static init() {\n   109\t        console.log(`Loading Shadowrun 5e System\n   110\t___________________\n   111\t ___________ _____ \n   112\t/  ___| ___ \\\\  ___|\n   113\t\\\\ \\`--.| |_/ /___ \\\\ \n   114\t \\`--. \\\\    /    \\\\ \\\\\n   115\t/\\\\__/ / |\\\\ \\\\/\\\\__/ /\n   116\t\\\\____/\\\\_| \\\\_\\\\____/ \n   117\t===================\n   118\t`);\n   119\t        // Create a sr6elysium namespace within the game global\n   120\t        game['sr6elysium'] = {\n   121\t            /**\n   122\t             * System level Document implementations.\n   123\t             */\n   124\t            SR6Actor: SR6Actor,\n   125\t            SR6Item: SR6Item,\n   126\t            SR6ActiveEffect: SR6ActiveEffect,\n   127\t            /**\n   128\t             * Macro hooks used when something's dropped onto the hotbar.\n   129\t             */\n   130\t            rollItemMacro,\n   131\t            rollSkillMacro,\n   132\t            /**\n   133\t             * Should you only really need dice handling, use this. If you need more complex testing behaviour,\n   134\t             * check the Test implementations.\n   135\t             */\n   136\t            SR6Roll: SR6Roll,\n...\n   330\t\n   331\t        HooksManager.configureVision()\n   332\t\n   333\t        HooksManager.configureTextEnrichers();\n   334\t\n   335\t        // Preload might reduce loading time during play.\n   336\t        HandlebarManager.loadTemplates();\n   337\t\n   338\t        // Register Tours\n   339\t        registerSR6Tours();\n   340\t\n   341\t        DataStorage.validate();\n   342\t    }\n   343\t\n   344\t    static async ready() {\n   345\t        if (game.user?.isGM) {\n   346\t            // Prohibit migration on empty worlds...\n   347\t            if (Migrator.isEmptyWorld) {\n   348\t                await Migrator.InitWorldForMigration();\n   349\t                return;\n   350\t            }\n   351\t\n   352\t            // On populated worlds, try migrating\n   353\t            await Migrator.BeginMigration();\n   354\t\n   355\t            if (ChangelogApplication.showApplication) {\n   356\t                await new ChangelogApplication().render(true);\n   357\t            }\n   358\t        }\n...\n   446\t\n   447\t        if (item.isHost) {\n   448\t            // Collect actors from sidebar and active scene to update / rerender\n   449\t            let connectedIC = [\n   450\t                // All sidebar actors should also include tokens with linked actors.\n   451\t                ...game.actors.filter((actor: SR6Actor) =&gt; actor.isIC() &amp;&amp; actor.hasHost()) as SR6Actor[],\n   452\t                // All token actors that aren't linked.\n   453\t                // @ts-expect-error // TODO: foundry-vtt-types v10\n   454\t                ...canvas.scene.tokens.filter(token =&gt; !token.actorLink &amp;&amp; token.actor?.isIC() &amp;&amp; token.actor?.hasHost()).map(t =&gt; t.actor)\n   455\t            ];\n   456\t\n   457\t            // Update host data on the ic actor.\n   458\t            const host = item.asHost;\n   459\t            if (!host) return;\n   460\t            for (const ic of connectedIC) {\n   461\t                if (!ic) continue;\n   462\t                await ic._updateICHostData(host);\n   463\t            }\n   464\t        }\n   465\t    }\n...\n   470\t\n   471\t    /**\n   472\t     * This method is used as a simple place to register socket hook handlers for the system.\n   473\t     *\n   474\t     * You can use the SocketMessage for sending messages using a socket event message id and generic data object.\n   475\t     */\n   476\t    static registerSocketListeners() {\n   477\t        if (!game.socket || !game.user) return;\n   478\t        console.log('Registering sr6elysium system socket messages...');\n   479\t        const hooks: Shadowrun.SocketMessageHooks = {\n   480\t            [FLAGS.addNetworkController]: [NetworkDeviceFlow._handleAddNetworkControllerSocketMessage],\n   481\t            [FLAGS.DoNextRound]: [SR6Combat._handleDoNextRoundSocketMessage],\n   482\t            [FLAGS.DoInitPass]: [SR6Combat._handleDoInitPassSocketMessage],\n   483\t            [FLAGS.DoNewActionPhase]: [SR6Combat._handleDoNewActionPhaseSocketMessage],\n...\n   488\t\n   489\t        game.socket.on(SYSTEM_SOCKET, async (message: Shadowrun.SocketMessageData) =&gt; {\n   490\t            console.log('Shadowrun 6e | Received system socket message.', message);\n   491\t\n   492\t            const handlers = hooks[message.type];\n   493\t            if (!handlers || handlers.length === 0) return console.warn('Shadowrun 6e | System socket message has no registered handler!', message);\n   494\t            // In case of targeted socket message only execute with target user (intended for GM usage)\n   495\t            if (message.userId &amp;&amp; game.user?.id !== message.userId) return;\n   496\t            if (message.userId &amp;&amp; game.user?.id) console.log('Shadowrun 6e | GM is handling system socket message');\n   497\t\n   498\t            for (const handler of handlers) {\n   499\t                console.debug(`Shadowrun 6e | Handover system socket message to handler: ${handler.name}`);\n   500\t                await handler(message);\n   501\t            }\n   502\t        });\n   503\t    }\n...\nPath: src/module/targeting/index.ts\n...\n     2\t\n     3\t/**\n     4\t * Register targeting hooks\n     5\t */\n     6\texport function registerTargetingHooks() {\n     7\t    // Register a hook to highlight valid targets when an item is used\n     8\t    Hooks.on('sr6:preItemRoll', (item, actor) =&gt; {\n     9\t        // Only highlight targets for items that can target other actors\n    10\t        if (item.isRangedWeapon() || item.isSpell() || item.isMatrixAction()) {\n    11\t            TargetingService.highlightValidTargets(item, actor);\n    12\t        }\n    13\t    });\n    14\t    \n    15\t    // Register a hook to clear target highlights when an item roll is complete\n    16\t    Hooks.on('sr6:itemRoll', () =&gt; {\n    17\t        TargetingService.clearTargetHighlights();\n    18\t    });\n    19\t    \n    20\t    // Register a hook to clear target highlights when an item roll is cancelled\n    21\t    Hooks.on('sr6:itemRollCancel', () =&gt; {\n    22\t        TargetingService.clearTargetHighlights();\n    23\t    });\n    24\t    \n    25\t    console.log(\&quot;Shadowrun 6e | Targeting hooks registered\&quot;);\n    26\t}\n...\nPath: src/module/actor/prep/CharacterPrep.ts\n...\n    28\t\n    29\t    /**\n    30\t     * All derived data should depend on basic values like Attributes or Skills.\n    31\t     *\n    32\t     * It shouldn't be modified by Active Effects, which instead should modify the global modifiers.\n    33\t     *\n    34\t     * @param system\n    35\t     * @param items\n    36\t     */\n    37\t    static prepareDerivedData(system: Shadowrun.CharacterData, items: SR6ItemDataWrapper[]) {\n    38\t        AttributesPrep.prepareAttributes(system);\n    39\t        AttributesPrep.prepareEssence(system, items);\n    40\t\n    41\t        // NPCPrep is reliant to be called after AttributesPrep.\n    42\t        NPCPrep.prepareNPCData(system);\n    43\t\n    44\t        SkillsPrep.prepareSkills(system);\n    45\t\n    46\t        ItemPrep.prepareArmor(system, items);\n    47\t        ItemPrep.prepareWeapons(system, items);\n    48\t\n    49\t        MatrixPrep.prepareMatrix(system, items);\n    50\t        MatrixPrep.prepareMatrixToLimitsAndAttributes(system);\n    51\t\n    52\t        GruntPrep.prepareConditionMonitors(system);\n...\nPath: src/module/actor/prep/ICPrep.ts\n...\n    13\t\n    14\t\n    15\texport class ICPrep {\n    16\t    static prepareBaseData(system: ICData) {\n    17\t        ModifiersPrep.clearAttributeMods(system);\n    18\t        ModifiersPrep.clearLimitMods(system);\n    19\t        SkillsPrep.prepareSkillData(system);\n    20\t\n    21\t        ICPrep.addMissingTracks(system);\n    22\t        ICPrep.prepareModifiers(system);\n    23\t        ICPrep.hideMeatAttributes(system);\n    24\t        ICPrep.addHostAttributes(system);\n    25\t    }\n    26\t\n    27\t    static prepareDerivedData(system: ICData, items: SR6ItemDataWrapper[]) {\n    28\t        ICPrep.prepareMatrixAttributes(system);\n    29\t\n    30\t        SkillsPrep.prepareSkills(system);\n    31\t\n    32\t        ICPrep.prepareHostAttributes(system);\n    33\t        ICPrep.prepareMeatAttributes(system);\n    34\t\n    35\t        MatrixPrep.prepareMatrixToLimitsAndAttributes(system);\n    36\t\n    37\t        ICPrep.prepareMatrix(system);\n    38\t        ICPrep.prepareMatrixTrack(system);\n    39\t\n    40\t        ICPrep.prepareMatrixInit(system);\n    41\t        InitiativePrep.prepareCurrentInitiative(system);\n    42\t    }\n...\nPath: src/module/main.ts\n     1\timport { HandlebarManager } from './handlebars/HandlebarManager';\n     2\timport {HooksManager} from \&quot;./hooks\&quot;;\n     3\t\n     4\t/* -------------------------------------------- */\n     5\t/*  Foundry VTT Initialization                  */\n     6\t/* -------------------------------------------- */\n     7\t\n     8\t\n     9\tHooksManager.registerHooks();\n    10\tHandlebarManager.registerHelpers();...\nPath: src/module/canvas.ts\n     1\timport {FLAGS, SYSTEM_NAME} from './constants';\n     2\t\n     3\tinterface DistanceOptions {\n     4\t    gridSpaces?: boolean\n     5\t}\n     6\t\n     7\t/**\n     8\t * Pulled from the FoundryVTT DND5e system: grid.mjs#measureDistance\n     9\t * \n    10\t * @param segments \n    11\t * @param options \n    12\t * @returns \n    13\t */\n    14\tconst measureDistances = function (segments, options: DistanceOptions = {}) {\n    15\t    if (!options.gridSpaces) return BaseGrid.prototype.measureDistances.call(this, segments, options);\n    16\t\n    17\t    // Track the total number of diagonals\n    18\t    let nDiagonal = 0;\n    19\t    const rule = this.diagonalRule;\n    20\t    const d = canvas.dimensions as Canvas.Dimensions;\n    21\t\n    22\t    // Iterate over measured segments\n    23\t    return segments.map((s) =&gt; {\n    24\t        let r = s.ray;\n    25\t\n    26\t        // Determine the total distance traveled\n    27\t        let nx = Math.abs(Math.ceil(r.dx / d.size));\n    28\t        let ny = Math.abs(Math.ceil(r.dy / d.size));\n    29\t\n    30\t        // Determine the number of straight and diagonal moves\n    31\t        let nd = Math.min(nx, ny);\n    32\t        let ns = Math.abs(ny - nx);\n    33\t        nDiagonal += nd;\n    34\t\n    35\t        // Estimate diagonal like other battle grid systems do. (DnD5e)\n    36\t        if (rule === '1-2-1') {\n    37\t            let nd10 = Math.floor(nDiagonal / 2) - Math.floor((nDiagonal - nd) / 2);\n    38\t            let spaces = nd10 * 2 + (nd - nd10) + ns;\n    39\t            // @ts-expect-error TODO: foundry-vtt-types v10\n    40\t            return spaces * canvas.dimensions.distance;\n    41\t        }\n    42\t\n    43\t        // Treat diagonal as straight line\n    44\t        else if (rule === 'EUCL') {\n    45\t            // @ts-expect-error TODO: foundry-vtt-types v10\n    46\t            // return Math.round(Math.hypot(nx, ny) * canvas.scene.data.gridDistance);\n    47\t            return Math.round(Math.hypot(nx, ny) * canvas.scene?.grid.distance);\n    48\t        }\n    49\t\n    50\t        // Treat diagonal as straight movement\n    51\t        // @ts-expect-error TODO: foundry-vtt-types v10\n    52\t        else return (ns + nd) * canvas.scene?.grid.distance;\n    53\t    });\n    54\t};\n    55\t\n    56\t\n    57\texport function canvasInit() {\n    58\t    //@ts-expect-error TODO: foundry-vtt-types v10\n    59\t    // Copy DnD5e's approach to movement measurement and add a custom field to the grid to be used in canvas.ts#measureDistances\n    60\t    canvas.grid.diagonalRule = game.settings.get(SYSTEM_NAME, FLAGS.DiagonalMovement);\n    61\t    // Add a custom measureDistances function, overwriting default to add more movement styles.\n    62\t    SquareGrid.prototype.measureDistances = measureDistances;\n    63\t}...\nPath: src/module/helpers.ts\n...\n   307\t\n   308\t    // TODO: Foundry 0.9 Should TokenDocument be used instead of Token?\n   309\t    // TODO: Check canvas.scene.tokens\n   310\t    static getToken(id?: string): Token | undefined {\n   311\t        if (!canvas || !canvas.ready || !canvas.tokens) return;\n   312\t\n   313\t        for (const token of canvas.tokens.placeables) {\n   314\t            if (token.id === id) {\n   315\t                return token;\n   316\t            }\n   317\t        }\n   318\t    }\n   319\t\n   320\t    /**\n   321\t     * Use this helper to get a tokens actor from any given scene id.\n   322\t     * @param sceneTokenId A mixed id with the format '&lt;sceneId&gt;.&lt;tokenid&gt;\n   323\t     */\n   324\t    static getSceneTokenActor(sceneTokenId: string): SR6Actor | null {\n   325\t        const [sceneId, tokenId] = Helpers.deconstructSceneTokenId(sceneTokenId);\n   326\t        const token = Helpers.getSceneTokenDocument(sceneId, tokenId);\n   327\t        if (!token) return null;\n   328\t        return token.getActor();\n   329\t    }\n...\nPath: shadowrun6-genesis-importer/module/main.js\n     1\timport { GenesisImportForm } from './apps/genesis-import-form.js';\n     2\t\n     3\tHooks.once('init', () =&gt; {\n     4\t    console.log('Shadowrun 6e Genesis Importer | Initializing module');\n     5\t});\n     6\t\n     7\tHooks.once('ready', () =&gt; {\n     8\t    console.log('Shadowrun 6e Genesis Importer | Module ready');\n     9\t});\n    10\t\n    11\t// Register the Genesis importer with the Shadowrun 6e system\n    12\tHooks.on('renderActorSheet', (app, html, data) =&gt; {\n    13\t    // Only add the button to Shadowrun 6e character sheets\n    14\t    if (app.actor.type !== 'character' || !app.actor.system) return;\n    15\t    \n    16\t    // Find the import character button\n    17\t    const importButton = html.find('.import-character');\n    18\t    if (importButton.length === 0) return;\n    19\t    \n    20\t    // Add our own click handler\n    21\t    importButton.off('click').on('click', (event) =&gt; {\n    22\t        event.preventDefault();\n    23\t        \n    24\t        // Create a dialog to choose between Chummer and Genesis import\n    25\t        const content = `\n    26\t            &lt;div style=\&quot;text-align: center; margin-bottom: 10px;\&quot;&gt;\n    27\t                &lt;p&gt;${game.i18n.localize('SR6.ImportCharacterChoose')}&lt;/p&gt;\n    28\t            &lt;/div&gt;\n    29\t            &lt;div style=\&quot;display: flex; justify-content: space-around;\&quot;&gt;\n    30\t                &lt;button class=\&quot;chummer-import\&quot;&gt;${game.i18n.localize('SR6.ChummerImport')}&lt;/button&gt;\n    31\t                &lt;button class=\&quot;genesis-import\&quot;&gt;${game.i18n.localize('SR6.GenesisImport')}&lt;/button&gt;\n    32\t            &lt;/div&gt;\n    33\t        `;\n    34\t\n    35\t        const dialog = new Dialog({\n    36\t            title: game.i18n.localize('SR6.ImportCharacter'),\n    37\t            content: content,\n    38\t            buttons: {},\n    39\t            render: html =&gt; {\n    40\t                html.find('.chummer-import').click(() =&gt; {\n    41\t                    dialog.close();\n    42\t                    // Call the system's Chummer importer\n    43\t                    app._onShowImportCharacter(event);\n    44\t                });\n    45\t\n    46\t                html.find('.genesis-import').click(() =&gt; {\n    47\t                    dialog.close();\n    48\t                    const options = {\n    49\t                        name: 'genesis-import',\n    50\t                        title: game.i18n.localize('SR6.GenesisImport'),\n    51\t                    };\n    52\t                    new GenesisImportForm(app.actor, options).render(true);\n    53\t                });\n    54\t            }\n    55\t        });\n    56\t\n    57\t        dialog.render(true);\n    58\t    });\n    59\t});\n    60\t\n    61\t// Export the GenesisImportForm for external use\n    62\texport { GenesisImportForm };\n...\nPath: src/module/rules/DocumentSituationModifiers.ts\n...\n   390\t\n   391\t    /**\n   392\t     * Helper for scene modifier instances to clear all modifiers for all placed tokens\n   393\t     */\n   394\t    async clearAllTokensOnScene() {\n   395\t        if (!canvas.ready || !canvas.scene) return;\n   396\t        if (!this.documentIsScene) return;\n   397\t\n   398\t        // Validate that modifiers scene is same to current scene.\n   399\t        const scene = this.document as Scene;\n   400\t        if (canvas.scene.id !== scene.id) return;\n   401\t\n   402\t        // Use current scene for ease of access to tokens\n   403\t        canvas.scene.tokens.forEach(token =&gt; token.actor?.getSituationModifiers().clearAll());\n   404\t    }\n   405\t}\n...\nPath: src/module/combat/SR6Combat.ts\n...\n   365\t        let nextTurn = this.settings?.skipDefeated ?\n   366\t            this.nextUndefeatedTurnPosition :\n   367\t            this.nextViableTurnPosition;\n   368\t\n   369\t        // Start of the combat Handling\n   370\t        if (nextRound === 0 &amp;&amp; initiativePass === 0) {\n   371\t            await this.startCombat();\n   372\t            return;\n   373\t        }\n   374\t\n   375\t        // Just step from one combatant to the next!\n   376\t        if (nextTurn &lt; this.turns.length) {\n   377\t            await this.update({ turn: nextTurn });\n   378\t            await this.handleActionPhase();\n   379\t            return;\n   380\t        }\n   381\t\n   382\t        // In Shadowrun 6th Edition, there are no initiative passes\n   383\t\n   384\t\n   385\t        // Initiative Round Handling.\n   386\t        // NOTE: It's not checked if the next is needed. This should result in the user noticing the turn going up, when it\n   387\t        //       maybe shouldn't and reporting a unhandled combat phase flow case.\n   388\t        return this.nextRound();\n   389\t    }\n...\nPath: src/module/migrator/VersionMigration.ts\n...\n   134\t\n   135\t    /**\n   136\t     * Iterate through all scenes and migrate each if needed.\n   137\t     * @param game\n   138\t     * @param entityUpdates\n   139\t     */\n   140\t    protected async IterateScenes(game: Game, entityUpdates: Map&lt;SystemMigrationDocuments, DocumentUpdate&gt;) {\n   141\t        // @ts-expect-error // ignore null state\n   142\t        for (const scene of game.scenes.contents) {\n   143\t            try {\n   144\t                if (!(await this.ShouldMigrateSceneData(scene))) {\n   145\t                    continue;\n   146\t                }\n   147\t\n   148\t                // Migrate SceneData itself.\n   149\t                console.log(`Migrating Scene entity ${scene.name}`);\n   150\t                const updateData = await this.MigrateSceneData(scene);\n   151\t\n   152\t                expandObject(updateData);\n   153\t                entityUpdates.set(scene, {\n   154\t                    updateData,\n   155\t                    embeddedItems: null,\n   156\t             ...&quot;,&quot;isError&quot;:false,&quot;requestId&quot;:&quot;&quot;}},&quot;933964ef-27f6-47ab-a531-473c17b8837c;toolu_vrtx_01QoZMNMfqm8PKi5uRBtygv2&quot;:{&quot;requestId&quot;:&quot;933964ef-27f6-47ab-a531-473c17b8837c&quot;,&quot;toolUseId&quot;:&quot;toolu_vrtx_01QoZMNMfqm8PKi5uRBtygv2&quot;,&quot;phase&quot;:5,&quot;result&quot;:{&quot;text&quot;:&quot;Here's the result of running `cat -n` on src/module/actor/SR6Actor.ts:\n   315\t                break;\n   316\t        }\n   317\t\n   318\t        // Ensure matrix actions are available for all actors that can use the Matrix\n   319\t        if (game.user?.isGM &amp;&amp; this.isOwner &amp;&amp; (this.isCharacter() || this.isSprite() || this.isIC())) {\n   320\t            // Check if we've already added matrix actions to this actor\n   321\t            const hasMatrixActions = this.getFlag('sr6elysium', 'hasMatrixActions');\n   322\t            if (!hasMatrixActions) {\n   323\t                // We need to use a setTimeout to avoid issues with the actor being locked during data preparation\n   324\t                setTimeout(() =&gt; this.ensureMatrixActions(), 500);\n   325\t            }\n   326\t        }\n   327\t    }\n   328\t\n   329\t    /**\n   330\t     * NOTE: This method is unused at the moment, keep it for future inspiration.\nTotal lines in file: 3031\n&quot;,&quot;isError&quot;:false,&quot;requestId&quot;:&quot;&quot;}},&quot;d0c4d893-9d82-4f5d-8bc1-895259d33975;toolu_vrtx_01SUN8Fn8uYuYrPFWNxmViFJ&quot;:{&quot;requestId&quot;:&quot;d0c4d893-9d82-4f5d-8bc1-895259d33975&quot;,&quot;toolUseId&quot;:&quot;toolu_vrtx_01SUN8Fn8uYuYrPFWNxmViFJ&quot;,&quot;phase&quot;:5,&quot;result&quot;:{&quot;text&quot;:&quot;Here's the result of running `cat -n` on src/module/hooks.ts:\n   445\t        if (!canvas.ready || !game.actors) return;\n   446\t\n   447\t        if (item.isHost) {\n   448\t            // Collect actors from sidebar and active scene to update / rerender\n   449\t            let connectedIC = [\n   450\t                // All sidebar actors should also include tokens with linked actors.\n   451\t                ...game.actors.filter((actor: SR6Actor) =&gt; actor.isIC() &amp;&amp; actor.hasHost()) as SR6Actor[],\n   452\t                // All token actors that aren't linked.\n   453\t                // @ts-expect-error // TODO: foundry-vtt-types v10\n   454\t                ...canvas.scene.tokens.filter(token =&gt; !token.actorLink &amp;&amp; token.actor?.isIC() &amp;&amp; token.actor?.hasHost()).map(t =&gt; t.actor)\n   455\t            ];\n   456\t\n   457\t            // Update host data on the ic actor.\n   458\t            const host = item.asHost;\n   459\t            if (!host) return;\n   460\t            for (const ic of connectedIC) {\n   461\t                if (!ic) continue;\n   462\t                await ic._updateICHostData(host);\n   463\t            }\n   464\t        }\n   465\t    }\n   466\t\n   467\t    static async removeDeletedItemsFromNetworks(item: SR6Item, data: Shadowrun.ShadowrunItemDataData, id: string) {\n   468\t        await NetworkDeviceFlow.handleOnDeleteItem(item, data, id);\n   469\t    }\n   470\t\nTotal lines in file: 533\n&quot;,&quot;isError&quot;:false,&quot;requestId&quot;:&quot;&quot;}},&quot;f156d8fe-3453-413e-9b57-54d971817689;toolu_vrtx_01PTWeRdmwpuFXC1H5LmmP9U&quot;:{&quot;requestId&quot;:&quot;f156d8fe-3453-413e-9b57-54d971817689&quot;,&quot;toolUseId&quot;:&quot;toolu_vrtx_01PTWeRdmwpuFXC1H5LmmP9U&quot;,&quot;phase&quot;:5,&quot;result&quot;:{&quot;text&quot;:&quot;The following code sections were retrieved:\nPath: src/module/helpers.ts\n...\n   307\t\n   308\t    // TODO: Foundry 0.9 Should TokenDocument be used instead of Token?\n   309\t    // TODO: Check canvas.scene.tokens\n   310\t    static getToken(id?: string): Token | undefined {\n   311\t        if (!canvas || !canvas.ready || !canvas.tokens) return;\n   312\t\n   313\t        for (const token of canvas.tokens.placeables) {\n   314\t            if (token.id === id) {\n   315\t                return token;\n   316\t            }\n   317\t        }\n   318\t    }\n   319\t\n   320\t    /**\n   321\t     * Use this helper to get a tokens actor from any given scene id.\n   322\t     * @param sceneTokenId A mixed id with the format '&lt;sceneId&gt;.&lt;tokenid&gt;\n   323\t     */\n   324\t    static getSceneTokenActor(sceneTokenId: string): SR6Actor | null {\n   325\t        const [sceneId, tokenId] = Helpers.deconstructSceneTokenId(sceneTokenId);\n   326\t        const token = Helpers.getSceneTokenDocument(sceneId, tokenId);\n   327\t        if (!token) return null;\n   328\t        return token.getActor();\n   329\t    }\n   330\t\n   331\t    static deconstructSceneTokenId(sceneTokenId: string): [sceneId: string, tokenId: string] {\n   332\t        return sceneTokenId.split('.') as [sceneId: string, tokenId: string];\n   333\t    }\n   334\t\n   335\t    static getSceneTokenDocument(sceneId, tokenId): TokenDocument | undefined {\n   336\t        const scene = game.scenes?.get(sceneId);\n   337\t        if (!scene) return;\n   338\t        const token = scene.tokens.get(tokenId);\n   339\t        if (!token) return;\n   340\t\n   341\t        return token;\n   342\t    }\n   343\t\n   344\t    static getUserTargets(user?: User | null): Token[] {\n   345\t        user = user ? user : game.user;\n   346\t\n   347\t        if (!user) return []\n   348\t\n   349\t        return Array.from(user.targets);\n   350\t    }\n   351\t\n   352\t    static userHasTargets(user?: User | null): boolean {\n   353\t        user = user ? user : game.user;\n   354\t\n   355\t        if (!user) return false;\n   356\t\n   357\t        return user.targets.size &gt; 0;\n   358\t    }\n...\n   661\t\n   662\t        // If we did not find anything on the actor, search the active tokens (the item might only exist on a non linked token)\n   663\t        // This will not work if we are on a different scene or the token got deleted, which is expected when you put an\n   664\t        // item on a token without linking it.\n   665\t        const tokens = actorSource.getActiveTokens();\n   666\t        let tokenItem: SR6Item | undefined;\n   667\t        tokens.forEach(token =&gt; {\n   668\t            if (!token.actor) return;\n   669\t\n   670\t            const foundItem = token.actor.items.get(itemId);\n   671\t            if (foundItem) {\n   672\t                tokenItem = foundItem as unknown as SR6Item;\n   673\t            }\n   674\t        });\n   675\t\n   676\t        return tokenItem;\n   677\t    }\n...\nPath: src/module/actor/SR6Actor.ts\n...\n    34\t\n    35\t\n    36\t/**\n    37\t * The general Shadowrun actor implementation, which currently handles all actor types.\n    38\t *\n    39\t * To easily access ActorData without any typing issues us the SR6Actor.asCritter helpers.\n    40\t * They are set up in a way that will handle both error management and type narrowing.\n    41\t * Example:\n    42\t * &lt;pre&gt;&lt;code&gt;\n    43\t *     const actor = game.actors.get('randomId');\n    44\t *     const critter = actor.asCritter();\n    45\t *     if (!critter) return;\n    46\t *     // critter.type === 'critter'\n    47\t *     // critter.system as CritterData\n    48\t * &lt;/code&gt;&lt;/pre&gt;\n    49\t *\n    50\t */\n    51\texport class SR6Actor extends Actor {\n    52\t    /**\n    53\t     * Cache for armor calculations to avoid recalculating unnecessarily\n    54\t     * @type {Object}\n    55\t     * @private\n    56\t     */\n    57\t    private _armorCache: {\n    58\t        armor?: Shadowrun.ActorArmor,\n    59\t        timestamp: number,\n    60\t        equipmentHash: string\n    61\t    } = {\n    62\t        timestamp: 0,\n...\n  1450\t\n  1451\t    /** Return either the linked token or the token of the synthetic actor.\n  1452\t     *\n  1453\t     * @return Will return null should no token have been placed on scene.\n  1454\t     */\n  1455\t    getToken(): TokenDocument | null {\n  1456\t        // Linked actors can only have one token, which isn't stored within actor data...\n  1457\t        if (this._isLinkedToToken() &amp;&amp; this.hasToken()) {\n  1458\t            const linked = true;\n  1459\t            const tokens = this.getActiveTokens(linked) as unknown as Token[];\n  1460\t            // This assumes for a token to exist and should fail if not.\n  1461\t            return tokens[0].document;\n  1462\t        }\n  1463\t\n  1464\t        // Unlinked actors can have multiple active token but each have theirs directly attached...\n  1465\t        return this.token;\n  1466\t    }\n  1467\t\n  1468\t    /**\n  1469\t     * There is no need for a token to placed. The prototype token is enough.\n  1470\t     */\n  1471\t    _isLinkedToToken(): boolean {\n  1472\t        //@ts-expect-error // TODO: foundry-vtt-types v10\n  1473\t        // If an actor is linked, all it's copies also contain this linked status, even if they're not.\n  1474\t        return this.prototypeToken.actorLink &amp;&amp; !this.token;\n  1475\t    }\n  1476\t\n  1477\t    hasToken(): boolean {\n  1478\t        return this.getActiveTokens().length &gt; 0;\n  1479\t    }\n  1480\t\n  1481\t    hasActivePlayerOwner(): boolean {\n  1482\t        const players = this.getActivePlayerOwners();\n  1483\t        return players.length &gt; 0;\n  1484\t    }\n  1485\t\n  1486\t    getActivePlayer(): User | null {\n  1487\t        if (!game.users) return null;\n  1488\t        if (!this.hasPlayerOwner) return null;\n  1489\t\n  1490\t        for (const user of game.users.contents) {\n  1491\t            if (!user.active || user.isGM) {\n  1492\t                continue;\n  1493\t            }\n  1494\t            if (this.id === user.character?.id) {\n  1495\t                return user;\n  1496\t            }\n  1497\t        }\n  1498\t\n  1499\t        return null;\n  1500\t    }\n...\n  2500\t\n  2501\t        // Initialize the actions object if it doesn't exist\n  2502\t        if (!this.system.initiative.actions) {\n  2503\t            console.log(`Shadowrun 6e | Actor ${this.name} has no actions data, initializing`);\n  2504\t            await this.update({\n  2505\t                'system.initiative.actions': {}\n  2506\t            });\n  2507\t            // Reset actions to ensure they're properly initialized\n  2508\t            await this.resetActions();\n  2509\t            return;\n  2510\t        }\n  2511\t\n  2512\t        const actions = this.system.initiative.actions;\n  2513\t        console.log(`Shadowrun 6e | Current actions for ${this.name}:`, actions);\n  2514\t\n  2515\t        // Check if the actor has at least 4 minor actions\n  2516\t        if (actions.minor &lt; 4) {\n  2517\t            ui.notifications?.warn(game.i18n.format('SR6.NotEnoughMinorActions', {\n  2518\t                name: this.name,\n  2519\t                count: actions.minor\n  2520\t            }));\n  2521\t            return;\n  2522\t        }\n  2523\t\n  2524\t        // Get the actor from the game.actors collection to ensure we're working with the latest data\n  2525\t        const checkActor = game.actors.get(this.id);\n  2526\t        if (checkActor &amp;&amp; checkActor.system.initiative &amp;&amp; checkActor.system.initiative.actions) {\n  2527\t            // Check if the actor has at least 4 minor actions in the database\n  2528\t            const dbMinorActions = checkActor.system.initiative.actions.minor;\n  2529\t            if (dbMinorActions &lt; 4) {\n  2530\t                ui.notifications?.warn(game.i18n.format('SR6.NotEnoughMinorActions', {\n  2531\t                    name: this.name,\n  2532\t                    count: dbMinorActions\n  2533\t                }));\n  2534\t                return;\n  2535\t            }\n  2536\t        }\n...\n  2704\t\n  2705\t    /**\n  2706\t     * Find and refresh all token sheets for this actor\n  2707\t     * This is needed because token sheets are not automatically refreshed when the actor is updated\n  2708\t     */\n  2709\t    refreshTokenSheets() {\n  2710\t        console.log(`Shadowrun 6e | Refreshing token sheets for ${this.name}`);\n  2711\t\n  2712\t        // Get all tokens for this actor\n  2713\t        const tokens = this.getActiveTokens();\n  2714\t        console.log(`Shadowrun 6e | Found ${tokens.length} tokens for ${this.name}`);\n  2715\t\n  2716\t        // Refresh each token\n  2717\t        for (const token of tokens) {\n  2718\t            // Refresh the token\n  2719\t            if (token.refresh) token.refresh();\n  2720\t\n  2721\t            // Refresh the token's sheet if it's open\n  2722\t            if (token.sheet &amp;&amp; token.sheet.rendered) {\n  2723\t                token.sheet.render(true);\n  2724\t                console.log(`Shadowrun 6e | Refreshed token sheet for ${token.name}`);\n  2725\t            }\n  2726\t        }\n...\n  2817\t\n  2818\t        // Initialize the actions object if it doesn't exist\n  2819\t        if (!this.system.initiative.actions) {\n  2820\t            console.log(`Shadowrun 6e | Actor ${this.name} has no actions data, initializing`);\n  2821\t            await this.update({\n  2822\t                'system.initiative.actions': {}\n  2823\t            });\n  2824\t            // Reset actions to ensure they're properly initialized\n  2825\t            await this.resetActions();\n  2826\t            return false;\n  2827\t        }\n  2828\t\n  2829\t        const actions = this.system.initiative.actions;\n  2830\t        console.log(`Shadowrun 6e | Current actions for ${this.name}:`, actions);\n  2831\t\n  2832\t        // Check if the actor has at least 1 major action\n  2833\t        if (actions.major &lt; 1) {\n  2834\t            ui.notifications?.warn(game.i18n.format('SR6.NoMajorActionsLeft', {\n  2835\t                name: this.name\n  2836\t            }));\n  2837\t            return false;\n  2838\t        }\n...\n  2900\t\n  2901\t        // Initialize the actions object if it doesn't exist\n  2902\t        if (!this.system.initiative.actions) {\n  2903\t            console.log(`Shadowrun 6e | Actor ${this.name} has no actions data, initializing`);\n  2904\t            await this.update({\n  2905\t                'system.initiative.actions': {}\n  2906\t            });\n  2907\t            // Reset actions to ensure they're properly initialized\n  2908\t            await this.resetActions();\n  2909\t            return false;\n  2910\t        }\n  2911\t\n  2912\t        const actions = this.system.initiative.actions;\n  2913\t        console.log(`Shadowrun 6e | Current actions for ${this.name}:`, actions);\n  2914\t\n  2915\t        // Check if the actor has at least 1 minor action\n  2916\t        if (actions.minor &lt; 1) {\n  2917\t            ui.notifications?.warn(game.i18n.format('SR6.NoMinorActionsLeft', {\n  2918\t                name: this.name\n  2919\t            }));\n  2920\t            return false;\n  2921\t        }\n...\nPath: src/module/token/SR6Token.ts\n     1\timport {FLAGS, SYSTEM_NAME} from \&quot;../constants\&quot;;\n     2\timport TrackType = Shadowrun.TrackType;\n     3\t\n     4\texport class SR6Token extends Token {\n     5\t    // @ts-expect-error Ignore getBarAttribute from Token\n     6\t    override _drawBar(number: number, bar: PIXI.Graphics, data: ReturnType&lt;Token['getBarAttribute']&gt;){\n     7\t        const tokenHealthBars = game.settings.get(SYSTEM_NAME, FLAGS.TokenHealthBars);\n     8\t        // FoundryVTT draws resource bars as full/good when the value is the\n     9\t        // same as the max and empty/bad at 0 (colored along a gradient).\n    10\t        // Shadowrun condition trackers count up from 0 to the maximum.\n    11\t        // We flip the values from Shadowrun format to FoundryVTT format here\n    12\t        // for drawing.\n    13\t        if (tokenHealthBars &amp;&amp; data &amp;&amp; data.attribute.startsWith('track')) {\n    14\t            const track = data as unknown as TrackType;\n    15\t            track.value = track.max - track.value;\n    16\t        }\n    17\t        super._drawBar(number, bar, data);\n    18\t    }\n    19\t}\n...\nPath: macros/edge-add-one-die.js\n     1\tconst EDGE_COST = 1;\n     2\t\n     3\t// Get the selected token's actor\n     4\tconst actor = token?.actor || character;\n     5\tif (!actor) {\n     6\t    ui.notifications.error(\&quot;Please select a token or assign a character\&quot;);\n     7\t    return;\n     8\t}\n     9\t\n    10\t// Get edge data\n    11\tconst edge = actor.getEdge();\n    12\tif (!edge) {\n    13\t    ui.notifications.error(\&quot;Selected character has no Edge attribute\&quot;);\n    14\t    return;\n    15\t}\n    16\t\n    17\t// Check if actor has enough edge\n    18\tif (edge.uses &lt; EDGE_COST) {\n    19\t    ui.notifications.error(`Not enough Edge! Need ${EDGE_COST} but only have ${edge.uses}`);\n    20\t    return;\n    21\t}\n...\nPath: src/module/hooks.ts\n...\n    70\timport { SuccessTestEffectsFlow } from './effect/flows/SuccessTestEffectsFlow';\n    71\timport { JournalEnrichers } from './journal/enricher';\n    72\timport { DataStorage } from './data/DataStorage';\n    73\t\n    74\t\n    75\t\n    76\t// Redeclare SR5config as a global as foundry-vtt-types CONFIG with SR5 property causes issues.\n    77\texport const SR6CONFIG = SR6;\n    78\t\n    79\texport class HooksManager {\n    80\t    static registerHooks() {\n    81\t        console.log('Shadowrun 6e | Registering system hooks');\n    82\t        // Register your highest level hook callbacks here for a quick overview of what's hooked into.\n    83\t\n    84\t        Hooks.once('init', HooksManager.init);\n    85\t        Hooks.once('setup', AutocompleteInlineHooksFlow.setupHook);\n    86\t\n    87\t        Hooks.on('canvasInit', canvasInit);\n    88\t        Hooks.on('ready', HooksManager.ready);\n    89\t        Hooks.on('hotbarDrop', HooksManager.hotbarDrop);\n    90\t        Hooks.on('renderSceneControls', HooksManager.renderSceneControls);\n    91\t        Hooks.on('getSceneControlButtons', HooksManager.getSceneControlButtons);\n    92\t        Hooks.on('getCombatTrackerEntryContext', SR6Combat.addCombatTrackerContextOptions);\n    93\t        Hooks.on('renderItemDirectory', HooksManager.renderItemDirectory);\n    94\t        // Hooks.on('renderTokenHUD', EnvModifiersApplication.addTokenHUDFields);\n    95\t        Hooks.on('renderTokenHUD', SituationModifiersApplication.onRenderTokenHUD);\n    96\t        Hooks.on('updateItem', HooksManager.updateIcConnectedToHostItem);\n    97\t        Hooks.on('deleteItem', HooksManager.removeDeletedItemsFromNetworks);\n...\n   107\t\n   108\t    static init() {\n   109\t        console.log(`Loading Shadowrun 5e System\n   110\t___________________\n   111\t ___________ _____ \n   112\t/  ___| ___ \\\\  ___|\n   113\t\\\\ \\`--.| |_/ /___ \\\\ \n   114\t \\`--. \\\\    /    \\\\ \\\\\n   115\t/\\\\__/ / |\\\\ \\\\/\\\\__/ /\n   116\t\\\\____/\\\\_| \\\\_\\\\____/ \n   117\t===================\n   118\t`);\n   119\t        // Create a sr6elysium namespace within the game global\n   120\t        game['sr6elysium'] = {\n   121\t            /**\n   122\t             * System level Document implementations.\n   123\t             */\n   124\t            SR6Actor: SR6Actor,\n   125\t            SR6Item: SR6Item,\n   126\t            SR6ActiveEffect: SR6ActiveEffect,\n   127\t            /**\n   128\t             * Macro hooks used when something's dropped onto the hotbar.\n   129\t             */\n   130\t            rollItemMacro,\n   131\t            rollSkillMacro,\n   132\t            /**\n   133\t             * Should you only really need dice handling, use this. If you need more complex testing behaviour,\n   134\t             * check the Test implementations.\n   135\t             */\n   136\t            SR6Roll: SR6Roll,\n...\n   330\t\n   331\t        HooksManager.configureVision()\n   332\t\n   333\t        HooksManager.configureTextEnrichers();\n   334\t\n   335\t        // Preload might reduce loading time during play.\n   336\t        HandlebarManager.loadTemplates();\n   337\t\n   338\t        // Register Tours\n   339\t        registerSR6Tours();\n   340\t\n   341\t        DataStorage.validate();\n   342\t    }\n   343\t\n   344\t    static async ready() {\n   345\t        if (game.user?.isGM) {\n   346\t            // Prohibit migration on empty worlds...\n   347\t            if (Migrator.isEmptyWorld) {\n   348\t                await Migrator.InitWorldForMigration();\n   349\t                return;\n   350\t            }\n   351\t\n   352\t            // On populated worlds, try migrating\n   353\t            await Migrator.BeginMigration();\n   354\t\n   355\t            if (ChangelogApplication.showApplication) {\n   356\t                await new ChangelogApplication().render(true);\n   357\t            }\n   358\t        }\n...\n   470\t\n   471\t    /**\n   472\t     * This method is used as a simple place to register socket hook handlers for the system.\n   473\t     *\n   474\t     * You can use the SocketMessage for sending messages using a socket event message id and generic data object.\n   475\t     */\n   476\t    static registerSocketListeners() {\n   477\t        if (!game.socket || !game.user) return;\n   478\t        console.log('Registering sr6elysium system socket messages...');\n   479\t        const hooks: Shadowrun.SocketMessageHooks = {\n   480\t            [FLAGS.addNetworkController]: [NetworkDeviceFlow._handleAddNetworkControllerSocketMessage],\n   481\t            [FLAGS.DoNextRound]: [SR6Combat._handleDoNextRoundSocketMessage],\n   482\t            [FLAGS.DoInitPass]: [SR6Combat._handleDoInitPassSocketMessage],\n   483\t            [FLAGS.DoNewActionPhase]: [SR6Combat._handleDoNewActionPhaseSocketMessage],\n...\nPath: macros/edge-reroll-failed.js\n     1\tconst EDGE_COST = 4;\n     2\t\n     3\t// Get the selected token's actor\n     4\tconst actor = token?.actor || character;\n     5\tif (!actor) {\n     6\t    ui.notifications.error(\&quot;Please select a token or assign a character\&quot;);\n     7\t    return;\n     8\t}\n     9\t\n    10\t// Get edge data\n    11\tconst edge = actor.getEdge();\n    12\tif (!edge) {\n    13\t    ui.notifications.error(\&quot;Selected character has no Edge attribute\&quot;);\n    14\t    return;\n    15\t}\n...\nPath: macros/edge-reroll-sr6.js\n     1\t// Get the selected token's actor\n     2\tconst actor = token?.actor || character;\n     3\tif (!actor) {\n     4\t    ui.notifications.error(\&quot;Please select a token or assign a character\&quot;);\n     5\t    return;\n     6\t}\n     7\t\n     8\t// Get edge data\n     9\tconst edge = actor.getEdge();\n    10\tif (!edge) {\n    11\t    ui.notifications.error(\&quot;Selected character has no Edge attribute\&quot;);\n    12\t    return;\n    13\t}\n...\nPath: macros/edge-add-attribute.js\n     1\tconst EDGE_COST = 4;\n     2\t\n     3\t// Get the selected token's actor\n     4\tconst actor = token?.actor || character;\n     5\tif (!actor) {\n     6\t    ui.notifications.error(\&quot;Please select a token or assign a character\&quot;);\n     7\t    return;\n     8\t}\n     9\t\n    10\t// Get edge data\n    11\tconst edge = actor.getEdge();\n    12\tif (!edge) {\n    13\t    ui.notifications.error(\&quot;Selected character has no Edge attribute\&quot;);\n    14\t    return;\n    15\t}\n    16\t\n    17\t// Check if actor has enough edge\n    18\tif (edge.uses &lt; EDGE_COST) {\n    19\t    ui.notifications.error(`Not enough Edge! Need ${EDGE_COST} but only have ${edge.uses}`);\n    20\t    return;\n    21\t}\n    22\t\n    23\t// Get edge attribute value\n    24\tconst edgeAttr = actor.system.attributes.edge.value;\n    25\tif (!edgeAttr) {\n    26\t    ui.notifications.error(\&quot;Could not determine Edge attribute value\&quot;);\n    27\t    return;\n    28\t}\n...\nPath: macros/edge-heal-physical.js\n     1\tconst EDGE_COST = 4;\n     2\t\n     3\t// Get the selected token's actor\n     4\tconst actor = token?.actor || character;\n     5\tif (!actor) {\n     6\t    ui.notifications.error(\&quot;Please select a token or assign a character\&quot;);\n     7\t    return;\n     8\t}\n     9\t\n    10\t// Get edge data\n    11\tconst edge = actor.getEdge();\n    12\tif (!edge) {\n    13\t    ui.notifications.error(\&quot;Selected character has no Edge attribute\&quot;);\n    14\t    return;\n    15\t}\n    16\t\n    17\t// Check if actor has enough edge\n    18\tif (edge.uses &lt; EDGE_COST) {\n    19\t    ui.notifications.error(`Not enough Edge! Need ${EDGE_COST} but only have ${edge.uses}`);\n    20\t    return;\n    21\t}\n...\n&quot;,&quot;isError&quot;:false,&quot;requestId&quot;:&quot;&quot;}},&quot;7eb2eae3-a7f1-48a6-bfd3-8d9ffdeabbd8;toolu_vrtx_015yuiu6dUK1jy3nGUH63CNU&quot;:{&quot;requestId&quot;:&quot;7eb2eae3-a7f1-48a6-bfd3-8d9ffdeabbd8&quot;,&quot;toolUseId&quot;:&quot;toolu_vrtx_015yuiu6dUK1jy3nGUH63CNU&quot;,&quot;phase&quot;:5,&quot;result&quot;:{&quot;text&quot;:&quot;Here's the result of running `cat -n` on src/module/hooks.ts:\n   450\t                // All sidebar actors should also include tokens with linked actors.\n   451\t                ...game.actors.filter((actor: SR6Actor) =&gt; actor.isIC() &amp;&amp; actor.hasHost()) as SR6Actor[],\n   452\t                // All token actors that aren't linked.\n   453\t                // @ts-expect-error // TODO: foundry-vtt-types v10\n   454\t                ...canvas.scene.tokens.filter(token =&gt; !token.actorLink &amp;&amp; token.actor?.isIC() &amp;&amp; token.actor?.hasHost()).map(t =&gt; t.actor)\n   455\t            ];\n   456\t\n   457\t            // Update host data on the ic actor.\n   458\t            const host = item.asHost;\n   459\t            if (!host) return;\n   460\t            for (const ic of connectedIC) {\nTotal lines in file: 533\n&quot;,&quot;isError&quot;:false,&quot;requestId&quot;:&quot;&quot;}},&quot;0e5a19be-a896-4b53-b0f4-8d3ab8a19442;toolu_vrtx_01J5CVojM5AFp41pSXFS7vYw&quot;:{&quot;requestId&quot;:&quot;0e5a19be-a896-4b53-b0f4-8d3ab8a19442&quot;,&quot;toolUseId&quot;:&quot;toolu_vrtx_01J5CVojM5AFp41pSXFS7vYw&quot;,&quot;phase&quot;:5,&quot;result&quot;:{&quot;text&quot;:&quot;The following code sections were retrieved:\nPath: src/module/helpers.ts\n...\n   247\t\n   248\t    static orderKeys(obj) {\n   249\t        const keys = Object.keys(obj).sort(function keyOrder(k1, k2) {\n   250\t            if (k1 &lt; k2) return -1;\n   251\t            if (k1 &gt; k2) return +1;\n   252\t            return 0;\n   253\t        });\n   254\t\n   255\t        let i;\n   256\t        const after = {};\n   257\t        for (i = 0; i &lt; keys.length; i++) {\n   258\t            after[keys[i]] = obj[keys[i]];\n   259\t            delete obj[keys[i]];\n   260\t        }\n   261\t\n   262\t        for (i = 0; i &lt; keys.length; i++) {\n   263\t            obj[keys[i]] = after[keys[i]];\n   264\t        }\n   265\t        return obj;\n   266\t    }\n   267\t\n   268\t    static hasModifiers(event) {\n   269\t        return event &amp;&amp; (event.shiftKey || event.altKey || event.ctrlKey || event.metaKey);\n   270\t    }\n   271\t\n   272\t    static filter(obj, comp) {\n   273\t        const retObj = {};\n   274\t        if (typeof obj === 'object' &amp;&amp; obj !== null) {\n   275\t            Object.entries(obj).forEach(([key, value]) =&gt; {\n   276\t                if (comp([key, value])) retObj[key] = value;\n   277\t            });\n   278\t        }\n   279\t        return retObj;\n   280\t    }\n...\n   307\t\n   308\t    // TODO: Foundry 0.9 Should TokenDocument be used instead of Token?\n   309\t    // TODO: Check canvas.scene.tokens\n   310\t    static getToken(id?: string): Token | undefined {\n   311\t        if (!canvas || !canvas.ready || !canvas.tokens) return;\n   312\t\n   313\t        for (const token of canvas.tokens.placeables) {\n   314\t            if (token.id === id) {\n   315\t                return token;\n   316\t            }\n   317\t        }\n   318\t    }\n   319\t\n   320\t    /**\n   321\t     * Use this helper to get a tokens actor from any given scene id.\n   322\t     * @param sceneTokenId A mixed id with the format '&lt;sceneId&gt;.&lt;tokenid&gt;\n   323\t     */\n   324\t    static getSceneTokenActor(sceneTokenId: string): SR6Actor | null {\n   325\t        const [sceneId, tokenId] = Helpers.deconstructSceneTokenId(sceneTokenId);\n   326\t        const token = Helpers.getSceneTokenDocument(sceneId, tokenId);\n   327\t        if (!token) return null;\n   328\t        return token.getActor();\n   329\t    }\n   330\t\n   331\t    static deconstructSceneTokenId(sceneTokenId: string): [sceneId: string, tokenId: string] {\n   332\t        return sceneTokenId.split('.') as [sceneId: string, tokenId: string];\n   333\t    }\n   334\t\n   335\t    static getSceneTokenDocument(sceneId, tokenId): TokenDocument | undefined {\n   336\t        const scene = game.scenes?.get(sceneId);\n   337\t        if (!scene) return;\n   338\t        const token = scene.tokens.get(tokenId);\n   339\t        if (!token) return;\n   340\t\n   341\t        return token;\n   342\t    }\n   343\t\n   344\t    static getUserTargets(user?: User | null): Token[] {\n   345\t        user = user ? user : game.user;\n   346\t\n   347\t        if (!user) return []\n   348\t\n   349\t        return Array.from(user.targets);\n   350\t    }\n   351\t\n   352\t    static userHasTargets(user?: User | null): boolean {\n   353\t        user = user ? user : game.user;\n   354\t\n   355\t        if (!user) return false;\n   356\t\n   357\t        return user.targets.size &gt; 0;\n   358\t    }\n...\n   446\t\n   447\t    /**\n   448\t     * Determine if the current user has any tokens selected.\n   449\t     * @returns true if one or more tokens have been selected.\n   450\t     */\n   451\t    static userHasControlledTokens(): boolean {\n   452\t        if (!canvas || !canvas.ready || !canvas.tokens) return false;\n   453\t        return canvas.tokens.controlled.length &gt; 0;\n   454\t    }\n   455\t\n   456\t    /**\n   457\t     * Return all actors connected to all user controlled tokens.\n   458\t     * @returns An array token actors.\n   459\t     */\n   460\t    static getControlledTokenActors(): SR6Actor[] {\n   461\t        if (!canvas || !canvas.ready) return []\n   462\t\n   463\t        const tokens = Helpers.getControlledTokens();\n   464\t        return tokens.map(token =&gt; token.actor) as SR6Actor[];\n   465\t    }\n   466\t\n   467\t    /**\n   468\t     * return all tokens a user has targeted at the moment.\n   469\t     * @returns An array tokens.\n   470\t     */\n   471\t    static getTargetedTokens(): Token[] {\n   472\t        if (!canvas.ready || !game.user) return [];\n   473\t\n   474\t        return Array.from(game.user.targets);\n   475\t    }\n   476\t\n   477\t    /**\n   478\t     * Return either all user selected token actors or the users game character actor.\n   479\t     * @returns An array of actors.\n   480\t     */\n   481\t    static getSelectedActorsOrCharacter(): SR6Actor[] {\n   482\t        if (!game.user) return [];\n   483\t\n   484\t        const actors = Helpers.getControlledTokenActors();\n   485\t\n   486\t        // Try to default to a users character.\n   487\t        if (actors.length === 0 &amp;&amp; game.user.character) {\n   488\t            actors.push(game.user.character);\n   489\t        }\n   490\t\n   491\t        return actors as SR6Actor[];\n   492\t    }\n...\n   576\t\n   577\t    static getDefenseRating(targets: TokenDocument[]): number {\n   578\t        let defenseRating = 0;\n   579\t        for(const token of targets) {\n   580\t            let target = token.actor;\n   581\t            console.log(target);\n   582\t            // @ts-ignore\n   583\t            if ('defense_rating' in target.system.values &amp;&amp; target.system.values.defense_rating.value &gt; defenseRating) {\n   584\t                // @ts-ignore\n   585\t                defenseRating = target.system.values.defense_rating.value;\n   586\t            }\n   587\t        }\n   588\t        return defenseRating;\n   589\t    }\n   590\t\n   591\t    static getAttackRating(actor: SR6Actor): number {\n   592\t        return 0;\n   593\t    }\n...\n   661\t\n   662\t        // If we did not find anything on the actor, search the active tokens (the item might only exist on a non linked token)\n   663\t        // This will not work if we are on a different scene or the token got deleted, which is expected when you put an\n   664\t        // item on a token without linking it.\n   665\t        const tokens = actorSource.getActiveTokens();\n   666\t        let tokenItem: SR6Item | undefined;\n   667\t        tokens.forEach(token =&gt; {\n   668\t            if (!token.actor) return;\n   669\t\n   670\t            const foundItem = token.actor.items.get(itemId);\n   671\t            if (foundItem) {\n   672\t                tokenItem = foundItem as unknown as SR6Item;\n   673\t            }\n   674\t        });\n   675\t\n   676\t        return tokenItem;\n   677\t    }\n...\nPath: src/module/actor/SR6Actor.ts\n...\n  2704\t\n  2705\t    /**\n  2706\t     * Find and refresh all token sheets for this actor\n  2707\t     * This is needed because token sheets are not automatically refreshed when the actor is updated\n  2708\t     */\n  2709\t    refreshTokenSheets() {\n  2710\t        console.log(`Shadowrun 6e | Refreshing token sheets for ${this.name}`);\n  2711\t\n  2712\t        // Get all tokens for this actor\n  2713\t        const tokens = this.getActiveTokens();\n  2714\t        console.log(`Shadowrun 6e | Found ${tokens.length} tokens for ${this.name}`);\n  2715\t\n  2716\t        // Refresh each token\n  2717\t        for (const token of tokens) {\n  2718\t            // Refresh the token\n  2719\t            if (token.refresh) token.refresh();\n  2720\t\n  2721\t            // Refresh the token's sheet if it's open\n  2722\t            if (token.sheet &amp;&amp; token.sheet.rendered) {\n  2723\t                token.sheet.render(true);\n  2724\t                console.log(`Shadowrun 6e | Refreshed token sheet for ${token.name}`);\n  2725\t            }\n  2726\t        }\n  2727\t\n  2728\t        // Find and refresh all token sheets in the ui.windows collection\n  2729\t        for (const [id, app] of Object.entries(ui.windows)) {\n  2730\t            // Check if this is a sheet for one of our tokens\n  2731\t            if (app.token &amp;&amp; tokens.some(t =&gt; t.id === app.token.id)) {\n  2732\t                app.render(true);\n  2733\t                console.log(`Shadowrun 6e | Refreshed token sheet ${id} for ${app.token.name}`);\n  2734\t            }\n  2735\t        }\n  2736\t    }\n...\n  2990\t\n  2991\t        // Refresh the canvas if it exists\n  2992\t        if (canvas &amp;&amp; canvas.tokens &amp;&amp; typeof canvas.tokens.placeables !== 'undefined') {\n  2993\t            canvas.tokens.placeables.forEach(token =&gt; {\n  2994\t                if (token.actor &amp;&amp; token.actor.id === this.id &amp;&amp; token.refresh) {\n  2995\t                    token.refresh();\n  2996\t                }\n  2997\t            });\n  2998\t        }\n  2999\t\n  3000\t        // Refresh token sheets\n  3001\t        this.refreshTokenSheets();\n  3002\t\n  3003\t        console.log(`Shadowrun 6e | Completed refresh of all sheets for ${this.name}`);\n  3004\t    }\n...\nPath: src/module/targeting/TargetingService.ts\n...\n   122\t    \n   123\t    /**\n   124\t     * Suggest targets for an action when none are selected\n   125\t     * @param action The action being performed\n   126\t     * @param actor The actor performing the action\n   127\t     * @returns An array of suggested target tokens\n   128\t     */\n   129\t    static suggestTargetsForAction(action: SR6Item, actor: SR6Actor): Token[] {\n   130\t        // Get the actor's token\n   131\t        const actorToken = actor.getToken();\n   132\t        if (!actorToken) return [];\n   133\t        \n   134\t        // Get all tokens in the scene\n   135\t        const tokens = canvas.tokens?.placeables || [];\n   136\t        \n   137\t        // Filter for potential targets (exclude the actor's own token)\n   138\t        const potentialTargets = tokens.filter(token =&gt; \n   139\t            token.id !== actorToken.id &amp;&amp; \n   140\t            token.actor &amp;&amp; \n   141\t            this.isValidTarget(token, action, actor)\n   142\t        );\n...\n   151\t    \n   152\t    /**\n   153\t     * Highlight valid targets for an action\n   154\t     * @param action The action being performed\n   155\t     * @param actor The actor performing the action\n   156\t     */\n   157\t    static highlightValidTargets(action: SR6Item, actor: SR6Actor): void {\n   158\t        // Get all tokens in the scene\n   159\t        const tokens = canvas.tokens?.placeables || [];\n   160\t        \n   161\t        // Reset all token highlights\n   162\t        tokens.forEach(token =&gt; {\n   163\t            token.border?.visible = false;\n   164\t        });\n   165\t        \n   166\t        // Get valid targets\n   167\t        const validTargets = tokens.filter(token =&gt; \n   168\t            token.actor &amp;&amp; \n   169\t            this.isValidTarget(token, action, actor)\n   170\t        );\n   171\t        \n   172\t        // Highlight valid targets\n   173\t        validTargets.forEach(token =&gt; {\n   174\t            token.border.visible = true;\n   175\t            token.border.style.borderColor = 0x00FF00; // Green for valid targets\n   176\t        });\n   177\t        \n   178\t        // Force a canvas refresh\n   179\t        canvas.tokens?.refresh();\n   180\t    }\n   181\t    \n   182\t    /**\n   183\t     * Clear target highlights\n   184\t     */\n   185\t    static clearTargetHighlights(): void {\n   186\t        // Get all tokens in the scene\n   187\t        const tokens = canvas.tokens?.placeables || [];\n   188\t        \n   189\t        // Reset all token highlights\n   190\t        tokens.forEach(token =&gt; {\n   191\t            token.border?.visible = false;\n   192\t        });\n   193\t        \n   194\t        // Force a canvas refresh\n   195\t        canvas.tokens?.refresh();\n   196\t    }\n   197\t    \n   198\t    /**\n   199\t     * Get targets for an opposed test\n   200\t     * @param action The action being performed\n   201\t     * @param actor The actor performing the action\n   202\t     * @returns An array of target actors\n   203\t     */\n   204\t    static getOpposedTestTargets(action: SR6Item, actor: SR6Actor): SR6Actor[] {\n   205\t        // Get valid targets\n   206\t        const validTargets = this.getValidTargetsForAction(action, actor);\n   207\t        \n   208\t        // Convert to actors\n   209\t        return validTargets\n   210\t            .map(token =&gt; token.actor as SR6Actor)\n   211\t            .filter(actor =&gt; actor !== undefined);\n   212\t    }\n...\nPath: src/module/tests/TestCreator.ts\n...\n   216\t\n   217\t        // Determine actors to roll test with.\n   218\t        let actors = await Helpers.getOpposedTestActors(testData.data);\n   219\t\n   220\t        // Inform user about tokens with deleted sidebar actors.\n   221\t        // This can both happen for linked tokens immediately and unlinked tokens after reloading.\n   222\t        if (actors.filter(actor =&gt; !actor).length &gt; 0) {\n   223\t            ui.notifications?.warn('TOKEN.WarningNoActor', {localize: true});\n   224\t            return;\n   225\t        }\n   226\t\n   227\t        // filter out actors current user shouldn't be able to test with.\n   228\t        actors = actors.filter(actor =&gt; actor.isOwner);\n   229\t        // Fallback to player character.\n   230\t        if (actors.length === 0 &amp;&amp; game.user.character) {\n   231\t            actors.push(game.user.character);\n   232\t        }\n   233\t\n   234\t        if (actors.length === 0) {\n   235\t            ui.notifications?.warn(game.i18n.localize('SR6.Warnings.TokenSelectionNeeded'));\n   236\t        }\n...\nPath: src/module/apps/gmtools/OverwatchScoreTracker.js\n...\n    80\t\n    81\t        // Add linked token actors.\n    82\t        tokens.filter(token =&gt; token.document.actorLink).forEach(token =&gt; {\n    83\t            // Double check that the actor actually lives in the actors collection.\n    84\t            const actor = game.actors.get(token.document.actorId);\n    85\t            if (!actor) return;\n    86\t            if (this._isActorOnTracker(actor)) return;\n    87\t\n    88\t            OverwatchScoreTracker.addedActors.push(actor.id);\n    89\t        });\n    90\t\n    91\t        this.render();\n    92\t    }\n    93\t\n    94\t    /**\n    95\t     * Check if the given actor is already added and displayed on the current tracker.\n    96\t     *\n    97\t     * @param actor A actors collection actor.\n    98\t     * @returns {boolean} Will return true when the given actor already exists.\n    99\t     */\n   100\t    _isActorOnTracker(actor) {\n   101\t        return this.actors.find(actorData =&gt; actorData._id === actor.id) !== undefined;\n   102\t    }\n...\nPath: src/module/rules/DocumentSituationModifiers.ts\n...\n   390\t\n   391\t    /**\n   392\t     * Helper for scene modifier instances to clear all modifiers for all placed tokens\n   393\t     */\n   394\t    async clearAllTokensOnScene() {\n   395\t        if (!canvas.ready || !canvas.scene) return;\n   396\t        if (!this.documentIsScene) return;\n   397\t\n   398\t        // Validate that modifiers scene is same to current scene.\n   399\t        const scene = this.document as Scene;\n   400\t        if (canvas.scene.id !== scene.id) return;\n   401\t\n   402\t        // Use current scene for ease of access to tokens\n   403\t        canvas.scene.tokens.forEach(token =&gt; token.actor?.getSituationModifiers().clearAll());\n   404\t    }\n   405\t}\n...\nPath: src/module/hooks.ts\n...\n   446\t\n   447\t        if (item.isHost) {\n   448\t            // Collect actors from sidebar and active scene to update / rerender\n   449\t            let connectedIC = [\n   450\t                // All sidebar actors should also include tokens with linked actors.\n   451\t                ...game.actors.filter((actor: SR6Actor) =&gt; actor.isIC() &amp;&amp; actor.hasHost()) as SR6Actor[],\n   452\t                // All token actors that aren't linked.\n   453\t                // @ts-expect-error // TODO: foundry-vtt-types v10\n   454\t                ...canvas.scene.tokens.filter(token =&gt; !token.actorLink &amp;&amp; token.actor?.isIC() &amp;&amp; token.actor?.hasHost()).map(t =&gt; t.actor)\n   455\t            ];\n   456\t\n   457\t            // Update host data on the ic actor.\n   458\t            const host = item.asHost;\n   459\t            if (!host) return;\n   460\t            for (const ic of connectedIC) {\n   461\t                if (!ic) continue;\n   462\t                await ic._updateICHostData(host);\n   463\t            }\n   464\t        }\n   465\t    }\n...\nPath: src/module/item/flows/ActionFlow.ts\n...\n   120\t\n   121\t        // CASE - Return actor skills when available.\n   122\t        //        the major use case is owned items, where the actor is available.\n   123\t        const activeSkills = actor.getActiveSkills();\n   124\t\n   125\t        // Convert skill data to a value label mapping.\n   126\t        const skills: Record&lt;string, Translation&gt; = {};\n   127\t        for (const [id, skill] of Object.entries(activeSkills)) {\n   128\t            const key = skill.name || id;\n   129\t            const label = skill.label || skill.name;\n   130\t            skills[key] = label as Translation;\n   131\t        }\n   132\t\n   133\t        ActionFlow._injectMissingCustomSkill(skills, skillName);\n   134\t        return Helpers.sortConfigValuesByTranslation(skills);\n   135\t    }\n...\nPath: src/module/migrator/VersionMigration.ts\n...\n   158\t\n   159\t                // Migrate embedded TokenDocument / ActorData within SceneData\n   160\t                for (const token of scene.data.tokens) {\n   161\t                    // Don't migrate tokens without or a linked actor.\n   162\t                    if (!token.actor || token.data.actorLink) continue;\n   163\t\n   164\t                    //@ts-expect-error // TODO: foundry-vtt-types v10\n   165\t                    if (foundry.utils.isEmpty(token.actor)) continue;\n   166\t\n   167\t                    const updateData = await this.MigrateActorData(token.actor);\n   168\t\n   169\t                    expandObject(updateData);\n   170\t                    entityUpdates.set(token.actor, {\n   171\t                        updateData: updateData.data || null,\n   172\t                        embeddedItems: updateData.items || null,\n   173\t                        embeddedEffects: updateData.effects || null\n   174\t                    });\n   175\t                }\n   176\t\n   177\t                //@ts-expect-error // TODO: foundry-vtt-types v10\n   178\t                if (foundry.utils.isEmpty(updateData)) {\n   179\t                    continue;\n   180\t                }\n...\nPath: src/module/effects.ts\n...\n   149\t\n   150\t/**\n   151\t * Collect all effects from a documents items and nested items.\n   152\t *\n   153\t * @param document Either a actor or item document.\n   154\t * @param options.applyTo A iterable of apply-to target values\n   155\t * @param options.nestedItems Whether to include nested items\n   156\t * @returns An iterator effect\n   157\t */\n   158\texport function *allApplicableItemsEffects(document: SR6Actor|SR6Item, options: ApplicableItemEffectOptions = {}) {\n   159\t    const applyTo = options.applyTo ?? [];\n   160\t    const nestedItems = options.nestedItems ?? true;\n...\nPath: src/module/tests/RangedAttackTest.ts\n...\n    61\t\n    62\t        if(this.actor) {\n    63\t            console.log('Shadowrun 6e | Processing targets for actor:', this.actor.name);\n    64\t\n    65\t            // Map targets to defenders with their actual DR values\n    66\t            data.defenders = targets.map(token =&gt; {\n    67\t                console.log('Shadowrun 6e | Processing target token:', token.name);\n    68\t\n    69\t                const targetActor = token.actor;\n    70\t                let dr = 5; // default DR\n    71\t\n    72\t                if (!targetActor) {\n    73\t                    console.log('Shadowrun 6e | No actor found for token:', token.name);\n    74\t                    return null;\n    75\t                }\n    76\t\n    77\t                if (!(targetActor instanceof SR6Actor)) {\n    78\t                    console.log('Shadowrun 6e | Actor is not SR6Actor:', token.name);\n    79\t                    return null;\n    80\t                }\n    81\t\n    82\t                console.log('Shadowrun 6e | Processing SR6Actor target:', {\n    83\t                    name: targetActor.name,\n    84\t                    type: targetActor.type,\n    85\t                    hasSystem: !!targetActor.system,\n    86\t                    hasAttributes: !!targetActor.system?.attributes\n    87\t                });\n...\n&quot;,&quot;isError&quot;:false,&quot;requestId&quot;:&quot;&quot;}},&quot;b6452cb1-128a-4822-b54d-30c5294bb2fe;toolu_vrtx_01DBKRhSah2vw9f9ku1k4LXY&quot;:{&quot;requestId&quot;:&quot;b6452cb1-128a-4822-b54d-30c5294bb2fe&quot;,&quot;toolUseId&quot;:&quot;toolu_vrtx_01DBKRhSah2vw9f9ku1k4LXY&quot;,&quot;phase&quot;:5,&quot;result&quot;:{&quot;text&quot;:&quot;Successfully edited the file src/module/hooks.ts.\nResult for str_replace for entry with index [0]:\nReplacement successful.\nEdited section after IDE auto-formatting was applied:\n   443\t     */\n   444\t    static async updateIcConnectedToHostItem(item: SR6Item, data: Shadowrun.ShadowrunItemDataData, id: string) {\n   445\t        if (!canvas.ready || !game.actors) return;\n   446\t\n   447\t        if (item.isHost) {\n   448\t            // Collect actors from sidebar and active scene to update / rerender\n   449\t            let connectedIC = [\n   450\t                // All sidebar actors should also include tokens with linked actors.\n   451\t                ...game.actors.filter((actor: SR6Actor) =&gt; actor.isIC() &amp;&amp; actor.hasHost()) as SR6Actor[],\n   452\t                // All token actors that aren't linked.\n   453\t                // @ts-expect-error // TODO: foundry-vtt-types v10\n   454\t                ...canvas.scene.tokens.filter(token =&gt; !token.actorLink &amp;&amp; token.actor?.isIC() &amp;&amp; token.actor?.hasHost()).map(t =&gt; t.actor).filter(actor =&gt; actor !== null &amp;&amp; actor !== undefined)\n   455\t            ];\n   456\t\n   457\t            // Update host data on the ic actor.\n   458\t            const host = item.asHost;\n   459\t            if (!host) return;\n\nReview the changes and make sure they are as expected (correct indentation, no duplicate lines, etc).\nEdit the file again if necessary.\n&quot;,&quot;isError&quot;:false,&quot;requestId&quot;:&quot;&quot;}},&quot;a3b4150d-db66-4794-98e1-7e175b79d295;toolu_vrtx_01Y1UrDHFxtMLpYjYnJUwoAW&quot;:{&quot;requestId&quot;:&quot;a3b4150d-db66-4794-98e1-7e175b79d295&quot;,&quot;toolUseId&quot;:&quot;toolu_vrtx_01Y1UrDHFxtMLpYjYnJUwoAW&quot;,&quot;phase&quot;:5,&quot;result&quot;:{&quot;text&quot;:&quot;Successfully edited the file src/module/actor/SR6Actor.ts.\nResult for str_replace for entry with index [0]:\nReplacement successful.\nEdited section after IDE auto-formatting was applied:\n   314\t                ICPrep.prepareDerivedData(this.system, itemDataWrappers);\n   315\t                break;\n   316\t        }\n   317\t\n   318\t        // Ensure matrix actions are available for all actors that can use the Matrix\n   319\t        if (game.user?.isGM &amp;&amp; this.isOwner &amp;&amp; (this.isCharacter() || this.isSprite() || this.isIC())) {\n   320\t            // Check if we've already added matrix actions to this actor\n   321\t            const hasMatrixActions = this.getFlag('sr6elysium', 'hasMatrixActions');\n   322\t            if (!hasMatrixActions) {\n   323\t                // We need to use a setTimeout to avoid issues with the actor being locked during data preparation\n   324\t                // Also add error handling to prevent crashes during initialization\n   325\t                setTimeout(() =&gt; {\n   326\t                    try {\n   327\t                        this.ensureMatrixActions();\n   328\t                    } catch (error) {\n   329\t                        console.warn(`Shadowrun 6e | Failed to ensure matrix actions for actor ${this.name}:`, error);\n   330\t                    }\n   331\t                }, 500);\n   332\t            }\n   333\t        }\n   334\t    }\n   335\t\n   336\t    /**\n   337\t     * NOTE: This method is unused at the moment, keep it for future inspiration.\n\nReview the changes and make sure they are as expected (correct indentation, no duplicate lines, etc).\nEdit the file again if necessary.\n&quot;,&quot;isError&quot;:false,&quot;requestId&quot;:&quot;&quot;}},&quot;f481e317-a940-4876-bd51-32125577c863;toolu_vrtx_01XKMrtafLbfrRSRAmoRahAQ&quot;:{&quot;requestId&quot;:&quot;f481e317-a940-4876-bd51-32125577c863&quot;,&quot;toolUseId&quot;:&quot;toolu_vrtx_01XKMrtafLbfrRSRAmoRahAQ&quot;,&quot;phase&quot;:5,&quot;result&quot;:{&quot;text&quot;:&quot;Here's the result of running `cat -n` on src/module/actor/SR6Actor.ts:\n  2740\t                console.log(`Shadowrun 6e | Refreshed token sheet ${id} for ${app.token.name}`);\n  2741\t            }\n  2742\t        }\n  2743\t    }\n  2744\t\n  2745\t    /**\n  2746\t     * Ensures that the actor has access to all matrix actions from the matrix-actions compendium.\n  2747\t     * This method will add any missing matrix actions to the actor.\n  2748\t     *\n  2749\t     * @returns {Promise&lt;void&gt;}\n  2750\t     */\n  2751\t    async ensureMatrixActions() {\n  2752\t        console.log(`Shadowrun 6e | Ensuring matrix actions for actor ${this.name} (${this.id})`);\n  2753\t\n  2754\t        // Check if we've already added matrix actions to this actor\n  2755\t        const hasMatrixActions = this.getFlag('sr6elysium', 'hasMatrixActions');\n  2756\t        if (hasMatrixActions) {\n  2757\t            console.log(`Shadowrun 6e | ${this.name} already has matrix actions flag set`);\n  2758\t            return;\n  2759\t        }\n  2760\t\n  2761\t        // Get the matrix actions compendium\n  2762\t        const matrixPack = game.packs.get(\&quot;sr6elysium.matrix-actions\&quot;);\n  2763\t        if (!matrixPack) {\n  2764\t            console.error(\&quot;Shadowrun 6e | Matrix Actions compendium not found\&quot;);\n  2765\t            return;\n  2766\t        }\n  2767\t\n  2768\t        // Get all matrix actions\n  2769\t        await matrixPack.getIndex();\n  2770\t        const matrixActions = await Promise.all(\n  2771\t            Array.from(matrixPack.index).map(i =&gt; matrixPack.getDocument(i._id))\n  2772\t        );\n  2773\t\n  2774\t        // Get existing action names to avoid duplicates\n  2775\t        const existingNames = this.items\n  2776\t            .filter(i =&gt; i.type === \&quot;action\&quot;)\n  2777\t            .map(i =&gt; i.name.toLowerCase());\n  2778\t\n  2779\t        // Filter out actions the actor already has\n  2780\t        const actionsToAdd = matrixActions.filter(\n  2781\t            a =&gt; !existingNames.includes(a.name.toLowerCase())\n  2782\t        );\n  2783\t\n  2784\t        if (actionsToAdd.length === 0) {\n  2785\t            console.log(`Shadowrun 6e | ${this.name} already has all matrix actions`);\n  2786\t            // Set the flag to indicate that we've checked for matrix actions\n  2787\t            await this.setFlag('sr6elysium', 'hasMatrixActions', true);\n  2788\t            return;\n  2789\t        }\n  2790\t\n  2791\t        // Add the actions\n  2792\t        await this.createEmbeddedDocuments(\n  2793\t            \&quot;Item\&quot;,\n  2794\t            actionsToAdd.map(a =&gt; a.toObject())\n  2795\t        );\n  2796\t\n  2797\t        console.log(`Shadowrun 6e | Added ${actionsToAdd.length} matrix actions to ${this.name}`);\n  2798\t\n  2799\t        // Set the flag to indicate that we've added matrix actions\n  2800\t        await this.setFlag('sr6elysium', 'hasMatrixActions', true);\nTotal lines in file: 3038\n&quot;,&quot;isError&quot;:false,&quot;requestId&quot;:&quot;&quot;}},&quot;6780cfe8-3d82-45da-8815-1be78f56c85d;toolu_vrtx_01WEYaNeofMCX49CUzEzZieN&quot;:{&quot;requestId&quot;:&quot;6780cfe8-3d82-45da-8815-1be78f56c85d&quot;,&quot;toolUseId&quot;:&quot;toolu_vrtx_01WEYaNeofMCX49CUzEzZieN&quot;,&quot;phase&quot;:5,&quot;result&quot;:{&quot;text&quot;:&quot;Successfully edited the file src/module/actor/SR6Actor.ts.\nResult for str_replace for entry with index [0]:\nReplacement successful.\nEdited section after IDE auto-formatting was applied:\n  2747\t     * This method will add any missing matrix actions to the actor.\n  2748\t     *\n  2749\t     * @returns {Promise&lt;void&gt;}\n  2750\t     */\n  2751\t    async ensureMatrixActions() {\n  2752\t        try {\n  2753\t            console.log(`Shadowrun 6e | Ensuring matrix actions for actor ${this.name} (${this.id})`);\n  2754\t\n  2755\t            // Validate that the actor still exists and is valid\n  2756\t            if (!this.id || !this.name) {\n  2757\t                console.warn(`Shadowrun 6e | Actor is invalid, skipping matrix actions initialization`);\n  2758\t                return;\n  2759\t            }\n  2760\t\n  2761\t            // Check if we've already added matrix actions to this actor\n  2762\t            const hasMatrixActions = this.getFlag('sr6elysium', 'hasMatrixActions');\n  2763\t            if (hasMatrixActions) {\n  2764\t                console.log(`Shadowrun 6e | ${this.name} already has matrix actions flag set`);\n  2765\t                return;\n  2766\t            }\n  2767\t\n  2768\t            // Get the matrix actions compendium\n  2769\t            const matrixPack = game.packs.get(\&quot;sr6elysium.matrix-actions\&quot;);\n  2770\t            if (!matrixPack) {\n  2771\t                console.error(\&quot;Shadowrun 6e | Matrix Actions compendium not found\&quot;);\n  2772\t                return;\n  2773\t            }\n  2774\t\n  2775\t            // Get all matrix actions\n  2776\t            await matrixPack.getIndex();\n  2777\t            const matrixActions = await Promise.all(\n  2778\t                Array.from(matrixPack.index).map(i =&gt; matrixPack.getDocument(i._id))\n  2779\t            );\n  2780\t\n  2781\t            // Filter out null/undefined actions\n  2782\t            const validMatrixActions = matrixActions.filter(action =&gt; action &amp;&amp; action.name);\n  2783\t            if (validMatrixActions.length === 0) {\n  2784\t                console.warn(`Shadowrun 6e | No valid matrix actions found in compendium`);\n  2785\t                await this.setFlag('sr6elysium', 'hasMatrixActions', true);\n  2786\t                return;\n  2787\t            }\n  2788\t\n  2789\t            // Get existing action names to avoid duplicates\n  2790\t            const existingNames = this.items\n  2791\t                .filter(i =&gt; i &amp;&amp; i.type === \&quot;action\&quot; &amp;&amp; i.name)\n  2792\t                .map(i =&gt; i.name.toLowerCase());\n  2793\t\n  2794\t            // Filter out actions the actor already has\n  2795\t            const actionsToAdd = validMatrixActions.filter(\n  2796\t                a =&gt; a &amp;&amp; a.name &amp;&amp; !existingNames.includes(a.name.toLowerCase())\n  2797\t            );\n  2798\t\n  2799\t            if (actionsToAdd.length === 0) {\n  2800\t                console.log(`Shadowrun 6e | ${this.name} already has all matrix actions`);\n  2801\t                // Set the flag to indicate that we've checked for matrix actions\n  2802\t                await this.setFlag('sr6elysium', 'hasMatrixActions', true);\n  2803\t                return;\n  2804\t            }\n  2805\t\n  2806\t            // Add the actions\n  2807\t            await this.createEmbeddedDocuments(\n  2808\t                \&quot;Item\&quot;,\n  2809\t                actionsToAdd.map(a =&gt; a.toObject())\n  2810\t            );\n  2811\t\n  2812\t            console.log(`Shadowrun 6e | Added ${actionsToAdd.length} matrix actions to ${this.name}`);\n  2813\t\n  2814\t            // Set the flag to indicate that we've added matrix actions\n  2815\t            await this.setFlag('sr6elysium', 'hasMatrixActions', true);\n  2816\t        } catch (error) {\n  2817\t            console.error(`Shadowrun 6e | Error ensuring matrix actions for actor ${this.name}:`, error);\n  2818\t            // Set the flag anyway to prevent repeated attempts\n  2819\t            try {\n  2820\t                await this.setFlag('sr6elysium', 'hasMatrixActions', true);\n  2821\t            } catch (flagError) {\n  2822\t                console.error(`Shadowrun 6e | Failed to set matrix actions flag for ${this.name}:`, flagError);\n  2823\t            }\n  2824\t        }\n  2825\t    }\n  2826\t\n  2827\t    async newSceneSetup() {\n  2828\t        const updateData: Record&lt;string, any&gt; = {};\n\nReview the changes and make sure they are as expected (correct indentation, no duplicate lines, etc).\nEdit the file again if necessary.\n&quot;,&quot;isError&quot;:false,&quot;requestId&quot;:&quot;&quot;}},&quot;b6fdb711-eb04-4ad4-9aa4-26e54493eb09;toolu_vrtx_01N8GuyrBEnt1DQ2GxN1h9iT&quot;:{&quot;requestId&quot;:&quot;b6fdb711-eb04-4ad4-9aa4-26e54493eb09&quot;,&quot;toolUseId&quot;:&quot;toolu_vrtx_01N8GuyrBEnt1DQ2GxN1h9iT&quot;,&quot;phase&quot;:5,&quot;result&quot;:{&quot;text&quot;:&quot;Successfully edited the file src/module/helpers.ts.\nResult for str_replace for entry with index [0]:\nReplacement successful.\nEdited section after IDE auto-formatting was applied:\n   452\t        if (!canvas || !canvas.ready || !canvas.tokens) return false;\n   453\t        return canvas.tokens.controlled.length &gt; 0;\n   454\t    }\n   455\t\n   456\t    /**\n   457\t     * Return all actors connected to all user controlled tokens.\n   458\t     * @returns An array token actors.\n   459\t     */\n   460\t    static getControlledTokenActors(): SR6Actor[] {\n   461\t        if (!canvas || !canvas.ready) return []\n   462\t\n   463\t        const tokens = Helpers.getControlledTokens();\n   464\t        return tokens.map(token =&gt; token.actor).filter(actor =&gt; actor !== null &amp;&amp; actor !== undefined) as SR6Actor[];\n   465\t    }\n   466\t\n   467\t    /**\n   468\t     * return all tokens a user has targeted at the moment.\n   469\t     * @returns An array tokens.\n\nReview the changes and make sure they are as expected (correct indentation, no duplicate lines, etc).\nEdit the file again if necessary.\n&quot;,&quot;isError&quot;:false,&quot;requestId&quot;:&quot;&quot;}},&quot;5cc95c70-f12c-4c0e-b46d-49a4328e6448;toolu_vrtx_01PN9Cvr19KEpK6VnitQwm3M&quot;:{&quot;requestId&quot;:&quot;5cc95c70-f12c-4c0e-b46d-49a4328e6448&quot;,&quot;toolUseId&quot;:&quot;toolu_vrtx_01PN9Cvr19KEpK6VnitQwm3M&quot;,&quot;phase&quot;:5,&quot;result&quot;:{&quot;text&quot;:&quot;Successfully edited the file src/module/helpers.ts.\nResult for str_replace for entry with index [0]:\nReplacement successful.\nEdited section after IDE auto-formatting was applied:\n   573\t\n   574\t        return actor.name as string;\n   575\t    }\n   576\t\n   577\t    static getDefenseRating(targets: TokenDocument[]): number {\n   578\t        let defenseRating = 0;\n   579\t        for(const token of targets) {\n   580\t            let target = token.actor;\n   581\t            if (!target) {\n   582\t                console.warn('Shadowrun 6e | Token has no actor:', token.name);\n   583\t                continue;\n   584\t            }\n   585\t            console.log(target);\n   586\t            // @ts-ignore\n   587\t            if (target.system &amp;&amp; target.system.values &amp;&amp; 'defense_rating' in target.system.values &amp;&amp; target.system.values.defense_rating.value &gt; defenseRating) {\n   588\t                // @ts-ignore\n   589\t                defenseRating = target.system.values.defense_rating.value;\n   590\t            }\n   591\t        }\n   592\t        return defenseRating;\n   593\t    }\n   594\t\n   595\t    static getAttackRating(actor: SR6Actor): number {\n   596\t        return 0;\n   597\t    }\n\nReview the changes and make sure they are as expected (correct indentation, no duplicate lines, etc).\nEdit the file again if necessary.\n&quot;,&quot;isError&quot;:false,&quot;requestId&quot;:&quot;&quot;}},&quot;43a9a213-6823-4ba9-89cb-17d3b7847f6c;toolu_vrtx_01WxRAoD8xxXw4AqEVeVZQPq&quot;:{&quot;requestId&quot;:&quot;43a9a213-6823-4ba9-89cb-17d3b7847f6c&quot;,&quot;toolUseId&quot;:&quot;toolu_vrtx_01WxRAoD8xxXw4AqEVeVZQPq&quot;,&quot;phase&quot;:5,&quot;result&quot;:{&quot;text&quot;:&quot;Successfully edited the file src/module/rules/DocumentSituationModifiers.ts.\nResult for str_replace for entry with index [0]:\nReplacement successful.\nEdited section after IDE auto-formatting was applied:\n   398\t        // Validate that modifiers scene is same to current scene.\n   399\t        const scene = this.document as Scene;\n   400\t        if (canvas.scene.id !== scene.id) return;\n   401\t\n   402\t        // Use current scene for ease of access to tokens\n   403\t        canvas.scene.tokens.forEach(token =&gt; {\n   404\t            if (token.actor) {\n   405\t                token.actor.getSituationModifiers().clearAll();\n   406\t            }\n   407\t        });\n   408\t    }\n   409\t}\n   410\t\n\nReview the changes and make sure they are as expected (correct indentation, no duplicate lines, etc).\nEdit the file again if necessary.\n&quot;,&quot;isError&quot;:false,&quot;requestId&quot;:&quot;&quot;}},&quot;9a37be07-8376-410c-bcd8-2c191383b532;toolu_vrtx_019Uf5qPEYx7arNVjEfE5DtM&quot;:{&quot;requestId&quot;:&quot;9a37be07-8376-410c-bcd8-2c191383b532&quot;,&quot;toolUseId&quot;:&quot;toolu_vrtx_019Uf5qPEYx7arNVjEfE5DtM&quot;,&quot;phase&quot;:5,&quot;result&quot;:{&quot;text&quot;:&quot;Successfully edited the file src/module/actor/SR6Actor.ts.\nResult for str_replace for entry with index [0]:\nReplacement successful.\nEdited section after IDE auto-formatting was applied:\n  3018\t        for (const token of this.getActiveTokens()) {\n  3019\t            if (token.refresh) token.refresh();\n  3020\t        }\n  3021\t\n  3022\t        // Refresh the canvas if it exists\n  3023\t        if (canvas &amp;&amp; canvas.tokens &amp;&amp; typeof canvas.tokens.placeables !== 'undefined') {\n  3024\t            canvas.tokens.placeables.forEach(token =&gt; {\n  3025\t                if (token.actor &amp;&amp; token.actor.id === this.id &amp;&amp; token.refresh) {\n  3026\t                    token.refresh();\n  3027\t                }\n  3028\t            });\n  3029\t        }\n  3030\t\n  3031\t        // Refresh token sheets\n  3032\t        this.refreshTokenSheets();\n  3033\t\n\nReview the changes and make sure they are as expected (correct indentation, no duplicate lines, etc).\nEdit the file again if necessary.\n&quot;,&quot;isError&quot;:false,&quot;requestId&quot;:&quot;&quot;}},&quot;5096e646-b949-4e2c-a7f1-1162a8e216df;toolu_vrtx_01TS6tsv5qMdBBkHuogUw2vW&quot;:{&quot;requestId&quot;:&quot;5096e646-b949-4e2c-a7f1-1162a8e216df&quot;,&quot;toolUseId&quot;:&quot;toolu_vrtx_01TS6tsv5qMdBBkHuogUw2vW&quot;,&quot;phase&quot;:5,&quot;result&quot;:{&quot;text&quot;:&quot;Successfully edited the file src/module/actor/SR6Actor.ts.\nResult for str_replace for entry with index [0]:\nReplacement successful.\nEdited section after IDE auto-formatting was applied:\n   314\t                ICPrep.prepareDerivedData(this.system, itemDataWrappers);\n   315\t                break;\n   316\t        }\n   317\t\n   318\t        // Ensure matrix actions are available for all actors that can use the Matrix\n   319\t        // Only run this if the game is fully ready and not during migration\n   320\t        if (game.ready &amp;&amp; game.user?.isGM &amp;&amp; this.isOwner &amp;&amp; (this.isCharacter() || this.isSprite() || this.isIC())) {\n   321\t            // Check if we've already added matrix actions to this actor\n   322\t            const hasMatrixActions = this.getFlag('sr6elysium', 'hasMatrixActions');\n   323\t            if (!hasMatrixActions) {\n   324\t                // We need to use a setTimeout to avoid issues with the actor being locked during data preparation\n   325\t                // Also add error handling to prevent crashes during initialization\n   326\t                setTimeout(() =&gt; {\n   327\t                    try {\n   328\t                        // Double-check that the game is still ready and the actor is valid\n   329\t                        if (game.ready &amp;&amp; this.id &amp;&amp; this.name) {\n   330\t                            this.ensureMatrixActions();\n   331\t                        }\n   332\t                    } catch (error) {\n   333\t                        console.warn(`Shadowrun 6e | Failed to ensure matrix actions for actor ${this.name}:`, error);\n   334\t                    }\n   335\t                }, 500);\n   336\t            }\n   337\t        }\n   338\t    }\n   339\t\n   340\t    /**\n   341\t     * NOTE: This method is unused at the moment, keep it for future inspiration.\n\nReview the changes and make sure they are as expected (correct indentation, no duplicate lines, etc).\nEdit the file again if necessary.\n&quot;,&quot;isError&quot;:false,&quot;requestId&quot;:&quot;&quot;}},&quot;e43f4ed4-7fd8-4ce7-a1d5-2455003f775a;toolu_vrtx_01XRw5nccdmHgzNFdAd7Bgqw&quot;:{&quot;requestId&quot;:&quot;e43f4ed4-7fd8-4ce7-a1d5-2455003f775a&quot;,&quot;toolUseId&quot;:&quot;toolu_vrtx_01XRw5nccdmHgzNFdAd7Bgqw&quot;,&quot;phase&quot;:5,&quot;result&quot;:{&quot;text&quot;:&quot;Here's the result of running `cat -n` on src/module/targeting/TargetingService.ts:\n   135\t        const tokens = canvas.tokens?.placeables || [];\n   136\t        \n   137\t        // Filter for potential targets (exclude the actor's own token)\n   138\t        const potentialTargets = tokens.filter(token =&gt; \n   139\t            token.id !== actorToken.id &amp;&amp; \n   140\t            token.actor &amp;&amp; \n   141\t            this.isValidTarget(token, action, actor)\n   142\t        );\n   143\t        \n   144\t        // Sort by distance to the actor\n   145\t        return potentialTargets.sort((a, b) =&gt; {\nTotal lines in file: 252\n&quot;,&quot;isError&quot;:false,&quot;requestId&quot;:&quot;&quot;}},&quot;6272e7fd-a67b-4614-8bbc-4fdc2447ee64;toolu_vrtx_01UaQCzuypBU3MEeNi7vqwyT&quot;:{&quot;requestId&quot;:&quot;6272e7fd-a67b-4614-8bbc-4fdc2447ee64&quot;,&quot;toolUseId&quot;:&quot;toolu_vrtx_01UaQCzuypBU3MEeNi7vqwyT&quot;,&quot;phase&quot;:5,&quot;result&quot;:{&quot;text&quot;:&quot;Here's the result of running `cat -n` on src/module/apps/gmtools/OverwatchScoreTracker.js:\n    80\t\n    81\t        // Add linked token actors.\n    82\t        tokens.filter(token =&gt; token.document.actorLink).forEach(token =&gt; {\n    83\t            // Double check that the actor actually lives in the actors collection.\n    84\t            const actor = game.actors.get(token.document.actorId);\n    85\t            if (!actor) return;\n    86\t            if (this._isActorOnTracker(actor)) return;\n    87\t\n    88\t            OverwatchScoreTracker.addedActors.push(actor.id);\n    89\t        });\n    90\t\n    91\t        this.render();\n    92\t    }\n    93\t\n    94\t    /**\n    95\t     * Check if the given actor is already added and displayed on the current tracker.\nTotal lines in file: 165\n&quot;,&quot;isError&quot;:false,&quot;requestId&quot;:&quot;&quot;}},&quot;499c1985-0c36-46b6-907a-3e50894d539e;toolu_vrtx_01QTdJTSvx2vF5Yh9JB9aBzg&quot;:{&quot;requestId&quot;:&quot;499c1985-0c36-46b6-907a-3e50894d539e&quot;,&quot;toolUseId&quot;:&quot;toolu_vrtx_01QTdJTSvx2vF5Yh9JB9aBzg&quot;,&quot;phase&quot;:8}},&quot;draftExchange&quot;:{&quot;request_message&quot;:&quot;&quot;,&quot;rich_text_json_repr&quot;:{&quot;type&quot;:&quot;doc&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;paragraph&quot;}]},&quot;mentioned_items&quot;:[],&quot;status&quot;:&quot;draft&quot;},&quot;requestIds&quot;:[],&quot;isPinned&quot;:false,&quot;isShareable&quot;:true,&quot;extraData&quot;:{&quot;isAgentConversation&quot;:true,&quot;hasDirtyEdits&quot;:true},&quot;personaType&quot;:0,&quot;rootTaskUuid&quot;:&quot;26a30142-af69-4f5b-ab07-b3e18dbd856e&quot;,&quot;draftActiveContextIds&quot;:[&quot;userGuidelines&quot;,&quot;agentMemories&quot;]},&quot;2c9a18bf-842f-44cb-ac92-8f4f746459ec&quot;:{&quot;id&quot;:&quot;2c9a18bf-842f-44cb-ac92-8f4f746459ec&quot;,&quot;createdAtIso&quot;:&quot;2025-06-03T21:30:14.880Z&quot;,&quot;lastInteractedAtIso&quot;:&quot;2025-06-05T22:55:05.990Z&quot;,&quot;chatHistory&quot;:[{&quot;request_id&quot;:&quot;4924e941-ddd8-44e8-b785-a1f9c02bda41&quot;,&quot;uuid&quot;:&quot;e8b1e81f-fe9f-4e34-8ebf-c900bbc1b562&quot;,&quot;chatItemType&quot;:&quot;agentic-checkpoint-delimiter&quot;,&quot;status&quot;:&quot;success&quot;,&quot;fromTimestamp&quot;:0,&quot;toTimestamp&quot;:1748986214882,&quot;seen_state&quot;:&quot;seen&quot;},{&quot;status&quot;:&quot;success&quot;,&quot;request_id&quot;:&quot;ca16b995-2b14-4008-8022-b9b8ec991222&quot;,&quot;request_message&quot;:&quot;do we have code in place that grants edge for skills like analytical mind, or by looking for effects that grant edge for attribute tests?&quot;,&quot;rich_text_json_repr&quot;:{&quot;type&quot;:&quot;doc&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;paragraph&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;do we have code in place that grants edge for skills like analytical mind, or by looking for effects that grant edge for attribute tests?&quot;}]}]},&quot;mentioned_items&quot;:[],&quot;structured_output_nodes&quot;:[{&quot;id&quot;:0,&quot;type&quot;:0,&quot;content&quot;:&quot;&quot;},{&quot;id&quot;:1,&quot;type&quot;:2,&quot;content&quot;:&quot;*Your subscription for account jc.murray@technomanci.com is inactive. If you have another account with an active subscription, please sign out and sign in with that one. Otherwise, update your plan [here](https://app.augmentcode.com/account) to continue using Augment.*&quot;}],&quot;seen_state&quot;:&quot;seen&quot;,&quot;structured_request_nodes&quot;:[{&quot;id&quot;:0,&quot;type&quot;:0,&quot;text_node&quot;:{&quot;content&quot;:&quot;do we have code in place that grants edge for skills like analytical mind, or by looking for effects that grant edge for attribute tests?&quot;}},{&quot;id&quot;:1,&quot;type&quot;:4,&quot;ide_state_node&quot;:{&quot;workspaceFolders&quot;:[{&quot;repositoryRoot&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;,&quot;folderRoot&quot;:&quot;C:/Users/JC Murray/projects/games/foundryvtt/shadowrun6-elysium&quot;}],&quot;workspaceFoldersUnchanged&quot;:false}}],&quot;timestamp&quot;:&quot;2025-06-03T21:31:08.242Z&quot;,&quot;response_text&quot;:&quot;*Your subscription for account jc.murray@technomanci.com is inactive. If you have another account with an active subscription, please sign out and sign in with that one. Otherwise, update your plan [here](https://app.augmentcode.com/account) to continue using Augment.*&quot;,&quot;workspace_file_chunks&quot;:[]}],&quot;feedbackStates&quot;:{&quot;temp-fe-6728f059-e124-4b5a-9853-449edd30e64d&quot;:{&quot;selectedRating&quot;:0,&quot;feedbackNote&quot;:&quot;&quot;}},&quot;toolUseStates&quot;:{},&quot;draftExchange&quot;:{&quot;request_message&quot;:&quot;&quot;,&quot;rich_text_json_repr&quot;:{&quot;type&quot;:&quot;doc&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;paragraph&quot;}]},&quot;mentioned_items&quot;:[],&quot;status&quot;:&quot;draft&quot;},&quot;requestIds&quot;:[],&quot;isPinned&quot;:false,&quot;isShareable&quot;:true,&quot;extraData&quot;:{&quot;isAgentConversation&quot;:true,&quot;hasDirtyEdits&quot;:false},&quot;personaType&quot;:0,&quot;rootTaskUuid&quot;:&quot;9e82f632-82d6-4fd1-81ca-831a14733938&quot;}},&quot;agentExecutionMode&quot;:&quot;manual&quot;,&quot;isPanelCollapsed&quot;:true,&quot;displayedAnnouncements&quot;:[],&quot;isAgentEditsCollapsed&quot;:true,&quot;isContextPaneOpen&quot;:false,&quot;isActionsPaneOpen&quot;:false,&quot;sortConversationsBy&quot;:&quot;lastMessageTimestamp&quot;}" />
      </map>
    </option>
  </component>
</project>