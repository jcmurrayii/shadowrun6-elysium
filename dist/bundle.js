var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name3 in all)
    __defProp(target, name3, { get: all[name3], enumerable: true });
};

// node_modules/xml2js/lib/defaults.js
var require_defaults = __commonJS({
  "node_modules/xml2js/lib/defaults.js"(exports) {
    (function() {
      exports.defaults = {
        "0.1": {
          explicitCharkey: false,
          trim: true,
          normalize: true,
          normalizeTags: false,
          attrkey: "@",
          charkey: "#",
          explicitArray: false,
          ignoreAttrs: false,
          mergeAttrs: false,
          explicitRoot: false,
          validator: null,
          xmlns: false,
          explicitChildren: false,
          childkey: "@@",
          charsAsChildren: false,
          includeWhiteChars: false,
          async: false,
          strict: true,
          attrNameProcessors: null,
          attrValueProcessors: null,
          tagNameProcessors: null,
          valueProcessors: null,
          emptyTag: ""
        },
        "0.2": {
          explicitCharkey: false,
          trim: false,
          normalize: false,
          normalizeTags: false,
          attrkey: "$",
          charkey: "_",
          explicitArray: true,
          ignoreAttrs: false,
          mergeAttrs: false,
          explicitRoot: true,
          validator: null,
          xmlns: false,
          explicitChildren: false,
          preserveChildrenOrder: false,
          childkey: "$$",
          charsAsChildren: false,
          includeWhiteChars: false,
          async: false,
          strict: true,
          attrNameProcessors: null,
          attrValueProcessors: null,
          tagNameProcessors: null,
          valueProcessors: null,
          rootName: "root",
          xmldec: {
            "version": "1.0",
            "encoding": "UTF-8",
            "standalone": true
          },
          doctype: null,
          renderOpts: {
            "pretty": true,
            "indent": "  ",
            "newline": "\n"
          },
          headless: false,
          chunkSize: 1e4,
          emptyTag: "",
          cdata: false
        }
      };
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/Utility.js
var require_Utility = __commonJS({
  "node_modules/xmlbuilder/lib/Utility.js"(exports, module) {
    (function() {
      var assign, getValue, isArray, isEmpty, isFunction, isObject, isPlainObject, slice = [].slice, hasProp = {}.hasOwnProperty;
      assign = /* @__PURE__ */ __name(function() {
        var i2, key, len, source3, sources, target;
        target = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];
        if (isFunction(Object.assign)) {
          Object.assign.apply(null, arguments);
        } else {
          for (i2 = 0, len = sources.length; i2 < len; i2++) {
            source3 = sources[i2];
            if (source3 != null) {
              for (key in source3) {
                if (!hasProp.call(source3, key)) continue;
                target[key] = source3[key];
              }
            }
          }
        }
        return target;
      }, "assign");
      isFunction = /* @__PURE__ */ __name(function(val) {
        return !!val && Object.prototype.toString.call(val) === "[object Function]";
      }, "isFunction");
      isObject = /* @__PURE__ */ __name(function(val) {
        var ref;
        return !!val && ((ref = typeof val) === "function" || ref === "object");
      }, "isObject");
      isArray = /* @__PURE__ */ __name(function(val) {
        if (isFunction(Array.isArray)) {
          return Array.isArray(val);
        } else {
          return Object.prototype.toString.call(val) === "[object Array]";
        }
      }, "isArray");
      isEmpty = /* @__PURE__ */ __name(function(val) {
        var key;
        if (isArray(val)) {
          return !val.length;
        } else {
          for (key in val) {
            if (!hasProp.call(val, key)) continue;
            return false;
          }
          return true;
        }
      }, "isEmpty");
      isPlainObject = /* @__PURE__ */ __name(function(val) {
        var ctor, proto;
        return isObject(val) && (proto = Object.getPrototypeOf(val)) && (ctor = proto.constructor) && typeof ctor === "function" && ctor instanceof ctor && Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object);
      }, "isPlainObject");
      getValue = /* @__PURE__ */ __name(function(obj) {
        if (isFunction(obj.valueOf)) {
          return obj.valueOf();
        } else {
          return obj;
        }
      }, "getValue");
      module.exports.assign = assign;
      module.exports.isFunction = isFunction;
      module.exports.isObject = isObject;
      module.exports.isArray = isArray;
      module.exports.isEmpty = isEmpty;
      module.exports.isPlainObject = isPlainObject;
      module.exports.getValue = getValue;
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDOMImplementation.js
var require_XMLDOMImplementation = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDOMImplementation.js"(exports, module) {
    (function() {
      var XMLDOMImplementation;
      module.exports = XMLDOMImplementation = function() {
        function XMLDOMImplementation2() {
        }
        __name(XMLDOMImplementation2, "XMLDOMImplementation");
        XMLDOMImplementation2.prototype.hasFeature = function(feature, version) {
          return true;
        };
        XMLDOMImplementation2.prototype.createDocumentType = function(qualifiedName, publicId, systemId) {
          throw new Error("This DOM method is not implemented.");
        };
        XMLDOMImplementation2.prototype.createDocument = function(namespaceURI, qualifiedName, doctype) {
          throw new Error("This DOM method is not implemented.");
        };
        XMLDOMImplementation2.prototype.createHTMLDocument = function(title) {
          throw new Error("This DOM method is not implemented.");
        };
        XMLDOMImplementation2.prototype.getFeature = function(feature, version) {
          throw new Error("This DOM method is not implemented.");
        };
        return XMLDOMImplementation2;
      }();
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDOMErrorHandler.js
var require_XMLDOMErrorHandler = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDOMErrorHandler.js"(exports, module) {
    (function() {
      var XMLDOMErrorHandler;
      module.exports = XMLDOMErrorHandler = function() {
        function XMLDOMErrorHandler2() {
        }
        __name(XMLDOMErrorHandler2, "XMLDOMErrorHandler");
        XMLDOMErrorHandler2.prototype.handleError = function(error) {
          throw new Error(error);
        };
        return XMLDOMErrorHandler2;
      }();
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDOMStringList.js
var require_XMLDOMStringList = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDOMStringList.js"(exports, module) {
    (function() {
      var XMLDOMStringList;
      module.exports = XMLDOMStringList = function() {
        function XMLDOMStringList2(arr) {
          this.arr = arr || [];
        }
        __name(XMLDOMStringList2, "XMLDOMStringList");
        Object.defineProperty(XMLDOMStringList2.prototype, "length", {
          get: /* @__PURE__ */ __name(function() {
            return this.arr.length;
          }, "get")
        });
        XMLDOMStringList2.prototype.item = function(index) {
          return this.arr[index] || null;
        };
        XMLDOMStringList2.prototype.contains = function(str) {
          return this.arr.indexOf(str) !== -1;
        };
        return XMLDOMStringList2;
      }();
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDOMConfiguration.js
var require_XMLDOMConfiguration = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDOMConfiguration.js"(exports, module) {
    (function() {
      var XMLDOMConfiguration, XMLDOMErrorHandler, XMLDOMStringList;
      XMLDOMErrorHandler = require_XMLDOMErrorHandler();
      XMLDOMStringList = require_XMLDOMStringList();
      module.exports = XMLDOMConfiguration = function() {
        function XMLDOMConfiguration2() {
          var clonedSelf;
          this.defaultParams = {
            "canonical-form": false,
            "cdata-sections": false,
            "comments": false,
            "datatype-normalization": false,
            "element-content-whitespace": true,
            "entities": true,
            "error-handler": new XMLDOMErrorHandler(),
            "infoset": true,
            "validate-if-schema": false,
            "namespaces": true,
            "namespace-declarations": true,
            "normalize-characters": false,
            "schema-location": "",
            "schema-type": "",
            "split-cdata-sections": true,
            "validate": false,
            "well-formed": true
          };
          this.params = clonedSelf = Object.create(this.defaultParams);
        }
        __name(XMLDOMConfiguration2, "XMLDOMConfiguration");
        Object.defineProperty(XMLDOMConfiguration2.prototype, "parameterNames", {
          get: /* @__PURE__ */ __name(function() {
            return new XMLDOMStringList(Object.keys(this.defaultParams));
          }, "get")
        });
        XMLDOMConfiguration2.prototype.getParameter = function(name3) {
          if (this.params.hasOwnProperty(name3)) {
            return this.params[name3];
          } else {
            return null;
          }
        };
        XMLDOMConfiguration2.prototype.canSetParameter = function(name3, value) {
          return true;
        };
        XMLDOMConfiguration2.prototype.setParameter = function(name3, value) {
          if (value != null) {
            return this.params[name3] = value;
          } else {
            return delete this.params[name3];
          }
        };
        return XMLDOMConfiguration2;
      }();
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/NodeType.js
var require_NodeType = __commonJS({
  "node_modules/xmlbuilder/lib/NodeType.js"(exports, module) {
    (function() {
      module.exports = {
        Element: 1,
        Attribute: 2,
        Text: 3,
        CData: 4,
        EntityReference: 5,
        EntityDeclaration: 6,
        ProcessingInstruction: 7,
        Comment: 8,
        Document: 9,
        DocType: 10,
        DocumentFragment: 11,
        NotationDeclaration: 12,
        Declaration: 201,
        Raw: 202,
        AttributeDeclaration: 203,
        ElementDeclaration: 204,
        Dummy: 205
      };
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLAttribute.js
var require_XMLAttribute = __commonJS({
  "node_modules/xmlbuilder/lib/XMLAttribute.js"(exports, module) {
    (function() {
      var NodeType, XMLAttribute, XMLNode;
      NodeType = require_NodeType();
      XMLNode = require_XMLNode();
      module.exports = XMLAttribute = function() {
        function XMLAttribute2(parent, name3, value) {
          this.parent = parent;
          if (this.parent) {
            this.options = this.parent.options;
            this.stringify = this.parent.stringify;
          }
          if (name3 == null) {
            throw new Error("Missing attribute name. " + this.debugInfo(name3));
          }
          this.name = this.stringify.name(name3);
          this.value = this.stringify.attValue(value);
          this.type = NodeType.Attribute;
          this.isId = false;
          this.schemaTypeInfo = null;
        }
        __name(XMLAttribute2, "XMLAttribute");
        Object.defineProperty(XMLAttribute2.prototype, "nodeType", {
          get: /* @__PURE__ */ __name(function() {
            return this.type;
          }, "get")
        });
        Object.defineProperty(XMLAttribute2.prototype, "ownerElement", {
          get: /* @__PURE__ */ __name(function() {
            return this.parent;
          }, "get")
        });
        Object.defineProperty(XMLAttribute2.prototype, "textContent", {
          get: /* @__PURE__ */ __name(function() {
            return this.value;
          }, "get"),
          set: /* @__PURE__ */ __name(function(value) {
            return this.value = value || "";
          }, "set")
        });
        Object.defineProperty(XMLAttribute2.prototype, "namespaceURI", {
          get: /* @__PURE__ */ __name(function() {
            return "";
          }, "get")
        });
        Object.defineProperty(XMLAttribute2.prototype, "prefix", {
          get: /* @__PURE__ */ __name(function() {
            return "";
          }, "get")
        });
        Object.defineProperty(XMLAttribute2.prototype, "localName", {
          get: /* @__PURE__ */ __name(function() {
            return this.name;
          }, "get")
        });
        Object.defineProperty(XMLAttribute2.prototype, "specified", {
          get: /* @__PURE__ */ __name(function() {
            return true;
          }, "get")
        });
        XMLAttribute2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLAttribute2.prototype.toString = function(options) {
          return this.options.writer.attribute(this, this.options.writer.filterOptions(options));
        };
        XMLAttribute2.prototype.debugInfo = function(name3) {
          name3 = name3 || this.name;
          if (name3 == null) {
            return "parent: <" + this.parent.name + ">";
          } else {
            return "attribute: {" + name3 + "}, parent: <" + this.parent.name + ">";
          }
        };
        XMLAttribute2.prototype.isEqualNode = function(node) {
          if (node.namespaceURI !== this.namespaceURI) {
            return false;
          }
          if (node.prefix !== this.prefix) {
            return false;
          }
          if (node.localName !== this.localName) {
            return false;
          }
          if (node.value !== this.value) {
            return false;
          }
          return true;
        };
        return XMLAttribute2;
      }();
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLNamedNodeMap.js
var require_XMLNamedNodeMap = __commonJS({
  "node_modules/xmlbuilder/lib/XMLNamedNodeMap.js"(exports, module) {
    (function() {
      var XMLNamedNodeMap;
      module.exports = XMLNamedNodeMap = function() {
        function XMLNamedNodeMap2(nodes) {
          this.nodes = nodes;
        }
        __name(XMLNamedNodeMap2, "XMLNamedNodeMap");
        Object.defineProperty(XMLNamedNodeMap2.prototype, "length", {
          get: /* @__PURE__ */ __name(function() {
            return Object.keys(this.nodes).length || 0;
          }, "get")
        });
        XMLNamedNodeMap2.prototype.clone = function() {
          return this.nodes = null;
        };
        XMLNamedNodeMap2.prototype.getNamedItem = function(name3) {
          return this.nodes[name3];
        };
        XMLNamedNodeMap2.prototype.setNamedItem = function(node) {
          var oldNode;
          oldNode = this.nodes[node.nodeName];
          this.nodes[node.nodeName] = node;
          return oldNode || null;
        };
        XMLNamedNodeMap2.prototype.removeNamedItem = function(name3) {
          var oldNode;
          oldNode = this.nodes[name3];
          delete this.nodes[name3];
          return oldNode || null;
        };
        XMLNamedNodeMap2.prototype.item = function(index) {
          return this.nodes[Object.keys(this.nodes)[index]] || null;
        };
        XMLNamedNodeMap2.prototype.getNamedItemNS = function(namespaceURI, localName) {
          throw new Error("This DOM method is not implemented.");
        };
        XMLNamedNodeMap2.prototype.setNamedItemNS = function(node) {
          throw new Error("This DOM method is not implemented.");
        };
        XMLNamedNodeMap2.prototype.removeNamedItemNS = function(namespaceURI, localName) {
          throw new Error("This DOM method is not implemented.");
        };
        return XMLNamedNodeMap2;
      }();
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLElement.js
var require_XMLElement = __commonJS({
  "node_modules/xmlbuilder/lib/XMLElement.js"(exports, module) {
    (function() {
      var NodeType, XMLAttribute, XMLElement, XMLNamedNodeMap, XMLNode, getValue, isFunction, isObject, ref, extend = /* @__PURE__ */ __name(function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        __name(ctor, "ctor");
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, "extend"), hasProp = {}.hasOwnProperty;
      ref = require_Utility(), isObject = ref.isObject, isFunction = ref.isFunction, getValue = ref.getValue;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      XMLAttribute = require_XMLAttribute();
      XMLNamedNodeMap = require_XMLNamedNodeMap();
      module.exports = XMLElement = function(superClass) {
        extend(XMLElement2, superClass);
        function XMLElement2(parent, name3, attributes) {
          var child, j2, len, ref1;
          XMLElement2.__super__.constructor.call(this, parent);
          if (name3 == null) {
            throw new Error("Missing element name. " + this.debugInfo());
          }
          this.name = this.stringify.name(name3);
          this.type = NodeType.Element;
          this.attribs = {};
          this.schemaTypeInfo = null;
          if (attributes != null) {
            this.attribute(attributes);
          }
          if (parent.type === NodeType.Document) {
            this.isRoot = true;
            this.documentObject = parent;
            parent.rootObject = this;
            if (parent.children) {
              ref1 = parent.children;
              for (j2 = 0, len = ref1.length; j2 < len; j2++) {
                child = ref1[j2];
                if (child.type === NodeType.DocType) {
                  child.name = this.name;
                  break;
                }
              }
            }
          }
        }
        __name(XMLElement2, "XMLElement");
        Object.defineProperty(XMLElement2.prototype, "tagName", {
          get: /* @__PURE__ */ __name(function() {
            return this.name;
          }, "get")
        });
        Object.defineProperty(XMLElement2.prototype, "namespaceURI", {
          get: /* @__PURE__ */ __name(function() {
            return "";
          }, "get")
        });
        Object.defineProperty(XMLElement2.prototype, "prefix", {
          get: /* @__PURE__ */ __name(function() {
            return "";
          }, "get")
        });
        Object.defineProperty(XMLElement2.prototype, "localName", {
          get: /* @__PURE__ */ __name(function() {
            return this.name;
          }, "get")
        });
        Object.defineProperty(XMLElement2.prototype, "id", {
          get: /* @__PURE__ */ __name(function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }, "get")
        });
        Object.defineProperty(XMLElement2.prototype, "className", {
          get: /* @__PURE__ */ __name(function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }, "get")
        });
        Object.defineProperty(XMLElement2.prototype, "classList", {
          get: /* @__PURE__ */ __name(function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }, "get")
        });
        Object.defineProperty(XMLElement2.prototype, "attributes", {
          get: /* @__PURE__ */ __name(function() {
            if (!this.attributeMap || !this.attributeMap.nodes) {
              this.attributeMap = new XMLNamedNodeMap(this.attribs);
            }
            return this.attributeMap;
          }, "get")
        });
        XMLElement2.prototype.clone = function() {
          var att, attName, clonedSelf, ref1;
          clonedSelf = Object.create(this);
          if (clonedSelf.isRoot) {
            clonedSelf.documentObject = null;
          }
          clonedSelf.attribs = {};
          ref1 = this.attribs;
          for (attName in ref1) {
            if (!hasProp.call(ref1, attName)) continue;
            att = ref1[attName];
            clonedSelf.attribs[attName] = att.clone();
          }
          clonedSelf.children = [];
          this.children.forEach(function(child) {
            var clonedChild;
            clonedChild = child.clone();
            clonedChild.parent = clonedSelf;
            return clonedSelf.children.push(clonedChild);
          });
          return clonedSelf;
        };
        XMLElement2.prototype.attribute = function(name3, value) {
          var attName, attValue;
          if (name3 != null) {
            name3 = getValue(name3);
          }
          if (isObject(name3)) {
            for (attName in name3) {
              if (!hasProp.call(name3, attName)) continue;
              attValue = name3[attName];
              this.attribute(attName, attValue);
            }
          } else {
            if (isFunction(value)) {
              value = value.apply();
            }
            if (this.options.keepNullAttributes && value == null) {
              this.attribs[name3] = new XMLAttribute(this, name3, "");
            } else if (value != null) {
              this.attribs[name3] = new XMLAttribute(this, name3, value);
            }
          }
          return this;
        };
        XMLElement2.prototype.removeAttribute = function(name3) {
          var attName, j2, len;
          if (name3 == null) {
            throw new Error("Missing attribute name. " + this.debugInfo());
          }
          name3 = getValue(name3);
          if (Array.isArray(name3)) {
            for (j2 = 0, len = name3.length; j2 < len; j2++) {
              attName = name3[j2];
              delete this.attribs[attName];
            }
          } else {
            delete this.attribs[name3];
          }
          return this;
        };
        XMLElement2.prototype.toString = function(options) {
          return this.options.writer.element(this, this.options.writer.filterOptions(options));
        };
        XMLElement2.prototype.att = function(name3, value) {
          return this.attribute(name3, value);
        };
        XMLElement2.prototype.a = function(name3, value) {
          return this.attribute(name3, value);
        };
        XMLElement2.prototype.getAttribute = function(name3) {
          if (this.attribs.hasOwnProperty(name3)) {
            return this.attribs[name3].value;
          } else {
            return null;
          }
        };
        XMLElement2.prototype.setAttribute = function(name3, value) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.getAttributeNode = function(name3) {
          if (this.attribs.hasOwnProperty(name3)) {
            return this.attribs[name3];
          } else {
            return null;
          }
        };
        XMLElement2.prototype.setAttributeNode = function(newAttr) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.removeAttributeNode = function(oldAttr) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.getElementsByTagName = function(name3) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.getAttributeNS = function(namespaceURI, localName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.setAttributeNS = function(namespaceURI, qualifiedName, value) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.removeAttributeNS = function(namespaceURI, localName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.getAttributeNodeNS = function(namespaceURI, localName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.setAttributeNodeNS = function(newAttr) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.hasAttribute = function(name3) {
          return this.attribs.hasOwnProperty(name3);
        };
        XMLElement2.prototype.hasAttributeNS = function(namespaceURI, localName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.setIdAttribute = function(name3, isId) {
          if (this.attribs.hasOwnProperty(name3)) {
            return this.attribs[name3].isId;
          } else {
            return isId;
          }
        };
        XMLElement2.prototype.setIdAttributeNS = function(namespaceURI, localName, isId) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.setIdAttributeNode = function(idAttr, isId) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.getElementsByTagName = function(tagname) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.getElementsByClassName = function(classNames) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLElement2.prototype.isEqualNode = function(node) {
          var i2, j2, ref1;
          if (!XMLElement2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
            return false;
          }
          if (node.namespaceURI !== this.namespaceURI) {
            return false;
          }
          if (node.prefix !== this.prefix) {
            return false;
          }
          if (node.localName !== this.localName) {
            return false;
          }
          if (node.attribs.length !== this.attribs.length) {
            return false;
          }
          for (i2 = j2 = 0, ref1 = this.attribs.length - 1; 0 <= ref1 ? j2 <= ref1 : j2 >= ref1; i2 = 0 <= ref1 ? ++j2 : --j2) {
            if (!this.attribs[i2].isEqualNode(node.attribs[i2])) {
              return false;
            }
          }
          return true;
        };
        return XMLElement2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLCharacterData.js
var require_XMLCharacterData = __commonJS({
  "node_modules/xmlbuilder/lib/XMLCharacterData.js"(exports, module) {
    (function() {
      var XMLCharacterData, XMLNode, extend = /* @__PURE__ */ __name(function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        __name(ctor, "ctor");
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, "extend"), hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      module.exports = XMLCharacterData = function(superClass) {
        extend(XMLCharacterData2, superClass);
        function XMLCharacterData2(parent) {
          XMLCharacterData2.__super__.constructor.call(this, parent);
          this.value = "";
        }
        __name(XMLCharacterData2, "XMLCharacterData");
        Object.defineProperty(XMLCharacterData2.prototype, "data", {
          get: /* @__PURE__ */ __name(function() {
            return this.value;
          }, "get"),
          set: /* @__PURE__ */ __name(function(value) {
            return this.value = value || "";
          }, "set")
        });
        Object.defineProperty(XMLCharacterData2.prototype, "length", {
          get: /* @__PURE__ */ __name(function() {
            return this.value.length;
          }, "get")
        });
        Object.defineProperty(XMLCharacterData2.prototype, "textContent", {
          get: /* @__PURE__ */ __name(function() {
            return this.value;
          }, "get"),
          set: /* @__PURE__ */ __name(function(value) {
            return this.value = value || "";
          }, "set")
        });
        XMLCharacterData2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLCharacterData2.prototype.substringData = function(offset, count) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLCharacterData2.prototype.appendData = function(arg) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLCharacterData2.prototype.insertData = function(offset, arg) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLCharacterData2.prototype.deleteData = function(offset, count) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLCharacterData2.prototype.replaceData = function(offset, count, arg) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLCharacterData2.prototype.isEqualNode = function(node) {
          if (!XMLCharacterData2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
            return false;
          }
          if (node.data !== this.data) {
            return false;
          }
          return true;
        };
        return XMLCharacterData2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLCData.js
var require_XMLCData = __commonJS({
  "node_modules/xmlbuilder/lib/XMLCData.js"(exports, module) {
    (function() {
      var NodeType, XMLCData, XMLCharacterData, extend = /* @__PURE__ */ __name(function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        __name(ctor, "ctor");
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, "extend"), hasProp = {}.hasOwnProperty;
      NodeType = require_NodeType();
      XMLCharacterData = require_XMLCharacterData();
      module.exports = XMLCData = function(superClass) {
        extend(XMLCData2, superClass);
        function XMLCData2(parent, text) {
          XMLCData2.__super__.constructor.call(this, parent);
          if (text == null) {
            throw new Error("Missing CDATA text. " + this.debugInfo());
          }
          this.name = "#cdata-section";
          this.type = NodeType.CData;
          this.value = this.stringify.cdata(text);
        }
        __name(XMLCData2, "XMLCData");
        XMLCData2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLCData2.prototype.toString = function(options) {
          return this.options.writer.cdata(this, this.options.writer.filterOptions(options));
        };
        return XMLCData2;
      }(XMLCharacterData);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLComment.js
var require_XMLComment = __commonJS({
  "node_modules/xmlbuilder/lib/XMLComment.js"(exports, module) {
    (function() {
      var NodeType, XMLCharacterData, XMLComment, extend = /* @__PURE__ */ __name(function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        __name(ctor, "ctor");
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, "extend"), hasProp = {}.hasOwnProperty;
      NodeType = require_NodeType();
      XMLCharacterData = require_XMLCharacterData();
      module.exports = XMLComment = function(superClass) {
        extend(XMLComment2, superClass);
        function XMLComment2(parent, text) {
          XMLComment2.__super__.constructor.call(this, parent);
          if (text == null) {
            throw new Error("Missing comment text. " + this.debugInfo());
          }
          this.name = "#comment";
          this.type = NodeType.Comment;
          this.value = this.stringify.comment(text);
        }
        __name(XMLComment2, "XMLComment");
        XMLComment2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLComment2.prototype.toString = function(options) {
          return this.options.writer.comment(this, this.options.writer.filterOptions(options));
        };
        return XMLComment2;
      }(XMLCharacterData);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDeclaration.js
var require_XMLDeclaration = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDeclaration.js"(exports, module) {
    (function() {
      var NodeType, XMLDeclaration, XMLNode, isObject, extend = /* @__PURE__ */ __name(function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        __name(ctor, "ctor");
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, "extend"), hasProp = {}.hasOwnProperty;
      isObject = require_Utility().isObject;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      module.exports = XMLDeclaration = function(superClass) {
        extend(XMLDeclaration2, superClass);
        function XMLDeclaration2(parent, version, encoding, standalone) {
          var ref;
          XMLDeclaration2.__super__.constructor.call(this, parent);
          if (isObject(version)) {
            ref = version, version = ref.version, encoding = ref.encoding, standalone = ref.standalone;
          }
          if (!version) {
            version = "1.0";
          }
          this.type = NodeType.Declaration;
          this.version = this.stringify.xmlVersion(version);
          if (encoding != null) {
            this.encoding = this.stringify.xmlEncoding(encoding);
          }
          if (standalone != null) {
            this.standalone = this.stringify.xmlStandalone(standalone);
          }
        }
        __name(XMLDeclaration2, "XMLDeclaration");
        XMLDeclaration2.prototype.toString = function(options) {
          return this.options.writer.declaration(this, this.options.writer.filterOptions(options));
        };
        return XMLDeclaration2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDTDAttList.js
var require_XMLDTDAttList = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDTDAttList.js"(exports, module) {
    (function() {
      var NodeType, XMLDTDAttList, XMLNode, extend = /* @__PURE__ */ __name(function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        __name(ctor, "ctor");
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, "extend"), hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      module.exports = XMLDTDAttList = function(superClass) {
        extend(XMLDTDAttList2, superClass);
        function XMLDTDAttList2(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {
          XMLDTDAttList2.__super__.constructor.call(this, parent);
          if (elementName == null) {
            throw new Error("Missing DTD element name. " + this.debugInfo());
          }
          if (attributeName == null) {
            throw new Error("Missing DTD attribute name. " + this.debugInfo(elementName));
          }
          if (!attributeType) {
            throw new Error("Missing DTD attribute type. " + this.debugInfo(elementName));
          }
          if (!defaultValueType) {
            throw new Error("Missing DTD attribute default. " + this.debugInfo(elementName));
          }
          if (defaultValueType.indexOf("#") !== 0) {
            defaultValueType = "#" + defaultValueType;
          }
          if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {
            throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT. " + this.debugInfo(elementName));
          }
          if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {
            throw new Error("Default value only applies to #FIXED or #DEFAULT. " + this.debugInfo(elementName));
          }
          this.elementName = this.stringify.name(elementName);
          this.type = NodeType.AttributeDeclaration;
          this.attributeName = this.stringify.name(attributeName);
          this.attributeType = this.stringify.dtdAttType(attributeType);
          if (defaultValue) {
            this.defaultValue = this.stringify.dtdAttDefault(defaultValue);
          }
          this.defaultValueType = defaultValueType;
        }
        __name(XMLDTDAttList2, "XMLDTDAttList");
        XMLDTDAttList2.prototype.toString = function(options) {
          return this.options.writer.dtdAttList(this, this.options.writer.filterOptions(options));
        };
        return XMLDTDAttList2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDTDEntity.js
var require_XMLDTDEntity = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDTDEntity.js"(exports, module) {
    (function() {
      var NodeType, XMLDTDEntity, XMLNode, isObject, extend = /* @__PURE__ */ __name(function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        __name(ctor, "ctor");
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, "extend"), hasProp = {}.hasOwnProperty;
      isObject = require_Utility().isObject;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      module.exports = XMLDTDEntity = function(superClass) {
        extend(XMLDTDEntity2, superClass);
        function XMLDTDEntity2(parent, pe, name3, value) {
          XMLDTDEntity2.__super__.constructor.call(this, parent);
          if (name3 == null) {
            throw new Error("Missing DTD entity name. " + this.debugInfo(name3));
          }
          if (value == null) {
            throw new Error("Missing DTD entity value. " + this.debugInfo(name3));
          }
          this.pe = !!pe;
          this.name = this.stringify.name(name3);
          this.type = NodeType.EntityDeclaration;
          if (!isObject(value)) {
            this.value = this.stringify.dtdEntityValue(value);
            this.internal = true;
          } else {
            if (!value.pubID && !value.sysID) {
              throw new Error("Public and/or system identifiers are required for an external entity. " + this.debugInfo(name3));
            }
            if (value.pubID && !value.sysID) {
              throw new Error("System identifier is required for a public external entity. " + this.debugInfo(name3));
            }
            this.internal = false;
            if (value.pubID != null) {
              this.pubID = this.stringify.dtdPubID(value.pubID);
            }
            if (value.sysID != null) {
              this.sysID = this.stringify.dtdSysID(value.sysID);
            }
            if (value.nData != null) {
              this.nData = this.stringify.dtdNData(value.nData);
            }
            if (this.pe && this.nData) {
              throw new Error("Notation declaration is not allowed in a parameter entity. " + this.debugInfo(name3));
            }
          }
        }
        __name(XMLDTDEntity2, "XMLDTDEntity");
        Object.defineProperty(XMLDTDEntity2.prototype, "publicId", {
          get: /* @__PURE__ */ __name(function() {
            return this.pubID;
          }, "get")
        });
        Object.defineProperty(XMLDTDEntity2.prototype, "systemId", {
          get: /* @__PURE__ */ __name(function() {
            return this.sysID;
          }, "get")
        });
        Object.defineProperty(XMLDTDEntity2.prototype, "notationName", {
          get: /* @__PURE__ */ __name(function() {
            return this.nData || null;
          }, "get")
        });
        Object.defineProperty(XMLDTDEntity2.prototype, "inputEncoding", {
          get: /* @__PURE__ */ __name(function() {
            return null;
          }, "get")
        });
        Object.defineProperty(XMLDTDEntity2.prototype, "xmlEncoding", {
          get: /* @__PURE__ */ __name(function() {
            return null;
          }, "get")
        });
        Object.defineProperty(XMLDTDEntity2.prototype, "xmlVersion", {
          get: /* @__PURE__ */ __name(function() {
            return null;
          }, "get")
        });
        XMLDTDEntity2.prototype.toString = function(options) {
          return this.options.writer.dtdEntity(this, this.options.writer.filterOptions(options));
        };
        return XMLDTDEntity2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDTDElement.js
var require_XMLDTDElement = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDTDElement.js"(exports, module) {
    (function() {
      var NodeType, XMLDTDElement, XMLNode, extend = /* @__PURE__ */ __name(function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        __name(ctor, "ctor");
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, "extend"), hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      module.exports = XMLDTDElement = function(superClass) {
        extend(XMLDTDElement2, superClass);
        function XMLDTDElement2(parent, name3, value) {
          XMLDTDElement2.__super__.constructor.call(this, parent);
          if (name3 == null) {
            throw new Error("Missing DTD element name. " + this.debugInfo());
          }
          if (!value) {
            value = "(#PCDATA)";
          }
          if (Array.isArray(value)) {
            value = "(" + value.join(",") + ")";
          }
          this.name = this.stringify.name(name3);
          this.type = NodeType.ElementDeclaration;
          this.value = this.stringify.dtdElementValue(value);
        }
        __name(XMLDTDElement2, "XMLDTDElement");
        XMLDTDElement2.prototype.toString = function(options) {
          return this.options.writer.dtdElement(this, this.options.writer.filterOptions(options));
        };
        return XMLDTDElement2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDTDNotation.js
var require_XMLDTDNotation = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDTDNotation.js"(exports, module) {
    (function() {
      var NodeType, XMLDTDNotation, XMLNode, extend = /* @__PURE__ */ __name(function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        __name(ctor, "ctor");
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, "extend"), hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      module.exports = XMLDTDNotation = function(superClass) {
        extend(XMLDTDNotation2, superClass);
        function XMLDTDNotation2(parent, name3, value) {
          XMLDTDNotation2.__super__.constructor.call(this, parent);
          if (name3 == null) {
            throw new Error("Missing DTD notation name. " + this.debugInfo(name3));
          }
          if (!value.pubID && !value.sysID) {
            throw new Error("Public or system identifiers are required for an external entity. " + this.debugInfo(name3));
          }
          this.name = this.stringify.name(name3);
          this.type = NodeType.NotationDeclaration;
          if (value.pubID != null) {
            this.pubID = this.stringify.dtdPubID(value.pubID);
          }
          if (value.sysID != null) {
            this.sysID = this.stringify.dtdSysID(value.sysID);
          }
        }
        __name(XMLDTDNotation2, "XMLDTDNotation");
        Object.defineProperty(XMLDTDNotation2.prototype, "publicId", {
          get: /* @__PURE__ */ __name(function() {
            return this.pubID;
          }, "get")
        });
        Object.defineProperty(XMLDTDNotation2.prototype, "systemId", {
          get: /* @__PURE__ */ __name(function() {
            return this.sysID;
          }, "get")
        });
        XMLDTDNotation2.prototype.toString = function(options) {
          return this.options.writer.dtdNotation(this, this.options.writer.filterOptions(options));
        };
        return XMLDTDNotation2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDocType.js
var require_XMLDocType = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDocType.js"(exports, module) {
    (function() {
      var NodeType, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDocType, XMLNamedNodeMap, XMLNode, isObject, extend = /* @__PURE__ */ __name(function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        __name(ctor, "ctor");
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, "extend"), hasProp = {}.hasOwnProperty;
      isObject = require_Utility().isObject;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      XMLDTDAttList = require_XMLDTDAttList();
      XMLDTDEntity = require_XMLDTDEntity();
      XMLDTDElement = require_XMLDTDElement();
      XMLDTDNotation = require_XMLDTDNotation();
      XMLNamedNodeMap = require_XMLNamedNodeMap();
      module.exports = XMLDocType = function(superClass) {
        extend(XMLDocType2, superClass);
        function XMLDocType2(parent, pubID, sysID) {
          var child, i2, len, ref, ref1, ref2;
          XMLDocType2.__super__.constructor.call(this, parent);
          this.type = NodeType.DocType;
          if (parent.children) {
            ref = parent.children;
            for (i2 = 0, len = ref.length; i2 < len; i2++) {
              child = ref[i2];
              if (child.type === NodeType.Element) {
                this.name = child.name;
                break;
              }
            }
          }
          this.documentObject = parent;
          if (isObject(pubID)) {
            ref1 = pubID, pubID = ref1.pubID, sysID = ref1.sysID;
          }
          if (sysID == null) {
            ref2 = [pubID, sysID], sysID = ref2[0], pubID = ref2[1];
          }
          if (pubID != null) {
            this.pubID = this.stringify.dtdPubID(pubID);
          }
          if (sysID != null) {
            this.sysID = this.stringify.dtdSysID(sysID);
          }
        }
        __name(XMLDocType2, "XMLDocType");
        Object.defineProperty(XMLDocType2.prototype, "entities", {
          get: /* @__PURE__ */ __name(function() {
            var child, i2, len, nodes, ref;
            nodes = {};
            ref = this.children;
            for (i2 = 0, len = ref.length; i2 < len; i2++) {
              child = ref[i2];
              if (child.type === NodeType.EntityDeclaration && !child.pe) {
                nodes[child.name] = child;
              }
            }
            return new XMLNamedNodeMap(nodes);
          }, "get")
        });
        Object.defineProperty(XMLDocType2.prototype, "notations", {
          get: /* @__PURE__ */ __name(function() {
            var child, i2, len, nodes, ref;
            nodes = {};
            ref = this.children;
            for (i2 = 0, len = ref.length; i2 < len; i2++) {
              child = ref[i2];
              if (child.type === NodeType.NotationDeclaration) {
                nodes[child.name] = child;
              }
            }
            return new XMLNamedNodeMap(nodes);
          }, "get")
        });
        Object.defineProperty(XMLDocType2.prototype, "publicId", {
          get: /* @__PURE__ */ __name(function() {
            return this.pubID;
          }, "get")
        });
        Object.defineProperty(XMLDocType2.prototype, "systemId", {
          get: /* @__PURE__ */ __name(function() {
            return this.sysID;
          }, "get")
        });
        Object.defineProperty(XMLDocType2.prototype, "internalSubset", {
          get: /* @__PURE__ */ __name(function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }, "get")
        });
        XMLDocType2.prototype.element = function(name3, value) {
          var child;
          child = new XMLDTDElement(this, name3, value);
          this.children.push(child);
          return this;
        };
        XMLDocType2.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
          var child;
          child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
          this.children.push(child);
          return this;
        };
        XMLDocType2.prototype.entity = function(name3, value) {
          var child;
          child = new XMLDTDEntity(this, false, name3, value);
          this.children.push(child);
          return this;
        };
        XMLDocType2.prototype.pEntity = function(name3, value) {
          var child;
          child = new XMLDTDEntity(this, true, name3, value);
          this.children.push(child);
          return this;
        };
        XMLDocType2.prototype.notation = function(name3, value) {
          var child;
          child = new XMLDTDNotation(this, name3, value);
          this.children.push(child);
          return this;
        };
        XMLDocType2.prototype.toString = function(options) {
          return this.options.writer.docType(this, this.options.writer.filterOptions(options));
        };
        XMLDocType2.prototype.ele = function(name3, value) {
          return this.element(name3, value);
        };
        XMLDocType2.prototype.att = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
          return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);
        };
        XMLDocType2.prototype.ent = function(name3, value) {
          return this.entity(name3, value);
        };
        XMLDocType2.prototype.pent = function(name3, value) {
          return this.pEntity(name3, value);
        };
        XMLDocType2.prototype.not = function(name3, value) {
          return this.notation(name3, value);
        };
        XMLDocType2.prototype.up = function() {
          return this.root() || this.documentObject;
        };
        XMLDocType2.prototype.isEqualNode = function(node) {
          if (!XMLDocType2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
            return false;
          }
          if (node.name !== this.name) {
            return false;
          }
          if (node.publicId !== this.publicId) {
            return false;
          }
          if (node.systemId !== this.systemId) {
            return false;
          }
          return true;
        };
        return XMLDocType2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLRaw.js
var require_XMLRaw = __commonJS({
  "node_modules/xmlbuilder/lib/XMLRaw.js"(exports, module) {
    (function() {
      var NodeType, XMLNode, XMLRaw, extend = /* @__PURE__ */ __name(function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        __name(ctor, "ctor");
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, "extend"), hasProp = {}.hasOwnProperty;
      NodeType = require_NodeType();
      XMLNode = require_XMLNode();
      module.exports = XMLRaw = function(superClass) {
        extend(XMLRaw2, superClass);
        function XMLRaw2(parent, text) {
          XMLRaw2.__super__.constructor.call(this, parent);
          if (text == null) {
            throw new Error("Missing raw text. " + this.debugInfo());
          }
          this.type = NodeType.Raw;
          this.value = this.stringify.raw(text);
        }
        __name(XMLRaw2, "XMLRaw");
        XMLRaw2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLRaw2.prototype.toString = function(options) {
          return this.options.writer.raw(this, this.options.writer.filterOptions(options));
        };
        return XMLRaw2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLText.js
var require_XMLText = __commonJS({
  "node_modules/xmlbuilder/lib/XMLText.js"(exports, module) {
    (function() {
      var NodeType, XMLCharacterData, XMLText, extend = /* @__PURE__ */ __name(function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        __name(ctor, "ctor");
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, "extend"), hasProp = {}.hasOwnProperty;
      NodeType = require_NodeType();
      XMLCharacterData = require_XMLCharacterData();
      module.exports = XMLText = function(superClass) {
        extend(XMLText2, superClass);
        function XMLText2(parent, text) {
          XMLText2.__super__.constructor.call(this, parent);
          if (text == null) {
            throw new Error("Missing element text. " + this.debugInfo());
          }
          this.name = "#text";
          this.type = NodeType.Text;
          this.value = this.stringify.text(text);
        }
        __name(XMLText2, "XMLText");
        Object.defineProperty(XMLText2.prototype, "isElementContentWhitespace", {
          get: /* @__PURE__ */ __name(function() {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }, "get")
        });
        Object.defineProperty(XMLText2.prototype, "wholeText", {
          get: /* @__PURE__ */ __name(function() {
            var next, prev, str;
            str = "";
            prev = this.previousSibling;
            while (prev) {
              str = prev.data + str;
              prev = prev.previousSibling;
            }
            str += this.data;
            next = this.nextSibling;
            while (next) {
              str = str + next.data;
              next = next.nextSibling;
            }
            return str;
          }, "get")
        });
        XMLText2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLText2.prototype.toString = function(options) {
          return this.options.writer.text(this, this.options.writer.filterOptions(options));
        };
        XMLText2.prototype.splitText = function(offset) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLText2.prototype.replaceWholeText = function(content) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        return XMLText2;
      }(XMLCharacterData);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLProcessingInstruction.js
var require_XMLProcessingInstruction = __commonJS({
  "node_modules/xmlbuilder/lib/XMLProcessingInstruction.js"(exports, module) {
    (function() {
      var NodeType, XMLCharacterData, XMLProcessingInstruction, extend = /* @__PURE__ */ __name(function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        __name(ctor, "ctor");
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, "extend"), hasProp = {}.hasOwnProperty;
      NodeType = require_NodeType();
      XMLCharacterData = require_XMLCharacterData();
      module.exports = XMLProcessingInstruction = function(superClass) {
        extend(XMLProcessingInstruction2, superClass);
        function XMLProcessingInstruction2(parent, target, value) {
          XMLProcessingInstruction2.__super__.constructor.call(this, parent);
          if (target == null) {
            throw new Error("Missing instruction target. " + this.debugInfo());
          }
          this.type = NodeType.ProcessingInstruction;
          this.target = this.stringify.insTarget(target);
          this.name = this.target;
          if (value) {
            this.value = this.stringify.insValue(value);
          }
        }
        __name(XMLProcessingInstruction2, "XMLProcessingInstruction");
        XMLProcessingInstruction2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLProcessingInstruction2.prototype.toString = function(options) {
          return this.options.writer.processingInstruction(this, this.options.writer.filterOptions(options));
        };
        XMLProcessingInstruction2.prototype.isEqualNode = function(node) {
          if (!XMLProcessingInstruction2.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {
            return false;
          }
          if (node.target !== this.target) {
            return false;
          }
          return true;
        };
        return XMLProcessingInstruction2;
      }(XMLCharacterData);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDummy.js
var require_XMLDummy = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDummy.js"(exports, module) {
    (function() {
      var NodeType, XMLDummy, XMLNode, extend = /* @__PURE__ */ __name(function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        __name(ctor, "ctor");
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, "extend"), hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      module.exports = XMLDummy = function(superClass) {
        extend(XMLDummy2, superClass);
        function XMLDummy2(parent) {
          XMLDummy2.__super__.constructor.call(this, parent);
          this.type = NodeType.Dummy;
        }
        __name(XMLDummy2, "XMLDummy");
        XMLDummy2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLDummy2.prototype.toString = function(options) {
          return "";
        };
        return XMLDummy2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLNodeList.js
var require_XMLNodeList = __commonJS({
  "node_modules/xmlbuilder/lib/XMLNodeList.js"(exports, module) {
    (function() {
      var XMLNodeList;
      module.exports = XMLNodeList = function() {
        function XMLNodeList2(nodes) {
          this.nodes = nodes;
        }
        __name(XMLNodeList2, "XMLNodeList");
        Object.defineProperty(XMLNodeList2.prototype, "length", {
          get: /* @__PURE__ */ __name(function() {
            return this.nodes.length || 0;
          }, "get")
        });
        XMLNodeList2.prototype.clone = function() {
          return this.nodes = null;
        };
        XMLNodeList2.prototype.item = function(index) {
          return this.nodes[index] || null;
        };
        return XMLNodeList2;
      }();
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/DocumentPosition.js
var require_DocumentPosition = __commonJS({
  "node_modules/xmlbuilder/lib/DocumentPosition.js"(exports, module) {
    (function() {
      module.exports = {
        Disconnected: 1,
        Preceding: 2,
        Following: 4,
        Contains: 8,
        ContainedBy: 16,
        ImplementationSpecific: 32
      };
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLNode.js
var require_XMLNode = __commonJS({
  "node_modules/xmlbuilder/lib/XMLNode.js"(exports, module) {
    (function() {
      var DocumentPosition, NodeType, XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLNamedNodeMap, XMLNode, XMLNodeList, XMLProcessingInstruction, XMLRaw, XMLText, getValue, isEmpty, isFunction, isObject, ref1, hasProp = {}.hasOwnProperty;
      ref1 = require_Utility(), isObject = ref1.isObject, isFunction = ref1.isFunction, isEmpty = ref1.isEmpty, getValue = ref1.getValue;
      XMLElement = null;
      XMLCData = null;
      XMLComment = null;
      XMLDeclaration = null;
      XMLDocType = null;
      XMLRaw = null;
      XMLText = null;
      XMLProcessingInstruction = null;
      XMLDummy = null;
      NodeType = null;
      XMLNodeList = null;
      XMLNamedNodeMap = null;
      DocumentPosition = null;
      module.exports = XMLNode = function() {
        function XMLNode2(parent1) {
          this.parent = parent1;
          if (this.parent) {
            this.options = this.parent.options;
            this.stringify = this.parent.stringify;
          }
          this.value = null;
          this.children = [];
          this.baseURI = null;
          if (!XMLElement) {
            XMLElement = require_XMLElement();
            XMLCData = require_XMLCData();
            XMLComment = require_XMLComment();
            XMLDeclaration = require_XMLDeclaration();
            XMLDocType = require_XMLDocType();
            XMLRaw = require_XMLRaw();
            XMLText = require_XMLText();
            XMLProcessingInstruction = require_XMLProcessingInstruction();
            XMLDummy = require_XMLDummy();
            NodeType = require_NodeType();
            XMLNodeList = require_XMLNodeList();
            XMLNamedNodeMap = require_XMLNamedNodeMap();
            DocumentPosition = require_DocumentPosition();
          }
        }
        __name(XMLNode2, "XMLNode");
        Object.defineProperty(XMLNode2.prototype, "nodeName", {
          get: /* @__PURE__ */ __name(function() {
            return this.name;
          }, "get")
        });
        Object.defineProperty(XMLNode2.prototype, "nodeType", {
          get: /* @__PURE__ */ __name(function() {
            return this.type;
          }, "get")
        });
        Object.defineProperty(XMLNode2.prototype, "nodeValue", {
          get: /* @__PURE__ */ __name(function() {
            return this.value;
          }, "get")
        });
        Object.defineProperty(XMLNode2.prototype, "parentNode", {
          get: /* @__PURE__ */ __name(function() {
            return this.parent;
          }, "get")
        });
        Object.defineProperty(XMLNode2.prototype, "childNodes", {
          get: /* @__PURE__ */ __name(function() {
            if (!this.childNodeList || !this.childNodeList.nodes) {
              this.childNodeList = new XMLNodeList(this.children);
            }
            return this.childNodeList;
          }, "get")
        });
        Object.defineProperty(XMLNode2.prototype, "firstChild", {
          get: /* @__PURE__ */ __name(function() {
            return this.children[0] || null;
          }, "get")
        });
        Object.defineProperty(XMLNode2.prototype, "lastChild", {
          get: /* @__PURE__ */ __name(function() {
            return this.children[this.children.length - 1] || null;
          }, "get")
        });
        Object.defineProperty(XMLNode2.prototype, "previousSibling", {
          get: /* @__PURE__ */ __name(function() {
            var i2;
            i2 = this.parent.children.indexOf(this);
            return this.parent.children[i2 - 1] || null;
          }, "get")
        });
        Object.defineProperty(XMLNode2.prototype, "nextSibling", {
          get: /* @__PURE__ */ __name(function() {
            var i2;
            i2 = this.parent.children.indexOf(this);
            return this.parent.children[i2 + 1] || null;
          }, "get")
        });
        Object.defineProperty(XMLNode2.prototype, "ownerDocument", {
          get: /* @__PURE__ */ __name(function() {
            return this.document() || null;
          }, "get")
        });
        Object.defineProperty(XMLNode2.prototype, "textContent", {
          get: /* @__PURE__ */ __name(function() {
            var child, j2, len, ref2, str;
            if (this.nodeType === NodeType.Element || this.nodeType === NodeType.DocumentFragment) {
              str = "";
              ref2 = this.children;
              for (j2 = 0, len = ref2.length; j2 < len; j2++) {
                child = ref2[j2];
                if (child.textContent) {
                  str += child.textContent;
                }
              }
              return str;
            } else {
              return null;
            }
          }, "get"),
          set: /* @__PURE__ */ __name(function(value) {
            throw new Error("This DOM method is not implemented." + this.debugInfo());
          }, "set")
        });
        XMLNode2.prototype.setParent = function(parent) {
          var child, j2, len, ref2, results;
          this.parent = parent;
          if (parent) {
            this.options = parent.options;
            this.stringify = parent.stringify;
          }
          ref2 = this.children;
          results = [];
          for (j2 = 0, len = ref2.length; j2 < len; j2++) {
            child = ref2[j2];
            results.push(child.setParent(this));
          }
          return results;
        };
        XMLNode2.prototype.element = function(name3, attributes, text) {
          var childNode, item, j2, k2, key, lastChild, len, len1, ref2, ref3, val;
          lastChild = null;
          if (attributes === null && text == null) {
            ref2 = [{}, null], attributes = ref2[0], text = ref2[1];
          }
          if (attributes == null) {
            attributes = {};
          }
          attributes = getValue(attributes);
          if (!isObject(attributes)) {
            ref3 = [attributes, text], text = ref3[0], attributes = ref3[1];
          }
          if (name3 != null) {
            name3 = getValue(name3);
          }
          if (Array.isArray(name3)) {
            for (j2 = 0, len = name3.length; j2 < len; j2++) {
              item = name3[j2];
              lastChild = this.element(item);
            }
          } else if (isFunction(name3)) {
            lastChild = this.element(name3.apply());
          } else if (isObject(name3)) {
            for (key in name3) {
              if (!hasProp.call(name3, key)) continue;
              val = name3[key];
              if (isFunction(val)) {
                val = val.apply();
              }
              if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {
                lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);
              } else if (!this.options.separateArrayItems && Array.isArray(val) && isEmpty(val)) {
                lastChild = this.dummy();
              } else if (isObject(val) && isEmpty(val)) {
                lastChild = this.element(key);
              } else if (!this.options.keepNullNodes && val == null) {
                lastChild = this.dummy();
              } else if (!this.options.separateArrayItems && Array.isArray(val)) {
                for (k2 = 0, len1 = val.length; k2 < len1; k2++) {
                  item = val[k2];
                  childNode = {};
                  childNode[key] = item;
                  lastChild = this.element(childNode);
                }
              } else if (isObject(val)) {
                if (!this.options.ignoreDecorators && this.stringify.convertTextKey && key.indexOf(this.stringify.convertTextKey) === 0) {
                  lastChild = this.element(val);
                } else {
                  lastChild = this.element(key);
                  lastChild.element(val);
                }
              } else {
                lastChild = this.element(key, val);
              }
            }
          } else if (!this.options.keepNullNodes && text === null) {
            lastChild = this.dummy();
          } else {
            if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name3.indexOf(this.stringify.convertTextKey) === 0) {
              lastChild = this.text(text);
            } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name3.indexOf(this.stringify.convertCDataKey) === 0) {
              lastChild = this.cdata(text);
            } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name3.indexOf(this.stringify.convertCommentKey) === 0) {
              lastChild = this.comment(text);
            } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name3.indexOf(this.stringify.convertRawKey) === 0) {
              lastChild = this.raw(text);
            } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && name3.indexOf(this.stringify.convertPIKey) === 0) {
              lastChild = this.instruction(name3.substr(this.stringify.convertPIKey.length), text);
            } else {
              lastChild = this.node(name3, attributes, text);
            }
          }
          if (lastChild == null) {
            throw new Error("Could not create any elements with: " + name3 + ". " + this.debugInfo());
          }
          return lastChild;
        };
        XMLNode2.prototype.insertBefore = function(name3, attributes, text) {
          var child, i2, newChild, refChild, removed;
          if (name3 != null ? name3.type : void 0) {
            newChild = name3;
            refChild = attributes;
            newChild.setParent(this);
            if (refChild) {
              i2 = children.indexOf(refChild);
              removed = children.splice(i2);
              children.push(newChild);
              Array.prototype.push.apply(children, removed);
            } else {
              children.push(newChild);
            }
            return newChild;
          } else {
            if (this.isRoot) {
              throw new Error("Cannot insert elements at root level. " + this.debugInfo(name3));
            }
            i2 = this.parent.children.indexOf(this);
            removed = this.parent.children.splice(i2);
            child = this.parent.element(name3, attributes, text);
            Array.prototype.push.apply(this.parent.children, removed);
            return child;
          }
        };
        XMLNode2.prototype.insertAfter = function(name3, attributes, text) {
          var child, i2, removed;
          if (this.isRoot) {
            throw new Error("Cannot insert elements at root level. " + this.debugInfo(name3));
          }
          i2 = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i2 + 1);
          child = this.parent.element(name3, attributes, text);
          Array.prototype.push.apply(this.parent.children, removed);
          return child;
        };
        XMLNode2.prototype.remove = function() {
          var i2, ref2;
          if (this.isRoot) {
            throw new Error("Cannot remove the root element. " + this.debugInfo());
          }
          i2 = this.parent.children.indexOf(this);
          [].splice.apply(this.parent.children, [i2, i2 - i2 + 1].concat(ref2 = [])), ref2;
          return this.parent;
        };
        XMLNode2.prototype.node = function(name3, attributes, text) {
          var child, ref2;
          if (name3 != null) {
            name3 = getValue(name3);
          }
          attributes || (attributes = {});
          attributes = getValue(attributes);
          if (!isObject(attributes)) {
            ref2 = [attributes, text], text = ref2[0], attributes = ref2[1];
          }
          child = new XMLElement(this, name3, attributes);
          if (text != null) {
            child.text(text);
          }
          this.children.push(child);
          return child;
        };
        XMLNode2.prototype.text = function(value) {
          var child;
          if (isObject(value)) {
            this.element(value);
          }
          child = new XMLText(this, value);
          this.children.push(child);
          return this;
        };
        XMLNode2.prototype.cdata = function(value) {
          var child;
          child = new XMLCData(this, value);
          this.children.push(child);
          return this;
        };
        XMLNode2.prototype.comment = function(value) {
          var child;
          child = new XMLComment(this, value);
          this.children.push(child);
          return this;
        };
        XMLNode2.prototype.commentBefore = function(value) {
          var child, i2, removed;
          i2 = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i2);
          child = this.parent.comment(value);
          Array.prototype.push.apply(this.parent.children, removed);
          return this;
        };
        XMLNode2.prototype.commentAfter = function(value) {
          var child, i2, removed;
          i2 = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i2 + 1);
          child = this.parent.comment(value);
          Array.prototype.push.apply(this.parent.children, removed);
          return this;
        };
        XMLNode2.prototype.raw = function(value) {
          var child;
          child = new XMLRaw(this, value);
          this.children.push(child);
          return this;
        };
        XMLNode2.prototype.dummy = function() {
          var child;
          child = new XMLDummy(this);
          return child;
        };
        XMLNode2.prototype.instruction = function(target, value) {
          var insTarget, insValue, instruction, j2, len;
          if (target != null) {
            target = getValue(target);
          }
          if (value != null) {
            value = getValue(value);
          }
          if (Array.isArray(target)) {
            for (j2 = 0, len = target.length; j2 < len; j2++) {
              insTarget = target[j2];
              this.instruction(insTarget);
            }
          } else if (isObject(target)) {
            for (insTarget in target) {
              if (!hasProp.call(target, insTarget)) continue;
              insValue = target[insTarget];
              this.instruction(insTarget, insValue);
            }
          } else {
            if (isFunction(value)) {
              value = value.apply();
            }
            instruction = new XMLProcessingInstruction(this, target, value);
            this.children.push(instruction);
          }
          return this;
        };
        XMLNode2.prototype.instructionBefore = function(target, value) {
          var child, i2, removed;
          i2 = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i2);
          child = this.parent.instruction(target, value);
          Array.prototype.push.apply(this.parent.children, removed);
          return this;
        };
        XMLNode2.prototype.instructionAfter = function(target, value) {
          var child, i2, removed;
          i2 = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i2 + 1);
          child = this.parent.instruction(target, value);
          Array.prototype.push.apply(this.parent.children, removed);
          return this;
        };
        XMLNode2.prototype.declaration = function(version, encoding, standalone) {
          var doc, xmldec;
          doc = this.document();
          xmldec = new XMLDeclaration(doc, version, encoding, standalone);
          if (doc.children.length === 0) {
            doc.children.unshift(xmldec);
          } else if (doc.children[0].type === NodeType.Declaration) {
            doc.children[0] = xmldec;
          } else {
            doc.children.unshift(xmldec);
          }
          return doc.root() || doc;
        };
        XMLNode2.prototype.dtd = function(pubID, sysID) {
          var child, doc, doctype, i2, j2, k2, len, len1, ref2, ref3;
          doc = this.document();
          doctype = new XMLDocType(doc, pubID, sysID);
          ref2 = doc.children;
          for (i2 = j2 = 0, len = ref2.length; j2 < len; i2 = ++j2) {
            child = ref2[i2];
            if (child.type === NodeType.DocType) {
              doc.children[i2] = doctype;
              return doctype;
            }
          }
          ref3 = doc.children;
          for (i2 = k2 = 0, len1 = ref3.length; k2 < len1; i2 = ++k2) {
            child = ref3[i2];
            if (child.isRoot) {
              doc.children.splice(i2, 0, doctype);
              return doctype;
            }
          }
          doc.children.push(doctype);
          return doctype;
        };
        XMLNode2.prototype.up = function() {
          if (this.isRoot) {
            throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
          }
          return this.parent;
        };
        XMLNode2.prototype.root = function() {
          var node;
          node = this;
          while (node) {
            if (node.type === NodeType.Document) {
              return node.rootObject;
            } else if (node.isRoot) {
              return node;
            } else {
              node = node.parent;
            }
          }
        };
        XMLNode2.prototype.document = function() {
          var node;
          node = this;
          while (node) {
            if (node.type === NodeType.Document) {
              return node;
            } else {
              node = node.parent;
            }
          }
        };
        XMLNode2.prototype.end = function(options) {
          return this.document().end(options);
        };
        XMLNode2.prototype.prev = function() {
          var i2;
          i2 = this.parent.children.indexOf(this);
          if (i2 < 1) {
            throw new Error("Already at the first node. " + this.debugInfo());
          }
          return this.parent.children[i2 - 1];
        };
        XMLNode2.prototype.next = function() {
          var i2;
          i2 = this.parent.children.indexOf(this);
          if (i2 === -1 || i2 === this.parent.children.length - 1) {
            throw new Error("Already at the last node. " + this.debugInfo());
          }
          return this.parent.children[i2 + 1];
        };
        XMLNode2.prototype.importDocument = function(doc) {
          var clonedRoot;
          clonedRoot = doc.root().clone();
          clonedRoot.parent = this;
          clonedRoot.isRoot = false;
          this.children.push(clonedRoot);
          return this;
        };
        XMLNode2.prototype.debugInfo = function(name3) {
          var ref2, ref3;
          name3 = name3 || this.name;
          if (name3 == null && !((ref2 = this.parent) != null ? ref2.name : void 0)) {
            return "";
          } else if (name3 == null) {
            return "parent: <" + this.parent.name + ">";
          } else if (!((ref3 = this.parent) != null ? ref3.name : void 0)) {
            return "node: <" + name3 + ">";
          } else {
            return "node: <" + name3 + ">, parent: <" + this.parent.name + ">";
          }
        };
        XMLNode2.prototype.ele = function(name3, attributes, text) {
          return this.element(name3, attributes, text);
        };
        XMLNode2.prototype.nod = function(name3, attributes, text) {
          return this.node(name3, attributes, text);
        };
        XMLNode2.prototype.txt = function(value) {
          return this.text(value);
        };
        XMLNode2.prototype.dat = function(value) {
          return this.cdata(value);
        };
        XMLNode2.prototype.com = function(value) {
          return this.comment(value);
        };
        XMLNode2.prototype.ins = function(target, value) {
          return this.instruction(target, value);
        };
        XMLNode2.prototype.doc = function() {
          return this.document();
        };
        XMLNode2.prototype.dec = function(version, encoding, standalone) {
          return this.declaration(version, encoding, standalone);
        };
        XMLNode2.prototype.e = function(name3, attributes, text) {
          return this.element(name3, attributes, text);
        };
        XMLNode2.prototype.n = function(name3, attributes, text) {
          return this.node(name3, attributes, text);
        };
        XMLNode2.prototype.t = function(value) {
          return this.text(value);
        };
        XMLNode2.prototype.d = function(value) {
          return this.cdata(value);
        };
        XMLNode2.prototype.c = function(value) {
          return this.comment(value);
        };
        XMLNode2.prototype.r = function(value) {
          return this.raw(value);
        };
        XMLNode2.prototype.i = function(target, value) {
          return this.instruction(target, value);
        };
        XMLNode2.prototype.u = function() {
          return this.up();
        };
        XMLNode2.prototype.importXMLBuilder = function(doc) {
          return this.importDocument(doc);
        };
        XMLNode2.prototype.replaceChild = function(newChild, oldChild) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.removeChild = function(oldChild) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.appendChild = function(newChild) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.hasChildNodes = function() {
          return this.children.length !== 0;
        };
        XMLNode2.prototype.cloneNode = function(deep) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.normalize = function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.isSupported = function(feature, version) {
          return true;
        };
        XMLNode2.prototype.hasAttributes = function() {
          return this.attribs.length !== 0;
        };
        XMLNode2.prototype.compareDocumentPosition = function(other) {
          var ref, res;
          ref = this;
          if (ref === other) {
            return 0;
          } else if (this.document() !== other.document()) {
            res = DocumentPosition.Disconnected | DocumentPosition.ImplementationSpecific;
            if (Math.random() < 0.5) {
              res |= DocumentPosition.Preceding;
            } else {
              res |= DocumentPosition.Following;
            }
            return res;
          } else if (ref.isAncestor(other)) {
            return DocumentPosition.Contains | DocumentPosition.Preceding;
          } else if (ref.isDescendant(other)) {
            return DocumentPosition.Contains | DocumentPosition.Following;
          } else if (ref.isPreceding(other)) {
            return DocumentPosition.Preceding;
          } else {
            return DocumentPosition.Following;
          }
        };
        XMLNode2.prototype.isSameNode = function(other) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.lookupPrefix = function(namespaceURI) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.isDefaultNamespace = function(namespaceURI) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.lookupNamespaceURI = function(prefix) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.isEqualNode = function(node) {
          var i2, j2, ref2;
          if (node.nodeType !== this.nodeType) {
            return false;
          }
          if (node.children.length !== this.children.length) {
            return false;
          }
          for (i2 = j2 = 0, ref2 = this.children.length - 1; 0 <= ref2 ? j2 <= ref2 : j2 >= ref2; i2 = 0 <= ref2 ? ++j2 : --j2) {
            if (!this.children[i2].isEqualNode(node.children[i2])) {
              return false;
            }
          }
          return true;
        };
        XMLNode2.prototype.getFeature = function(feature, version) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.setUserData = function(key, data, handler) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.getUserData = function(key) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLNode2.prototype.contains = function(other) {
          if (!other) {
            return false;
          }
          return other === this || this.isDescendant(other);
        };
        XMLNode2.prototype.isDescendant = function(node) {
          var child, isDescendantChild, j2, len, ref2;
          ref2 = this.children;
          for (j2 = 0, len = ref2.length; j2 < len; j2++) {
            child = ref2[j2];
            if (node === child) {
              return true;
            }
            isDescendantChild = child.isDescendant(node);
            if (isDescendantChild) {
              return true;
            }
          }
          return false;
        };
        XMLNode2.prototype.isAncestor = function(node) {
          return node.isDescendant(this);
        };
        XMLNode2.prototype.isPreceding = function(node) {
          var nodePos, thisPos;
          nodePos = this.treePosition(node);
          thisPos = this.treePosition(this);
          if (nodePos === -1 || thisPos === -1) {
            return false;
          } else {
            return nodePos < thisPos;
          }
        };
        XMLNode2.prototype.isFollowing = function(node) {
          var nodePos, thisPos;
          nodePos = this.treePosition(node);
          thisPos = this.treePosition(this);
          if (nodePos === -1 || thisPos === -1) {
            return false;
          } else {
            return nodePos > thisPos;
          }
        };
        XMLNode2.prototype.treePosition = function(node) {
          var found, pos;
          pos = 0;
          found = false;
          this.foreachTreeNode(this.document(), function(childNode) {
            pos++;
            if (!found && childNode === node) {
              return found = true;
            }
          });
          if (found) {
            return pos;
          } else {
            return -1;
          }
        };
        XMLNode2.prototype.foreachTreeNode = function(node, func) {
          var child, j2, len, ref2, res;
          node || (node = this.document());
          ref2 = node.children;
          for (j2 = 0, len = ref2.length; j2 < len; j2++) {
            child = ref2[j2];
            if (res = func(child)) {
              return res;
            } else {
              res = this.foreachTreeNode(child, func);
              if (res) {
                return res;
              }
            }
          }
        };
        return XMLNode2;
      }();
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLStringifier.js
var require_XMLStringifier = __commonJS({
  "node_modules/xmlbuilder/lib/XMLStringifier.js"(exports, module) {
    (function() {
      var XMLStringifier, bind = /* @__PURE__ */ __name(function(fn, me) {
        return function() {
          return fn.apply(me, arguments);
        };
      }, "bind"), hasProp = {}.hasOwnProperty;
      module.exports = XMLStringifier = function() {
        function XMLStringifier2(options) {
          this.assertLegalName = bind(this.assertLegalName, this);
          this.assertLegalChar = bind(this.assertLegalChar, this);
          var key, ref, value;
          options || (options = {});
          this.options = options;
          if (!this.options.version) {
            this.options.version = "1.0";
          }
          ref = options.stringify || {};
          for (key in ref) {
            if (!hasProp.call(ref, key)) continue;
            value = ref[key];
            this[key] = value;
          }
        }
        __name(XMLStringifier2, "XMLStringifier");
        XMLStringifier2.prototype.name = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalName("" + val || "");
        };
        XMLStringifier2.prototype.text = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar(this.textEscape("" + val || ""));
        };
        XMLStringifier2.prototype.cdata = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          val = "" + val || "";
          val = val.replace("]]>", "]]]]><![CDATA[>");
          return this.assertLegalChar(val);
        };
        XMLStringifier2.prototype.comment = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          val = "" + val || "";
          if (val.match(/--/)) {
            throw new Error("Comment text cannot contain double-hypen: " + val);
          }
          return this.assertLegalChar(val);
        };
        XMLStringifier2.prototype.raw = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return "" + val || "";
        };
        XMLStringifier2.prototype.attValue = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar(this.attEscape(val = "" + val || ""));
        };
        XMLStringifier2.prototype.insTarget = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar("" + val || "");
        };
        XMLStringifier2.prototype.insValue = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          val = "" + val || "";
          if (val.match(/\?>/)) {
            throw new Error("Invalid processing instruction value: " + val);
          }
          return this.assertLegalChar(val);
        };
        XMLStringifier2.prototype.xmlVersion = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          val = "" + val || "";
          if (!val.match(/1\.[0-9]+/)) {
            throw new Error("Invalid version number: " + val);
          }
          return val;
        };
        XMLStringifier2.prototype.xmlEncoding = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          val = "" + val || "";
          if (!val.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/)) {
            throw new Error("Invalid encoding: " + val);
          }
          return this.assertLegalChar(val);
        };
        XMLStringifier2.prototype.xmlStandalone = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          if (val) {
            return "yes";
          } else {
            return "no";
          }
        };
        XMLStringifier2.prototype.dtdPubID = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar("" + val || "");
        };
        XMLStringifier2.prototype.dtdSysID = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar("" + val || "");
        };
        XMLStringifier2.prototype.dtdElementValue = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar("" + val || "");
        };
        XMLStringifier2.prototype.dtdAttType = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar("" + val || "");
        };
        XMLStringifier2.prototype.dtdAttDefault = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar("" + val || "");
        };
        XMLStringifier2.prototype.dtdEntityValue = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar("" + val || "");
        };
        XMLStringifier2.prototype.dtdNData = function(val) {
          if (this.options.noValidation) {
            return val;
          }
          return this.assertLegalChar("" + val || "");
        };
        XMLStringifier2.prototype.convertAttKey = "@";
        XMLStringifier2.prototype.convertPIKey = "?";
        XMLStringifier2.prototype.convertTextKey = "#text";
        XMLStringifier2.prototype.convertCDataKey = "#cdata";
        XMLStringifier2.prototype.convertCommentKey = "#comment";
        XMLStringifier2.prototype.convertRawKey = "#raw";
        XMLStringifier2.prototype.assertLegalChar = function(str) {
          var regex, res;
          if (this.options.noValidation) {
            return str;
          }
          regex = "";
          if (this.options.version === "1.0") {
            regex = /[\0-\x08\x0B\f\x0E-\x1F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
            if (res = str.match(regex)) {
              throw new Error("Invalid character in string: " + str + " at index " + res.index);
            }
          } else if (this.options.version === "1.1") {
            regex = /[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
            if (res = str.match(regex)) {
              throw new Error("Invalid character in string: " + str + " at index " + res.index);
            }
          }
          return str;
        };
        XMLStringifier2.prototype.assertLegalName = function(str) {
          var regex;
          if (this.options.noValidation) {
            return str;
          }
          this.assertLegalChar(str);
          regex = /^([:A-Z_a-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])([\x2D\.0-:A-Z_a-z\xB7\xC0-\xD6\xD8-\xF6\xF8-\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])*$/;
          if (!str.match(regex)) {
            throw new Error("Invalid character in name");
          }
          return str;
        };
        XMLStringifier2.prototype.textEscape = function(str) {
          var ampregex;
          if (this.options.noValidation) {
            return str;
          }
          ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
          return str.replace(ampregex, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#xD;");
        };
        XMLStringifier2.prototype.attEscape = function(str) {
          var ampregex;
          if (this.options.noValidation) {
            return str;
          }
          ampregex = this.options.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
          return str.replace(ampregex, "&amp;").replace(/</g, "&lt;").replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
        };
        return XMLStringifier2;
      }();
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/WriterState.js
var require_WriterState = __commonJS({
  "node_modules/xmlbuilder/lib/WriterState.js"(exports, module) {
    (function() {
      module.exports = {
        None: 0,
        OpenTag: 1,
        InsideTag: 2,
        CloseTag: 3
      };
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLWriterBase.js
var require_XMLWriterBase = __commonJS({
  "node_modules/xmlbuilder/lib/XMLWriterBase.js"(exports, module) {
    (function() {
      var NodeType, WriterState, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLProcessingInstruction, XMLRaw, XMLText, XMLWriterBase, assign, hasProp = {}.hasOwnProperty;
      assign = require_Utility().assign;
      NodeType = require_NodeType();
      XMLDeclaration = require_XMLDeclaration();
      XMLDocType = require_XMLDocType();
      XMLCData = require_XMLCData();
      XMLComment = require_XMLComment();
      XMLElement = require_XMLElement();
      XMLRaw = require_XMLRaw();
      XMLText = require_XMLText();
      XMLProcessingInstruction = require_XMLProcessingInstruction();
      XMLDummy = require_XMLDummy();
      XMLDTDAttList = require_XMLDTDAttList();
      XMLDTDElement = require_XMLDTDElement();
      XMLDTDEntity = require_XMLDTDEntity();
      XMLDTDNotation = require_XMLDTDNotation();
      WriterState = require_WriterState();
      module.exports = XMLWriterBase = function() {
        function XMLWriterBase2(options) {
          var key, ref, value;
          options || (options = {});
          this.options = options;
          ref = options.writer || {};
          for (key in ref) {
            if (!hasProp.call(ref, key)) continue;
            value = ref[key];
            this["_" + key] = this[key];
            this[key] = value;
          }
        }
        __name(XMLWriterBase2, "XMLWriterBase");
        XMLWriterBase2.prototype.filterOptions = function(options) {
          var filteredOptions, ref, ref1, ref2, ref3, ref4, ref5, ref6;
          options || (options = {});
          options = assign({}, this.options, options);
          filteredOptions = {
            writer: this
          };
          filteredOptions.pretty = options.pretty || false;
          filteredOptions.allowEmpty = options.allowEmpty || false;
          filteredOptions.indent = (ref = options.indent) != null ? ref : "  ";
          filteredOptions.newline = (ref1 = options.newline) != null ? ref1 : "\n";
          filteredOptions.offset = (ref2 = options.offset) != null ? ref2 : 0;
          filteredOptions.dontPrettyTextNodes = (ref3 = (ref4 = options.dontPrettyTextNodes) != null ? ref4 : options.dontprettytextnodes) != null ? ref3 : 0;
          filteredOptions.spaceBeforeSlash = (ref5 = (ref6 = options.spaceBeforeSlash) != null ? ref6 : options.spacebeforeslash) != null ? ref5 : "";
          if (filteredOptions.spaceBeforeSlash === true) {
            filteredOptions.spaceBeforeSlash = " ";
          }
          filteredOptions.suppressPrettyCount = 0;
          filteredOptions.user = {};
          filteredOptions.state = WriterState.None;
          return filteredOptions;
        };
        XMLWriterBase2.prototype.indent = function(node, options, level) {
          var indentLevel;
          if (!options.pretty || options.suppressPrettyCount) {
            return "";
          } else if (options.pretty) {
            indentLevel = (level || 0) + options.offset + 1;
            if (indentLevel > 0) {
              return new Array(indentLevel).join(options.indent);
            }
          }
          return "";
        };
        XMLWriterBase2.prototype.endline = function(node, options, level) {
          if (!options.pretty || options.suppressPrettyCount) {
            return "";
          } else {
            return options.newline;
          }
        };
        XMLWriterBase2.prototype.attribute = function(att, options, level) {
          var r2;
          this.openAttribute(att, options, level);
          r2 = " " + att.name + '="' + att.value + '"';
          this.closeAttribute(att, options, level);
          return r2;
        };
        XMLWriterBase2.prototype.cdata = function(node, options, level) {
          var r2;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r2 = this.indent(node, options, level) + "<![CDATA[";
          options.state = WriterState.InsideTag;
          r2 += node.value;
          options.state = WriterState.CloseTag;
          r2 += "]]>" + this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r2;
        };
        XMLWriterBase2.prototype.comment = function(node, options, level) {
          var r2;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r2 = this.indent(node, options, level) + "<!-- ";
          options.state = WriterState.InsideTag;
          r2 += node.value;
          options.state = WriterState.CloseTag;
          r2 += " -->" + this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r2;
        };
        XMLWriterBase2.prototype.declaration = function(node, options, level) {
          var r2;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r2 = this.indent(node, options, level) + "<?xml";
          options.state = WriterState.InsideTag;
          r2 += ' version="' + node.version + '"';
          if (node.encoding != null) {
            r2 += ' encoding="' + node.encoding + '"';
          }
          if (node.standalone != null) {
            r2 += ' standalone="' + node.standalone + '"';
          }
          options.state = WriterState.CloseTag;
          r2 += options.spaceBeforeSlash + "?>";
          r2 += this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r2;
        };
        XMLWriterBase2.prototype.docType = function(node, options, level) {
          var child, i2, len, r2, ref;
          level || (level = 0);
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r2 = this.indent(node, options, level);
          r2 += "<!DOCTYPE " + node.root().name;
          if (node.pubID && node.sysID) {
            r2 += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
          } else if (node.sysID) {
            r2 += ' SYSTEM "' + node.sysID + '"';
          }
          if (node.children.length > 0) {
            r2 += " [";
            r2 += this.endline(node, options, level);
            options.state = WriterState.InsideTag;
            ref = node.children;
            for (i2 = 0, len = ref.length; i2 < len; i2++) {
              child = ref[i2];
              r2 += this.writeChildNode(child, options, level + 1);
            }
            options.state = WriterState.CloseTag;
            r2 += "]";
          }
          options.state = WriterState.CloseTag;
          r2 += options.spaceBeforeSlash + ">";
          r2 += this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r2;
        };
        XMLWriterBase2.prototype.element = function(node, options, level) {
          var att, child, childNodeCount, firstChildNode, i2, j2, len, len1, name3, prettySuppressed, r2, ref, ref1, ref2;
          level || (level = 0);
          prettySuppressed = false;
          r2 = "";
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r2 += this.indent(node, options, level) + "<" + node.name;
          ref = node.attribs;
          for (name3 in ref) {
            if (!hasProp.call(ref, name3)) continue;
            att = ref[name3];
            r2 += this.attribute(att, options, level);
          }
          childNodeCount = node.children.length;
          firstChildNode = childNodeCount === 0 ? null : node.children[0];
          if (childNodeCount === 0 || node.children.every(function(e2) {
            return (e2.type === NodeType.Text || e2.type === NodeType.Raw) && e2.value === "";
          })) {
            if (options.allowEmpty) {
              r2 += ">";
              options.state = WriterState.CloseTag;
              r2 += "</" + node.name + ">" + this.endline(node, options, level);
            } else {
              options.state = WriterState.CloseTag;
              r2 += options.spaceBeforeSlash + "/>" + this.endline(node, options, level);
            }
          } else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && firstChildNode.value != null) {
            r2 += ">";
            options.state = WriterState.InsideTag;
            options.suppressPrettyCount++;
            prettySuppressed = true;
            r2 += this.writeChildNode(firstChildNode, options, level + 1);
            options.suppressPrettyCount--;
            prettySuppressed = false;
            options.state = WriterState.CloseTag;
            r2 += "</" + node.name + ">" + this.endline(node, options, level);
          } else {
            if (options.dontPrettyTextNodes) {
              ref1 = node.children;
              for (i2 = 0, len = ref1.length; i2 < len; i2++) {
                child = ref1[i2];
                if ((child.type === NodeType.Text || child.type === NodeType.Raw) && child.value != null) {
                  options.suppressPrettyCount++;
                  prettySuppressed = true;
                  break;
                }
              }
            }
            r2 += ">" + this.endline(node, options, level);
            options.state = WriterState.InsideTag;
            ref2 = node.children;
            for (j2 = 0, len1 = ref2.length; j2 < len1; j2++) {
              child = ref2[j2];
              r2 += this.writeChildNode(child, options, level + 1);
            }
            options.state = WriterState.CloseTag;
            r2 += this.indent(node, options, level) + "</" + node.name + ">";
            if (prettySuppressed) {
              options.suppressPrettyCount--;
            }
            r2 += this.endline(node, options, level);
            options.state = WriterState.None;
          }
          this.closeNode(node, options, level);
          return r2;
        };
        XMLWriterBase2.prototype.writeChildNode = function(node, options, level) {
          switch (node.type) {
            case NodeType.CData:
              return this.cdata(node, options, level);
            case NodeType.Comment:
              return this.comment(node, options, level);
            case NodeType.Element:
              return this.element(node, options, level);
            case NodeType.Raw:
              return this.raw(node, options, level);
            case NodeType.Text:
              return this.text(node, options, level);
            case NodeType.ProcessingInstruction:
              return this.processingInstruction(node, options, level);
            case NodeType.Dummy:
              return "";
            case NodeType.Declaration:
              return this.declaration(node, options, level);
            case NodeType.DocType:
              return this.docType(node, options, level);
            case NodeType.AttributeDeclaration:
              return this.dtdAttList(node, options, level);
            case NodeType.ElementDeclaration:
              return this.dtdElement(node, options, level);
            case NodeType.EntityDeclaration:
              return this.dtdEntity(node, options, level);
            case NodeType.NotationDeclaration:
              return this.dtdNotation(node, options, level);
            default:
              throw new Error("Unknown XML node type: " + node.constructor.name);
          }
        };
        XMLWriterBase2.prototype.processingInstruction = function(node, options, level) {
          var r2;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r2 = this.indent(node, options, level) + "<?";
          options.state = WriterState.InsideTag;
          r2 += node.target;
          if (node.value) {
            r2 += " " + node.value;
          }
          options.state = WriterState.CloseTag;
          r2 += options.spaceBeforeSlash + "?>";
          r2 += this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r2;
        };
        XMLWriterBase2.prototype.raw = function(node, options, level) {
          var r2;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r2 = this.indent(node, options, level);
          options.state = WriterState.InsideTag;
          r2 += node.value;
          options.state = WriterState.CloseTag;
          r2 += this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r2;
        };
        XMLWriterBase2.prototype.text = function(node, options, level) {
          var r2;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r2 = this.indent(node, options, level);
          options.state = WriterState.InsideTag;
          r2 += node.value;
          options.state = WriterState.CloseTag;
          r2 += this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r2;
        };
        XMLWriterBase2.prototype.dtdAttList = function(node, options, level) {
          var r2;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r2 = this.indent(node, options, level) + "<!ATTLIST";
          options.state = WriterState.InsideTag;
          r2 += " " + node.elementName + " " + node.attributeName + " " + node.attributeType;
          if (node.defaultValueType !== "#DEFAULT") {
            r2 += " " + node.defaultValueType;
          }
          if (node.defaultValue) {
            r2 += ' "' + node.defaultValue + '"';
          }
          options.state = WriterState.CloseTag;
          r2 += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r2;
        };
        XMLWriterBase2.prototype.dtdElement = function(node, options, level) {
          var r2;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r2 = this.indent(node, options, level) + "<!ELEMENT";
          options.state = WriterState.InsideTag;
          r2 += " " + node.name + " " + node.value;
          options.state = WriterState.CloseTag;
          r2 += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r2;
        };
        XMLWriterBase2.prototype.dtdEntity = function(node, options, level) {
          var r2;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r2 = this.indent(node, options, level) + "<!ENTITY";
          options.state = WriterState.InsideTag;
          if (node.pe) {
            r2 += " %";
          }
          r2 += " " + node.name;
          if (node.value) {
            r2 += ' "' + node.value + '"';
          } else {
            if (node.pubID && node.sysID) {
              r2 += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
            } else if (node.sysID) {
              r2 += ' SYSTEM "' + node.sysID + '"';
            }
            if (node.nData) {
              r2 += " NDATA " + node.nData;
            }
          }
          options.state = WriterState.CloseTag;
          r2 += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r2;
        };
        XMLWriterBase2.prototype.dtdNotation = function(node, options, level) {
          var r2;
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          r2 = this.indent(node, options, level) + "<!NOTATION";
          options.state = WriterState.InsideTag;
          r2 += " " + node.name;
          if (node.pubID && node.sysID) {
            r2 += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
          } else if (node.pubID) {
            r2 += ' PUBLIC "' + node.pubID + '"';
          } else if (node.sysID) {
            r2 += ' SYSTEM "' + node.sysID + '"';
          }
          options.state = WriterState.CloseTag;
          r2 += options.spaceBeforeSlash + ">" + this.endline(node, options, level);
          options.state = WriterState.None;
          this.closeNode(node, options, level);
          return r2;
        };
        XMLWriterBase2.prototype.openNode = function(node, options, level) {
        };
        XMLWriterBase2.prototype.closeNode = function(node, options, level) {
        };
        XMLWriterBase2.prototype.openAttribute = function(att, options, level) {
        };
        XMLWriterBase2.prototype.closeAttribute = function(att, options, level) {
        };
        return XMLWriterBase2;
      }();
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLStringWriter.js
var require_XMLStringWriter = __commonJS({
  "node_modules/xmlbuilder/lib/XMLStringWriter.js"(exports, module) {
    (function() {
      var XMLStringWriter, XMLWriterBase, extend = /* @__PURE__ */ __name(function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        __name(ctor, "ctor");
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, "extend"), hasProp = {}.hasOwnProperty;
      XMLWriterBase = require_XMLWriterBase();
      module.exports = XMLStringWriter = function(superClass) {
        extend(XMLStringWriter2, superClass);
        function XMLStringWriter2(options) {
          XMLStringWriter2.__super__.constructor.call(this, options);
        }
        __name(XMLStringWriter2, "XMLStringWriter");
        XMLStringWriter2.prototype.document = function(doc, options) {
          var child, i2, len, r2, ref;
          options = this.filterOptions(options);
          r2 = "";
          ref = doc.children;
          for (i2 = 0, len = ref.length; i2 < len; i2++) {
            child = ref[i2];
            r2 += this.writeChildNode(child, options, 0);
          }
          if (options.pretty && r2.slice(-options.newline.length) === options.newline) {
            r2 = r2.slice(0, -options.newline.length);
          }
          return r2;
        };
        return XMLStringWriter2;
      }(XMLWriterBase);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDocument.js
var require_XMLDocument = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDocument.js"(exports, module) {
    (function() {
      var NodeType, XMLDOMConfiguration, XMLDOMImplementation, XMLDocument, XMLNode, XMLStringWriter, XMLStringifier, isPlainObject, extend = /* @__PURE__ */ __name(function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        __name(ctor, "ctor");
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, "extend"), hasProp = {}.hasOwnProperty;
      isPlainObject = require_Utility().isPlainObject;
      XMLDOMImplementation = require_XMLDOMImplementation();
      XMLDOMConfiguration = require_XMLDOMConfiguration();
      XMLNode = require_XMLNode();
      NodeType = require_NodeType();
      XMLStringifier = require_XMLStringifier();
      XMLStringWriter = require_XMLStringWriter();
      module.exports = XMLDocument = function(superClass) {
        extend(XMLDocument2, superClass);
        function XMLDocument2(options) {
          XMLDocument2.__super__.constructor.call(this, null);
          this.name = "#document";
          this.type = NodeType.Document;
          this.documentURI = null;
          this.domConfig = new XMLDOMConfiguration();
          options || (options = {});
          if (!options.writer) {
            options.writer = new XMLStringWriter();
          }
          this.options = options;
          this.stringify = new XMLStringifier(options);
        }
        __name(XMLDocument2, "XMLDocument");
        Object.defineProperty(XMLDocument2.prototype, "implementation", {
          value: new XMLDOMImplementation()
        });
        Object.defineProperty(XMLDocument2.prototype, "doctype", {
          get: /* @__PURE__ */ __name(function() {
            var child, i2, len, ref;
            ref = this.children;
            for (i2 = 0, len = ref.length; i2 < len; i2++) {
              child = ref[i2];
              if (child.type === NodeType.DocType) {
                return child;
              }
            }
            return null;
          }, "get")
        });
        Object.defineProperty(XMLDocument2.prototype, "documentElement", {
          get: /* @__PURE__ */ __name(function() {
            return this.rootObject || null;
          }, "get")
        });
        Object.defineProperty(XMLDocument2.prototype, "inputEncoding", {
          get: /* @__PURE__ */ __name(function() {
            return null;
          }, "get")
        });
        Object.defineProperty(XMLDocument2.prototype, "strictErrorChecking", {
          get: /* @__PURE__ */ __name(function() {
            return false;
          }, "get")
        });
        Object.defineProperty(XMLDocument2.prototype, "xmlEncoding", {
          get: /* @__PURE__ */ __name(function() {
            if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
              return this.children[0].encoding;
            } else {
              return null;
            }
          }, "get")
        });
        Object.defineProperty(XMLDocument2.prototype, "xmlStandalone", {
          get: /* @__PURE__ */ __name(function() {
            if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
              return this.children[0].standalone === "yes";
            } else {
              return false;
            }
          }, "get")
        });
        Object.defineProperty(XMLDocument2.prototype, "xmlVersion", {
          get: /* @__PURE__ */ __name(function() {
            if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {
              return this.children[0].version;
            } else {
              return "1.0";
            }
          }, "get")
        });
        Object.defineProperty(XMLDocument2.prototype, "URL", {
          get: /* @__PURE__ */ __name(function() {
            return this.documentURI;
          }, "get")
        });
        Object.defineProperty(XMLDocument2.prototype, "origin", {
          get: /* @__PURE__ */ __name(function() {
            return null;
          }, "get")
        });
        Object.defineProperty(XMLDocument2.prototype, "compatMode", {
          get: /* @__PURE__ */ __name(function() {
            return null;
          }, "get")
        });
        Object.defineProperty(XMLDocument2.prototype, "characterSet", {
          get: /* @__PURE__ */ __name(function() {
            return null;
          }, "get")
        });
        Object.defineProperty(XMLDocument2.prototype, "contentType", {
          get: /* @__PURE__ */ __name(function() {
            return null;
          }, "get")
        });
        XMLDocument2.prototype.end = function(writer) {
          var writerOptions;
          writerOptions = {};
          if (!writer) {
            writer = this.options.writer;
          } else if (isPlainObject(writer)) {
            writerOptions = writer;
            writer = this.options.writer;
          }
          return writer.document(this, writer.filterOptions(writerOptions));
        };
        XMLDocument2.prototype.toString = function(options) {
          return this.options.writer.document(this, this.options.writer.filterOptions(options));
        };
        XMLDocument2.prototype.createElement = function(tagName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createDocumentFragment = function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createTextNode = function(data) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createComment = function(data) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createCDATASection = function(data) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createProcessingInstruction = function(target, data) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createAttribute = function(name3) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createEntityReference = function(name3) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.getElementsByTagName = function(tagname) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.importNode = function(importedNode, deep) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createElementNS = function(namespaceURI, qualifiedName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createAttributeNS = function(namespaceURI, qualifiedName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.getElementById = function(elementId) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.adoptNode = function(source3) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.normalizeDocument = function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.renameNode = function(node, namespaceURI, qualifiedName) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.getElementsByClassName = function(classNames) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createEvent = function(eventInterface) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createRange = function() {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createNodeIterator = function(root, whatToShow, filter) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        XMLDocument2.prototype.createTreeWalker = function(root, whatToShow, filter) {
          throw new Error("This DOM method is not implemented." + this.debugInfo());
        };
        return XMLDocument2;
      }(XMLNode);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLDocumentCB.js
var require_XMLDocumentCB = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDocumentCB.js"(exports, module) {
    (function() {
      var NodeType, WriterState, XMLAttribute, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDocument, XMLDocumentCB, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLStringifier, XMLText, getValue, isFunction, isObject, isPlainObject, ref, hasProp = {}.hasOwnProperty;
      ref = require_Utility(), isObject = ref.isObject, isFunction = ref.isFunction, isPlainObject = ref.isPlainObject, getValue = ref.getValue;
      NodeType = require_NodeType();
      XMLDocument = require_XMLDocument();
      XMLElement = require_XMLElement();
      XMLCData = require_XMLCData();
      XMLComment = require_XMLComment();
      XMLRaw = require_XMLRaw();
      XMLText = require_XMLText();
      XMLProcessingInstruction = require_XMLProcessingInstruction();
      XMLDeclaration = require_XMLDeclaration();
      XMLDocType = require_XMLDocType();
      XMLDTDAttList = require_XMLDTDAttList();
      XMLDTDEntity = require_XMLDTDEntity();
      XMLDTDElement = require_XMLDTDElement();
      XMLDTDNotation = require_XMLDTDNotation();
      XMLAttribute = require_XMLAttribute();
      XMLStringifier = require_XMLStringifier();
      XMLStringWriter = require_XMLStringWriter();
      WriterState = require_WriterState();
      module.exports = XMLDocumentCB = function() {
        function XMLDocumentCB2(options, onData, onEnd) {
          var writerOptions;
          this.name = "?xml";
          this.type = NodeType.Document;
          options || (options = {});
          writerOptions = {};
          if (!options.writer) {
            options.writer = new XMLStringWriter();
          } else if (isPlainObject(options.writer)) {
            writerOptions = options.writer;
            options.writer = new XMLStringWriter();
          }
          this.options = options;
          this.writer = options.writer;
          this.writerOptions = this.writer.filterOptions(writerOptions);
          this.stringify = new XMLStringifier(options);
          this.onDataCallback = onData || function() {
          };
          this.onEndCallback = onEnd || function() {
          };
          this.currentNode = null;
          this.currentLevel = -1;
          this.openTags = {};
          this.documentStarted = false;
          this.documentCompleted = false;
          this.root = null;
        }
        __name(XMLDocumentCB2, "XMLDocumentCB");
        XMLDocumentCB2.prototype.createChildNode = function(node) {
          var att, attName, attributes, child, i2, len, ref1, ref2;
          switch (node.type) {
            case NodeType.CData:
              this.cdata(node.value);
              break;
            case NodeType.Comment:
              this.comment(node.value);
              break;
            case NodeType.Element:
              attributes = {};
              ref1 = node.attribs;
              for (attName in ref1) {
                if (!hasProp.call(ref1, attName)) continue;
                att = ref1[attName];
                attributes[attName] = att.value;
              }
              this.node(node.name, attributes);
              break;
            case NodeType.Dummy:
              this.dummy();
              break;
            case NodeType.Raw:
              this.raw(node.value);
              break;
            case NodeType.Text:
              this.text(node.value);
              break;
            case NodeType.ProcessingInstruction:
              this.instruction(node.target, node.value);
              break;
            default:
              throw new Error("This XML node type is not supported in a JS object: " + node.constructor.name);
          }
          ref2 = node.children;
          for (i2 = 0, len = ref2.length; i2 < len; i2++) {
            child = ref2[i2];
            this.createChildNode(child);
            if (child.type === NodeType.Element) {
              this.up();
            }
          }
          return this;
        };
        XMLDocumentCB2.prototype.dummy = function() {
          return this;
        };
        XMLDocumentCB2.prototype.node = function(name3, attributes, text) {
          var ref1;
          if (name3 == null) {
            throw new Error("Missing node name.");
          }
          if (this.root && this.currentLevel === -1) {
            throw new Error("Document can only have one root node. " + this.debugInfo(name3));
          }
          this.openCurrent();
          name3 = getValue(name3);
          if (attributes == null) {
            attributes = {};
          }
          attributes = getValue(attributes);
          if (!isObject(attributes)) {
            ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];
          }
          this.currentNode = new XMLElement(this, name3, attributes);
          this.currentNode.children = false;
          this.currentLevel++;
          this.openTags[this.currentLevel] = this.currentNode;
          if (text != null) {
            this.text(text);
          }
          return this;
        };
        XMLDocumentCB2.prototype.element = function(name3, attributes, text) {
          var child, i2, len, oldValidationFlag, ref1, root;
          if (this.currentNode && this.currentNode.type === NodeType.DocType) {
            this.dtdElement.apply(this, arguments);
          } else {
            if (Array.isArray(name3) || isObject(name3) || isFunction(name3)) {
              oldValidationFlag = this.options.noValidation;
              this.options.noValidation = true;
              root = new XMLDocument(this.options).element("TEMP_ROOT");
              root.element(name3);
              this.options.noValidation = oldValidationFlag;
              ref1 = root.children;
              for (i2 = 0, len = ref1.length; i2 < len; i2++) {
                child = ref1[i2];
                this.createChildNode(child);
                if (child.type === NodeType.Element) {
                  this.up();
                }
              }
            } else {
              this.node(name3, attributes, text);
            }
          }
          return this;
        };
        XMLDocumentCB2.prototype.attribute = function(name3, value) {
          var attName, attValue;
          if (!this.currentNode || this.currentNode.children) {
            throw new Error("att() can only be used immediately after an ele() call in callback mode. " + this.debugInfo(name3));
          }
          if (name3 != null) {
            name3 = getValue(name3);
          }
          if (isObject(name3)) {
            for (attName in name3) {
              if (!hasProp.call(name3, attName)) continue;
              attValue = name3[attName];
              this.attribute(attName, attValue);
            }
          } else {
            if (isFunction(value)) {
              value = value.apply();
            }
            if (this.options.keepNullAttributes && value == null) {
              this.currentNode.attribs[name3] = new XMLAttribute(this, name3, "");
            } else if (value != null) {
              this.currentNode.attribs[name3] = new XMLAttribute(this, name3, value);
            }
          }
          return this;
        };
        XMLDocumentCB2.prototype.text = function(value) {
          var node;
          this.openCurrent();
          node = new XMLText(this, value);
          this.onData(this.writer.text(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.cdata = function(value) {
          var node;
          this.openCurrent();
          node = new XMLCData(this, value);
          this.onData(this.writer.cdata(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.comment = function(value) {
          var node;
          this.openCurrent();
          node = new XMLComment(this, value);
          this.onData(this.writer.comment(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.raw = function(value) {
          var node;
          this.openCurrent();
          node = new XMLRaw(this, value);
          this.onData(this.writer.raw(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.instruction = function(target, value) {
          var i2, insTarget, insValue, len, node;
          this.openCurrent();
          if (target != null) {
            target = getValue(target);
          }
          if (value != null) {
            value = getValue(value);
          }
          if (Array.isArray(target)) {
            for (i2 = 0, len = target.length; i2 < len; i2++) {
              insTarget = target[i2];
              this.instruction(insTarget);
            }
          } else if (isObject(target)) {
            for (insTarget in target) {
              if (!hasProp.call(target, insTarget)) continue;
              insValue = target[insTarget];
              this.instruction(insTarget, insValue);
            }
          } else {
            if (isFunction(value)) {
              value = value.apply();
            }
            node = new XMLProcessingInstruction(this, target, value);
            this.onData(this.writer.processingInstruction(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          }
          return this;
        };
        XMLDocumentCB2.prototype.declaration = function(version, encoding, standalone) {
          var node;
          this.openCurrent();
          if (this.documentStarted) {
            throw new Error("declaration() must be the first node.");
          }
          node = new XMLDeclaration(this, version, encoding, standalone);
          this.onData(this.writer.declaration(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.doctype = function(root, pubID, sysID) {
          this.openCurrent();
          if (root == null) {
            throw new Error("Missing root node name.");
          }
          if (this.root) {
            throw new Error("dtd() must come before the root node.");
          }
          this.currentNode = new XMLDocType(this, pubID, sysID);
          this.currentNode.rootNodeName = root;
          this.currentNode.children = false;
          this.currentLevel++;
          this.openTags[this.currentLevel] = this.currentNode;
          return this;
        };
        XMLDocumentCB2.prototype.dtdElement = function(name3, value) {
          var node;
          this.openCurrent();
          node = new XMLDTDElement(this, name3, value);
          this.onData(this.writer.dtdElement(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
          var node;
          this.openCurrent();
          node = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
          this.onData(this.writer.dtdAttList(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.entity = function(name3, value) {
          var node;
          this.openCurrent();
          node = new XMLDTDEntity(this, false, name3, value);
          this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.pEntity = function(name3, value) {
          var node;
          this.openCurrent();
          node = new XMLDTDEntity(this, true, name3, value);
          this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.notation = function(name3, value) {
          var node;
          this.openCurrent();
          node = new XMLDTDNotation(this, name3, value);
          this.onData(this.writer.dtdNotation(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.up = function() {
          if (this.currentLevel < 0) {
            throw new Error("The document node has no parent.");
          }
          if (this.currentNode) {
            if (this.currentNode.children) {
              this.closeNode(this.currentNode);
            } else {
              this.openNode(this.currentNode);
            }
            this.currentNode = null;
          } else {
            this.closeNode(this.openTags[this.currentLevel]);
          }
          delete this.openTags[this.currentLevel];
          this.currentLevel--;
          return this;
        };
        XMLDocumentCB2.prototype.end = function() {
          while (this.currentLevel >= 0) {
            this.up();
          }
          return this.onEnd();
        };
        XMLDocumentCB2.prototype.openCurrent = function() {
          if (this.currentNode) {
            this.currentNode.children = true;
            return this.openNode(this.currentNode);
          }
        };
        XMLDocumentCB2.prototype.openNode = function(node) {
          var att, chunk, name3, ref1;
          if (!node.isOpen) {
            if (!this.root && this.currentLevel === 0 && node.type === NodeType.Element) {
              this.root = node;
            }
            chunk = "";
            if (node.type === NodeType.Element) {
              this.writerOptions.state = WriterState.OpenTag;
              chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "<" + node.name;
              ref1 = node.attribs;
              for (name3 in ref1) {
                if (!hasProp.call(ref1, name3)) continue;
                att = ref1[name3];
                chunk += this.writer.attribute(att, this.writerOptions, this.currentLevel);
              }
              chunk += (node.children ? ">" : "/>") + this.writer.endline(node, this.writerOptions, this.currentLevel);
              this.writerOptions.state = WriterState.InsideTag;
            } else {
              this.writerOptions.state = WriterState.OpenTag;
              chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "<!DOCTYPE " + node.rootNodeName;
              if (node.pubID && node.sysID) {
                chunk += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
              } else if (node.sysID) {
                chunk += ' SYSTEM "' + node.sysID + '"';
              }
              if (node.children) {
                chunk += " [";
                this.writerOptions.state = WriterState.InsideTag;
              } else {
                this.writerOptions.state = WriterState.CloseTag;
                chunk += ">";
              }
              chunk += this.writer.endline(node, this.writerOptions, this.currentLevel);
            }
            this.onData(chunk, this.currentLevel);
            return node.isOpen = true;
          }
        };
        XMLDocumentCB2.prototype.closeNode = function(node) {
          var chunk;
          if (!node.isClosed) {
            chunk = "";
            this.writerOptions.state = WriterState.CloseTag;
            if (node.type === NodeType.Element) {
              chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "</" + node.name + ">" + this.writer.endline(node, this.writerOptions, this.currentLevel);
            } else {
              chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + "]>" + this.writer.endline(node, this.writerOptions, this.currentLevel);
            }
            this.writerOptions.state = WriterState.None;
            this.onData(chunk, this.currentLevel);
            return node.isClosed = true;
          }
        };
        XMLDocumentCB2.prototype.onData = function(chunk, level) {
          this.documentStarted = true;
          return this.onDataCallback(chunk, level + 1);
        };
        XMLDocumentCB2.prototype.onEnd = function() {
          this.documentCompleted = true;
          return this.onEndCallback();
        };
        XMLDocumentCB2.prototype.debugInfo = function(name3) {
          if (name3 == null) {
            return "";
          } else {
            return "node: <" + name3 + ">";
          }
        };
        XMLDocumentCB2.prototype.ele = function() {
          return this.element.apply(this, arguments);
        };
        XMLDocumentCB2.prototype.nod = function(name3, attributes, text) {
          return this.node(name3, attributes, text);
        };
        XMLDocumentCB2.prototype.txt = function(value) {
          return this.text(value);
        };
        XMLDocumentCB2.prototype.dat = function(value) {
          return this.cdata(value);
        };
        XMLDocumentCB2.prototype.com = function(value) {
          return this.comment(value);
        };
        XMLDocumentCB2.prototype.ins = function(target, value) {
          return this.instruction(target, value);
        };
        XMLDocumentCB2.prototype.dec = function(version, encoding, standalone) {
          return this.declaration(version, encoding, standalone);
        };
        XMLDocumentCB2.prototype.dtd = function(root, pubID, sysID) {
          return this.doctype(root, pubID, sysID);
        };
        XMLDocumentCB2.prototype.e = function(name3, attributes, text) {
          return this.element(name3, attributes, text);
        };
        XMLDocumentCB2.prototype.n = function(name3, attributes, text) {
          return this.node(name3, attributes, text);
        };
        XMLDocumentCB2.prototype.t = function(value) {
          return this.text(value);
        };
        XMLDocumentCB2.prototype.d = function(value) {
          return this.cdata(value);
        };
        XMLDocumentCB2.prototype.c = function(value) {
          return this.comment(value);
        };
        XMLDocumentCB2.prototype.r = function(value) {
          return this.raw(value);
        };
        XMLDocumentCB2.prototype.i = function(target, value) {
          return this.instruction(target, value);
        };
        XMLDocumentCB2.prototype.att = function() {
          if (this.currentNode && this.currentNode.type === NodeType.DocType) {
            return this.attList.apply(this, arguments);
          } else {
            return this.attribute.apply(this, arguments);
          }
        };
        XMLDocumentCB2.prototype.a = function() {
          if (this.currentNode && this.currentNode.type === NodeType.DocType) {
            return this.attList.apply(this, arguments);
          } else {
            return this.attribute.apply(this, arguments);
          }
        };
        XMLDocumentCB2.prototype.ent = function(name3, value) {
          return this.entity(name3, value);
        };
        XMLDocumentCB2.prototype.pent = function(name3, value) {
          return this.pEntity(name3, value);
        };
        XMLDocumentCB2.prototype.not = function(name3, value) {
          return this.notation(name3, value);
        };
        return XMLDocumentCB2;
      }();
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/XMLStreamWriter.js
var require_XMLStreamWriter = __commonJS({
  "node_modules/xmlbuilder/lib/XMLStreamWriter.js"(exports, module) {
    (function() {
      var NodeType, WriterState, XMLStreamWriter, XMLWriterBase, extend = /* @__PURE__ */ __name(function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        __name(ctor, "ctor");
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, "extend"), hasProp = {}.hasOwnProperty;
      NodeType = require_NodeType();
      XMLWriterBase = require_XMLWriterBase();
      WriterState = require_WriterState();
      module.exports = XMLStreamWriter = function(superClass) {
        extend(XMLStreamWriter2, superClass);
        function XMLStreamWriter2(stream, options) {
          this.stream = stream;
          XMLStreamWriter2.__super__.constructor.call(this, options);
        }
        __name(XMLStreamWriter2, "XMLStreamWriter");
        XMLStreamWriter2.prototype.endline = function(node, options, level) {
          if (node.isLastRootNode && options.state === WriterState.CloseTag) {
            return "";
          } else {
            return XMLStreamWriter2.__super__.endline.call(this, node, options, level);
          }
        };
        XMLStreamWriter2.prototype.document = function(doc, options) {
          var child, i2, j2, k2, len, len1, ref, ref1, results;
          ref = doc.children;
          for (i2 = j2 = 0, len = ref.length; j2 < len; i2 = ++j2) {
            child = ref[i2];
            child.isLastRootNode = i2 === doc.children.length - 1;
          }
          options = this.filterOptions(options);
          ref1 = doc.children;
          results = [];
          for (k2 = 0, len1 = ref1.length; k2 < len1; k2++) {
            child = ref1[k2];
            results.push(this.writeChildNode(child, options, 0));
          }
          return results;
        };
        XMLStreamWriter2.prototype.attribute = function(att, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.attribute.call(this, att, options, level));
        };
        XMLStreamWriter2.prototype.cdata = function(node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.cdata.call(this, node, options, level));
        };
        XMLStreamWriter2.prototype.comment = function(node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.comment.call(this, node, options, level));
        };
        XMLStreamWriter2.prototype.declaration = function(node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.declaration.call(this, node, options, level));
        };
        XMLStreamWriter2.prototype.docType = function(node, options, level) {
          var child, j2, len, ref;
          level || (level = 0);
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          this.stream.write(this.indent(node, options, level));
          this.stream.write("<!DOCTYPE " + node.root().name);
          if (node.pubID && node.sysID) {
            this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
          } else if (node.sysID) {
            this.stream.write(' SYSTEM "' + node.sysID + '"');
          }
          if (node.children.length > 0) {
            this.stream.write(" [");
            this.stream.write(this.endline(node, options, level));
            options.state = WriterState.InsideTag;
            ref = node.children;
            for (j2 = 0, len = ref.length; j2 < len; j2++) {
              child = ref[j2];
              this.writeChildNode(child, options, level + 1);
            }
            options.state = WriterState.CloseTag;
            this.stream.write("]");
          }
          options.state = WriterState.CloseTag;
          this.stream.write(options.spaceBeforeSlash + ">");
          this.stream.write(this.endline(node, options, level));
          options.state = WriterState.None;
          return this.closeNode(node, options, level);
        };
        XMLStreamWriter2.prototype.element = function(node, options, level) {
          var att, child, childNodeCount, firstChildNode, j2, len, name3, prettySuppressed, ref, ref1;
          level || (level = 0);
          this.openNode(node, options, level);
          options.state = WriterState.OpenTag;
          this.stream.write(this.indent(node, options, level) + "<" + node.name);
          ref = node.attribs;
          for (name3 in ref) {
            if (!hasProp.call(ref, name3)) continue;
            att = ref[name3];
            this.attribute(att, options, level);
          }
          childNodeCount = node.children.length;
          firstChildNode = childNodeCount === 0 ? null : node.children[0];
          if (childNodeCount === 0 || node.children.every(function(e2) {
            return (e2.type === NodeType.Text || e2.type === NodeType.Raw) && e2.value === "";
          })) {
            if (options.allowEmpty) {
              this.stream.write(">");
              options.state = WriterState.CloseTag;
              this.stream.write("</" + node.name + ">");
            } else {
              options.state = WriterState.CloseTag;
              this.stream.write(options.spaceBeforeSlash + "/>");
            }
          } else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && firstChildNode.value != null) {
            this.stream.write(">");
            options.state = WriterState.InsideTag;
            options.suppressPrettyCount++;
            prettySuppressed = true;
            this.writeChildNode(firstChildNode, options, level + 1);
            options.suppressPrettyCount--;
            prettySuppressed = false;
            options.state = WriterState.CloseTag;
            this.stream.write("</" + node.name + ">");
          } else {
            this.stream.write(">" + this.endline(node, options, level));
            options.state = WriterState.InsideTag;
            ref1 = node.children;
            for (j2 = 0, len = ref1.length; j2 < len; j2++) {
              child = ref1[j2];
              this.writeChildNode(child, options, level + 1);
            }
            options.state = WriterState.CloseTag;
            this.stream.write(this.indent(node, options, level) + "</" + node.name + ">");
          }
          this.stream.write(this.endline(node, options, level));
          options.state = WriterState.None;
          return this.closeNode(node, options, level);
        };
        XMLStreamWriter2.prototype.processingInstruction = function(node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.processingInstruction.call(this, node, options, level));
        };
        XMLStreamWriter2.prototype.raw = function(node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.raw.call(this, node, options, level));
        };
        XMLStreamWriter2.prototype.text = function(node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.text.call(this, node, options, level));
        };
        XMLStreamWriter2.prototype.dtdAttList = function(node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.dtdAttList.call(this, node, options, level));
        };
        XMLStreamWriter2.prototype.dtdElement = function(node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.dtdElement.call(this, node, options, level));
        };
        XMLStreamWriter2.prototype.dtdEntity = function(node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.dtdEntity.call(this, node, options, level));
        };
        XMLStreamWriter2.prototype.dtdNotation = function(node, options, level) {
          return this.stream.write(XMLStreamWriter2.__super__.dtdNotation.call(this, node, options, level));
        };
        return XMLStreamWriter2;
      }(XMLWriterBase);
    }).call(exports);
  }
});

// node_modules/xmlbuilder/lib/index.js
var require_lib = __commonJS({
  "node_modules/xmlbuilder/lib/index.js"(exports, module) {
    (function() {
      var NodeType, WriterState, XMLDOMImplementation, XMLDocument, XMLDocumentCB, XMLStreamWriter, XMLStringWriter, assign, isFunction, ref;
      ref = require_Utility(), assign = ref.assign, isFunction = ref.isFunction;
      XMLDOMImplementation = require_XMLDOMImplementation();
      XMLDocument = require_XMLDocument();
      XMLDocumentCB = require_XMLDocumentCB();
      XMLStringWriter = require_XMLStringWriter();
      XMLStreamWriter = require_XMLStreamWriter();
      NodeType = require_NodeType();
      WriterState = require_WriterState();
      module.exports.create = function(name3, xmldec, doctype, options) {
        var doc, root;
        if (name3 == null) {
          throw new Error("Root element needs a name.");
        }
        options = assign({}, xmldec, doctype, options);
        doc = new XMLDocument(options);
        root = doc.element(name3);
        if (!options.headless) {
          doc.declaration(options);
          if (options.pubID != null || options.sysID != null) {
            doc.dtd(options);
          }
        }
        return root;
      };
      module.exports.begin = function(options, onData, onEnd) {
        var ref1;
        if (isFunction(options)) {
          ref1 = [options, onData], onData = ref1[0], onEnd = ref1[1];
          options = {};
        }
        if (onData) {
          return new XMLDocumentCB(options, onData, onEnd);
        } else {
          return new XMLDocument(options);
        }
      };
      module.exports.stringWriter = function(options) {
        return new XMLStringWriter(options);
      };
      module.exports.streamWriter = function(stream, options) {
        return new XMLStreamWriter(stream, options);
      };
      module.exports.implementation = new XMLDOMImplementation();
      module.exports.nodeType = NodeType;
      module.exports.writerState = WriterState;
    }).call(exports);
  }
});

// node_modules/xml2js/lib/builder.js
var require_builder = __commonJS({
  "node_modules/xml2js/lib/builder.js"(exports) {
    (function() {
      "use strict";
      var builder, defaults, escapeCDATA, requiresCDATA, wrapCDATA, hasProp = {}.hasOwnProperty;
      builder = require_lib();
      defaults = require_defaults().defaults;
      requiresCDATA = /* @__PURE__ */ __name(function(entry) {
        return typeof entry === "string" && (entry.indexOf("&") >= 0 || entry.indexOf(">") >= 0 || entry.indexOf("<") >= 0);
      }, "requiresCDATA");
      wrapCDATA = /* @__PURE__ */ __name(function(entry) {
        return "<![CDATA[" + escapeCDATA(entry) + "]]>";
      }, "wrapCDATA");
      escapeCDATA = /* @__PURE__ */ __name(function(entry) {
        return entry.replace("]]>", "]]]]><![CDATA[>");
      }, "escapeCDATA");
      exports.Builder = function() {
        function Builder(opts) {
          var key, ref, value;
          this.options = {};
          ref = defaults["0.2"];
          for (key in ref) {
            if (!hasProp.call(ref, key)) continue;
            value = ref[key];
            this.options[key] = value;
          }
          for (key in opts) {
            if (!hasProp.call(opts, key)) continue;
            value = opts[key];
            this.options[key] = value;
          }
        }
        __name(Builder, "Builder");
        Builder.prototype.buildObject = function(rootObj) {
          var attrkey, charkey, render, rootElement, rootName;
          attrkey = this.options.attrkey;
          charkey = this.options.charkey;
          if (Object.keys(rootObj).length === 1 && this.options.rootName === defaults["0.2"].rootName) {
            rootName = Object.keys(rootObj)[0];
            rootObj = rootObj[rootName];
          } else {
            rootName = this.options.rootName;
          }
          render = /* @__PURE__ */ function(_this) {
            return function(element, obj) {
              var attr, child, entry, index, key, value;
              if (typeof obj !== "object") {
                if (_this.options.cdata && requiresCDATA(obj)) {
                  element.raw(wrapCDATA(obj));
                } else {
                  element.txt(obj);
                }
              } else if (Array.isArray(obj)) {
                for (index in obj) {
                  if (!hasProp.call(obj, index)) continue;
                  child = obj[index];
                  for (key in child) {
                    entry = child[key];
                    element = render(element.ele(key), entry).up();
                  }
                }
              } else {
                for (key in obj) {
                  if (!hasProp.call(obj, key)) continue;
                  child = obj[key];
                  if (key === attrkey) {
                    if (typeof child === "object") {
                      for (attr in child) {
                        value = child[attr];
                        element = element.att(attr, value);
                      }
                    }
                  } else if (key === charkey) {
                    if (_this.options.cdata && requiresCDATA(child)) {
                      element = element.raw(wrapCDATA(child));
                    } else {
                      element = element.txt(child);
                    }
                  } else if (Array.isArray(child)) {
                    for (index in child) {
                      if (!hasProp.call(child, index)) continue;
                      entry = child[index];
                      if (typeof entry === "string") {
                        if (_this.options.cdata && requiresCDATA(entry)) {
                          element = element.ele(key).raw(wrapCDATA(entry)).up();
                        } else {
                          element = element.ele(key, entry).up();
                        }
                      } else {
                        element = render(element.ele(key), entry).up();
                      }
                    }
                  } else if (typeof child === "object") {
                    element = render(element.ele(key), child).up();
                  } else {
                    if (typeof child === "string" && _this.options.cdata && requiresCDATA(child)) {
                      element = element.ele(key).raw(wrapCDATA(child)).up();
                    } else {
                      if (child == null) {
                        child = "";
                      }
                      element = element.ele(key, child.toString()).up();
                    }
                  }
                }
              }
              return element;
            };
          }(this);
          rootElement = builder.create(rootName, this.options.xmldec, this.options.doctype, {
            headless: this.options.headless,
            allowSurrogateChars: this.options.allowSurrogateChars
          });
          return render(rootElement, rootObj).end(this.options.renderOpts);
        };
        return Builder;
      }();
    }).call(exports);
  }
});

// node_modules/component-emitter/index.js
var require_component_emitter = __commonJS({
  "node_modules/component-emitter/index.js"(exports, module) {
    function Emitter(object) {
      if (object) {
        return mixin(object);
      }
      this._callbacks = /* @__PURE__ */ new Map();
    }
    __name(Emitter, "Emitter");
    function mixin(object) {
      Object.assign(object, Emitter.prototype);
      object._callbacks = /* @__PURE__ */ new Map();
      return object;
    }
    __name(mixin, "mixin");
    Emitter.prototype.on = function(event, listener) {
      const callbacks = this._callbacks.get(event) ?? [];
      callbacks.push(listener);
      this._callbacks.set(event, callbacks);
      return this;
    };
    Emitter.prototype.once = function(event, listener) {
      const on = /* @__PURE__ */ __name((...arguments_) => {
        this.off(event, on);
        listener.apply(this, arguments_);
      }, "on");
      on.fn = listener;
      this.on(event, on);
      return this;
    };
    Emitter.prototype.off = function(event, listener) {
      if (event === void 0 && listener === void 0) {
        this._callbacks.clear();
        return this;
      }
      if (listener === void 0) {
        this._callbacks.delete(event);
        return this;
      }
      const callbacks = this._callbacks.get(event);
      if (callbacks) {
        for (const [index, callback] of callbacks.entries()) {
          if (callback === listener || callback.fn === listener) {
            callbacks.splice(index, 1);
            break;
          }
        }
        if (callbacks.length === 0) {
          this._callbacks.delete(event);
        } else {
          this._callbacks.set(event, callbacks);
        }
      }
      return this;
    };
    Emitter.prototype.emit = function(event, ...arguments_) {
      const callbacks = this._callbacks.get(event);
      if (callbacks) {
        const callbacksCopy = [...callbacks];
        for (const callback of callbacksCopy) {
          callback.apply(this, arguments_);
        }
      }
      return this;
    };
    Emitter.prototype.listeners = function(event) {
      return this._callbacks.get(event) ?? [];
    };
    Emitter.prototype.listenerCount = function(event) {
      if (event) {
        return this.listeners(event).length;
      }
      let totalCount = 0;
      for (const callbacks of this._callbacks.values()) {
        totalCount += callbacks.length;
      }
      return totalCount;
    };
    Emitter.prototype.hasListeners = function(event) {
      return this.listenerCount(event) > 0;
    };
    Emitter.prototype.addEventListener = Emitter.prototype.on;
    Emitter.prototype.removeListener = Emitter.prototype.off;
    Emitter.prototype.removeEventListener = Emitter.prototype.off;
    Emitter.prototype.removeAllListeners = Emitter.prototype.off;
    if (typeof module !== "undefined") {
      module.exports = Emitter;
    }
  }
});

// node_modules/stream/index.js
var require_stream = __commonJS({
  "node_modules/stream/index.js"(exports, module) {
    var Emitter = require_component_emitter();
    function Stream() {
      Emitter.call(this);
    }
    __name(Stream, "Stream");
    Stream.prototype = new Emitter();
    module.exports = Stream;
    Stream.Stream = Stream;
    Stream.prototype.pipe = function(dest, options) {
      var source3 = this;
      function ondata(chunk) {
        if (dest.writable) {
          if (false === dest.write(chunk) && source3.pause) {
            source3.pause();
          }
        }
      }
      __name(ondata, "ondata");
      source3.on("data", ondata);
      function ondrain() {
        if (source3.readable && source3.resume) {
          source3.resume();
        }
      }
      __name(ondrain, "ondrain");
      dest.on("drain", ondrain);
      if (!dest._isStdio && (!options || options.end !== false)) {
        source3.on("end", onend);
        source3.on("close", onclose);
      }
      var didOnEnd = false;
      function onend() {
        if (didOnEnd) return;
        didOnEnd = true;
        dest.end();
      }
      __name(onend, "onend");
      function onclose() {
        if (didOnEnd) return;
        didOnEnd = true;
        if (typeof dest.destroy === "function") dest.destroy();
      }
      __name(onclose, "onclose");
      function onerror(er) {
        cleanup();
        if (!this.hasListeners("error")) {
          throw er;
        }
      }
      __name(onerror, "onerror");
      source3.on("error", onerror);
      dest.on("error", onerror);
      function cleanup() {
        source3.off("data", ondata);
        dest.off("drain", ondrain);
        source3.off("end", onend);
        source3.off("close", onclose);
        source3.off("error", onerror);
        dest.off("error", onerror);
        source3.off("end", cleanup);
        source3.off("close", cleanup);
        dest.off("end", cleanup);
        dest.off("close", cleanup);
      }
      __name(cleanup, "cleanup");
      source3.on("end", cleanup);
      source3.on("close", cleanup);
      dest.on("end", cleanup);
      dest.on("close", cleanup);
      dest.emit("pipe", source3);
      return dest;
    };
  }
});

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports) {
    "use strict";
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i2 = 0, len = code.length; i2 < len; ++i2) {
      lookup[i2] = code[i2];
      revLookup[code.charCodeAt(i2)] = i2;
    }
    var i2;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    __name(getLens, "getLens");
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    __name(byteLength, "byteLength");
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    __name(_byteLength, "_byteLength");
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i3;
      for (i3 = 0; i3 < len2; i3 += 4) {
        tmp = revLookup[b64.charCodeAt(i3)] << 18 | revLookup[b64.charCodeAt(i3 + 1)] << 12 | revLookup[b64.charCodeAt(i3 + 2)] << 6 | revLookup[b64.charCodeAt(i3 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i3)] << 2 | revLookup[b64.charCodeAt(i3 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i3)] << 10 | revLookup[b64.charCodeAt(i3 + 1)] << 4 | revLookup[b64.charCodeAt(i3 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    __name(toByteArray, "toByteArray");
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    __name(tripletToBase64, "tripletToBase64");
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i3 = start; i3 < end; i3 += 3) {
        tmp = (uint8[i3] << 16 & 16711680) + (uint8[i3 + 1] << 8 & 65280) + (uint8[i3 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    __name(encodeChunk, "encodeChunk");
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i3 = 0, len22 = len2 - extraBytes; i3 < len22; i3 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i3, i3 + maxChunkLength > len22 ? len22 : i3 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
    __name(fromByteArray, "fromByteArray");
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports) {
    exports.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e2, m2;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i2 = isLE ? nBytes - 1 : 0;
      var d2 = isLE ? -1 : 1;
      var s2 = buffer[offset + i2];
      i2 += d2;
      e2 = s2 & (1 << -nBits) - 1;
      s2 >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e2 = e2 * 256 + buffer[offset + i2], i2 += d2, nBits -= 8) {
      }
      m2 = e2 & (1 << -nBits) - 1;
      e2 >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m2 = m2 * 256 + buffer[offset + i2], i2 += d2, nBits -= 8) {
      }
      if (e2 === 0) {
        e2 = 1 - eBias;
      } else if (e2 === eMax) {
        return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
      } else {
        m2 = m2 + Math.pow(2, mLen);
        e2 = e2 - eBias;
      }
      return (s2 ? -1 : 1) * m2 * Math.pow(2, e2 - mLen);
    };
    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e2, m2, c2;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i2 = isLE ? 0 : nBytes - 1;
      var d2 = isLE ? 1 : -1;
      var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m2 = isNaN(value) ? 1 : 0;
        e2 = eMax;
      } else {
        e2 = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c2 = Math.pow(2, -e2)) < 1) {
          e2--;
          c2 *= 2;
        }
        if (e2 + eBias >= 1) {
          value += rt / c2;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c2 >= 2) {
          e2++;
          c2 /= 2;
        }
        if (e2 + eBias >= eMax) {
          m2 = 0;
          e2 = eMax;
        } else if (e2 + eBias >= 1) {
          m2 = (value * c2 - 1) * Math.pow(2, mLen);
          e2 = e2 + eBias;
        } else {
          m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e2 = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i2] = m2 & 255, i2 += d2, m2 /= 256, mLen -= 8) {
      }
      e2 = e2 << mLen | m2;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i2] = e2 & 255, i2 += d2, e2 /= 256, eLen -= 8) {
      }
      buffer[offset + i2 - d2] |= s2 * 128;
    };
  }
});

// node_modules/buffer/index.js
var require_buffer = __commonJS({
  "node_modules/buffer/index.js"(exports) {
    "use strict";
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer2;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: /* @__PURE__ */ __name(function() {
          return 42;
        }, "foo") };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e2) {
        return false;
      }
    }
    __name(typedArraySupport, "typedArraySupport");
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        if (!Buffer2.isBuffer(this)) return void 0;
        return this.buffer;
      }, "get")
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        if (!Buffer2.isBuffer(this)) return void 0;
        return this.byteOffset;
      }, "get")
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    __name(createBuffer, "createBuffer");
    function Buffer2(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    __name(Buffer2, "Buffer");
    Buffer2.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer2.from(valueOf, encodingOrOffset, length);
      }
      const b2 = fromObject(value);
      if (b2) return b2;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    __name(from, "from");
    Buffer2.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    __name(assertSize, "assertSize");
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    __name(alloc, "alloc");
    Buffer2.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    __name(allocUnsafe, "allocUnsafe");
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength(string, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    __name(fromString, "fromString");
    function fromArrayLike(array) {
      const length = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length);
      for (let i2 = 0; i2 < length; i2 += 1) {
        buf[i2] = array[i2] & 255;
      }
      return buf;
    }
    __name(fromArrayLike, "fromArrayLike");
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    __name(fromArrayView, "fromArrayView");
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    __name(fromArrayBuffer, "fromArrayBuffer");
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    __name(fromObject, "fromObject");
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    __name(checked, "checked");
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer2.alloc(+length);
    }
    __name(SlowBuffer, "SlowBuffer");
    Buffer2.isBuffer = /* @__PURE__ */ __name(function isBuffer(b2) {
      return b2 != null && b2._isBuffer === true && b2 !== Buffer2.prototype;
    }, "isBuffer");
    Buffer2.compare = /* @__PURE__ */ __name(function compare(a2, b2) {
      if (isInstance(a2, Uint8Array)) a2 = Buffer2.from(a2, a2.offset, a2.byteLength);
      if (isInstance(b2, Uint8Array)) b2 = Buffer2.from(b2, b2.offset, b2.byteLength);
      if (!Buffer2.isBuffer(a2) || !Buffer2.isBuffer(b2)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a2 === b2) return 0;
      let x2 = a2.length;
      let y2 = b2.length;
      for (let i2 = 0, len = Math.min(x2, y2); i2 < len; ++i2) {
        if (a2[i2] !== b2[i2]) {
          x2 = a2[i2];
          y2 = b2[i2];
          break;
        }
      }
      if (x2 < y2) return -1;
      if (y2 < x2) return 1;
      return 0;
    }, "compare");
    Buffer2.isEncoding = /* @__PURE__ */ __name(function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    }, "isEncoding");
    Buffer2.concat = /* @__PURE__ */ __name(function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      let i2;
      if (length === void 0) {
        length = 0;
        for (i2 = 0; i2 < list.length; ++i2) {
          length += list[i2].length;
        }
      }
      const buffer = Buffer2.allocUnsafe(length);
      let pos = 0;
      for (i2 = 0; i2 < list.length; ++i2) {
        let buf = list[i2];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            if (!Buffer2.isBuffer(buf)) buf = Buffer2.from(buf);
            buf.copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer,
              buf,
              pos
            );
          }
        } else if (!Buffer2.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    }, "concat");
    function byteLength(string, encoding) {
      if (Buffer2.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      const len = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0) return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    __name(byteLength, "byteLength");
    Buffer2.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding) encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    __name(slowToString, "slowToString");
    Buffer2.prototype._isBuffer = true;
    function swap(b2, n2, m2) {
      const i2 = b2[n2];
      b2[n2] = b2[m2];
      b2[m2] = i2;
    }
    __name(swap, "swap");
    Buffer2.prototype.swap16 = /* @__PURE__ */ __name(function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i2 = 0; i2 < len; i2 += 2) {
        swap(this, i2, i2 + 1);
      }
      return this;
    }, "swap16");
    Buffer2.prototype.swap32 = /* @__PURE__ */ __name(function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i2 = 0; i2 < len; i2 += 4) {
        swap(this, i2, i2 + 3);
        swap(this, i2 + 1, i2 + 2);
      }
      return this;
    }, "swap32");
    Buffer2.prototype.swap64 = /* @__PURE__ */ __name(function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i2 = 0; i2 < len; i2 += 8) {
        swap(this, i2, i2 + 7);
        swap(this, i2 + 1, i2 + 6);
        swap(this, i2 + 2, i2 + 5);
        swap(this, i2 + 3, i2 + 4);
      }
      return this;
    }, "swap64");
    Buffer2.prototype.toString = /* @__PURE__ */ __name(function toString() {
      const length = this.length;
      if (length === 0) return "";
      if (arguments.length === 0) return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    }, "toString");
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = /* @__PURE__ */ __name(function equals(b2) {
      if (!Buffer2.isBuffer(b2)) throw new TypeError("Argument must be a Buffer");
      if (this === b2) return true;
      return Buffer2.compare(this, b2) === 0;
    }, "equals");
    Buffer2.prototype.inspect = /* @__PURE__ */ __name(function inspect() {
      let str = "";
      const max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max) str += " ... ";
      return "<Buffer " + str + ">";
    }, "inspect");
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = /* @__PURE__ */ __name(function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0;
      let x2 = thisEnd - thisStart;
      let y2 = end - start;
      const len = Math.min(x2, y2);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i2 = 0; i2 < len; ++i2) {
        if (thisCopy[i2] !== targetCopy[i2]) {
          x2 = thisCopy[i2];
          y2 = targetCopy[i2];
          break;
        }
      }
      if (x2 < y2) return -1;
      if (y2 < x2) return 1;
      return 0;
    }, "compare");
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0) return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
      }
      if (typeof val === "string") {
        val = Buffer2.from(val, encoding);
      }
      if (Buffer2.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    __name(bidirectionalIndexOf, "bidirectionalIndexOf");
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i3) {
        if (indexSize === 1) {
          return buf[i3];
        } else {
          return buf.readUInt16BE(i3 * indexSize);
        }
      }
      __name(read, "read");
      let i2;
      if (dir) {
        let foundIndex = -1;
        for (i2 = byteOffset; i2 < arrLength; i2++) {
          if (read(arr, i2) === read(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
            if (foundIndex === -1) foundIndex = i2;
            if (i2 - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i2 -= i2 - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i2 = byteOffset; i2 >= 0; i2--) {
          let found = true;
          for (let j2 = 0; j2 < valLength; j2++) {
            if (read(arr, i2 + j2) !== read(val, j2)) {
              found = false;
              break;
            }
          }
          if (found) return i2;
        }
      }
      return -1;
    }
    __name(arrayIndexOf, "arrayIndexOf");
    Buffer2.prototype.includes = /* @__PURE__ */ __name(function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    }, "includes");
    Buffer2.prototype.indexOf = /* @__PURE__ */ __name(function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    }, "indexOf");
    Buffer2.prototype.lastIndexOf = /* @__PURE__ */ __name(function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    }, "lastIndexOf");
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i2;
      for (i2 = 0; i2 < length; ++i2) {
        const parsed = parseInt(string.substr(i2 * 2, 2), 16);
        if (numberIsNaN(parsed)) return i2;
        buf[offset + i2] = parsed;
      }
      return i2;
    }
    __name(hexWrite, "hexWrite");
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    __name(utf8Write, "utf8Write");
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    __name(asciiWrite, "asciiWrite");
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    __name(base64Write, "base64Write");
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    __name(ucs2Write, "ucs2Write");
    Buffer2.prototype.write = /* @__PURE__ */ __name(function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0) encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining) length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding) encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }, "write");
    Buffer2.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    }, "toJSON");
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    __name(base64Slice, "base64Slice");
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i2 = start;
      while (i2 < end) {
        const firstByte = buf[i2];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i2 + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i2 + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i2 + 1];
              thirdByte = buf[i2 + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i2 + 1];
              thirdByte = buf[i2 + 2];
              fourthByte = buf[i2 + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i2 += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    __name(utf8Slice, "utf8Slice");
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i2 = 0;
      while (i2 < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    __name(decodeCodePointsArray, "decodeCodePointsArray");
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i2 = start; i2 < end; ++i2) {
        ret += String.fromCharCode(buf[i2] & 127);
      }
      return ret;
    }
    __name(asciiSlice, "asciiSlice");
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i2 = start; i2 < end; ++i2) {
        ret += String.fromCharCode(buf[i2]);
      }
      return ret;
    }
    __name(latin1Slice, "latin1Slice");
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;
      let out = "";
      for (let i2 = start; i2 < end; ++i2) {
        out += hexSliceLookupTable[buf[i2]];
      }
      return out;
    }
    __name(hexSlice, "hexSlice");
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i2 = 0; i2 < bytes.length - 1; i2 += 2) {
        res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
      }
      return res;
    }
    __name(utf16leSlice, "utf16leSlice");
    Buffer2.prototype.slice = /* @__PURE__ */ __name(function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start) end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    }, "slice");
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
      if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
    }
    __name(checkOffset, "checkOffset");
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = /* @__PURE__ */ __name(function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i2 = 0;
      while (++i2 < byteLength2 && (mul *= 256)) {
        val += this[offset + i2] * mul;
      }
      return val;
    }, "readUIntLE");
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = /* @__PURE__ */ __name(function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    }, "readUIntBE");
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = /* @__PURE__ */ __name(function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset];
    }, "readUInt8");
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = /* @__PURE__ */ __name(function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    }, "readUInt16LE");
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = /* @__PURE__ */ __name(function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    }, "readUInt16BE");
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = /* @__PURE__ */ __name(function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    }, "readUInt32LE");
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = /* @__PURE__ */ __name(function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    }, "readUInt32BE");
    Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(/* @__PURE__ */ __name(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    }, "readBigUInt64LE"));
    Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(/* @__PURE__ */ __name(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    }, "readBigUInt64BE"));
    Buffer2.prototype.readIntLE = /* @__PURE__ */ __name(function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i2 = 0;
      while (++i2 < byteLength2 && (mul *= 256)) {
        val += this[offset + i2] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    }, "readIntLE");
    Buffer2.prototype.readIntBE = /* @__PURE__ */ __name(function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let i2 = byteLength2;
      let mul = 1;
      let val = this[offset + --i2];
      while (i2 > 0 && (mul *= 256)) {
        val += this[offset + --i2] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    }, "readIntBE");
    Buffer2.prototype.readInt8 = /* @__PURE__ */ __name(function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128)) return this[offset];
      return (255 - this[offset] + 1) * -1;
    }, "readInt8");
    Buffer2.prototype.readInt16LE = /* @__PURE__ */ __name(function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    }, "readInt16LE");
    Buffer2.prototype.readInt16BE = /* @__PURE__ */ __name(function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    }, "readInt16BE");
    Buffer2.prototype.readInt32LE = /* @__PURE__ */ __name(function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    }, "readInt32LE");
    Buffer2.prototype.readInt32BE = /* @__PURE__ */ __name(function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    }, "readInt32BE");
    Buffer2.prototype.readBigInt64LE = defineBigIntMethod(/* @__PURE__ */ __name(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    }, "readBigInt64LE"));
    Buffer2.prototype.readBigInt64BE = defineBigIntMethod(/* @__PURE__ */ __name(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
    }, "readBigInt64BE"));
    Buffer2.prototype.readFloatLE = /* @__PURE__ */ __name(function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    }, "readFloatLE");
    Buffer2.prototype.readFloatBE = /* @__PURE__ */ __name(function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    }, "readFloatBE");
    Buffer2.prototype.readDoubleLE = /* @__PURE__ */ __name(function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    }, "readDoubleLE");
    Buffer2.prototype.readDoubleBE = /* @__PURE__ */ __name(function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    }, "readDoubleBE");
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer2.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
    }
    __name(checkInt, "checkInt");
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = /* @__PURE__ */ __name(function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i2 = 0;
      this[offset] = value & 255;
      while (++i2 < byteLength2 && (mul *= 256)) {
        this[offset + i2] = value / mul & 255;
      }
      return offset + byteLength2;
    }, "writeUIntLE");
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = /* @__PURE__ */ __name(function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i2 = byteLength2 - 1;
      let mul = 1;
      this[offset + i2] = value & 255;
      while (--i2 >= 0 && (mul *= 256)) {
        this[offset + i2] = value / mul & 255;
      }
      return offset + byteLength2;
    }, "writeUIntBE");
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = /* @__PURE__ */ __name(function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    }, "writeUInt8");
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = /* @__PURE__ */ __name(function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    }, "writeUInt16LE");
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = /* @__PURE__ */ __name(function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    }, "writeUInt16BE");
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = /* @__PURE__ */ __name(function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    }, "writeUInt32LE");
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = /* @__PURE__ */ __name(function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    }, "writeUInt32BE");
    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    __name(wrtBigUInt64LE, "wrtBigUInt64LE");
    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    __name(wrtBigUInt64BE, "wrtBigUInt64BE");
    Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(/* @__PURE__ */ __name(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    }, "writeBigUInt64LE"));
    Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(/* @__PURE__ */ __name(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    }, "writeBigUInt64BE"));
    Buffer2.prototype.writeIntLE = /* @__PURE__ */ __name(function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i2 = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i2 < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i2 - 1] !== 0) {
          sub = 1;
        }
        this[offset + i2] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    }, "writeIntLE");
    Buffer2.prototype.writeIntBE = /* @__PURE__ */ __name(function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i2 = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i2] = value & 255;
      while (--i2 >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i2 + 1] !== 0) {
          sub = 1;
        }
        this[offset + i2] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    }, "writeIntBE");
    Buffer2.prototype.writeInt8 = /* @__PURE__ */ __name(function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
      if (value < 0) value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    }, "writeInt8");
    Buffer2.prototype.writeInt16LE = /* @__PURE__ */ __name(function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    }, "writeInt16LE");
    Buffer2.prototype.writeInt16BE = /* @__PURE__ */ __name(function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    }, "writeInt16BE");
    Buffer2.prototype.writeInt32LE = /* @__PURE__ */ __name(function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    }, "writeInt32LE");
    Buffer2.prototype.writeInt32BE = /* @__PURE__ */ __name(function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0) value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    }, "writeInt32BE");
    Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(/* @__PURE__ */ __name(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    }, "writeBigInt64LE"));
    Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(/* @__PURE__ */ __name(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    }, "writeBigInt64BE"));
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
      if (offset < 0) throw new RangeError("Index out of range");
    }
    __name(checkIEEE754, "checkIEEE754");
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    __name(writeFloat, "writeFloat");
    Buffer2.prototype.writeFloatLE = /* @__PURE__ */ __name(function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    }, "writeFloatLE");
    Buffer2.prototype.writeFloatBE = /* @__PURE__ */ __name(function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    }, "writeFloatBE");
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    __name(writeDouble, "writeDouble");
    Buffer2.prototype.writeDoubleLE = /* @__PURE__ */ __name(function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    }, "writeDoubleLE");
    Buffer2.prototype.writeDoubleBE = /* @__PURE__ */ __name(function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    }, "writeDoubleBE");
    Buffer2.prototype.copy = /* @__PURE__ */ __name(function copy(target, targetStart, start, end) {
      if (!Buffer2.isBuffer(target)) throw new TypeError("argument should be a Buffer");
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;
      if (end === start) return 0;
      if (target.length === 0 || this.length === 0) return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
      if (end < 0) throw new RangeError("sourceEnd out of bounds");
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    }, "copy");
    Buffer2.prototype.fill = /* @__PURE__ */ __name(function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val) val = 0;
      let i2;
      if (typeof val === "number") {
        for (i2 = start; i2 < end; ++i2) {
          this[i2] = val;
        }
      } else {
        const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i2 = 0; i2 < end - start; ++i2) {
          this[i2 + start] = bytes[i2 % len];
        }
      }
      return this;
    }, "fill");
    var errors = {};
    function E2(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        static {
          __name(this, "NodeError");
        }
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    __name(E2, "E");
    E2(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name3) {
        if (name3) {
          return `${name3} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E2(
      "ERR_INVALID_ARG_TYPE",
      function(name3, actual) {
        return `The "${name3}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E2(
      "ERR_OUT_OF_RANGE",
      function(str, range, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i2 = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i2 >= start + 4; i2 -= 3) {
        res = `_${val.slice(i2 - 3, i2)}${res}`;
      }
      return `${val.slice(0, i2)}${res}`;
    }
    __name(addNumericalSeparator, "addNumericalSeparator");
    function checkBounds(buf, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
      }
    }
    __name(checkBounds, "checkBounds");
    function checkIntBI(value, min, max, buf, offset, byteLength2) {
      if (value > max || value < min) {
        const n2 = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n2} and < 2${n2} ** ${(byteLength2 + 1) * 8}${n2}`;
          } else {
            range = `>= -(2${n2} ** ${(byteLength2 + 1) * 8 - 1}${n2}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n2}`;
          }
        } else {
          range = `>= ${min}${n2} and <= ${max}${n2}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset, byteLength2);
    }
    __name(checkIntBI, "checkIntBI");
    function validateNumber(value, name3) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name3, "number", value);
      }
    }
    __name(validateNumber, "validateNumber");
    function boundsError(value, length, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
      }
      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(
        type || "offset",
        `>= ${type ? 1 : 0} and <= ${length}`,
        value
      );
    }
    __name(boundsError, "boundsError");
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2) return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    __name(base64clean, "base64clean");
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      let codePoint;
      const length = string.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i2 = 0; i2 < length; ++i2) {
        codePoint = string.charCodeAt(i2);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            } else if (i2 + 1 === length) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0) break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0) break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0) break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0) break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    __name(utf8ToBytes, "utf8ToBytes");
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i2 = 0; i2 < str.length; ++i2) {
        byteArray.push(str.charCodeAt(i2) & 255);
      }
      return byteArray;
    }
    __name(asciiToBytes, "asciiToBytes");
    function utf16leToBytes(str, units) {
      let c2, hi, lo;
      const byteArray = [];
      for (let i2 = 0; i2 < str.length; ++i2) {
        if ((units -= 2) < 0) break;
        c2 = str.charCodeAt(i2);
        hi = c2 >> 8;
        lo = c2 % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    __name(utf16leToBytes, "utf16leToBytes");
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    __name(base64ToBytes, "base64ToBytes");
    function blitBuffer(src, dst, offset, length) {
      let i2;
      for (i2 = 0; i2 < length; ++i2) {
        if (i2 + offset >= dst.length || i2 >= src.length) break;
        dst[i2 + offset] = src[i2];
      }
      return i2;
    }
    __name(blitBuffer, "blitBuffer");
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    __name(isInstance, "isInstance");
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    __name(numberIsNaN, "numberIsNaN");
    var hexSliceLookupTable = function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i2 = 0; i2 < 16; ++i2) {
        const i16 = i2 * 16;
        for (let j2 = 0; j2 < 16; ++j2) {
          table[i16 + j2] = alphabet[i2] + alphabet[j2];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    __name(defineBigIntMethod, "defineBigIntMethod");
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
    __name(BufferBigIntNotDefined, "BufferBigIntNotDefined");
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports, module) {
    var buffer = require_buffer();
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    __name(copyProps, "copyProps");
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    __name(SafeBuffer, "SafeBuffer");
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "node_modules/string_decoder/lib/string_decoder.js"(exports) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc) return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried) return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    __name(_normalizeEncoding, "_normalizeEncoding");
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    __name(normalizeEncoding, "normalizeEncoding");
    exports.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    __name(StringDecoder, "StringDecoder");
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0) return "";
      var r2;
      var i2;
      if (this.lastNeed) {
        r2 = this.fillLast(buf);
        if (r2 === void 0) return "";
        i2 = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i2 = 0;
      }
      if (i2 < buf.length) return r2 ? r2 + this.text(buf, i2) : this.text(buf, i2);
      return r2 || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127) return 0;
      else if (byte >> 5 === 6) return 2;
      else if (byte >> 4 === 14) return 3;
      else if (byte >> 3 === 30) return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    __name(utf8CheckByte, "utf8CheckByte");
    function utf8CheckIncomplete(self, buf, i2) {
      var j2 = buf.length - 1;
      if (j2 < i2) return 0;
      var nb = utf8CheckByte(buf[j2]);
      if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 1;
        return nb;
      }
      if (--j2 < i2 || nb === -2) return 0;
      nb = utf8CheckByte(buf[j2]);
      if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 2;
        return nb;
      }
      if (--j2 < i2 || nb === -2) return 0;
      nb = utf8CheckByte(buf[j2]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2) nb = 0;
          else self.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    __name(utf8CheckIncomplete, "utf8CheckIncomplete");
    function utf8CheckExtraBytes(self, buf, p2) {
      if ((buf[0] & 192) !== 128) {
        self.lastNeed = 0;
        return "\uFFFD";
      }
      if (self.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self.lastNeed = 1;
          return "\uFFFD";
        }
        if (self.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    __name(utf8CheckExtraBytes, "utf8CheckExtraBytes");
    function utf8FillLast(buf) {
      var p2 = this.lastTotal - this.lastNeed;
      var r2 = utf8CheckExtraBytes(this, buf, p2);
      if (r2 !== void 0) return r2;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p2, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p2, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    __name(utf8FillLast, "utf8FillLast");
    function utf8Text(buf, i2) {
      var total = utf8CheckIncomplete(this, buf, i2);
      if (!this.lastNeed) return buf.toString("utf8", i2);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i2, end);
    }
    __name(utf8Text, "utf8Text");
    function utf8End(buf) {
      var r2 = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) return r2 + "\uFFFD";
      return r2;
    }
    __name(utf8End, "utf8End");
    function utf16Text(buf, i2) {
      if ((buf.length - i2) % 2 === 0) {
        var r2 = buf.toString("utf16le", i2);
        if (r2) {
          var c2 = r2.charCodeAt(r2.length - 1);
          if (c2 >= 55296 && c2 <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r2.slice(0, -1);
          }
        }
        return r2;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i2, buf.length - 1);
    }
    __name(utf16Text, "utf16Text");
    function utf16End(buf) {
      var r2 = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r2 + this.lastChar.toString("utf16le", 0, end);
      }
      return r2;
    }
    __name(utf16End, "utf16End");
    function base64Text(buf, i2) {
      var n2 = (buf.length - i2) % 3;
      if (n2 === 0) return buf.toString("base64", i2);
      this.lastNeed = 3 - n2;
      this.lastTotal = 3;
      if (n2 === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i2, buf.length - n2);
    }
    __name(base64Text, "base64Text");
    function base64End(buf) {
      var r2 = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) return r2 + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r2;
    }
    __name(base64End, "base64End");
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    __name(simpleWrite, "simpleWrite");
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
    __name(simpleEnd, "simpleEnd");
  }
});

// node_modules/sax/lib/sax.js
var require_sax = __commonJS({
  "node_modules/sax/lib/sax.js"(exports) {
    (function(sax) {
      sax.parser = function(strict, opt) {
        return new SAXParser(strict, opt);
      };
      sax.SAXParser = SAXParser;
      sax.SAXStream = SAXStream;
      sax.createStream = createStream;
      sax.MAX_BUFFER_LENGTH = 64 * 1024;
      var buffers = [
        "comment",
        "sgmlDecl",
        "textNode",
        "tagName",
        "doctype",
        "procInstName",
        "procInstBody",
        "entity",
        "attribName",
        "attribValue",
        "cdata",
        "script"
      ];
      sax.EVENTS = [
        "text",
        "processinginstruction",
        "sgmldeclaration",
        "doctype",
        "comment",
        "opentagstart",
        "attribute",
        "opentag",
        "closetag",
        "opencdata",
        "cdata",
        "closecdata",
        "error",
        "end",
        "ready",
        "script",
        "opennamespace",
        "closenamespace"
      ];
      function SAXParser(strict, opt) {
        if (!(this instanceof SAXParser)) {
          return new SAXParser(strict, opt);
        }
        var parser = this;
        clearBuffers(parser);
        parser.q = parser.c = "";
        parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
        parser.opt = opt || {};
        parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
        parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
        parser.tags = [];
        parser.closed = parser.closedRoot = parser.sawRoot = false;
        parser.tag = parser.error = null;
        parser.strict = !!strict;
        parser.noscript = !!(strict || parser.opt.noscript);
        parser.state = S2.BEGIN;
        parser.strictEntities = parser.opt.strictEntities;
        parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
        parser.attribList = [];
        if (parser.opt.xmlns) {
          parser.ns = Object.create(rootNS);
        }
        if (parser.opt.unquotedAttributeValues === void 0) {
          parser.opt.unquotedAttributeValues = !strict;
        }
        parser.trackPosition = parser.opt.position !== false;
        if (parser.trackPosition) {
          parser.position = parser.line = parser.column = 0;
        }
        emit(parser, "onready");
      }
      __name(SAXParser, "SAXParser");
      if (!Object.create) {
        Object.create = function(o2) {
          function F2() {
          }
          __name(F2, "F");
          F2.prototype = o2;
          var newf = new F2();
          return newf;
        };
      }
      if (!Object.keys) {
        Object.keys = function(o2) {
          var a2 = [];
          for (var i2 in o2) if (o2.hasOwnProperty(i2)) a2.push(i2);
          return a2;
        };
      }
      function checkBufferLength(parser) {
        var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
        var maxActual = 0;
        for (var i2 = 0, l2 = buffers.length; i2 < l2; i2++) {
          var len = parser[buffers[i2]].length;
          if (len > maxAllowed) {
            switch (buffers[i2]) {
              case "textNode":
                closeText(parser);
                break;
              case "cdata":
                emitNode(parser, "oncdata", parser.cdata);
                parser.cdata = "";
                break;
              case "script":
                emitNode(parser, "onscript", parser.script);
                parser.script = "";
                break;
              default:
                error(parser, "Max buffer length exceeded: " + buffers[i2]);
            }
          }
          maxActual = Math.max(maxActual, len);
        }
        var m2 = sax.MAX_BUFFER_LENGTH - maxActual;
        parser.bufferCheckPosition = m2 + parser.position;
      }
      __name(checkBufferLength, "checkBufferLength");
      function clearBuffers(parser) {
        for (var i2 = 0, l2 = buffers.length; i2 < l2; i2++) {
          parser[buffers[i2]] = "";
        }
      }
      __name(clearBuffers, "clearBuffers");
      function flushBuffers(parser) {
        closeText(parser);
        if (parser.cdata !== "") {
          emitNode(parser, "oncdata", parser.cdata);
          parser.cdata = "";
        }
        if (parser.script !== "") {
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
      }
      __name(flushBuffers, "flushBuffers");
      SAXParser.prototype = {
        end: /* @__PURE__ */ __name(function() {
          end(this);
        }, "end"),
        write,
        resume: /* @__PURE__ */ __name(function() {
          this.error = null;
          return this;
        }, "resume"),
        close: /* @__PURE__ */ __name(function() {
          return this.write(null);
        }, "close"),
        flush: /* @__PURE__ */ __name(function() {
          flushBuffers(this);
        }, "flush")
      };
      var Stream;
      try {
        Stream = require_stream().Stream;
      } catch (ex) {
        Stream = /* @__PURE__ */ __name(function() {
        }, "Stream");
      }
      if (!Stream) Stream = /* @__PURE__ */ __name(function() {
      }, "Stream");
      var streamWraps = sax.EVENTS.filter(function(ev) {
        return ev !== "error" && ev !== "end";
      });
      function createStream(strict, opt) {
        return new SAXStream(strict, opt);
      }
      __name(createStream, "createStream");
      function SAXStream(strict, opt) {
        if (!(this instanceof SAXStream)) {
          return new SAXStream(strict, opt);
        }
        Stream.apply(this);
        this._parser = new SAXParser(strict, opt);
        this.writable = true;
        this.readable = true;
        var me = this;
        this._parser.onend = function() {
          me.emit("end");
        };
        this._parser.onerror = function(er) {
          me.emit("error", er);
          me._parser.error = null;
        };
        this._decoder = null;
        streamWraps.forEach(function(ev) {
          Object.defineProperty(me, "on" + ev, {
            get: /* @__PURE__ */ __name(function() {
              return me._parser["on" + ev];
            }, "get"),
            set: /* @__PURE__ */ __name(function(h2) {
              if (!h2) {
                me.removeAllListeners(ev);
                me._parser["on" + ev] = h2;
                return h2;
              }
              me.on(ev, h2);
            }, "set"),
            enumerable: true,
            configurable: false
          });
        });
      }
      __name(SAXStream, "SAXStream");
      SAXStream.prototype = Object.create(Stream.prototype, {
        constructor: {
          value: SAXStream
        }
      });
      SAXStream.prototype.write = function(data) {
        if (typeof Buffer === "function" && typeof Buffer.isBuffer === "function" && Buffer.isBuffer(data)) {
          if (!this._decoder) {
            var SD = require_string_decoder().StringDecoder;
            this._decoder = new SD("utf8");
          }
          data = this._decoder.write(data);
        }
        this._parser.write(data.toString());
        this.emit("data", data);
        return true;
      };
      SAXStream.prototype.end = function(chunk) {
        if (chunk && chunk.length) {
          this.write(chunk);
        }
        this._parser.end();
        return true;
      };
      SAXStream.prototype.on = function(ev, handler) {
        var me = this;
        if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
          me._parser["on" + ev] = function() {
            var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
            args.splice(0, 0, ev);
            me.emit.apply(me, args);
          };
        }
        return Stream.prototype.on.call(me, ev, handler);
      };
      var CDATA = "[CDATA[";
      var DOCTYPE = "DOCTYPE";
      var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
      var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
      var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
      var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      function isWhitespace(c2) {
        return c2 === " " || c2 === "\n" || c2 === "\r" || c2 === "	";
      }
      __name(isWhitespace, "isWhitespace");
      function isQuote(c2) {
        return c2 === '"' || c2 === "'";
      }
      __name(isQuote, "isQuote");
      function isAttribEnd(c2) {
        return c2 === ">" || isWhitespace(c2);
      }
      __name(isAttribEnd, "isAttribEnd");
      function isMatch(regex, c2) {
        return regex.test(c2);
      }
      __name(isMatch, "isMatch");
      function notMatch(regex, c2) {
        return !isMatch(regex, c2);
      }
      __name(notMatch, "notMatch");
      var S2 = 0;
      sax.STATE = {
        BEGIN: S2++,
        // leading byte order mark or whitespace
        BEGIN_WHITESPACE: S2++,
        // leading whitespace
        TEXT: S2++,
        // general stuff
        TEXT_ENTITY: S2++,
        // &amp and such.
        OPEN_WAKA: S2++,
        // <
        SGML_DECL: S2++,
        // <!BLARG
        SGML_DECL_QUOTED: S2++,
        // <!BLARG foo "bar
        DOCTYPE: S2++,
        // <!DOCTYPE
        DOCTYPE_QUOTED: S2++,
        // <!DOCTYPE "//blah
        DOCTYPE_DTD: S2++,
        // <!DOCTYPE "//blah" [ ...
        DOCTYPE_DTD_QUOTED: S2++,
        // <!DOCTYPE "//blah" [ "foo
        COMMENT_STARTING: S2++,
        // <!-
        COMMENT: S2++,
        // <!--
        COMMENT_ENDING: S2++,
        // <!-- blah -
        COMMENT_ENDED: S2++,
        // <!-- blah --
        CDATA: S2++,
        // <![CDATA[ something
        CDATA_ENDING: S2++,
        // ]
        CDATA_ENDING_2: S2++,
        // ]]
        PROC_INST: S2++,
        // <?hi
        PROC_INST_BODY: S2++,
        // <?hi there
        PROC_INST_ENDING: S2++,
        // <?hi "there" ?
        OPEN_TAG: S2++,
        // <strong
        OPEN_TAG_SLASH: S2++,
        // <strong /
        ATTRIB: S2++,
        // <a
        ATTRIB_NAME: S2++,
        // <a foo
        ATTRIB_NAME_SAW_WHITE: S2++,
        // <a foo _
        ATTRIB_VALUE: S2++,
        // <a foo=
        ATTRIB_VALUE_QUOTED: S2++,
        // <a foo="bar
        ATTRIB_VALUE_CLOSED: S2++,
        // <a foo="bar"
        ATTRIB_VALUE_UNQUOTED: S2++,
        // <a foo=bar
        ATTRIB_VALUE_ENTITY_Q: S2++,
        // <foo bar="&quot;"
        ATTRIB_VALUE_ENTITY_U: S2++,
        // <foo bar=&quot
        CLOSE_TAG: S2++,
        // </a
        CLOSE_TAG_SAW_WHITE: S2++,
        // </a   >
        SCRIPT: S2++,
        // <script> ...
        SCRIPT_ENDING: S2++
        // <script> ... <
      };
      sax.XML_ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'"
      };
      sax.ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'",
        "AElig": 198,
        "Aacute": 193,
        "Acirc": 194,
        "Agrave": 192,
        "Aring": 197,
        "Atilde": 195,
        "Auml": 196,
        "Ccedil": 199,
        "ETH": 208,
        "Eacute": 201,
        "Ecirc": 202,
        "Egrave": 200,
        "Euml": 203,
        "Iacute": 205,
        "Icirc": 206,
        "Igrave": 204,
        "Iuml": 207,
        "Ntilde": 209,
        "Oacute": 211,
        "Ocirc": 212,
        "Ograve": 210,
        "Oslash": 216,
        "Otilde": 213,
        "Ouml": 214,
        "THORN": 222,
        "Uacute": 218,
        "Ucirc": 219,
        "Ugrave": 217,
        "Uuml": 220,
        "Yacute": 221,
        "aacute": 225,
        "acirc": 226,
        "aelig": 230,
        "agrave": 224,
        "aring": 229,
        "atilde": 227,
        "auml": 228,
        "ccedil": 231,
        "eacute": 233,
        "ecirc": 234,
        "egrave": 232,
        "eth": 240,
        "euml": 235,
        "iacute": 237,
        "icirc": 238,
        "igrave": 236,
        "iuml": 239,
        "ntilde": 241,
        "oacute": 243,
        "ocirc": 244,
        "ograve": 242,
        "oslash": 248,
        "otilde": 245,
        "ouml": 246,
        "szlig": 223,
        "thorn": 254,
        "uacute": 250,
        "ucirc": 251,
        "ugrave": 249,
        "uuml": 252,
        "yacute": 253,
        "yuml": 255,
        "copy": 169,
        "reg": 174,
        "nbsp": 160,
        "iexcl": 161,
        "cent": 162,
        "pound": 163,
        "curren": 164,
        "yen": 165,
        "brvbar": 166,
        "sect": 167,
        "uml": 168,
        "ordf": 170,
        "laquo": 171,
        "not": 172,
        "shy": 173,
        "macr": 175,
        "deg": 176,
        "plusmn": 177,
        "sup1": 185,
        "sup2": 178,
        "sup3": 179,
        "acute": 180,
        "micro": 181,
        "para": 182,
        "middot": 183,
        "cedil": 184,
        "ordm": 186,
        "raquo": 187,
        "frac14": 188,
        "frac12": 189,
        "frac34": 190,
        "iquest": 191,
        "times": 215,
        "divide": 247,
        "OElig": 338,
        "oelig": 339,
        "Scaron": 352,
        "scaron": 353,
        "Yuml": 376,
        "fnof": 402,
        "circ": 710,
        "tilde": 732,
        "Alpha": 913,
        "Beta": 914,
        "Gamma": 915,
        "Delta": 916,
        "Epsilon": 917,
        "Zeta": 918,
        "Eta": 919,
        "Theta": 920,
        "Iota": 921,
        "Kappa": 922,
        "Lambda": 923,
        "Mu": 924,
        "Nu": 925,
        "Xi": 926,
        "Omicron": 927,
        "Pi": 928,
        "Rho": 929,
        "Sigma": 931,
        "Tau": 932,
        "Upsilon": 933,
        "Phi": 934,
        "Chi": 935,
        "Psi": 936,
        "Omega": 937,
        "alpha": 945,
        "beta": 946,
        "gamma": 947,
        "delta": 948,
        "epsilon": 949,
        "zeta": 950,
        "eta": 951,
        "theta": 952,
        "iota": 953,
        "kappa": 954,
        "lambda": 955,
        "mu": 956,
        "nu": 957,
        "xi": 958,
        "omicron": 959,
        "pi": 960,
        "rho": 961,
        "sigmaf": 962,
        "sigma": 963,
        "tau": 964,
        "upsilon": 965,
        "phi": 966,
        "chi": 967,
        "psi": 968,
        "omega": 969,
        "thetasym": 977,
        "upsih": 978,
        "piv": 982,
        "ensp": 8194,
        "emsp": 8195,
        "thinsp": 8201,
        "zwnj": 8204,
        "zwj": 8205,
        "lrm": 8206,
        "rlm": 8207,
        "ndash": 8211,
        "mdash": 8212,
        "lsquo": 8216,
        "rsquo": 8217,
        "sbquo": 8218,
        "ldquo": 8220,
        "rdquo": 8221,
        "bdquo": 8222,
        "dagger": 8224,
        "Dagger": 8225,
        "bull": 8226,
        "hellip": 8230,
        "permil": 8240,
        "prime": 8242,
        "Prime": 8243,
        "lsaquo": 8249,
        "rsaquo": 8250,
        "oline": 8254,
        "frasl": 8260,
        "euro": 8364,
        "image": 8465,
        "weierp": 8472,
        "real": 8476,
        "trade": 8482,
        "alefsym": 8501,
        "larr": 8592,
        "uarr": 8593,
        "rarr": 8594,
        "darr": 8595,
        "harr": 8596,
        "crarr": 8629,
        "lArr": 8656,
        "uArr": 8657,
        "rArr": 8658,
        "dArr": 8659,
        "hArr": 8660,
        "forall": 8704,
        "part": 8706,
        "exist": 8707,
        "empty": 8709,
        "nabla": 8711,
        "isin": 8712,
        "notin": 8713,
        "ni": 8715,
        "prod": 8719,
        "sum": 8721,
        "minus": 8722,
        "lowast": 8727,
        "radic": 8730,
        "prop": 8733,
        "infin": 8734,
        "ang": 8736,
        "and": 8743,
        "or": 8744,
        "cap": 8745,
        "cup": 8746,
        "int": 8747,
        "there4": 8756,
        "sim": 8764,
        "cong": 8773,
        "asymp": 8776,
        "ne": 8800,
        "equiv": 8801,
        "le": 8804,
        "ge": 8805,
        "sub": 8834,
        "sup": 8835,
        "nsub": 8836,
        "sube": 8838,
        "supe": 8839,
        "oplus": 8853,
        "otimes": 8855,
        "perp": 8869,
        "sdot": 8901,
        "lceil": 8968,
        "rceil": 8969,
        "lfloor": 8970,
        "rfloor": 8971,
        "lang": 9001,
        "rang": 9002,
        "loz": 9674,
        "spades": 9824,
        "clubs": 9827,
        "hearts": 9829,
        "diams": 9830
      };
      Object.keys(sax.ENTITIES).forEach(function(key) {
        var e2 = sax.ENTITIES[key];
        var s3 = typeof e2 === "number" ? String.fromCharCode(e2) : e2;
        sax.ENTITIES[key] = s3;
      });
      for (var s2 in sax.STATE) {
        sax.STATE[sax.STATE[s2]] = s2;
      }
      S2 = sax.STATE;
      function emit(parser, event, data) {
        parser[event] && parser[event](data);
      }
      __name(emit, "emit");
      function emitNode(parser, nodeType, data) {
        if (parser.textNode) closeText(parser);
        emit(parser, nodeType, data);
      }
      __name(emitNode, "emitNode");
      function closeText(parser) {
        parser.textNode = textopts(parser.opt, parser.textNode);
        if (parser.textNode) emit(parser, "ontext", parser.textNode);
        parser.textNode = "";
      }
      __name(closeText, "closeText");
      function textopts(opt, text) {
        if (opt.trim) text = text.trim();
        if (opt.normalize) text = text.replace(/\s+/g, " ");
        return text;
      }
      __name(textopts, "textopts");
      function error(parser, er) {
        closeText(parser);
        if (parser.trackPosition) {
          er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
        }
        er = new Error(er);
        parser.error = er;
        emit(parser, "onerror", er);
        return parser;
      }
      __name(error, "error");
      function end(parser) {
        if (parser.sawRoot && !parser.closedRoot) strictFail(parser, "Unclosed root tag");
        if (parser.state !== S2.BEGIN && parser.state !== S2.BEGIN_WHITESPACE && parser.state !== S2.TEXT) {
          error(parser, "Unexpected end");
        }
        closeText(parser);
        parser.c = "";
        parser.closed = true;
        emit(parser, "onend");
        SAXParser.call(parser, parser.strict, parser.opt);
        return parser;
      }
      __name(end, "end");
      function strictFail(parser, message) {
        if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
          throw new Error("bad call to strictFail");
        }
        if (parser.strict) {
          error(parser, message);
        }
      }
      __name(strictFail, "strictFail");
      function newTag(parser) {
        if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();
        var parent = parser.tags[parser.tags.length - 1] || parser;
        var tag = parser.tag = { name: parser.tagName, attributes: {} };
        if (parser.opt.xmlns) {
          tag.ns = parent.ns;
        }
        parser.attribList.length = 0;
        emitNode(parser, "onopentagstart", tag);
      }
      __name(newTag, "newTag");
      function qname(name3, attribute) {
        var i2 = name3.indexOf(":");
        var qualName = i2 < 0 ? ["", name3] : name3.split(":");
        var prefix = qualName[0];
        var local = qualName[1];
        if (attribute && name3 === "xmlns") {
          prefix = "xmlns";
          local = "";
        }
        return { prefix, local };
      }
      __name(qname, "qname");
      function attrib(parser) {
        if (!parser.strict) {
          parser.attribName = parser.attribName[parser.looseCase]();
        }
        if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
          parser.attribName = parser.attribValue = "";
          return;
        }
        if (parser.opt.xmlns) {
          var qn = qname(parser.attribName, true);
          var prefix = qn.prefix;
          var local = qn.local;
          if (prefix === "xmlns") {
            if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
              strictFail(
                parser,
                "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue
              );
            } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
              strictFail(
                parser,
                "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue
              );
            } else {
              var tag = parser.tag;
              var parent = parser.tags[parser.tags.length - 1] || parser;
              if (tag.ns === parent.ns) {
                tag.ns = Object.create(parent.ns);
              }
              tag.ns[local] = parser.attribValue;
            }
          }
          parser.attribList.push([parser.attribName, parser.attribValue]);
        } else {
          parser.tag.attributes[parser.attribName] = parser.attribValue;
          emitNode(parser, "onattribute", {
            name: parser.attribName,
            value: parser.attribValue
          });
        }
        parser.attribName = parser.attribValue = "";
      }
      __name(attrib, "attrib");
      function openTag(parser, selfClosing) {
        if (parser.opt.xmlns) {
          var tag = parser.tag;
          var qn = qname(parser.tagName);
          tag.prefix = qn.prefix;
          tag.local = qn.local;
          tag.uri = tag.ns[qn.prefix] || "";
          if (tag.prefix && !tag.uri) {
            strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
            tag.uri = qn.prefix;
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (tag.ns && parent.ns !== tag.ns) {
            Object.keys(tag.ns).forEach(function(p2) {
              emitNode(parser, "onopennamespace", {
                prefix: p2,
                uri: tag.ns[p2]
              });
            });
          }
          for (var i2 = 0, l2 = parser.attribList.length; i2 < l2; i2++) {
            var nv = parser.attribList[i2];
            var name3 = nv[0];
            var value = nv[1];
            var qualName = qname(name3, true);
            var prefix = qualName.prefix;
            var local = qualName.local;
            var uri = prefix === "" ? "" : tag.ns[prefix] || "";
            var a2 = {
              name: name3,
              value,
              prefix,
              local,
              uri
            };
            if (prefix && prefix !== "xmlns" && !uri) {
              strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
              a2.uri = prefix;
            }
            parser.tag.attributes[name3] = a2;
            emitNode(parser, "onattribute", a2);
          }
          parser.attribList.length = 0;
        }
        parser.tag.isSelfClosing = !!selfClosing;
        parser.sawRoot = true;
        parser.tags.push(parser.tag);
        emitNode(parser, "onopentag", parser.tag);
        if (!selfClosing) {
          if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
            parser.state = S2.SCRIPT;
          } else {
            parser.state = S2.TEXT;
          }
          parser.tag = null;
          parser.tagName = "";
        }
        parser.attribName = parser.attribValue = "";
        parser.attribList.length = 0;
      }
      __name(openTag, "openTag");
      function closeTag(parser) {
        if (!parser.tagName) {
          strictFail(parser, "Weird empty close tag.");
          parser.textNode += "</>";
          parser.state = S2.TEXT;
          return;
        }
        if (parser.script) {
          if (parser.tagName !== "script") {
            parser.script += "</" + parser.tagName + ">";
            parser.tagName = "";
            parser.state = S2.SCRIPT;
            return;
          }
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
        var t2 = parser.tags.length;
        var tagName = parser.tagName;
        if (!parser.strict) {
          tagName = tagName[parser.looseCase]();
        }
        var closeTo = tagName;
        while (t2--) {
          var close = parser.tags[t2];
          if (close.name !== closeTo) {
            strictFail(parser, "Unexpected close tag");
          } else {
            break;
          }
        }
        if (t2 < 0) {
          strictFail(parser, "Unmatched closing tag: " + parser.tagName);
          parser.textNode += "</" + parser.tagName + ">";
          parser.state = S2.TEXT;
          return;
        }
        parser.tagName = tagName;
        var s3 = parser.tags.length;
        while (s3-- > t2) {
          var tag = parser.tag = parser.tags.pop();
          parser.tagName = parser.tag.name;
          emitNode(parser, "onclosetag", parser.tagName);
          var x2 = {};
          for (var i2 in tag.ns) {
            x2[i2] = tag.ns[i2];
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (parser.opt.xmlns && tag.ns !== parent.ns) {
            Object.keys(tag.ns).forEach(function(p2) {
              var n2 = tag.ns[p2];
              emitNode(parser, "onclosenamespace", { prefix: p2, uri: n2 });
            });
          }
        }
        if (t2 === 0) parser.closedRoot = true;
        parser.tagName = parser.attribValue = parser.attribName = "";
        parser.attribList.length = 0;
        parser.state = S2.TEXT;
      }
      __name(closeTag, "closeTag");
      function parseEntity(parser) {
        var entity = parser.entity;
        var entityLC = entity.toLowerCase();
        var num;
        var numStr = "";
        if (parser.ENTITIES[entity]) {
          return parser.ENTITIES[entity];
        }
        if (parser.ENTITIES[entityLC]) {
          return parser.ENTITIES[entityLC];
        }
        entity = entityLC;
        if (entity.charAt(0) === "#") {
          if (entity.charAt(1) === "x") {
            entity = entity.slice(2);
            num = parseInt(entity, 16);
            numStr = num.toString(16);
          } else {
            entity = entity.slice(1);
            num = parseInt(entity, 10);
            numStr = num.toString(10);
          }
        }
        entity = entity.replace(/^0+/, "");
        if (isNaN(num) || numStr.toLowerCase() !== entity) {
          strictFail(parser, "Invalid character entity");
          return "&" + parser.entity + ";";
        }
        return String.fromCodePoint(num);
      }
      __name(parseEntity, "parseEntity");
      function beginWhiteSpace(parser, c2) {
        if (c2 === "<") {
          parser.state = S2.OPEN_WAKA;
          parser.startTagPosition = parser.position;
        } else if (!isWhitespace(c2)) {
          strictFail(parser, "Non-whitespace before first tag.");
          parser.textNode = c2;
          parser.state = S2.TEXT;
        }
      }
      __name(beginWhiteSpace, "beginWhiteSpace");
      function charAt(chunk, i2) {
        var result = "";
        if (i2 < chunk.length) {
          result = chunk.charAt(i2);
        }
        return result;
      }
      __name(charAt, "charAt");
      function write(chunk) {
        var parser = this;
        if (this.error) {
          throw this.error;
        }
        if (parser.closed) {
          return error(
            parser,
            "Cannot write after close. Assign an onready handler."
          );
        }
        if (chunk === null) {
          return end(parser);
        }
        if (typeof chunk === "object") {
          chunk = chunk.toString();
        }
        var i2 = 0;
        var c2 = "";
        while (true) {
          c2 = charAt(chunk, i2++);
          parser.c = c2;
          if (!c2) {
            break;
          }
          if (parser.trackPosition) {
            parser.position++;
            if (c2 === "\n") {
              parser.line++;
              parser.column = 0;
            } else {
              parser.column++;
            }
          }
          switch (parser.state) {
            case S2.BEGIN:
              parser.state = S2.BEGIN_WHITESPACE;
              if (c2 === "\uFEFF") {
                continue;
              }
              beginWhiteSpace(parser, c2);
              continue;
            case S2.BEGIN_WHITESPACE:
              beginWhiteSpace(parser, c2);
              continue;
            case S2.TEXT:
              if (parser.sawRoot && !parser.closedRoot) {
                var starti = i2 - 1;
                while (c2 && c2 !== "<" && c2 !== "&") {
                  c2 = charAt(chunk, i2++);
                  if (c2 && parser.trackPosition) {
                    parser.position++;
                    if (c2 === "\n") {
                      parser.line++;
                      parser.column = 0;
                    } else {
                      parser.column++;
                    }
                  }
                }
                parser.textNode += chunk.substring(starti, i2 - 1);
              }
              if (c2 === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                parser.state = S2.OPEN_WAKA;
                parser.startTagPosition = parser.position;
              } else {
                if (!isWhitespace(c2) && (!parser.sawRoot || parser.closedRoot)) {
                  strictFail(parser, "Text data outside of root node.");
                }
                if (c2 === "&") {
                  parser.state = S2.TEXT_ENTITY;
                } else {
                  parser.textNode += c2;
                }
              }
              continue;
            case S2.SCRIPT:
              if (c2 === "<") {
                parser.state = S2.SCRIPT_ENDING;
              } else {
                parser.script += c2;
              }
              continue;
            case S2.SCRIPT_ENDING:
              if (c2 === "/") {
                parser.state = S2.CLOSE_TAG;
              } else {
                parser.script += "<" + c2;
                parser.state = S2.SCRIPT;
              }
              continue;
            case S2.OPEN_WAKA:
              if (c2 === "!") {
                parser.state = S2.SGML_DECL;
                parser.sgmlDecl = "";
              } else if (isWhitespace(c2)) {
              } else if (isMatch(nameStart, c2)) {
                parser.state = S2.OPEN_TAG;
                parser.tagName = c2;
              } else if (c2 === "/") {
                parser.state = S2.CLOSE_TAG;
                parser.tagName = "";
              } else if (c2 === "?") {
                parser.state = S2.PROC_INST;
                parser.procInstName = parser.procInstBody = "";
              } else {
                strictFail(parser, "Unencoded <");
                if (parser.startTagPosition + 1 < parser.position) {
                  var pad = parser.position - parser.startTagPosition;
                  c2 = new Array(pad).join(" ") + c2;
                }
                parser.textNode += "<" + c2;
                parser.state = S2.TEXT;
              }
              continue;
            case S2.SGML_DECL:
              if (parser.sgmlDecl + c2 === "--") {
                parser.state = S2.COMMENT;
                parser.comment = "";
                parser.sgmlDecl = "";
                continue;
              }
              if (parser.doctype && parser.doctype !== true && parser.sgmlDecl) {
                parser.state = S2.DOCTYPE_DTD;
                parser.doctype += "<!" + parser.sgmlDecl + c2;
                parser.sgmlDecl = "";
              } else if ((parser.sgmlDecl + c2).toUpperCase() === CDATA) {
                emitNode(parser, "onopencdata");
                parser.state = S2.CDATA;
                parser.sgmlDecl = "";
                parser.cdata = "";
              } else if ((parser.sgmlDecl + c2).toUpperCase() === DOCTYPE) {
                parser.state = S2.DOCTYPE;
                if (parser.doctype || parser.sawRoot) {
                  strictFail(
                    parser,
                    "Inappropriately located doctype declaration"
                  );
                }
                parser.doctype = "";
                parser.sgmlDecl = "";
              } else if (c2 === ">") {
                emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
                parser.sgmlDecl = "";
                parser.state = S2.TEXT;
              } else if (isQuote(c2)) {
                parser.state = S2.SGML_DECL_QUOTED;
                parser.sgmlDecl += c2;
              } else {
                parser.sgmlDecl += c2;
              }
              continue;
            case S2.SGML_DECL_QUOTED:
              if (c2 === parser.q) {
                parser.state = S2.SGML_DECL;
                parser.q = "";
              }
              parser.sgmlDecl += c2;
              continue;
            case S2.DOCTYPE:
              if (c2 === ">") {
                parser.state = S2.TEXT;
                emitNode(parser, "ondoctype", parser.doctype);
                parser.doctype = true;
              } else {
                parser.doctype += c2;
                if (c2 === "[") {
                  parser.state = S2.DOCTYPE_DTD;
                } else if (isQuote(c2)) {
                  parser.state = S2.DOCTYPE_QUOTED;
                  parser.q = c2;
                }
              }
              continue;
            case S2.DOCTYPE_QUOTED:
              parser.doctype += c2;
              if (c2 === parser.q) {
                parser.q = "";
                parser.state = S2.DOCTYPE;
              }
              continue;
            case S2.DOCTYPE_DTD:
              if (c2 === "]") {
                parser.doctype += c2;
                parser.state = S2.DOCTYPE;
              } else if (c2 === "<") {
                parser.state = S2.OPEN_WAKA;
                parser.startTagPosition = parser.position;
              } else if (isQuote(c2)) {
                parser.doctype += c2;
                parser.state = S2.DOCTYPE_DTD_QUOTED;
                parser.q = c2;
              } else {
                parser.doctype += c2;
              }
              continue;
            case S2.DOCTYPE_DTD_QUOTED:
              parser.doctype += c2;
              if (c2 === parser.q) {
                parser.state = S2.DOCTYPE_DTD;
                parser.q = "";
              }
              continue;
            case S2.COMMENT:
              if (c2 === "-") {
                parser.state = S2.COMMENT_ENDING;
              } else {
                parser.comment += c2;
              }
              continue;
            case S2.COMMENT_ENDING:
              if (c2 === "-") {
                parser.state = S2.COMMENT_ENDED;
                parser.comment = textopts(parser.opt, parser.comment);
                if (parser.comment) {
                  emitNode(parser, "oncomment", parser.comment);
                }
                parser.comment = "";
              } else {
                parser.comment += "-" + c2;
                parser.state = S2.COMMENT;
              }
              continue;
            case S2.COMMENT_ENDED:
              if (c2 !== ">") {
                strictFail(parser, "Malformed comment");
                parser.comment += "--" + c2;
                parser.state = S2.COMMENT;
              } else if (parser.doctype && parser.doctype !== true) {
                parser.state = S2.DOCTYPE_DTD;
              } else {
                parser.state = S2.TEXT;
              }
              continue;
            case S2.CDATA:
              if (c2 === "]") {
                parser.state = S2.CDATA_ENDING;
              } else {
                parser.cdata += c2;
              }
              continue;
            case S2.CDATA_ENDING:
              if (c2 === "]") {
                parser.state = S2.CDATA_ENDING_2;
              } else {
                parser.cdata += "]" + c2;
                parser.state = S2.CDATA;
              }
              continue;
            case S2.CDATA_ENDING_2:
              if (c2 === ">") {
                if (parser.cdata) {
                  emitNode(parser, "oncdata", parser.cdata);
                }
                emitNode(parser, "onclosecdata");
                parser.cdata = "";
                parser.state = S2.TEXT;
              } else if (c2 === "]") {
                parser.cdata += "]";
              } else {
                parser.cdata += "]]" + c2;
                parser.state = S2.CDATA;
              }
              continue;
            case S2.PROC_INST:
              if (c2 === "?") {
                parser.state = S2.PROC_INST_ENDING;
              } else if (isWhitespace(c2)) {
                parser.state = S2.PROC_INST_BODY;
              } else {
                parser.procInstName += c2;
              }
              continue;
            case S2.PROC_INST_BODY:
              if (!parser.procInstBody && isWhitespace(c2)) {
                continue;
              } else if (c2 === "?") {
                parser.state = S2.PROC_INST_ENDING;
              } else {
                parser.procInstBody += c2;
              }
              continue;
            case S2.PROC_INST_ENDING:
              if (c2 === ">") {
                emitNode(parser, "onprocessinginstruction", {
                  name: parser.procInstName,
                  body: parser.procInstBody
                });
                parser.procInstName = parser.procInstBody = "";
                parser.state = S2.TEXT;
              } else {
                parser.procInstBody += "?" + c2;
                parser.state = S2.PROC_INST_BODY;
              }
              continue;
            case S2.OPEN_TAG:
              if (isMatch(nameBody, c2)) {
                parser.tagName += c2;
              } else {
                newTag(parser);
                if (c2 === ">") {
                  openTag(parser);
                } else if (c2 === "/") {
                  parser.state = S2.OPEN_TAG_SLASH;
                } else {
                  if (!isWhitespace(c2)) {
                    strictFail(parser, "Invalid character in tag name");
                  }
                  parser.state = S2.ATTRIB;
                }
              }
              continue;
            case S2.OPEN_TAG_SLASH:
              if (c2 === ">") {
                openTag(parser, true);
                closeTag(parser);
              } else {
                strictFail(parser, "Forward-slash in opening tag not followed by >");
                parser.state = S2.ATTRIB;
              }
              continue;
            case S2.ATTRIB:
              if (isWhitespace(c2)) {
                continue;
              } else if (c2 === ">") {
                openTag(parser);
              } else if (c2 === "/") {
                parser.state = S2.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c2)) {
                parser.attribName = c2;
                parser.attribValue = "";
                parser.state = S2.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S2.ATTRIB_NAME:
              if (c2 === "=") {
                parser.state = S2.ATTRIB_VALUE;
              } else if (c2 === ">") {
                strictFail(parser, "Attribute without value");
                parser.attribValue = parser.attribName;
                attrib(parser);
                openTag(parser);
              } else if (isWhitespace(c2)) {
                parser.state = S2.ATTRIB_NAME_SAW_WHITE;
              } else if (isMatch(nameBody, c2)) {
                parser.attribName += c2;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S2.ATTRIB_NAME_SAW_WHITE:
              if (c2 === "=") {
                parser.state = S2.ATTRIB_VALUE;
              } else if (isWhitespace(c2)) {
                continue;
              } else {
                strictFail(parser, "Attribute without value");
                parser.tag.attributes[parser.attribName] = "";
                parser.attribValue = "";
                emitNode(parser, "onattribute", {
                  name: parser.attribName,
                  value: ""
                });
                parser.attribName = "";
                if (c2 === ">") {
                  openTag(parser);
                } else if (isMatch(nameStart, c2)) {
                  parser.attribName = c2;
                  parser.state = S2.ATTRIB_NAME;
                } else {
                  strictFail(parser, "Invalid attribute name");
                  parser.state = S2.ATTRIB;
                }
              }
              continue;
            case S2.ATTRIB_VALUE:
              if (isWhitespace(c2)) {
                continue;
              } else if (isQuote(c2)) {
                parser.q = c2;
                parser.state = S2.ATTRIB_VALUE_QUOTED;
              } else {
                if (!parser.opt.unquotedAttributeValues) {
                  error(parser, "Unquoted attribute value");
                }
                parser.state = S2.ATTRIB_VALUE_UNQUOTED;
                parser.attribValue = c2;
              }
              continue;
            case S2.ATTRIB_VALUE_QUOTED:
              if (c2 !== parser.q) {
                if (c2 === "&") {
                  parser.state = S2.ATTRIB_VALUE_ENTITY_Q;
                } else {
                  parser.attribValue += c2;
                }
                continue;
              }
              attrib(parser);
              parser.q = "";
              parser.state = S2.ATTRIB_VALUE_CLOSED;
              continue;
            case S2.ATTRIB_VALUE_CLOSED:
              if (isWhitespace(c2)) {
                parser.state = S2.ATTRIB;
              } else if (c2 === ">") {
                openTag(parser);
              } else if (c2 === "/") {
                parser.state = S2.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c2)) {
                strictFail(parser, "No whitespace between attributes");
                parser.attribName = c2;
                parser.attribValue = "";
                parser.state = S2.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S2.ATTRIB_VALUE_UNQUOTED:
              if (!isAttribEnd(c2)) {
                if (c2 === "&") {
                  parser.state = S2.ATTRIB_VALUE_ENTITY_U;
                } else {
                  parser.attribValue += c2;
                }
                continue;
              }
              attrib(parser);
              if (c2 === ">") {
                openTag(parser);
              } else {
                parser.state = S2.ATTRIB;
              }
              continue;
            case S2.CLOSE_TAG:
              if (!parser.tagName) {
                if (isWhitespace(c2)) {
                  continue;
                } else if (notMatch(nameStart, c2)) {
                  if (parser.script) {
                    parser.script += "</" + c2;
                    parser.state = S2.SCRIPT;
                  } else {
                    strictFail(parser, "Invalid tagname in closing tag.");
                  }
                } else {
                  parser.tagName = c2;
                }
              } else if (c2 === ">") {
                closeTag(parser);
              } else if (isMatch(nameBody, c2)) {
                parser.tagName += c2;
              } else if (parser.script) {
                parser.script += "</" + parser.tagName;
                parser.tagName = "";
                parser.state = S2.SCRIPT;
              } else {
                if (!isWhitespace(c2)) {
                  strictFail(parser, "Invalid tagname in closing tag");
                }
                parser.state = S2.CLOSE_TAG_SAW_WHITE;
              }
              continue;
            case S2.CLOSE_TAG_SAW_WHITE:
              if (isWhitespace(c2)) {
                continue;
              }
              if (c2 === ">") {
                closeTag(parser);
              } else {
                strictFail(parser, "Invalid characters in closing tag");
              }
              continue;
            case S2.TEXT_ENTITY:
            case S2.ATTRIB_VALUE_ENTITY_Q:
            case S2.ATTRIB_VALUE_ENTITY_U:
              var returnState;
              var buffer;
              switch (parser.state) {
                case S2.TEXT_ENTITY:
                  returnState = S2.TEXT;
                  buffer = "textNode";
                  break;
                case S2.ATTRIB_VALUE_ENTITY_Q:
                  returnState = S2.ATTRIB_VALUE_QUOTED;
                  buffer = "attribValue";
                  break;
                case S2.ATTRIB_VALUE_ENTITY_U:
                  returnState = S2.ATTRIB_VALUE_UNQUOTED;
                  buffer = "attribValue";
                  break;
              }
              if (c2 === ";") {
                var parsedEntity = parseEntity(parser);
                if (parser.opt.unparsedEntities && !Object.values(sax.XML_ENTITIES).includes(parsedEntity)) {
                  parser.entity = "";
                  parser.state = returnState;
                  parser.write(parsedEntity);
                } else {
                  parser[buffer] += parsedEntity;
                  parser.entity = "";
                  parser.state = returnState;
                }
              } else if (isMatch(parser.entity.length ? entityBody : entityStart, c2)) {
                parser.entity += c2;
              } else {
                strictFail(parser, "Invalid character in entity name");
                parser[buffer] += "&" + parser.entity + c2;
                parser.entity = "";
                parser.state = returnState;
              }
              continue;
            default: {
              throw new Error(parser, "Unknown state: " + parser.state);
            }
          }
        }
        if (parser.position >= parser.bufferCheckPosition) {
          checkBufferLength(parser);
        }
        return parser;
      }
      __name(write, "write");
      if (!String.fromCodePoint) {
        (function() {
          var stringFromCharCode = String.fromCharCode;
          var floor = Math.floor;
          var fromCodePoint = /* @__PURE__ */ __name(function() {
            var MAX_SIZE = 16384;
            var codeUnits = [];
            var highSurrogate;
            var lowSurrogate;
            var index = -1;
            var length = arguments.length;
            if (!length) {
              return "";
            }
            var result = "";
            while (++index < length) {
              var codePoint = Number(arguments[index]);
              if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
              codePoint < 0 || // not a valid Unicode code point
              codePoint > 1114111 || // not a valid Unicode code point
              floor(codePoint) !== codePoint) {
                throw RangeError("Invalid code point: " + codePoint);
              }
              if (codePoint <= 65535) {
                codeUnits.push(codePoint);
              } else {
                codePoint -= 65536;
                highSurrogate = (codePoint >> 10) + 55296;
                lowSurrogate = codePoint % 1024 + 56320;
                codeUnits.push(highSurrogate, lowSurrogate);
              }
              if (index + 1 === length || codeUnits.length > MAX_SIZE) {
                result += stringFromCharCode.apply(null, codeUnits);
                codeUnits.length = 0;
              }
            }
            return result;
          }, "fromCodePoint");
          if (Object.defineProperty) {
            Object.defineProperty(String, "fromCodePoint", {
              value: fromCodePoint,
              configurable: true,
              writable: true
            });
          } else {
            String.fromCodePoint = fromCodePoint;
          }
        })();
      }
    })(typeof exports === "undefined" ? exports.sax = {} : exports);
  }
});

// node_modules/events/events.js
var require_events = __commonJS({
  "node_modules/events/events.js"(exports, module) {
    "use strict";
    var R2 = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R2 && typeof R2.apply === "function" ? R2.apply : /* @__PURE__ */ __name(function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    }, "ReflectApply");
    var ReflectOwnKeys;
    if (R2 && typeof R2.ownKeys === "function") {
      ReflectOwnKeys = R2.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = /* @__PURE__ */ __name(function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      }, "ReflectOwnKeys");
    } else {
      ReflectOwnKeys = /* @__PURE__ */ __name(function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      }, "ReflectOwnKeys");
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn) console.warn(warning);
    }
    __name(ProcessEmitWarning, "ProcessEmitWarning");
    var NumberIsNaN = Number.isNaN || /* @__PURE__ */ __name(function NumberIsNaN2(value) {
      return value !== value;
    }, "NumberIsNaN");
    function EventEmitter() {
      EventEmitter.init.call(this);
    }
    __name(EventEmitter, "EventEmitter");
    module.exports = EventEmitter;
    module.exports.once = once;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._eventsCount = 0;
    EventEmitter.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    __name(checkListener, "checkListener");
    Object.defineProperty(EventEmitter, "defaultMaxListeners", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return defaultMaxListeners;
      }, "get"),
      set: /* @__PURE__ */ __name(function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }, "set")
    });
    EventEmitter.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter.prototype.setMaxListeners = /* @__PURE__ */ __name(function setMaxListeners(n2) {
      if (typeof n2 !== "number" || n2 < 0 || NumberIsNaN(n2)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n2 + ".");
      }
      this._maxListeners = n2;
      return this;
    }, "setMaxListeners");
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter.defaultMaxListeners;
      return that._maxListeners;
    }
    __name(_getMaxListeners, "_getMaxListeners");
    EventEmitter.prototype.getMaxListeners = /* @__PURE__ */ __name(function getMaxListeners() {
      return _getMaxListeners(this);
    }, "getMaxListeners");
    EventEmitter.prototype.emit = /* @__PURE__ */ __name(function emit(type) {
      var args = [];
      for (var i2 = 1; i2 < arguments.length; i2++) args.push(arguments[i2]);
      var doError = type === "error";
      var events = this._events;
      if (events !== void 0)
        doError = doError && events.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i2 = 0; i2 < len; ++i2)
          ReflectApply(listeners[i2], this, args);
      }
      return true;
    }, "emit");
    function _addListener(target, type, listener, prepend) {
      var m2;
      var events;
      var existing;
      checkListener(listener);
      events = target._events;
      if (events === void 0) {
        events = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events = target._events;
        }
        existing = events[type];
      }
      if (existing === void 0) {
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m2 = _getMaxListeners(target);
        if (m2 > 0 && existing.length > m2 && !existing.warned) {
          existing.warned = true;
          var w2 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w2.name = "MaxListenersExceededWarning";
          w2.emitter = target;
          w2.type = type;
          w2.count = existing.length;
          ProcessEmitWarning(w2);
        }
      }
      return target;
    }
    __name(_addListener, "_addListener");
    EventEmitter.prototype.addListener = /* @__PURE__ */ __name(function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    }, "addListener");
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = /* @__PURE__ */ __name(function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    }, "prependListener");
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    __name(onceWrapper, "onceWrapper");
    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    __name(_onceWrap, "_onceWrap");
    EventEmitter.prototype.once = /* @__PURE__ */ __name(function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    }, "once");
    EventEmitter.prototype.prependOnceListener = /* @__PURE__ */ __name(function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    }, "prependOnceListener");
    EventEmitter.prototype.removeListener = /* @__PURE__ */ __name(function removeListener(type, listener) {
      var list, events, position, i2, originalListener;
      checkListener(listener);
      events = this._events;
      if (events === void 0)
        return this;
      list = events[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i2 = list.length - 1; i2 >= 0; i2--) {
          if (list[i2] === listener || list[i2].listener === listener) {
            originalListener = list[i2].listener;
            position = i2;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events[type] = list[0];
        if (events.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    }, "removeListener");
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.removeAllListeners = /* @__PURE__ */ __name(function removeAllListeners(type) {
      var listeners, events, i2;
      events = this._events;
      if (events === void 0)
        return this;
      if (events.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i2 = 0; i2 < keys.length; ++i2) {
          key = keys[i2];
          if (key === "removeListener") continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i2 = listeners.length - 1; i2 >= 0; i2--) {
          this.removeListener(type, listeners[i2]);
        }
      }
      return this;
    }, "removeAllListeners");
    function _listeners(target, type, unwrap) {
      var events = target._events;
      if (events === void 0)
        return [];
      var evlistener = events[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    __name(_listeners, "_listeners");
    EventEmitter.prototype.listeners = /* @__PURE__ */ __name(function listeners(type) {
      return _listeners(this, type, true);
    }, "listeners");
    EventEmitter.prototype.rawListeners = /* @__PURE__ */ __name(function rawListeners(type) {
      return _listeners(this, type, false);
    }, "rawListeners");
    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;
      if (events !== void 0) {
        var evlistener = events[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    __name(listenerCount, "listenerCount");
    EventEmitter.prototype.eventNames = /* @__PURE__ */ __name(function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    }, "eventNames");
    function arrayClone(arr, n2) {
      var copy = new Array(n2);
      for (var i2 = 0; i2 < n2; ++i2)
        copy[i2] = arr[i2];
      return copy;
    }
    __name(arrayClone, "arrayClone");
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }
    __name(spliceOne, "spliceOne");
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i2 = 0; i2 < ret.length; ++i2) {
        ret[i2] = arr[i2].listener || arr[i2];
      }
      return ret;
    }
    __name(unwrapListeners, "unwrapListeners");
    function once(emitter, name3) {
      return new Promise(function(resolve, reject) {
        function errorListener(err) {
          emitter.removeListener(name3, resolver);
          reject(err);
        }
        __name(errorListener, "errorListener");
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        __name(resolver, "resolver");
        ;
        eventTargetAgnosticAddListener(emitter, name3, resolver, { once: true });
        if (name3 !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    __name(once, "once");
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    __name(addErrorHandlerIfEventEmitter, "addErrorHandlerIfEventEmitter");
    function eventTargetAgnosticAddListener(emitter, name3, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name3, listener);
        } else {
          emitter.on(name3, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name3, /* @__PURE__ */ __name(function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name3, wrapListener);
          }
          listener(arg);
        }, "wrapListener"));
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
    __name(eventTargetAgnosticAddListener, "eventTargetAgnosticAddListener");
  }
});

// node_modules/xml2js/lib/bom.js
var require_bom = __commonJS({
  "node_modules/xml2js/lib/bom.js"(exports) {
    (function() {
      "use strict";
      exports.stripBOM = function(str) {
        if (str[0] === "\uFEFF") {
          return str.substring(1);
        } else {
          return str;
        }
      };
    }).call(exports);
  }
});

// node_modules/xml2js/lib/processors.js
var require_processors = __commonJS({
  "node_modules/xml2js/lib/processors.js"(exports) {
    (function() {
      "use strict";
      var prefixMatch;
      prefixMatch = new RegExp(/(?!xmlns)^.*:/);
      exports.normalize = function(str) {
        return str.toLowerCase();
      };
      exports.firstCharLowerCase = function(str) {
        return str.charAt(0).toLowerCase() + str.slice(1);
      };
      exports.stripPrefix = function(str) {
        return str.replace(prefixMatch, "");
      };
      exports.parseNumbers = function(str) {
        if (!isNaN(str)) {
          str = str % 1 === 0 ? parseInt(str, 10) : parseFloat(str);
        }
        return str;
      };
      exports.parseBooleans = function(str) {
        if (/^(?:true|false)$/i.test(str)) {
          str = str.toLowerCase() === "true";
        }
        return str;
      };
    }).call(exports);
  }
});

// node_modules/timers/index.js
var require_timers = __commonJS({
  "node_modules/timers/index.js"(exports) {
    exports.every = function(str) {
      return new Every(str);
    };
    var time = {
      millisecond: 1,
      second: 1e3,
      minute: 6e4,
      hour: 36e5,
      day: 864e5
    };
    for (key in time) {
      if (key === "millisecond") {
        time.ms = time[key];
      } else {
        time[key.charAt(0)] = time[key];
      }
      time[key + "s"] = time[key];
    }
    var key;
    function Every(str) {
      this.count = 0;
      var m2 = parse(str);
      if (m2) {
        this.time = Number(m2[0]) * time[m2[1]];
        this.type = m2[1];
      }
    }
    __name(Every, "Every");
    Every.prototype.do = function(cb) {
      if (this.time) {
        this.interval = setInterval(callback, this.time);
      }
      var that = this;
      function callback() {
        that.count++;
        cb.call(that);
      }
      __name(callback, "callback");
      return this;
    };
    Every.prototype.stop = function() {
      if (this.interval) {
        clearInterval(this.interval);
        delete this.interval;
      }
      return this;
    };
    var reg = /^\s*(\d+(?:\.\d+)?)\s*([a-z]+)\s*$/;
    function parse(str) {
      var m2 = str.match(reg);
      if (m2 && time[m2[2]]) {
        return m2.slice(1);
      }
      return null;
    }
    __name(parse, "parse");
  }
});

// node_modules/xml2js/lib/parser.js
var require_parser = __commonJS({
  "node_modules/xml2js/lib/parser.js"(exports) {
    (function() {
      "use strict";
      var bom, defaults, defineProperty, events, isEmpty, processItem, processors, sax, setImmediate, bind = /* @__PURE__ */ __name(function(fn, me) {
        return function() {
          return fn.apply(me, arguments);
        };
      }, "bind"), extend = /* @__PURE__ */ __name(function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        __name(ctor, "ctor");
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, "extend"), hasProp = {}.hasOwnProperty;
      sax = require_sax();
      events = require_events();
      bom = require_bom();
      processors = require_processors();
      setImmediate = require_timers().setImmediate;
      defaults = require_defaults().defaults;
      isEmpty = /* @__PURE__ */ __name(function(thing) {
        return typeof thing === "object" && thing != null && Object.keys(thing).length === 0;
      }, "isEmpty");
      processItem = /* @__PURE__ */ __name(function(processors2, item, key) {
        var i2, len, process;
        for (i2 = 0, len = processors2.length; i2 < len; i2++) {
          process = processors2[i2];
          item = process(item, key);
        }
        return item;
      }, "processItem");
      defineProperty = /* @__PURE__ */ __name(function(obj, key, value) {
        var descriptor;
        descriptor = /* @__PURE__ */ Object.create(null);
        descriptor.value = value;
        descriptor.writable = true;
        descriptor.enumerable = true;
        descriptor.configurable = true;
        return Object.defineProperty(obj, key, descriptor);
      }, "defineProperty");
      exports.Parser = function(superClass) {
        extend(Parser2, superClass);
        function Parser2(opts) {
          this.parseStringPromise = bind(this.parseStringPromise, this);
          this.parseString = bind(this.parseString, this);
          this.reset = bind(this.reset, this);
          this.assignOrPush = bind(this.assignOrPush, this);
          this.processAsync = bind(this.processAsync, this);
          var key, ref, value;
          if (!(this instanceof exports.Parser)) {
            return new exports.Parser(opts);
          }
          this.options = {};
          ref = defaults["0.2"];
          for (key in ref) {
            if (!hasProp.call(ref, key)) continue;
            value = ref[key];
            this.options[key] = value;
          }
          for (key in opts) {
            if (!hasProp.call(opts, key)) continue;
            value = opts[key];
            this.options[key] = value;
          }
          if (this.options.xmlns) {
            this.options.xmlnskey = this.options.attrkey + "ns";
          }
          if (this.options.normalizeTags) {
            if (!this.options.tagNameProcessors) {
              this.options.tagNameProcessors = [];
            }
            this.options.tagNameProcessors.unshift(processors.normalize);
          }
          this.reset();
        }
        __name(Parser2, "Parser");
        Parser2.prototype.processAsync = function() {
          var chunk, err;
          try {
            if (this.remaining.length <= this.options.chunkSize) {
              chunk = this.remaining;
              this.remaining = "";
              this.saxParser = this.saxParser.write(chunk);
              return this.saxParser.close();
            } else {
              chunk = this.remaining.substr(0, this.options.chunkSize);
              this.remaining = this.remaining.substr(this.options.chunkSize, this.remaining.length);
              this.saxParser = this.saxParser.write(chunk);
              return setImmediate(this.processAsync);
            }
          } catch (error1) {
            err = error1;
            if (!this.saxParser.errThrown) {
              this.saxParser.errThrown = true;
              return this.emit(err);
            }
          }
        };
        Parser2.prototype.assignOrPush = function(obj, key, newValue) {
          if (!(key in obj)) {
            if (!this.options.explicitArray) {
              return defineProperty(obj, key, newValue);
            } else {
              return defineProperty(obj, key, [newValue]);
            }
          } else {
            if (!(obj[key] instanceof Array)) {
              defineProperty(obj, key, [obj[key]]);
            }
            return obj[key].push(newValue);
          }
        };
        Parser2.prototype.reset = function() {
          var attrkey, charkey, ontext, stack;
          this.removeAllListeners();
          this.saxParser = sax.parser(this.options.strict, {
            trim: false,
            normalize: false,
            xmlns: this.options.xmlns
          });
          this.saxParser.errThrown = false;
          this.saxParser.onerror = /* @__PURE__ */ function(_this) {
            return function(error) {
              _this.saxParser.resume();
              if (!_this.saxParser.errThrown) {
                _this.saxParser.errThrown = true;
                return _this.emit("error", error);
              }
            };
          }(this);
          this.saxParser.onend = /* @__PURE__ */ function(_this) {
            return function() {
              if (!_this.saxParser.ended) {
                _this.saxParser.ended = true;
                return _this.emit("end", _this.resultObject);
              }
            };
          }(this);
          this.saxParser.ended = false;
          this.EXPLICIT_CHARKEY = this.options.explicitCharkey;
          this.resultObject = null;
          stack = [];
          attrkey = this.options.attrkey;
          charkey = this.options.charkey;
          this.saxParser.onopentag = /* @__PURE__ */ function(_this) {
            return function(node) {
              var key, newValue, obj, processedKey, ref;
              obj = {};
              obj[charkey] = "";
              if (!_this.options.ignoreAttrs) {
                ref = node.attributes;
                for (key in ref) {
                  if (!hasProp.call(ref, key)) continue;
                  if (!(attrkey in obj) && !_this.options.mergeAttrs) {
                    obj[attrkey] = {};
                  }
                  newValue = _this.options.attrValueProcessors ? processItem(_this.options.attrValueProcessors, node.attributes[key], key) : node.attributes[key];
                  processedKey = _this.options.attrNameProcessors ? processItem(_this.options.attrNameProcessors, key) : key;
                  if (_this.options.mergeAttrs) {
                    _this.assignOrPush(obj, processedKey, newValue);
                  } else {
                    defineProperty(obj[attrkey], processedKey, newValue);
                  }
                }
              }
              obj["#name"] = _this.options.tagNameProcessors ? processItem(_this.options.tagNameProcessors, node.name) : node.name;
              if (_this.options.xmlns) {
                obj[_this.options.xmlnskey] = {
                  uri: node.uri,
                  local: node.local
                };
              }
              return stack.push(obj);
            };
          }(this);
          this.saxParser.onclosetag = /* @__PURE__ */ function(_this) {
            return function() {
              var cdata, emptyStr, key, node, nodeName, obj, objClone, old, s2, xpath;
              obj = stack.pop();
              nodeName = obj["#name"];
              if (!_this.options.explicitChildren || !_this.options.preserveChildrenOrder) {
                delete obj["#name"];
              }
              if (obj.cdata === true) {
                cdata = obj.cdata;
                delete obj.cdata;
              }
              s2 = stack[stack.length - 1];
              if (obj[charkey].match(/^\s*$/) && !cdata) {
                emptyStr = obj[charkey];
                delete obj[charkey];
              } else {
                if (_this.options.trim) {
                  obj[charkey] = obj[charkey].trim();
                }
                if (_this.options.normalize) {
                  obj[charkey] = obj[charkey].replace(/\s{2,}/g, " ").trim();
                }
                obj[charkey] = _this.options.valueProcessors ? processItem(_this.options.valueProcessors, obj[charkey], nodeName) : obj[charkey];
                if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                  obj = obj[charkey];
                }
              }
              if (isEmpty(obj)) {
                if (typeof _this.options.emptyTag === "function") {
                  obj = _this.options.emptyTag();
                } else {
                  obj = _this.options.emptyTag !== "" ? _this.options.emptyTag : emptyStr;
                }
              }
              if (_this.options.validator != null) {
                xpath = "/" + function() {
                  var i2, len, results;
                  results = [];
                  for (i2 = 0, len = stack.length; i2 < len; i2++) {
                    node = stack[i2];
                    results.push(node["#name"]);
                  }
                  return results;
                }().concat(nodeName).join("/");
                (function() {
                  var err;
                  try {
                    return obj = _this.options.validator(xpath, s2 && s2[nodeName], obj);
                  } catch (error1) {
                    err = error1;
                    return _this.emit("error", err);
                  }
                })();
              }
              if (_this.options.explicitChildren && !_this.options.mergeAttrs && typeof obj === "object") {
                if (!_this.options.preserveChildrenOrder) {
                  node = {};
                  if (_this.options.attrkey in obj) {
                    node[_this.options.attrkey] = obj[_this.options.attrkey];
                    delete obj[_this.options.attrkey];
                  }
                  if (!_this.options.charsAsChildren && _this.options.charkey in obj) {
                    node[_this.options.charkey] = obj[_this.options.charkey];
                    delete obj[_this.options.charkey];
                  }
                  if (Object.getOwnPropertyNames(obj).length > 0) {
                    node[_this.options.childkey] = obj;
                  }
                  obj = node;
                } else if (s2) {
                  s2[_this.options.childkey] = s2[_this.options.childkey] || [];
                  objClone = {};
                  for (key in obj) {
                    if (!hasProp.call(obj, key)) continue;
                    defineProperty(objClone, key, obj[key]);
                  }
                  s2[_this.options.childkey].push(objClone);
                  delete obj["#name"];
                  if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                    obj = obj[charkey];
                  }
                }
              }
              if (stack.length > 0) {
                return _this.assignOrPush(s2, nodeName, obj);
              } else {
                if (_this.options.explicitRoot) {
                  old = obj;
                  obj = {};
                  defineProperty(obj, nodeName, old);
                }
                _this.resultObject = obj;
                _this.saxParser.ended = true;
                return _this.emit("end", _this.resultObject);
              }
            };
          }(this);
          ontext = /* @__PURE__ */ function(_this) {
            return function(text) {
              var charChild, s2;
              s2 = stack[stack.length - 1];
              if (s2) {
                s2[charkey] += text;
                if (_this.options.explicitChildren && _this.options.preserveChildrenOrder && _this.options.charsAsChildren && (_this.options.includeWhiteChars || text.replace(/\\n/g, "").trim() !== "")) {
                  s2[_this.options.childkey] = s2[_this.options.childkey] || [];
                  charChild = {
                    "#name": "__text__"
                  };
                  charChild[charkey] = text;
                  if (_this.options.normalize) {
                    charChild[charkey] = charChild[charkey].replace(/\s{2,}/g, " ").trim();
                  }
                  s2[_this.options.childkey].push(charChild);
                }
                return s2;
              }
            };
          }(this);
          this.saxParser.ontext = ontext;
          return this.saxParser.oncdata = /* @__PURE__ */ function(_this) {
            return function(text) {
              var s2;
              s2 = ontext(text);
              if (s2) {
                return s2.cdata = true;
              }
            };
          }(this);
        };
        Parser2.prototype.parseString = function(str, cb) {
          var err;
          if (cb != null && typeof cb === "function") {
            this.on("end", function(result) {
              this.reset();
              return cb(null, result);
            });
            this.on("error", function(err2) {
              this.reset();
              return cb(err2);
            });
          }
          try {
            str = str.toString();
            if (str.trim() === "") {
              this.emit("end", null);
              return true;
            }
            str = bom.stripBOM(str);
            if (this.options.async) {
              this.remaining = str;
              setImmediate(this.processAsync);
              return this.saxParser;
            }
            return this.saxParser.write(str).close();
          } catch (error1) {
            err = error1;
            if (!(this.saxParser.errThrown || this.saxParser.ended)) {
              this.emit("error", err);
              return this.saxParser.errThrown = true;
            } else if (this.saxParser.ended) {
              throw err;
            }
          }
        };
        Parser2.prototype.parseStringPromise = function(str) {
          return new Promise(/* @__PURE__ */ function(_this) {
            return function(resolve, reject) {
              return _this.parseString(str, function(err, value) {
                if (err) {
                  return reject(err);
                } else {
                  return resolve(value);
                }
              });
            };
          }(this));
        };
        return Parser2;
      }(events);
      exports.parseString = function(str, a2, b2) {
        var cb, options, parser;
        if (b2 != null) {
          if (typeof b2 === "function") {
            cb = b2;
          }
          if (typeof a2 === "object") {
            options = a2;
          }
        } else {
          if (typeof a2 === "function") {
            cb = a2;
          }
          options = {};
        }
        parser = new exports.Parser(options);
        return parser.parseString(str, cb);
      };
      exports.parseStringPromise = function(str, a2) {
        var options, parser;
        if (typeof a2 === "object") {
          options = a2;
        }
        parser = new exports.Parser(options);
        return parser.parseStringPromise(str);
      };
    }).call(exports);
  }
});

// node_modules/xml2js/lib/xml2js.js
var require_xml2js = __commonJS({
  "node_modules/xml2js/lib/xml2js.js"(exports) {
    (function() {
      "use strict";
      var builder, defaults, parser, processors, extend = /* @__PURE__ */ __name(function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor() {
          this.constructor = child;
        }
        __name(ctor, "ctor");
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
        child.__super__ = parent.prototype;
        return child;
      }, "extend"), hasProp = {}.hasOwnProperty;
      defaults = require_defaults();
      builder = require_builder();
      parser = require_parser();
      processors = require_processors();
      exports.defaults = defaults.defaults;
      exports.processors = processors;
      exports.ValidationError = function(superClass) {
        extend(ValidationError, superClass);
        function ValidationError(message) {
          this.message = message;
        }
        __name(ValidationError, "ValidationError");
        return ValidationError;
      }(Error);
      exports.Builder = builder.Builder;
      exports.Parser = parser.Parser;
      exports.parseString = parser.parseString;
      exports.parseStringPromise = parser.parseStringPromise;
    }).call(exports);
  }
});

// src/module/handlebars/HandlebarTemplates.ts
var preloadHandlebarsTemplates = /* @__PURE__ */ __name(async () => {
  const templatePaths = [
    // actor tabs
    "systems/shadowrun6-elysium/dist/templates/actor/tabs/ActionsTab.html",
    "systems/shadowrun6-elysium/dist/templates/actor/tabs/BioTab.html",
    "systems/shadowrun6-elysium/dist/templates/actor/tabs/MagicTab.html",
    "systems/shadowrun6-elysium/dist/templates/actor/tabs/MatrixTab.html",
    "systems/shadowrun6-elysium/dist/templates/actor/tabs/MiscTab.html",
    "systems/shadowrun6-elysium/dist/templates/actor/tabs/SkillsTab.html",
    "systems/shadowrun6-elysium/dist/templates/actor/tabs/SocialTab.html",
    "systems/shadowrun6-elysium/dist/templates/actor/tabs/SpellsTab.html",
    "systems/shadowrun6-elysium/dist/templates/actor/tabs/EffectsTab.html",
    "systems/shadowrun6-elysium/dist/templates/actor/tabs/CritterPowersTab.html",
    "systems/shadowrun6-elysium/dist/templates/actor/tabs/NetworkTab.html",
    "systems/shadowrun6-elysium/dist/templates/actor/tabs/InventoryTab.html",
    "systems/shadowrun6-elysium/dist/templates/actor/tabs/DescriptionTab.html",
    "systems/shadowrun6-elysium/dist/templates/actor/tabs/spirit/SpiritSkillsTab.html",
    "systems/shadowrun6-elysium/dist/templates/actor/tabs/matrix/SpriteSkillsTab.html",
    "systems/shadowrun6-elysium/dist/templates/actor/tabs/matrix/SpritePowersTab.html",
    "systems/shadowrun6-elysium/dist/templates/actor/tabs/vehicle/VehicleSkillsTab.html",
    "systems/shadowrun6-elysium/dist/templates/actor/tabs/vehicle/VehicleMatrixTab.html",
    "systems/shadowrun6-elysium/dist/templates/actor/tabs/ic/ICActorTab.html",
    "systems/shadowrun6-elysium/dist/templates/actor/tabs/ic/ICMiscTab.html",
    // uncategorized lists
    "systems/shadowrun6-elysium/dist/templates/actor/parts/Initiative.html",
    "systems/shadowrun6-elysium/dist/templates/actor/parts/ToggleImportFlags.html",
    "systems/shadowrun6-elysium/dist/templates/item/parts/import_flag_button.html",
    "systems/shadowrun6-elysium/dist/templates/actor/parts/Movement.html",
    "systems/shadowrun6-elysium/dist/templates/actor/parts/ProfileImage.html",
    "systems/shadowrun6-elysium/dist/templates/actor/parts/NameInput.html",
    "systems/shadowrun6-elysium/dist/templates/actor/parts/ActionList.html",
    "systems/shadowrun6-elysium/dist/templates/actor/parts/ContactList.html",
    "systems/shadowrun6-elysium/dist/templates/actor/parts/SinAndLifestyleList.html",
    // magic
    "systems/shadowrun6-elysium/dist/templates/actor/parts/magic/AdeptPowerList.html",
    "systems/shadowrun6-elysium/dist/templates/actor/parts/magic/MetamagicList.html",
    "systems/shadowrun6-elysium/dist/templates/actor/parts/magic/RitualList.html",
    "systems/shadowrun6-elysium/dist/templates/actor/parts/magic/SpellList.html",
    "systems/shadowrun6-elysium/dist/templates/actor/parts/magic/SummoningList.html",
    "systems/shadowrun6-elysium/dist/templates/actor/parts/magic/SpiritOptions.html",
    // matrix
    "systems/shadowrun6-elysium/dist/templates/actor/parts/matrix/ProgramList.html",
    "systems/shadowrun6-elysium/dist/templates/actor/parts/matrix/EchoList.html",
    "systems/shadowrun6-elysium/dist/templates/actor/parts/matrix/ComplexFormList.html",
    "systems/shadowrun6-elysium/dist/templates/actor/parts/matrix/CompilationList.html",
    "systems/shadowrun6-elysium/dist/templates/actor/parts/matrix/MatrixAttribute.html",
    "systems/shadowrun6-elysium/dist/templates/actor/parts/matrix/SpritePowerList.html",
    "systems/shadowrun6-elysium/dist/templates/actor/parts/matrix/DeviceRating.html",
    "systems/shadowrun6-elysium/dist/templates/actor/parts/matrix/Marks.html",
    // attributes
    "systems/shadowrun6-elysium/dist/templates/actor/parts/attributes/Attribute.html",
    "systems/shadowrun6-elysium/dist/templates/actor/parts/attributes/FakeAttribute.html",
    "systems/shadowrun6-elysium/dist/templates/actor/parts/attributes/AttributeList.html",
    "systems/shadowrun6-elysium/dist/templates/actor/parts/attributes/SpecialAttributeList.html",
    "systems/shadowrun6-elysium/dist/templates/actor/parts/attributes/Limits.html",
    // skills
    "systems/shadowrun6-elysium/dist/templates/actor/parts/skills/ActiveSkillList.html",
    "systems/shadowrun6-elysium/dist/templates/actor/parts/skills/LanguageAndKnowledgeSkillList.html",
    // vehicle
    "systems/shadowrun6-elysium/dist/templates/actor/parts/vehicle/VehicleStatsList.html",
    "systems/shadowrun6-elysium/dist/templates/actor/parts/vehicle/VehicleSecondStatsList.html",
    "systems/shadowrun6-elysium/dist/templates/actor/parts/vehicle/VehicleMovement.html",
    // IC
    "systems/shadowrun6-elysium/dist/templates/actor/parts/ic/ICStats.html",
    "systems/shadowrun6-elysium/dist/templates/actor/parts/ic/ICConfiguration.html",
    // limited actor
    "systems/shadowrun6-elysium/dist/templates/actor-limited/character.html",
    "systems/shadowrun6-elysium/dist/templates/actor-limited/spirit.html",
    "systems/shadowrun6-elysium/dist/templates/actor-limited/sprite.html",
    "systems/shadowrun6-elysium/dist/templates/actor-limited/vehicle.html",
    "systems/shadowrun6-elysium/dist/templates/actor-limited/critter.html",
    "systems/shadowrun6-elysium/dist/templates/actor-limited/parts/Header.html",
    "systems/shadowrun6-elysium/dist/templates/actor-limited/parts/MiscCharacter.html",
    "systems/shadowrun6-elysium/dist/templates/actor-limited/parts/MiscSpirit.html",
    "systems/shadowrun6-elysium/dist/templates/actor-limited/parts/MiscSprite.html",
    "systems/shadowrun6-elysium/dist/templates/actor-limited/parts/MiscIc.html",
    "systems/shadowrun6-elysium/dist/templates/actor-limited/parts/MiscVehicle.html",
    "systems/shadowrun6-elysium/dist/templates/actor-limited/parts/MiscCritter.html",
    "systems/shadowrun6-elysium/dist/templates/item/parts/description.html",
    "systems/shadowrun6-elysium/dist/templates/item/parts/technology.html",
    "systems/shadowrun6-elysium/dist/templates/item/parts/header.html",
    "systems/shadowrun6-elysium/dist/templates/item/parts/weapon-ammo-list.html",
    "systems/shadowrun6-elysium/dist/templates/item/parts/weapon-mods-list.html",
    "systems/shadowrun6-elysium/dist/templates/item/parts/action.html",
    "systems/shadowrun6-elysium/dist/templates/item/parts/action_results.html",
    "systems/shadowrun6-elysium/dist/templates/item/parts/modifier.html",
    "systems/shadowrun6-elysium/dist/templates/item/parts/damage.html",
    "systems/shadowrun6-elysium/dist/templates/item/parts/opposed.html",
    "systems/shadowrun6-elysium/dist/templates/item/parts/spell.html",
    "systems/shadowrun6-elysium/dist/templates/item/parts/complex_form.html",
    "systems/shadowrun6-elysium/dist/templates/item/parts/weapon.html",
    "systems/shadowrun6-elysium/dist/templates/item/parts/armor.html",
    "systems/shadowrun6-elysium/dist/templates/item/parts/matrix.html",
    "systems/shadowrun6-elysium/dist/templates/item/parts/sin.html",
    "systems/shadowrun6-elysium/dist/templates/item/parts/contact.html",
    "systems/shadowrun6-elysium/dist/templates/item/parts/lifestyle.html",
    "systems/shadowrun6-elysium/dist/templates/item/parts/ammo.html",
    "systems/shadowrun6-elysium/dist/templates/item/parts/modification.html",
    "systems/shadowrun6-elysium/dist/templates/item/parts/program.html",
    "systems/shadowrun6-elysium/dist/templates/item/parts/critter_power.html",
    "systems/shadowrun6-elysium/dist/templates/item/parts/summoning.html",
    "systems/shadowrun6-elysium/dist/templates/item/parts/compilation.html",
    "systems/shadowrun6-elysium/dist/templates/item/parts/ritual.html",
    "systems/shadowrun6-elysium/dist/templates/rolls/parts/parts-list.html",
    "systems/shadowrun6-elysium/dist/templates/rolls/parts/Damage.html",
    // to wrap the bodies of tabs
    "systems/shadowrun6-elysium/dist/templates/common/TabWrapper.html",
    "systems/shadowrun6-elysium/dist/templates/common/ValueInput.html",
    // Useful wrapper and implemented components
    "systems/shadowrun6-elysium/dist/templates/common/ValueMaxAttribute.html",
    "systems/shadowrun6-elysium/dist/templates/common/Attribute.html",
    "systems/shadowrun6-elysium/dist/templates/common/ValueModifiers.html",
    // useful select template for the common pattern
    "systems/shadowrun6-elysium/dist/templates/common/Select.html",
    // to create the condition monitors and edge counter
    "systems/shadowrun6-elysium/dist/templates/common/HorizontalCellInput.html",
    // looks like a ListHeader
    "systems/shadowrun6-elysium/dist/templates/common/HeaderBlock.html",
    "systems/shadowrun6-elysium/dist/templates/common/NameLineBlock.html",
    // list components
    "systems/shadowrun6-elysium/dist/templates/common/List/ListItem.html",
    "systems/shadowrun6-elysium/dist/templates/common/List/ListEntityItem.html",
    "systems/shadowrun6-elysium/dist/templates/common/List/ListHeader.html",
    // dialogs
    "systems/shadowrun6-elysium/dist/templates/apps/dialogs/damage-application.html",
    "systems/shadowrun6-elysium/dist/templates/apps/dialogs/parts/success-test-common.html",
    "systems/shadowrun6-elysium/dist/templates/apps/dialogs/parts/success-test-documents.html",
    "systems/shadowrun6-elysium/dist/templates/apps/dialogs/parts/attack-range-dialog-fragment.html",
    // Test chat messages and their parts
    "systems/shadowrun6-elysium/dist/templates/rolls/success-test-message.html",
    "systems/shadowrun6-elysium/dist/templates/rolls/parts/rolled-dice.html",
    // Modifier management parts
    "systems/shadowrun6-elysium/dist/templates/apps/partials/modifiers-physical.hbs"
  ];
  return loadTemplates(templatePaths);
}, "preloadHandlebarsTemplates");

// src/module/parts/PartsList.ts
var PartsList = class _PartsList {
  static {
    __name(this, "PartsList");
  }
  get list() {
    return this._list.slice();
  }
  get length() {
    return this._list.length;
  }
  /**
   * Return the sum total of the list.
   *
   * This can be used for numerical lists, that need the sum of all their list elements.
   */
  get total() {
    let total = 0;
    for (const part of this._list) {
      if (typeof part.value === "number") {
        total += part.value;
      }
    }
    return total;
  }
  /**
   * Return the last element in the list.
   *
   * This can be used for none numerical parts lists, in which the latest value would be whatever the value is.
   */
  get last() {
    return this._list[this._list.length - 1];
  }
  get isEmpty() {
    return this.length === 0;
  }
  getPartValue(name3) {
    return this._list.find((part) => part.name === name3)?.value;
  }
  clear() {
    this._list.length = 0;
  }
  constructor(parts) {
    let actualParts = [];
    if (parts) {
      if (Array.isArray(parts)) {
        actualParts = parts;
      } else if (typeof parts === "object") {
        for (const [name3, value] of Object.entries(parts)) {
          if (value !== null && value !== void 0) {
            if (!isNaN(Number(name3)) && typeof value === "object") {
              actualParts.push({
                name: value.name,
                value: value.value
              });
            } else {
              actualParts.push({
                name: name3,
                value
              });
            }
          }
        }
      }
    }
    this._list = actualParts;
  }
  addPart(name3, value) {
    this._list.push({
      name: name3,
      value
    });
  }
  addUniquePart(name3, value, overwrite = true) {
    const index = this._list.findIndex((part) => part.name === name3);
    if (index > -1) {
      if (!overwrite) return;
      this._list.splice(index, 1);
      if (value === void 0 || value === null) return;
      this.addUniquePart(name3, value);
    } else if (value !== void 0) {
      this.addPart(name3, value);
    } else {
      console.warn("Shadowrun 6e | PartsList cant add a none-numerical modifier.", name3, value);
    }
  }
  /**
   * Remove all occurences of the given part modifier.
   * 
   * @param name Search parts for this name (exactly)
   * @returns true for when all parts have been removed, otherwise falls.
   */
  removePart(name3) {
    let index = this._list.findIndex((part) => part.name === name3);
    let removed = false;
    while (index > -1) {
      removed = true;
      this._list.splice(index, 1);
      index = this._list.findIndex((part) => part.name === name3);
    }
    return removed;
  }
  /**
   * Check if this part list contains at least one part with a matching name.
   * 
   * @param name Needle in the part list stack
   * @returns true, when a matching part is found.
   */
  hasPart(name3) {
    return this._list.some((part) => part.name === name3);
  }
  getMessageOutput() {
    return this.list;
  }
  static AddPart(list, name3, value) {
    const parts = new _PartsList(list);
    parts.addPart(name3, value);
    return parts._list;
  }
  static AddUniquePart(list, name3, value, overwrite = true) {
    const parts = new _PartsList(list);
    parts.addUniquePart(name3, value, overwrite);
    return parts._list;
  }
  static RemovePart(list, name3) {
    const parts = new _PartsList(list);
    parts.removePart(name3);
    return parts._list;
  }
  static Total(list) {
    const parts = new _PartsList(list);
    return parts.total;
  }
};

// src/module/constants.ts
var SYSTEM_NAME = "shadowrun6-elysium";
var SYSTEM_SOCKET = `system.${SYSTEM_NAME}`;
var FLAGS = {
  DiagonalMovement: "diagonalMovement",
  ShowGlitchAnimation: "showGlitchAnimation",
  ShowTokenNameForChatOutput: "showTokenNameInsteadOfActor",
  OnlyAllowRollOnDefaultableSkills: "onlyAllowRollOnDefaultableSkills",
  ShowSkillsWithDetails: "showSkillsWithDetails",
  OnlyAutoRollNPCInCombat: "onlyAutoRollNPCInCombat",
  MessageCustomRoll: "customRoll",
  ApplyLimits: "applyLimits",
  LastRollPromptValue: "lastRollPromptValue",
  DisplayDefaultRollCard: "displayDefaultRollCard",
  CombatInitiativePass: "combatInitiativePass",
  EmbeddedItems: "embeddedItems",
  LastFireMode: "lastFireMode",
  LastSpellForce: "lastSpellForce",
  LastComplexFormLevel: "lastComplexFormLevel",
  LastFireRange: "lastFireRange",
  Attack: "attack",
  Roll: "roll",
  ActionTestData: "actionTestData",
  TargetsSceneTokenIds: "targetsSceneTokenIds",
  ChangelogShownForVersion: "changelogShownForVersion",
  Modifier: "modifier",
  DoInitPass: "doInitPass",
  DoNextRound: "doNextRound",
  DoNewActionPhase: "doNewActionPhase",
  addNetworkController: "addNetworkController",
  SetDataStorage: "setDataStorage",
  TokenHealthBars: "tokenHealthBars",
  Test: "TestData",
  HideGMOnlyChatContent: "HideGMOnlyChatContent",
  MustHaveRessourcesOnTest: "MustConsumeRessourcesOnTest",
  AutomateMultiDefenseModifier: "AutomateMultiDefenseModifier",
  AutomateProgressiveRecoil: "AutomateProgressiveRecoil",
  TurnsSinceLastAttack: "turnsSinceLastAttack",
  ManualRollOnSuccessTest: "ManualRollOnSuccessTest",
  MarkImports: "MarkImports",
  ImportIconFolder: "ImportIconFolder",
  UseImportIconOverrides: "UseImportIconOverrides",
  CreateTargetedEffects: "CreateTargetedEffects",
  DefaultOpposedTestActorSelection: "DefaultOpposedTestActorSelection",
  TeamworkTestFlow: "TeamworkTestFlow",
  UseDamageCondition: "UseDamageCondition",
  GlobalDataStorage: "GlobalDataStorage"
};
var CORE_NAME = "core";
var CORE_FLAGS = {
  RollMode: "rollMode"
};
var METATYPEMODIFIER = "SR6.Character.Modifiers.NPCMetatypeAttribute";
var LENGTH_UNIT_TO_METERS_MULTIPLIERS = {
  "m": 1,
  "meter": 1,
  "meters": 1,
  "km": 1e3,
  "kilometers": 1e3,
  "kilometer": 1e3
};
var DEFAULT_ROLL_NAME = "Roll";
var LENGTH_UNIT = "m";
var SKILL_DEFAULT_NAME = "";
var DEFAULT_ID_LENGTH = 16;
var SR = {
  combat: {
    // Modifiers to use for the different levels / ranges for environmental modifiers.
    environmental: {
      range_modifiers: {
        short: 0,
        medium: -1,
        long: -3,
        extreme: -6,
        // A modifier of zero will allow for users/gm to still test for targets with their own judgement.
        out_of_range: 0
      },
      levels: {
        good: 0,
        light: -1,
        moderate: -3,
        heavy: -6,
        extreme: -10
      }
    },
    INI_RESULT_MOD_AFTER_INI_PASS: -10,
    INITIAL_INI_PASS: 1,
    INITIAL_INI_ROUND: 1
  },
  die: {
    glitch: [1],
    success: [5, 6]
  },
  defense: {
    spell: {
      direct: {
        mana: "willpower",
        physical: "body"
      }
    }
  },
  attributes: {
    // Use for min/max value ranges (general). This will need expanding for different metatypes, should that ever
    // come to  be.
    // These are the most extreme outer, possible modified values for each attribute.
    ranges: {
      magic: { min: 0 },
      edge: { min: 0 },
      resonance: { min: 0 },
      essence: { min: 0 },
      body: { min: 0 },
      agility: { min: 0 },
      reaction: { min: 0 },
      strength: { min: 0 },
      willpower: { min: 0 },
      logic: { min: 0 },
      intuition: { min: 0 },
      charisma: { min: 0 },
      attack: { min: 0 },
      sleaze: { min: 0 },
      data_processing: { min: 0 },
      firewall: { min: 0 },
      host_rating: { min: 0, max: 12 },
      pilot: { min: 0 },
      force: { min: 0 }
    },
    /**
     * Spirits on creation can have calculated attributes that would lower them to 0 or lower, but still have to have a min value of
     * 1 for each.
     */
    rangesSpirit: {
      magic: { min: 0 },
      edge: { min: 0 },
      essence: { min: 0 },
      body: { min: 1 },
      agility: { min: 1 },
      reaction: { min: 1 },
      strength: { min: 1 },
      willpower: { min: 1 },
      logic: { min: 1 },
      intuition: { min: 1 },
      charisma: { min: 1 },
      pilot: { min: 0 },
      force: { min: 1 }
    },
    // Use for initial default values that aren't simply range.<>.min values.
    defaults: {
      essence: 6
    },
    // Reaction would be displayed as REA, when set to 3.
    SHORT_NAME_LENGTH: 3
  },
  /**
   * Instead of general attributes, these are the attribute ranges for specific actor types
   */
  actorTypeAttributes: {
    vehicle: {
      // These physical attributes don't really exist on a vehicle.
      // System does manage them in regards to GitHub issue #712
      strength: { min: 0 },
      agility: { min: 0 }
    }
  },
  skill: {
    // @PDF SR5#130
    DEFAULTING_MODIFIER: -1,
    SPECIALIZATION_MODIFIER: 2
  },
  initiatives: {
    ic: {
      dice: 4
    },
    ranges: {
      base: { min: 0 },
      dice: { min: 0, max: 5 }
    }
  },
  /**
   * Grunt related npc constant data.
   */
  grunt: {
    metatype_modifiers: {
      elf: {
        attributes: {
          agility: 1,
          charisma: 2,
          edge: -1
        }
      },
      ork: {
        attributes: {
          body: 3,
          strength: 2,
          logic: -1,
          charisma: -1,
          edge: -1
        }
      },
      troll: {
        attributes: {
          body: 4,
          agility: -1,
          strength: 4,
          logic: -1,
          intuition: -1,
          charisma: -2,
          edge: -1
        },
        general: {
          armor: 1
        }
      },
      dwarf: {
        attributes: {
          body: 2,
          reaction: -1,
          strength: 2,
          willpower: 1,
          edge: -1
        }
      }
    }
  }
};

// src/module/rules/RangedWeaponRules.ts
var RangedWeaponRules = {
  /**
   * Apply a distance to a selected target to the configured ranges of the used ranged weapon
   * to determine which range matches the distance.
   *
   * Apply ranges according to SR5#175 section 'Range'.
   * Assume that a distance matches a range up until it's farthest and lowest given value
   * in the 'Range Table' SR5#185 (i.e. the weapon item range configuration).
   *
   * @param distance Distance from the ranged weapon to the target in meters.
   * @param ranges Configured weapon ranges in meters taken from the weapon item configuration.
   * @returns The matching weapon range for the given distance.
   */
  getRangeForTargetDistance(distance, ranges) {
    const rangeKey = Object.keys(ranges).find((range) => distance <= ranges[range].distance);
    if (rangeKey) {
      return ranges[rangeKey];
    } else {
      const { extreme } = ranges;
      return Helpers.createRangeDescription("SR6.OutOfRange", extreme.distance, SR.combat.environmental.range_modifiers.out_of_range);
    }
  },
  /**
   * Calculate recoil compensation based on SR5#175 'Recoil' including SR5#178
   *
   * @param item
   * @returns total amount of recoil compensation to be used when attacking with this item.
   */
  recoilCompensation(item) {
    let compensation = item.recoilCompensation;
    if (item.actor) {
      compensation += item.actor.recoilCompensation;
    }
    return compensation;
  },
  /**
   * Calculate recoil compensation based on SR5#175 'Recoil' including SR5#178
   *
   * @param actor
   * @returns Partial amount of recoil compensation available to this actor
   */
  actorRecoilCompensation(actor) {
    if (actor.isVehicle()) return RangedWeaponRules.vehicleRecoilCompensation(actor);
    else return RangedWeaponRules.humanoidRecoilCompensation(actor);
  },
  /**
   * Vehicle use their own rc calculation according to SR5#176 'Vehicle and Drones and Mounted Weapons'
   *
   * @returns The recoil compensation part a vehicle will add to the total recoil compensation.
   */
  vehicleRecoilCompensation(actor) {
    if (!actor.isVehicle()) return 0;
    const body3 = actor.getAttribute("body");
    return body3 ? body3.value : 0;
  },
  /**
   * Calculate the actual recoil compensation for vehicles number from source values according to SR5#175 'Recoil'
   *
   * @param body The body level of the vehicle
   */
  vehicleRecoilCompensationValue(body3) {
    return Math.max(body3, 0);
  },
  /**
   * Humanoid characters use the default rc calculation according to SR5#175 'Recoil'
   *
   * A humanoid in this case is anything with physical attributes that's not a vehicle.
   * Matrix/Astral actors aren't included.
   *
   * @returns The recoil compensation part a humanoid will add to the total recoil compensation.
   */
  humanoidRecoilCompensation(actor) {
    if (actor.isVehicle() || actor.isIC() || actor.isSprite()) return 0;
    const strength = actor.getAttribute("strength");
    if (!strength) return 0;
    return RangedWeaponRules.humanoidRecoilCompensationValue(strength.value);
  },
  /**
   * Calculate the actual recoil compensation for humanoids number from source values according to SR5#175 'Recoil'
   *
   * @param strength The strength level of the humanoid
   * @param baseRc The base recoil compensation
   * @returns The recoil compensation for a humanoid
   */
  humanoidRecoilCompensationValue(strength) {
    return Math.max(Math.ceil(strength / 3), 0);
  },
  /**
   * Free recoil compensation according to SR5#175 'Recoil'
   * @param baseRc Optional parameter allowing you to define a custom base rc.
   */
  humanoidBaseRecoilCompensation(baseRc = 1) {
    return baseRc;
  },
  /**
   * The number of bullets when reloading during a complex action according to SR5#163 'Reloading Weapons'
   * @param clip The currently used clip
   * @param dex The owning actors dexterity value
   * @returns The number of bullets when reloading during a complex action or -1 if it can only be fully reloaded directly
   */
  partialReload(clip = "", dex = 1) {
    switch (clip) {
      case "internal_magazin":
      case "cylinder":
        return dex;
      case "break_action":
        return 2;
      case "muzzle_loader":
      case "bow":
        return 1;
      default:
        return -1;
    }
  }
};

// src/module/chat.ts
async function createChatMessage(template, templateData) {
  const chatData = await createChatData(template, templateData);
  const message = await ChatMessage.create(chatData);
  if (!message) return null;
  return message;
}
__name(createChatMessage, "createChatMessage");
var createChatData = /* @__PURE__ */ __name(async (template, templateData) => {
  const html = await renderTemplate(template, templateData);
  const chatData = {
    user: game.user?.id,
    speaker: {
      actor: templateData.actor?.id,
      token: templateData.token?.id,
      alias: game.user?.name
    },
    item: templateData.item,
    content: html,
    rollMode: game.settings.get(CORE_NAME, CORE_FLAGS.RollMode)
  };
  ChatMessage.applyRollMode(chatData, chatData.rollMode);
  return chatData;
}, "createChatData");
async function createItemChatMessage(options) {
  const templateData = createChatTemplateData(options);
  return await createChatMessage("systems/shadowrun6-elysium/dist/templates/rolls/item-card.html", templateData);
}
__name(createItemChatMessage, "createItemChatMessage");
function createChatTemplateData(options) {
  let { actor, item, description, tests } = options;
  const token = actor?.getToken();
  const title = game.i18n.localize("SR6.Description");
  return {
    title,
    actor,
    token,
    item,
    description,
    tests
  };
}
__name(createChatTemplateData, "createChatTemplateData");

// src/module/data/DataDefaults.ts
var DataDefaults = class {
  static {
    __name(this, "DataDefaults");
  }
  /**
   * Return a base item data structure with minimal necessary FoundryVTT ItemDataModel fields.
   *
   * @param name Whatever name you want to give but not ''.
   * @param type Whatever item type you want to have
   * @param systemData Whatever partial item system data you want to inject into general model system data.
   * @returns A minimum viable item data structure to use with Item#create
   */
  static baseItemData(itemData, systemData = {}) {
    const name3 = itemData.name ?? "Unnamed";
    const type = itemData.type;
    const modelSystemData = foundry.utils.duplicate(game.model.Item[type]);
    if (!modelSystemData) throw new Error(`FoundryVTT doesn't have item type: ${type} registered`);
    return {
      name: name3,
      type,
      system: foundry.utils.mergeObject(modelSystemData, systemData)
    };
  }
  /**
   * Damage data to hold everything around damaging actors.
   *
   * @param partialDamageData give partial DamageData fields to overwrite default values
   */
  static damageData(partialDamageData = {}) {
    const data = {
      type: {
        base: "physical",
        value: "physical"
      },
      element: {
        base: "",
        value: ""
      },
      base: 0,
      value: 0,
      ap: {
        base: 0,
        value: 0,
        mod: [],
        attribute: "",
        base_formula_operator: "add"
      },
      attribute: "",
      mod: [],
      base_formula_operator: "add",
      source: {
        actorId: "",
        itemId: "",
        itemType: "",
        itemName: ""
      }
    };
    return foundry.utils.mergeObject(data, partialDamageData);
  }
  /**
   * Armor data used within actor documents.
   *
   * @param partialActorArmorData Inject partial armor data
   */
  static actorArmor(partialActorArmorData = {}) {
    return foundry.utils.mergeObject({
      value: 0,
      mod: [],
      base: 0,
      label: "",
      fire: 0,
      electric: 0,
      cold: 0,
      acid: 0,
      hardened: false
    }, partialActorArmorData);
  }
  /**
   * Build a minimal viable action roll data structure.
   *
   * @param partialActionData Inject any minimal action property
   */
  static minimalActionData(partialActionData = {}) {
    return foundry.utils.mergeObject({
      attribute: "",
      attribute2: "",
      skill: "",
      mod: 0,
      armor: false,
      limit: {
        value: 0,
        attribute: "",
        mod: [],
        base: 0
      }
    }, partialActionData);
  }
  /**
   * Build a action data capable of rolling a test.
   *
   * This is used instead of game.model.Item.action.action as fields like armor don't mesh well with TestCreator._mergeMinimalActionDataInOrder
   *
   * @param partialActionRollData
   * @returns
   */
  static actionRollData(partialActionRollData = {}) {
    return foundry.utils.mergeObject({
      type: "",
      categories: [],
      attribute: "",
      attribute2: "",
      skill: "",
      spec: false,
      mod: 0,
      mod_description: "",
      damage: this.damageData(),
      modifiers: [],
      limit: {
        value: 0,
        base: 0,
        attribute: "",
        mod: []
      },
      threshold: {
        value: 0,
        base: 0
      },
      extended: false,
      opposed: {
        test: "",
        type: "",
        attribute: "",
        attribute2: "",
        skill: "",
        mod: 0,
        description: ""
      },
      followed: {
        test: "",
        attribute: "",
        attribute2: "",
        skill: "",
        mod: 0
      },
      alt_mod: 0,
      dice_pool_mod: []
    }, partialActionRollData);
  }
  /**
   * Build a skill field for use in document data
   *
   * @param partialSkillData Inject any skill property
   */
  static skillData(partialSkillData = {}) {
    return foundry.utils.mergeObject({
      name: SKILL_DEFAULT_NAME,
      base: 0,
      value: 0,
      hidden: false,
      canDefault: false,
      label: "",
      bonus: [],
      specs: [],
      mod: [],
      attribute: ""
    }, partialSkillData);
  }
  /**
   * Build a damage track field for use in document data.
   * @param partialTrackData Injet any track property
   * @returns
   */
  static trackData(partialTrackData = {}) {
    return foundry.utils.mergeObject({
      value: 0,
      max: 0,
      label: "",
      mod: [],
      disabled: false,
      wounds: 0
    }, partialTrackData);
  }
  /**
   * Data structure used to reference other document types.
   *
   * Example usage:
   * Host references other IC actors it's able to start in combat.
   *
   * TODO: This uses the v8 old style Document.id pattern instead of v9 style uuid pattern.
   *
   * @param partialSourceEntityData
   * @returns
   */
  static sourceItemData(partialSourceEntityData = {}) {
    return foundry.utils.mergeObject({
      id: "",
      name: "",
      pack: null,
      type: "Actor",
      // @ts-expect-error
      system: partialSourceEntityData.system || void 0
    }, partialSourceEntityData);
  }
  /**
   * Build a numerical value field for use anywhere necessary
   *
   * @param partialValueData Inject any value property
   */
  static valueData(partialValueData = {}) {
    return foundry.utils.mergeObject({
      base: 0,
      value: 0,
      temp: 0,
      mod: [],
      label: ""
    }, partialValueData);
  }
  /**
   * Build a value field holding any value for use anywhere necessary
   * Differs from valueData as it's not only allowing number type values.
   * @param partialGenericValueData Inject any value property
   */
  static genericValueData(partialGenericValueData = {}) {
    return foundry.utils.mergeObject({
      base: 0,
      value: 0,
      temp: 0,
      mod: [],
      label: ""
    }, partialGenericValueData);
  }
  /**
   * Build a fire mode field for use in range weapon data or testing
   *
   * @param partialFireModeData Inject any fire mode property
   */
  static fireModeData(partialFireModeData = {}) {
    return foundry.utils.mergeObject({
      value: 0,
      label: "",
      defense: 0,
      recoil: false,
      suppression: false,
      mode: "single_shot",
      action: "simple"
    }, partialFireModeData);
  }
  static weaponRangeData(partialRangeData = {}) {
    return foundry.utils.mergeObject({
      short: 0,
      medium: 0,
      long: 0,
      extreme: 0,
      category: "manual"
    }, partialRangeData);
  }
  /**
   * Build a description data segment
   *
   * @param partialDescriptionData
   * @returns
   */
  static descriptionData(partialDescriptionData = {}) {
    return foundry.utils.mergeObject({
      value: "",
      chat: "",
      source: ""
    }, partialDescriptionData);
  }
  /**
   * Build a technology data segment
   *
   * @param partialTechnologyData
   * @returns
   */
  static technologyData(partialTechnologyData = {}) {
    return foundry.utils.mergeObject({
      rating: "",
      availability: "",
      quantity: 1,
      cost: 0,
      equipped: false,
      conceal: {
        base: 0,
        value: 0,
        mod: []
      },
      condition_monitor: {
        label: "",
        value: 0,
        max: 0
      },
      wireless: true,
      networkController: void 0
    }, partialTechnologyData);
  }
  /**
   * Build a attribute data segment.
   *
   * @param partialAttributeData
   * @returns Merged of partial and basic attribute data
   */
  static attributeData(partialAttributeData = {}) {
    return foundry.utils.mergeObject({
      value: 0,
      mod: [],
      base: 0,
      label: "",
      hidden: false,
      device_att: "",
      temp: 0,
      limit: ""
    }, partialAttributeData);
  }
};

// src/module/data/DataWrapper.ts
var DataWrapper = class {
  constructor(data) {
    this.data = data;
  }
  static {
    __name(this, "DataWrapper");
  }
};

// src/module/data/SR6ItemDataWrapper.ts
var SR6ItemDataWrapper = class extends DataWrapper {
  static {
    __name(this, "SR6ItemDataWrapper");
  }
  getType() {
    return this.data.type;
  }
  getData() {
    return this.data.system;
  }
  isAreaOfEffect() {
    return this.isGrenade() || this.isAoESpell() || this.isAoEAmmo();
  }
  /** Should only be used to check for actual armor item type.
   * NOTE: Should you only care about a possible armor value use couldHaveArmor instead.
   */
  isArmor() {
    return this.data.type === "armor";
  }
  /** Will give an indicator if an item provides an armor value, without locking into only the Armor item type.
   * NOTE: Should you only care about the armor item type use isArmor instead.
   */
  couldHaveArmor() {
    const armor3 = this.getData().armor;
    return this.isArmor() || armor3 !== void 0;
  }
  hasArmorBase() {
    return this.hasArmor() && !this.getData().armor?.mod;
  }
  hasArmorAccessory() {
    return this.hasArmor() && (this.getData().armor?.mod ?? false);
  }
  hasArmor() {
    return this.getArmorValue() > 0;
  }
  isGrenade() {
    return this.isThrownWeapon() && (this.getData().thrown?.blast.radius ?? 0) > 0;
  }
  isThrownWeapon() {
    if (!this.isWeapon()) return false;
    const weaponData = this.getData();
    return weaponData.category === "thrown";
  }
  isWeapon() {
    return this.data.type === "weapon";
  }
  isModification() {
    return this.data.type === "modification";
  }
  isWeaponModification() {
    if (!this.isModification()) return false;
    const modification = this.data;
    return modification.system.type === "weapon";
  }
  isArmorModification() {
    if (!this.isModification()) return false;
    const modification = this.data;
    return modification.system.type === "armor";
  }
  isVehicleModification() {
    if (!this.isModification()) return false;
    const modification = this.data;
    return modification.system.type === "vehicle";
  }
  isDroneModification() {
    if (!this.isModification()) return false;
    const modification = this.data;
    return modification.system.type === "drone";
  }
  isProgram() {
    return this.data.type === "program";
  }
  isQuality() {
    return this.data.type === "quality";
  }
  isAmmo() {
    return this.data.type === "ammo";
  }
  isAoEAmmo() {
    if (!this.isAmmo()) return false;
    const ammoData = this.getData();
    return (ammoData.blast.radius ?? 0) > 0;
  }
  isCyberware() {
    return this.data.type === "cyberware";
  }
  isBioware() {
    return this.data.type === "bioware";
  }
  isBodyware() {
    return this.isCyberware() || this.isBioware();
  }
  isCombatSpell() {
    if (!this.isSpell()) return false;
    const spellData = this.getData();
    return spellData.category === "combat";
  }
  isDirectCombatSpell() {
    if (!this.isCombatSpell()) return false;
    return this.getData()?.combat?.type === "direct";
  }
  isIndirectCombatSpell() {
    if (!this.isCombatSpell()) return false;
    return this.getData()?.combat?.type === "indirect";
  }
  isManaSpell() {
    if (!this.isSpell()) return false;
    const spellData = this.getData();
    return spellData.type === "mana";
  }
  isPhysicalSpell() {
    if (!this.isSpell()) return false;
    const spellData = this.getData();
    return spellData.type === "physical";
  }
  isRangedWeapon() {
    if (!this.isWeapon()) return false;
    const weaponData = this.getData();
    return weaponData.category === "range";
  }
  isSpell() {
    return this.data.type === "spell";
  }
  isAoESpell() {
    return this.isSpell() && this.getData().range === "los_a";
  }
  isSpritePower() {
    return this.data.type === "sprite_power";
  }
  isComplexForm() {
    return this.data.type === "complex_form";
  }
  isContact() {
    return this.data.type === "contact";
  }
  isCritterPower() {
    return this.data.type === "critter_power";
  }
  isMeleeWeapon() {
    if (!this.isWeapon()) return false;
    const weaponData = this.getData();
    return weaponData.category === "melee";
  }
  isDevice() {
    return this.data.type === "device";
  }
  isEquipment() {
    return this.data.type === "equipment";
  }
  isEquipped() {
    return this.getData().technology?.equipped || false;
  }
  isWireless() {
    return this.getData().technology?.wireless || false;
  }
  isCyberdeck() {
    if (!this.isDevice()) return false;
    const deviceData = this.getData();
    return deviceData.category === "cyberdeck";
  }
  isRCC() {
    if (!this.isDevice()) return false;
    const deviceData = this.getData();
    return deviceData.category === "rcc";
  }
  isCommlink() {
    if (!this.isDevice()) return false;
    const deviceData = this.getData();
    return deviceData.category === "commlink";
  }
  isMatrixAction() {
    return this.isAction() && this.getData().result.success.matrix.placeMarks;
  }
  isSin() {
    return this.data.type === "sin";
  }
  isLifestyle() {
    return this.data.type === "lifestyle";
  }
  getId() {
    return this.data._id;
  }
  get hasSource() {
    return !!this.getData().description?.source;
  }
  getSource() {
    return this.getData().description?.source ?? "";
  }
  getConditionMonitor() {
    return this.getData().technology?.condition_monitor ?? { value: 0, max: 0, label: "" };
  }
  getRating() {
    return this.getData().technology?.rating || 0;
  }
  getArmorValue() {
    return this.getData()?.armor?.value ?? 0;
  }
  getHardened() {
    return this.getData()?.armor?.hardened ?? false;
  }
  getArmorElements() {
    const { fire, electricity, cold, acid, radiation } = this.getData().armor || {};
    return { fire: fire ?? 0, electricity: electricity ?? 0, cold: cold ?? 0, acid: acid ?? 0, radiation: radiation ?? 0 };
  }
  getLinkedActorUuid() {
    return this.getData().linkedActor;
  }
  getName() {
    return this.data.name;
  }
  /**
   * Essence loss of an item is flat value and depends on the quantity of that item
   *
   * Using quantity allows for two approaches:
   * - Add an item twice while still having book essence values
   * - Add an item with quantity 2 while also having book essence values
   * Both are valid.
   *
   * @returns A decimal as essence modifier
   */
  getEssenceLoss() {
    const loss = Number(this.getData()?.essence) ?? 0;
    const quantity = Number(this.getData()?.technology?.quantity) ?? 1;
    return loss * quantity;
  }
  getAmmo() {
    return this.getData().ammo;
  }
  getASDF() {
    if (!this.isDevice()) return void 0;
    const matrix = {
      attack: {
        value: 0,
        device_att: ""
      },
      sleaze: {
        value: 0,
        device_att: ""
      },
      data_processing: {
        value: this.getRating(),
        device_att: ""
      },
      firewall: {
        value: this.getRating(),
        device_att: ""
      }
    };
    if (this.isCyberdeck() || this.isRCC() || this.isCommlink()) {
      const atts = this.getData().atts;
      if (atts) {
        for (let [key, att] of Object.entries(atts)) {
          matrix[att.att].value = att.value;
          matrix[att.att].device_att = key;
        }
      }
    }
    return matrix;
  }
  getQuantity() {
    return this.getData()?.technology?.quantity || 1;
  }
  isAction() {
    return this.data.type === "action";
  }
  getAction() {
    return this.getData().action;
  }
  getActionDicePoolMod() {
    return this.getData().action?.mod;
  }
  getLimitAttribute() {
    return this.getData().action?.limit?.attribute;
  }
  getActionSkill() {
    return this.getData().action?.skill;
  }
  getActionAttribute() {
    return this.getData().action?.attribute;
  }
  getActionAttribute2() {
    return this.getData().action?.attribute2;
  }
  getActionLimit() {
    return this.getData().action?.limit?.value;
  }
  getModifierList() {
    return this.getData().action?.dice_pool_mod || [];
  }
  getActionSpecialization() {
    if (this.getData().action?.spec) return "SR6.Specialization";
    return void 0;
  }
  getDrain() {
    return this.getData().drain || 0;
  }
  isUsingRangeCategory() {
    if (this.isRangedWeapon()) {
      const category3 = this.getData().range?.ranges?.category;
      return !!category3 && category3 !== "manual";
    }
    if (this.isThrownWeapon()) {
      const category3 = this.getData().thrown?.ranges?.category;
      return !!category3 && category3 !== "manual";
    }
    return false;
  }
  getFade() {
    return this.getData().fade || 0;
  }
  getRecoilCompensation() {
    if (!this.isRangedWeapon()) return 0;
    const base = this.getData()?.range?.rc.value ?? "0";
    return Number(base);
  }
  getReach() {
    if (this.isMeleeWeapon()) {
      return this.getData().melee?.reach ?? 0;
    }
    return 0;
  }
  getTechnology() {
    if ("technology" in this.data.system)
      return this.data.system.technology;
  }
  getRange() {
    if (!("range" in this.data.system)) return;
    if (this.data.type === "critter_power")
      return this.data.system.range;
    if (this.data.type === "spell")
      return this.data.system.range;
    if (this.data.type === "weapon")
      return this.data.system.range;
  }
  getModificationCategory() {
    return this.getData().modification_category ?? "";
  }
  getModificationCategorySlots() {
    return this.getData().slots ?? 0;
  }
  hasDefenseTest() {
    return this.getData().action?.opposed?.type === "defense";
  }
  hasAmmo() {
    return !!this.getAmmo();
  }
  getActionResult() {
    return this.getData().result;
  }
};

// src/module/rules/MatrixRules.ts
var MatrixRules = class _MatrixRules {
  static {
    __name(this, "MatrixRules");
  }
  /**
   * Calculate the matrix condition monitor based on SR5#228 'Matrix Damage'
   *
   * The result is round up as for physical and stun monitor (SR5#101), even though it's not specified for
   * matrix monitors specifically.
   *
   * @param deviceRating The device rating of the matrix device for the condition monitor.
   * @return The condition max condition monitor value
   */
  static getConditionMonitor(deviceRating) {
    deviceRating = Math.max(deviceRating, SR.attributes.ranges.host_rating.min);
    return Math.ceil(8 + deviceRating / 2);
  }
  /**
   * Derive the IC device rating based of it's hosts rating based on SR5#247 'Intrusion Countermeasures'
   *
   */
  static getICDeviceRating(hostRating) {
    return Math.max(hostRating, SR.attributes.ranges.host_rating.min);
  }
  /**
   * Derive the IC initiative base value of it's host based on SR5#230 'Hot-SIM VR' and SR5#247 'Intrusion Countermeasures'
   *
   * @param hostRating A positive host rating.
   */
  static getICInitiativeBase(hostRating) {
    return Math.max(hostRating * 2, SR.attributes.ranges.host_rating.min);
  }
  /**
   * Get the amount of initiative dice IC has based on SR5#247 'Intrusion Countermeasures'
   *
   */
  static getICInitiativeDice() {
    return Math.max(SR.initiatives.ic.dice, SR.initiatives.ranges.dice.min);
  }
  /**
   * Derive the base value of any meat attribute an IC uses based on SR5#237 'Matrix actions', SR5#256 'Agents'
   * and SR5#247 'Intrusion Countermeasures'
   *
   */
  static getICMeatAttributeBase(hostRating) {
    return Math.max(hostRating, SR.attributes.ranges.host_rating.min);
  }
  /**
   * Determine if the count of marks (to be placed) is allowed within the rules. SR5#240 'Hack on the Fly'
   * @param marks
   */
  static isValidMarksCount(marks) {
    return marks >= _MatrixRules.minMarksCount() && marks <= _MatrixRules.maxMarksCount() && marks % 1 === 0;
  }
  static maxMarksCount() {
    return 3;
  }
  static minMarksCount() {
    return 0;
  }
  static getValidMarksCount(marks) {
    marks = Math.min(marks, _MatrixRules.maxMarksCount());
    return Math.max(marks, _MatrixRules.minMarksCount());
  }
  /**
   * Derive a hosts attributes ratings based on it's host rating. SR5#247 'Host Attributes'
   * @param hostRating
   */
  static hostMatrixAttributeRatings(hostRating) {
    return [0, 1, 2, 3].map((rating) => rating + hostRating);
  }
};

// src/module/rules/SkillRules.ts
var SkillRules = class _SkillRules {
  static {
    __name(this, "SkillRules");
  }
  /**
   * Determing if a skills value / level makes defaulting necessary.
   *
   * NOTE: A skill can be altered by an effect, which will leave it's base untouched.
   *       Therefore it's calculated value must be used as a level
   *
   * @param skill Any legacy or custom skill
   * @returns true, if a roll for the given skill must default.
   */
  static mustDefaultToRoll(skill) {
    return skill.value === 0;
  }
  /**
   * Allow defaulting a skill role.
   * @PDF SR5#130
   * @param skill Check for this skills ability to be defaulted.
   * @return true will allow for a SuccessTest / role to proceed.
   */
  static allowDefaultingRoll(skill) {
    return skill.canDefault;
  }
  /**
   * Allow a skill role.
   * @PDF SR5#130
   * @param skill Check for this skills ability to be rolled.
   * @return true will allow for a SuccessTest / role to proceed.
   */
  static allowRoll(skill) {
    return !_SkillRules.mustDefaultToRoll(skill) || _SkillRules.allowDefaultingRoll(skill);
  }
  /**
   * Add the defaulting modifier part to a parts list
   * @param parts Should be a PartsList involved with skills.
   */
  static addDefaultingPart(parts) {
    parts.addUniquePart("SR6.Defaulting", _SkillRules.defaultingModifier);
  }
  /**
   * Get the level a specific skill without its attribute.
   * @param skill
   * @param options
   * @param options.specialization If true will add the default specialization bonus onto the level.
   */
  static level(skill, options = { specialization: false }) {
    if (this.mustDefaultToRoll(skill)) {
      return _SkillRules.defaultingModifier;
    }
    const skillValue = typeof skill.value === "number" ? skill.value : 0;
    const specializationBonus = options.specialization ? SR.skill.SPECIALIZATION_MODIFIER : 0;
    return skillValue + specializationBonus;
  }
  static get defaultingModifier() {
    return SR.skill.DEFAULTING_MODIFIER;
  }
  static get SpecializationModifier() {
    return SR.skill.SPECIALIZATION_MODIFIER;
  }
};

// src/module/rolls/SR6Roll.ts
var SR6Roll = class extends Roll {
  static {
    __name(this, "SR6Roll");
  }
  // toJSON(): any {
  //     // TODO: Check if data includes custom ShadowrunRollData
  //     const data = super.toJSON();
  //     // add class Roll to the json so dice-so-nice works
  //     // TODO: Check if this is still necessary.
  //     // data.class = 'Roll';
  //     return data;
  // }
  get sides() {
    if (this.terms) {
      return this.terms[0].results.map((result) => result.result);
    }
    return this.parts[0].rolls.map((roll) => roll.roll);
  }
  get limit() {
    return this.data.limit;
  }
  get threshold() {
    return this.data.threshold;
  }
  get parts() {
    return this.data.parts;
  }
  // TODO: Not needed anymore with complex Formula of SuccessTest
  get explodeSixes() {
    return this.data.explodeSixes;
  }
  count(side) {
    return this.sides.reduce(
      (counted, result) => result === side ? counted + 1 : counted,
      0
    );
  }
  // TODO: Rework this to work with the complex formula of SuccessTest.formula (total counts all cs and cf)
  get hits() {
    return this.sides.reduce(
      (hits, result) => SR.die.success.includes(result) ? hits + 1 : hits,
      0
    );
  }
  get glitches() {
    return this.sides.reduce(
      (glitches, result) => SR.die.glitch.includes(result) ? glitches + 1 : glitches,
      0
    );
  }
  /**
   * The amount of dice going into the throw (the pool used).
   *
   * NOTE: this can be different from the amount of dice actually thrown.
   *       Use SR6Roll#diceThrown instead
   */
  get pool() {
    if (this.terms) {
      return this.dice[0].number;
    }
    return this.parts[0].rolls.length;
  }
  /**
   * The amount of dice actually thrown after all dice explosions have been resolved.
   */
  get poolThrown() {
    return this.sides.length;
  }
  get glitched() {
    return this.glitches > Math.floor(this.pool / 2);
  }
  get total() {
    return this.hits;
  }
};

// src/module/config.ts
var SR6 = {
  itemTypes: {
    action: "SR6.ItemTypes.Action",
    adept_power: "SR6.ItemTypes.AdeptPower",
    ammo: "SR6.ItemTypes.Ammo",
    armor: "SR6.ItemTypes.Armor",
    bioware: "SR6.ItemTypes.Bioware",
    complex_form: "SR6.ItemTypes.ComplexForm",
    contact: "SR6.ItemTypes.Contact",
    critter_power: "SR6.ItemTypes.CritterPower",
    cyberware: "SR6.ItemTypes.Cyberware",
    device: "SR6.ItemTypes.Device",
    echo: "SR6.ItemTypes.Echo",
    equipment: "SR6.ItemTypes.Equipment",
    host: "SR6.ItemTypes.Host",
    lifestyle: "SR6.ItemTypes.Lifestyle",
    metamagic: "SR6.ItemTypes.Metamagic",
    modification: "SR6.ItemTypes.Modification",
    program: "SR6.ItemTypes.Program",
    quality: "SR6.ItemTypes.Quality",
    ritual: "SR6.ItemTypes.Ritual",
    sin: "SR6.ItemTypes.Sin",
    spell: "SR6.ItemTypes.Spell",
    sprite_power: "SR6.ItemTypes.SpritePower",
    weapon: "SR6.ItemTypes.Weapon",
    call_in_action: "TYPES.Item.call_in_action"
  },
  // All available attributes. These are available as testable attributes across all actor types.
  attributes: {
    agility: "SR6.AttrAgility",
    attack: "SR6.MatrixAttrAttack",
    body: "SR6.AttrBody",
    charisma: "SR6.AttrCharisma",
    data_processing: "SR6.MatrixAttrDataProc",
    edge: "SR6.AttrEdge",
    essence: "SR6.AttrEssence",
    firewall: "SR6.MatrixAttrFirewall",
    intuition: "SR6.AttrIntuition",
    logic: "SR6.AttrLogic",
    magic: "SR6.AttrMagic",
    reaction: "SR6.AttrReaction",
    resonance: "SR6.AttrResonance",
    sleaze: "SR6.MatrixAttrSleaze",
    strength: "SR6.AttrStrength",
    willpower: "SR6.AttrWillpower",
    pilot: "SR6.Vehicle.Stats.Pilot",
    force: "SR6.Force",
    initiation: "SR6.Initiation",
    submersion: "SR6.Submersion",
    rating: "SR6.Rating"
  },
  /**
   * All labels for all limits used across all actor and item types.
   */
  limits: {
    physical: "SR6.LimitPhysical",
    social: "SR6.LimitSocial",
    mental: "SR6.LimitMental",
    astral: "SR6.LimitAstral",
    attack: "SR6.MatrixAttrAttack",
    sleaze: "SR6.MatrixAttrSleaze",
    data_processing: "SR6.MatrixAttrDataProc",
    firewall: "SR6.MatrixAttrFirewall",
    speed: "SR6.Vehicle.Stats.Speed",
    sensor: "SR6.Vehicle.Stats.Sensor",
    handling: "SR6.Vehicle.Stats.Handling",
    magic: "SR6.AttrMagic",
    initiation: "SR6.Initiation"
  },
  specialTypes: {
    mundane: "SR6.Mundane",
    magic: "SR6.Awakened",
    resonance: "SR6.Emerged"
  },
  damageTypes: {
    physical: "SR6.DmgTypePhysical",
    stun: "SR6.DmgTypeStun",
    matrix: "SR6.DmgTypeMatrix"
  },
  weaponRangeCategories: {
    manual: {
      label: "SR6.Weapon.Range.Category.Manual"
    },
    taser: {
      label: "SR6.Weapon.Range.Category.Taser",
      ranges: {
        short: 5,
        medium: 10,
        long: 15,
        extreme: 20
      }
    },
    holdOutPistol: {
      label: "SR6.Weapon.Range.Category.HoldOutPistol",
      ranges: {
        short: 5,
        medium: 15,
        long: 30,
        extreme: 50
      }
    },
    lightPistol: {
      label: "SR6.Weapon.Range.Category.LightPistol",
      ranges: {
        short: 5,
        medium: 15,
        long: 30,
        extreme: 50
      }
    },
    heavyPistol: {
      label: "SR6.Weapon.Range.Category.HeavyPistol",
      ranges: {
        short: 5,
        medium: 20,
        long: 40,
        extreme: 60
      }
    },
    machinePistol: {
      label: "SR6.Weapon.Range.Category.MachinePistol",
      ranges: {
        short: 5,
        medium: 15,
        long: 30,
        extreme: 50
      }
    },
    smg: {
      label: "SR6.Weapon.Range.Category.SMG",
      ranges: {
        short: 10,
        medium: 40,
        long: 80,
        extreme: 150
      }
    },
    assaultRifle: {
      label: "SR6.Weapon.Range.Category.AssaultRifle",
      ranges: {
        short: 25,
        medium: 150,
        long: 350,
        extreme: 550
      }
    },
    shotgunFlechette: {
      label: "SR6.Weapon.Range.Category.ShotgunFlechette",
      ranges: {
        short: 15,
        medium: 30,
        long: 45,
        extreme: 60
      }
    },
    shotgunSlug: {
      label: "SR6.Weapon.Range.Category.ShotgunSlug",
      ranges: {
        short: 10,
        medium: 40,
        long: 80,
        extreme: 150
      }
    },
    sniperRifle: {
      label: "SR6.Weapon.Range.Category.SniperRifle",
      ranges: {
        short: 50,
        medium: 350,
        long: 800,
        extreme: 1500
      }
    },
    sportingRifle: {
      label: "SR6.Weapon.Range.Category.SportingRifle",
      ranges: {
        short: 50,
        medium: 250,
        long: 500,
        extreme: 750
      }
    },
    lightMachinegun: {
      label: "SR6.Weapon.Range.Category.LightMachinegun",
      ranges: {
        short: 25,
        medium: 200,
        long: 400,
        extreme: 800
      }
    },
    mediumHeavyMachinegun: {
      label: "SR6.Weapon.Range.Category.MediumHeavyMachinegun",
      ranges: {
        short: 40,
        medium: 250,
        long: 750,
        extreme: 1200
      }
    },
    assaultCannon: {
      label: "SR6.Weapon.Range.Category.AssaultCannon",
      ranges: {
        short: 50,
        medium: 300,
        long: 750,
        extreme: 1500
      }
    },
    grenadeLauncher: {
      label: "SR6.Weapon.Range.Category.GrenadeLauncher",
      ranges: {
        short: 50,
        medium: 100,
        long: 150,
        extreme: 500
      }
    },
    missileLauncher: {
      label: "SR6.Weapon.Range.Category.MissileLauncher",
      ranges: {
        short: 70,
        medium: 150,
        long: 450,
        extreme: 1500
      }
    },
    bow: {
      label: "SR6.Weapon.Range.Category.Bow",
      ranges: {
        short: 1,
        medium: 10,
        long: 30,
        extreme: 60,
        attribute: "strength"
      }
    },
    lightCrossbow: {
      label: "SR6.Weapon.Range.Category.LightCrossbow",
      ranges: {
        short: 6,
        medium: 24,
        long: 60,
        extreme: 120
      }
    },
    mediumCrossbow: {
      label: "SR6.Weapon.Range.Category.MediumCrossbow",
      ranges: {
        short: 9,
        medium: 36,
        long: 90,
        extreme: 150
      }
    },
    heavyCrossbow: {
      label: "SR6.Weapon.Range.Category.HeavyCrossbow",
      ranges: {
        short: 15,
        medium: 45,
        long: 120,
        extreme: 180
      }
    },
    thrownKnife: {
      label: "SR6.Weapon.Range.Category.ThrownKnife",
      ranges: {
        short: 1,
        medium: 2,
        long: 3,
        extreme: 5,
        attribute: "strength"
      }
    },
    net: {
      label: "SR6.Weapon.Range.Category.Net",
      ranges: {
        short: 0.5,
        medium: 1,
        long: 1.5,
        extreme: 2.5,
        attribute: "strength"
      }
    },
    shuriken: {
      label: "SR6.Weapon.Range.Category.Shuriken",
      ranges: {
        short: 1,
        medium: 2,
        long: 5,
        extreme: 7,
        attribute: "strength"
      }
    },
    standardThrownGrenade: {
      label: "SR6.Weapon.Range.Category.StandardThrownGrenade",
      ranges: {
        short: 2,
        medium: 4,
        long: 6,
        extreme: 10,
        attribute: "strength"
      }
    },
    aerodynamicThrownGrenade: {
      label: "SR6.Weapon.Range.Category.AerodynamicThrownGrenade",
      ranges: {
        short: 2,
        medium: 4,
        long: 8,
        extreme: 15,
        attribute: "strength"
      }
    },
    harpoonGun: {
      label: "SR6.Weapon.Range.Category.HarpoonGun",
      ranges: {
        short: 5,
        medium: 20,
        long: 40,
        extreme: 60
      }
    },
    harpoonGunUnderwater: {
      label: "SR6.Weapon.Range.Category.HarpoonGunUnderwater",
      ranges: {
        short: 6,
        medium: 24,
        long: 60,
        extreme: 120
      }
    },
    flamethrower: {
      label: "SR6.Weapon.Range.Category.Flamethrower",
      ranges: {
        short: 15,
        medium: 20,
        long: -1,
        extreme: -1
      }
    }
  },
  elementTypes: {
    fire: "SR6.ElementFire",
    cold: "SR6.ElementCold",
    acid: "SR6.ElementAcid",
    electricity: "SR6.ElementElectricity",
    radiation: "SR6.ElementRadiation"
  },
  spellCategories: {
    combat: "SR6.Spell.CatCombat",
    detection: "SR6.Spell.CatDetection",
    health: "SR6.Spell.CatHealth",
    illusion: "SR6.Spell.CatIllusion",
    manipulation: "SR6.Spell.CatManipulation"
  },
  spellTypes: {
    physical: "SR6.Spell.TypePhysical",
    mana: "SR6.Spell.TypeMana"
  },
  spellRanges: {
    touch: "SR6.Spell.RangeTouch",
    los: "SR6.Spell.RangeLos",
    los_a: "SR6.Spell.RangeLosA"
  },
  combatSpellTypes: {
    direct: "SR6.Spell.CombatDirect",
    indirect: "SR6.Spell.CombatIndirect"
  },
  detectionSpellTypes: {
    directional: "SR6.Spell.DetectionDirectional",
    psychic: "SR6.Spell.DetectionPsychic",
    area: "SR6.Spell.DetectionArea"
  },
  illusionSpellTypes: {
    obvious: "SR6.Spell.IllusionObvious",
    realistic: "SR6.Spell.IllusionRealistic"
  },
  illusionSpellSenses: {
    "single-sense": "SR6.Spell.IllusionSingleSense",
    "multi-sense": "SR6.Spell.IllusionMultiSense"
  },
  attributeRolls: {
    composure: "SR6.RollComposure",
    lift_carry: "SR6.RollLiftCarry",
    judge_intentions: "SR6.RollJudgeIntentions",
    memory: "SR6.RollMemory"
  },
  /**
   * Used for complex form targeting options.
   */
  matrixTargets: {
    persona: "SR6.TargetPersona",
    device: "SR6.TargetDevice",
    file: "SR6.TargetFile",
    self: "SR6.TargetSelf",
    sprite: "SR6.TargetSprite",
    host: "TYPES.Item.host",
    ic: "TYPES.Actor.ic",
    other: "SR6.TargetOther"
  },
  durations: {
    instant: "SR6.DurationInstant",
    sustained: "SR6.DurationSustained",
    permanent: "SR6.DurationPermanent"
  },
  weaponCategories: {
    range: "SR6.Weapon.Category.Range",
    melee: "SR6.Weapon.Category.Melee",
    thrown: "SR6.Weapon.Category.Thrown"
  },
  weaponCliptypes: {
    removable_clip: "SR6.Weapon.Cliptype.RemovableClip",
    break_action: "SR6.Weapon.Cliptype.BreakAction",
    belt_fed: "SR6.Weapon.Cliptype.BeltFed",
    internal_magazin: "SR6.Weapon.Cliptype.InternalMagazin",
    muzzle_loader: "SR6.Weapon.Cliptype.MuzzleLoader",
    cylinder: "SR6.Weapon.Cliptype.Cylinder",
    drum: "SR6.Weapon.Cliptype.Drum",
    bow: "SR6.Weapon.Cliptype.Bow"
  },
  weaponRanges: {
    short: "SR6.Weapon.Range.Short",
    medium: "SR6.Weapon.Range.Medium",
    long: "SR6.Weapon.Range.Long",
    extreme: "SR6.Weapon.Range.Extreme"
  },
  qualityTypes: {
    positive: "SR6.QualityTypePositive",
    negative: "SR6.QualityTypeNegative",
    lifemodule: "SR6.QualityTypeLifeModule"
  },
  adeptPower: {
    types: {
      active: "SR6.AdeptPower.Types.Active",
      passive: "SR6.AdeptPower.Types.Passive"
    }
  },
  deviceCategories: {
    commlink: "SR6.DeviceCatCommlink",
    cyberdeck: "SR6.DeviceCatCyberdeck",
    rcc: "SR6.DeviceCatRCC"
  },
  cyberwareGrades: {
    standard: "SR6.CyberwareGradeStandard",
    alpha: "SR6.CyberwareGradeAlpha",
    beta: "SR6.CyberwareGradeBeta",
    delta: "SR6.CyberwareGradeDelta",
    used: "SR6.CyberwareGradeUsed"
  },
  knowledgeSkillCategories: {
    street: "SR6.KnowledgeSkillStreet",
    academic: "SR6.KnowledgeSkillAcademic",
    professional: "SR6.KnowledgeSkillProfessional",
    interests: "SR6.KnowledgeSkillInterests"
  },
  activeSkills: {
    astral: "SR6.Skill.Astral",
    athletics: "SR6.Skill.Athletics",
    biotech: "SR6.Skill.Biotech",
    closecombat: "SR6.Skill.CloseCombat",
    con: "SR6.Skill.Con",
    conjuring: "SR6.Skill.Conjuring",
    cracking: "SR6.Skill.Cracking",
    electronics: "SR6.Skill.Electronics",
    enchanting: "SR6.Skill.Enchanting",
    engineering: "SR6.Skill.Engineering",
    exoticweapons: "SR6.Skill.ExoticWeapons",
    firearms: "SR6.Skill.Firearms",
    influence: "SR6.Skill.Influence",
    outdoors: "SR6.Skill.Outdoors",
    perception: "SR6.Skill.Perception",
    piloting: "SR6.Skill.Piloting",
    sorcery: "SR6.Skill.Sorcery",
    stealth: "SR6.Skill.Stealth",
    tasking: "SR6.Skill.Tasking"
  },
  /**
   * Some skills are created on the fly and don't exist on all actors.
   * These values are used for those.
   */
  activeSkillAttribute: {
    flight: "agility"
  },
  actionTypes: {
    none: "SR6.ActionTypeNone",
    free: "SR6.ActionTypeFree",
    simple: "SR6.ActionTypeSimple",
    complex: "SR6.ActionTypeComplex",
    varies: "SR6.ActionTypeVaries"
  },
  // Use within action damage calculation (base <operator> attribute) => value
  actionDamageFormulaOperators: {
    add: "+",
    subtract: "-",
    multiply: "*",
    divide: "/"
  },
  // Map all Shadowrun.ActionCategories to their matching labels.
  // For more information around action categories, see type documentation.
  actionCategories: {
    "addiction_mental": "SR6.ActionCategory.AddictionMental",
    "addiction_physical": "SR6.ActionCategory.AddictionPhysical",
    "addiction": "SR6.ActionCategory.Addiction",
    "attack_melee": "SR6.ActionCategory.AttackMelee",
    "attack_ranged": "SR6.ActionCategory.AttackRanged",
    "attack_thrown": "SR6.ActionCategory.AttackThrown",
    "attack": "SR6.ActionCategory.Attack",
    "brute_force": "SR6.ActionCategory.BruteForce",
    "climbing": "SR6.ActionCategory.Climbing",
    "compiling": "SR6.ActionCategory.Compiling",
    "complex_form": "SR6.ActionCategory.ComplexForm",
    "defense_suppression": "SR6.ActionCategory.DefenseSuppression",
    "defense": "SR6.ActionCategory.Defense",
    "drain": "SR6.ActionCategory.Drain",
    "fade": "SR6.ActionCategory.Fade",
    "hack_on_the_fly": "SR6.ActionCategory.HackOnTheFly",
    "magic": "SR6.ActionCategory.Magic",
    "matrix": "SR6.ActionCategory.Matrix",
    "recovery_physical": "SR6.ActionCategory.RecoveryPhysical",
    "recovery_stun": "SR6.ActionCategory.RecoveryStun",
    "recovery": "SR6.ActionCategory.Recovery",
    "resist_disease": "SR6.ActionCategory.ResistDisease",
    "resist_toxin": "SR6.ActionCategory.ResistToxin",
    "resist": "SR6.ActionCategory.Resist",
    "resonance": "SR6.ActionCategory.Resonance",
    "rigging": "SR6.ActionCategory.Rigging",
    "social": "SR6.ActionCategory.Social",
    "spell_combat": "SR6.ActionCategory.SpellCombat",
    "spell_detection": "SR6.ActionCategory.SpellDetection",
    "spell_healing": "SR6.ActionCategory.SpellHealing",
    "spell_illusion": "SR6.ActionCategory.SpellIllusion",
    "spell_manipulation": "SR6.ActionCategory.SpellManipulation",
    "spell_ritual": "SR6.ActionCategory.SpellRitual",
    "summoning": "SR6.ActionCategory.Summoning"
  },
  matrixAttributes: {
    attack: "SR6.MatrixAttrAttack",
    sleaze: "SR6.MatrixAttrSleaze",
    data_processing: "SR6.MatrixAttrDataProc",
    firewall: "SR6.MatrixAttrFirewall"
  },
  initiativeCategories: {
    meatspace: "SR6.InitCatMeatspace",
    astral: "SR6.InitCatAstral",
    matrix: "SR6.InitCatMatrix"
  },
  // Gear modification types. :) Not modifiers.
  modificationTypes: {
    weapon: "SR6.Weapon.Weapon",
    armor: "SR6.Armor",
    vehicle: "SR6.Vehicle.Vehicle",
    drone: "SR6.Vehicle.Drone"
  },
  mountPoints: {
    barrel: "SR6.Barrel",
    under_barrel: "SR6.UnderBarrel",
    stock: "SR6.Stock",
    top: "SR6.Top",
    side: "SR6.Side",
    internal: "SR6.Internal"
  },
  modificationCategories: {
    body: "SR6.Vehicle.ModificationCategoryTypes.body",
    cosmetic: "SR6.Vehicle.ModificationCategoryTypes.cosmetic",
    electromagnetic: "SR6.Vehicle.ModificationCategoryTypes.electromagnetic",
    power_train: "SR6.Vehicle.ModificationCategoryTypes.power_train",
    protection: "SR6.Vehicle.ModificationCategoryTypes.protection",
    weapons: "SR6.Vehicle.ModificationCategoryTypes.weapons"
  },
  lifestyleTypes: {
    street: "SR6.LifestyleStreet",
    squatter: "SR6.LifestyleSquatter",
    low: "SR6.LifestyleLow",
    medium: "SR6.LifestyleMiddle",
    high: "SR6.LifestyleHigh",
    luxory: "SR6.LifestyleLuxory",
    other: "SR6.LifestyleOther"
  },
  /**
   * Labels for ALL actor types actor based local modifiers.
   *
   * All modifiers across all actor types must be included here, this is only used for display.
   */
  actorModifiers: {
    armor: "SR6.ModifierTypes.Armor",
    astral_initiative_dice: "SR6.ModifierTypes.AstralDice",
    astral_initiative: "SR6.ModifierTypes.AstralInit",
    astral_limit: "SR6.ModifierTypes.AstralLimit",
    composure: "SR6.ModifierTypes.Composure",
    defense_block: "SR6.ModifierTypes.DefenseBlock",
    defense_dodge: "SR6.ModifierTypes.DefenseDodge",
    defense_parry: "SR6.ModifierTypes.DefenseParry",
    defense_melee: "SR6.ModifierTypes.DefenseMelee",
    defense_ranged: "SR6.ModifierTypes.DefenseRanged",
    defense: "SR6.ModifierTypes.Defense",
    drain: "SR6.ModifierTypes.Drain",
    essence: "SR6.ModifierTypes.Essence",
    fade: "SR6.ModifierTypes.Fade",
    global: "SR6.ModifierTypes.Global",
    judge_intentions: "SR6.ModifierTypes.JudgeIntentions",
    lift_carry: "SR6.ModifierTypes.LiftCarry",
    matrix_initiative_dice: "SR6.ModifierTypes.MatrixDice",
    matrix_initiative: "SR6.ModifierTypes.MatrixInit",
    matrix_track: "SR6.ModifierTypes.MatrixTrack",
    meat_initiative_dice: "SR6.ModifierTypes.MeatSpaceDice",
    meat_initiative: "SR6.ModifierTypes.MeatSpaceInit",
    memory: "SR6.ModifierTypes.Memory",
    mental_limit: "SR6.ModifierTypes.MentalLimit",
    multi_defense: "SR6.ModifierTypes.DefenseMulti",
    pain_tolerance_physical: "SR6.ModifierTypes.PainTolerancePhysical",
    pain_tolerance_stun: "SR6.ModifierTypes.PainToleranceStun",
    physical_limit: "SR6.ModifierTypes.PhysicalLimit",
    physical_overflow_track: "SR6.ModifierTypes.PhysicalOverflowTrack",
    physical_track: "SR6.ModifierTypes.PhysicalTrack",
    reach: "SR6.ModifierTypes.Reach",
    run: "SR6.ModifierTypes.Run",
    soak: "SR6.ModifierTypes.Soak",
    social_limit: "SR6.ModifierTypes.SocialLimit",
    stun_track: "SR6.ModifierTypes.StunTrack",
    walk: "SR6.ModifierTypes.Walk",
    wound_tolerance: "SR6.ModifierTypes.WoundTolerance"
  },
  /**
   * Tooltip labels used for actor modifiers. Key should use actorModifiers key.
   */
  actorModifiersTooltip: {
    armor: "SR6.Tooltips.Modifiers.armor",
    astral_initiative_dice: "SR6.Tooltips.Modifiers.astral_initiative_dice",
    astral_initiative: "SR6.Tooltips.Modifiers.astral_initiative",
    astral_limit: "SR6.Tooltips.Modifiers.astral_limit",
    composure: "SR6.Tooltips.Modifiers.composure",
    defense_block: "SR6.Tooltips.Modifiers.defense_block",
    defense_dodge: "SR6.Tooltips.Modifiers.defense_dodge",
    defense_parry: "SR6.Tooltips.Modifiers.defense_parry",
    defense_melee: "SR6.Tooltips.Modifiers.defense_melee",
    defense_ranged: "SR6.Tooltips.Modifiers.defense_ranged",
    defense: "SR6.Tooltips.Modifiers.defense",
    drain: "SR6.Tooltips.Modifiers.drain",
    essence: "SR6.Tooltips.Modifiers.essence",
    fade: "SR6.Tooltips.Modifiers.fade",
    global: "SR6.Tooltips.Modifiers.global",
    judge_intentions: "SR6.Tooltips.Modifiers.judge_intentions",
    lift_carry: "SR6.Tooltips.Modifiers.lift_carry",
    matrix_initiative_dice: "SR6.Tooltips.Modifiers.matrix_initiative_dice",
    matrix_initiative: "SR6.Tooltips.Modifiers.matrix_initiative",
    matrix_track: "SR6.Tooltips.Modifiers.matrix_track",
    meat_initiative_dice: "SR6.Tooltips.Modifiers.meat_initiative_dice",
    meat_initiative: "SR6.Tooltips.Modifiers.meat_initiative",
    memory: "SR6.Tooltips.Modifiers.memory",
    mental_limit: "SR6.Tooltips.Modifiers.mental_limit",
    multi_defense: "SR6.Tooltips.Modifiers.multi_defense",
    pain_tolerance_physical: "SR6.Tooltips.Modifiers.pain_tolerance_physical",
    pain_tolerance_stun: "SR6.Tooltips.Modifiers.pain_tolerance_stun",
    physical_limit: "SR6.Tooltips.Modifiers.physical_limit",
    physical_overflow_track: "SR6.Tooltips.Modifiers.physical_overflow_track",
    physical_track: "SR6.Tooltips.Modifiers.physical_track",
    reach: "SR6.Tooltips.Modifiers.reach",
    run: "SR6.Tooltips.Modifiers.run",
    soak: "SR6.Tooltips.Modifiers.soak",
    social_limit: "SR6.Tooltips.Modifiers.social_limit",
    stun_track: "SR6.Tooltips.Modifiers.stun_track",
    walk: "SR6.Tooltips.Modifiers.walk",
    wound_tolerance: "SR6.Tooltips.Modifiers.wound_tolerance"
  },
  /**
   * Modification types used for actions and general success tests, based on actors.
   *
   * These are meant to be used with the Modifiers and SituationModifier classes and SR6Actor.modifiers.totalFor('wounds').
   *
   * There are additional item based modifiers that aren't present here.
   *
   * NOTE: Adding a modifier type here will directly affect modifiers shown on item actions for user selection.
   */
  modifierTypes: {
    armor: "SR6.ModifierTypes.Armor",
    composure: "SR6.ModifierTypes.Composure",
    defense: "SR6.ModifierTypes.Defense",
    multi_defense: "SR6.ModifierTypes.DefenseMulti",
    drain: "SR6.ModifierTypes.Drain",
    environmental: "SR6.ModifierTypes.Environmental",
    ["environmental.light"]: "SR6.ModifierTypes.EnvironmentalLight",
    ["environmental.visibility"]: "SR6.ModifierTypes.EnvironmentalVisibility",
    ["environmental.wind"]: "SR6.ModifierTypes.EnvironmentalWind",
    ["environmental.range"]: "SR6.ModifierTypes.EnvironmentalRange",
    background_count: "SR6.ModifierTypes.BackgroundCount",
    noise: "SR6.ModifierTypes.Noise",
    fade: "SR6.ModifierTypes.Fade",
    global: "SR6.ModifierTypes.Global",
    judge_intentions: "SR6.ModifierTypes.JudgeIntentions",
    lift_carry: "SR6.ModifierTypes.LiftCarry",
    memory: "SR6.ModifierTypes.Memory",
    soak: "SR6.ModifierTypes.Soak",
    wounds: "SR6.ModifierTypes.Wounds",
    recoil: "SR6.ModifierTypes.Recoil"
  },
  /**
   * Define here what kind of active test is to be used for the different weapon categories as a main action test.
   */
  weaponCategoryActiveTests: {
    "range": "RangedAttackTest",
    "melee": "MeleeAttackTest",
    "thrown": "ThrownAttackTest"
  },
  /**
   * When casting tests from these item types, use these tests as active tests
   */
  activeTests: {
    "spell": "SpellCastingTest",
    "ritual": "RitualSpellcastingTest",
    "complex_form": "ComplexFormTest"
  },
  /**
   * Using different active test details should result in these opposed tests
   *
   * Structure: {
   *  [item.type]: {[item.system.type]}: 'OpposedTest'
   * }
   */
  opposedTests: {
    "spell": {
      "combat": "CombatSpellDefenseTest"
    }
  },
  /**
   * Using different resist tests for the oppositing depending on active tests details
   *  Structure: {
   *  [item.type]: {[item.system.type]}: 'OpposedTest'
   * }
   */
  opposedResistTests: {
    "spell": {
      "combat": "PhysicalResistTest"
    }
  },
  /**
   * When a test is cast an active test this defines what tests should follow that tests completion
   */
  followedTests: {
    "SpellCastingTest": "DrainTest"
  },
  // When a firemode with suppression is used, this test should defend against it.
  suppressionDefenseTest: "SuppressionDefenseTest",
  /**
   * Names of FoundryVTT packs supplied by the system to be used as action sources.
   */
  packNames: {
    "generalActions": "general-actions",
    "matrixActions": "matrix-actions"
  },
  programTypes: {
    common_program: "SR6.CommonProgram",
    hacking_program: "SR6.HackingProgram",
    agent: "SR6.Agent"
  },
  spiritTypes: {
    // base types
    air: "SR6.Spirit.Types.Air",
    aircraft: "SR6.Spirit.Types.Aircraft",
    airwave: "SR6.Spirit.Types.Airwave",
    automotive: "SR6.Spirit.Types.Automotive",
    beasts: "SR6.Spirit.Types.Beasts",
    ceramic: "SR6.Spirit.Types.Ceramic",
    earth: "SR6.Spirit.Types.Earth",
    energy: "SR6.Spirit.Types.Energy",
    fire: "SR6.Spirit.Types.Fire",
    guardian: "SR6.Spirit.Types.Guardian",
    guidance: "SR6.Spirit.Types.Guidance",
    man: "SR6.Spirit.Types.Man",
    metal: "SR6.Spirit.Types.Metal",
    plant: "SR6.Spirit.Types.Plant",
    ship: "SR6.Spirit.Types.Ship",
    task: "SR6.Spirit.Types.Task",
    train: "SR6.Spirit.Types.Train",
    water: "SR6.Spirit.Types.Water",
    // toxic types
    toxic_air: "SR6.Spirit.Types.ToxicAir",
    toxic_beasts: "SR6.Spirit.Types.ToxicBeasts",
    toxic_earth: "SR6.Spirit.Types.ToxicEarth",
    toxic_fire: "SR6.Spirit.Types.ToxicFire",
    toxic_man: "SR6.Spirit.Types.ToxicMan",
    toxic_water: "SR6.Spirit.Types.ToxicWater",
    // blood types
    blood: "SR6.Spirit.Types.Blood",
    // shadow types
    muse: "SR6.Spirit.Types.Muse",
    nightmare: "SR6.Spirit.Types.Nightmare",
    shade: "SR6.Spirit.Types.Shade",
    succubus: "SR6.Spirit.Types.Succubus",
    wraith: "SR6.Spirit.Types.Wraith",
    // shedim types
    shedim: "SR6.Spirit.Types.Shedim",
    master_shedim: "SR6.Spirit.Types.MasterShedim",
    // insect types
    caretaker: "SR6.Spirit.Types.Caretaker",
    nymph: "SR6.Spirit.Types.Nymph",
    scout: "SR6.Spirit.Types.Scout",
    soldier: "SR6.Spirit.Types.Soldier",
    worker: "SR6.Spirit.Types.Worker",
    queen: "SR6.Spirit.Types.Queen",
    // Necro types
    carcass: "SR6.Spirit.Types.Carcass",
    corpse: "SR6.Spirit.Types.Corpse",
    rot: "SR6.Spirit.Types.Rot",
    palefire: "SR6.Spirit.Types.Palefire",
    detritus: "SR6.Spirit.Types.Detritus",
    // Howling Shadow spirits
    anarch: "SR6.Spirit.Types.Anarch",
    arboreal: "SR6.Spirit.Types.Arboreal",
    blackjack: "SR6.Spirit.Types.Blackjack",
    boggle: "SR6.Spirit.Types.Boggle",
    bugul: "SR6.Spirit.Types.Bugul",
    chindi: "SR6.Spirit.Types.Chindi",
    croki: "SR6.Spirit.Types.Croki",
    duende: "SR6.Spirit.Types.Duende",
    elvar: "SR6.Spirit.Types.Elvar",
    erinyes: "SR6.Spirit.Types.Erinyes",
    greenman: "SR6.Spirit.Types.Greenman",
    imp: "SR6.Spirit.Types.Imp",
    jarl: "SR6.Spirit.Types.Jarl",
    kappa: "SR6.Spirit.Types.Kappa",
    kokopelli: "SR6.Spirit.Types.Kokopelli",
    morbi: "SR6.Spirit.Types.Morbi",
    nocnitasa: "SR6.Spirit.Types.Nocnitasa",
    phantom: "SR6.Spirit.Types.Phantom",
    preta: "SR6.Spirit.Types.Preta",
    stabber: "SR6.Spirit.Types.Stabber",
    tungak: "SR6.Spirit.Types.Tungak",
    vucub: "SR6.Spirit.Types.Vucub"
  },
  /**
   * Actor types that can be called in using the call in action type and be
   * set in it's system.action_type property.
   */
  callInActorTypes: {
    "spirit": "TYPES.Actor.spirit",
    "sprite": "TYPES.Actor.sprite"
  },
  critterPower: {
    categories: {
      mundane: "SR6.CritterPower.Categories.Mundane",
      paranormal: "SR6.CritterPower.Categories.Paranormal",
      free_spirit: "SR6.CritterPower.Categories.FreeSpirit",
      emergent: "SR6.CritterPower.Categories.Emergent",
      shapeshifter: "SR6.CritterPower.Categories.Shapeshifter",
      drake: "SR6.CritterPower.Categories.Drake",
      echoes: "SR6.CritterPower.Categories.Echoes",
      weakness: "SR6.CritterPower.Categories.Weakness",
      paranormal_infected: "SR6.CritterPower.Categories.ParanormalInfected"
    },
    types: {
      mana: "SR6.CritterPower.Types.Mana",
      physical: "SR6.CritterPower.Types.Physical"
    },
    ranges: {
      los: "SR6.CritterPower.Ranges.LineOfSight",
      self: "SR6.CritterPower.Ranges.Self",
      touch: "SR6.CritterPower.Ranges.Touch",
      los_a: "SR6.CritterPower.Ranges.LineOfSightArea",
      special: "SR6.CritterPower.Ranges.Special"
    },
    durations: {
      always: "SR6.CritterPower.Durations.Always",
      instant: "SR6.CritterPower.Durations.Instant",
      sustained: "SR6.CritterPower.Durations.Sustained",
      permanent: "SR6.CritterPower.Durations.Permanent",
      special: "SR6.CritterPower.Durations.Special"
    }
  },
  spriteTypes: {
    courier: "SR6.Sprite.Types.Courier",
    crack: "SR6.Sprite.Types.Crack",
    data: "SR6.Sprite.Types.Data",
    fault: "SR6.Sprite.Types.Fault",
    machine: "SR6.Sprite.Types.Machine",
    companion: "SR6.Sprite.Types.Companion",
    generalist: "SR6.Sprite.Types.Generalist"
  },
  vehicle: {
    types: {
      air: "SR6.Vehicle.Types.Air",
      aerospace: "SR6.Vehicle.Types.Aerospace",
      ground: "SR6.Vehicle.Types.Ground",
      water: "SR6.Vehicle.Types.Water",
      walker: "SR6.Vehicle.Types.Walker",
      exotic: "SR6.Vehicle.Types.Exotic"
    },
    stats: {
      handling: "SR6.Vehicle.Stats.Handling",
      off_road_handling: "SR6.Vehicle.Stats.OffRoadHandling",
      speed: "SR6.Vehicle.Stats.Speed",
      off_road_speed: "SR6.Vehicle.Stats.OffRoadSpeed",
      acceleration: "SR6.Vehicle.Stats.Acceleration",
      pilot: "SR6.Vehicle.Stats.Pilot",
      sensor: "SR6.Vehicle.Stats.Sensor",
      seats: "SR6.Vehicle.Stats.Seats"
    },
    control_modes: {
      manual: "SR6.Vehicle.ControlModes.Manual",
      remote: "SR6.Vehicle.ControlModes.Remote",
      rigger: "SR6.Vehicle.ControlModes.Rigger",
      autopilot: "SR6.Vehicle.ControlModes.Autopilot"
    },
    environments: {
      speed: "SR6.Vehicle.Environments.Speed",
      handling: "SR6.Vehicle.Environments.Handling"
    }
  },
  ic: {
    types: {
      acid: "SR6.IC.Types.Acid",
      binder: "SR6.IC.Types.Binder",
      black_ic: "SR6.IC.Types.BlackIC",
      blaster: "SR6.IC.Types.Blaster",
      bloodhound: "SR6.IC.Types.Bloodhound",
      blue_goo: "SR6.IC.Types.BlueGoo",
      catapult: "SR6.IC.Types.Catapult",
      crash: "SR6.IC.Types.Crash",
      flicker: "SR6.IC.Types.Flicker",
      jammer: "SR6.IC.Types.Jammer",
      killer: "SR6.IC.Types.Killer",
      marker: "SR6.IC.Types.Marker",
      patrol: "SR6.IC.Types.Patrol",
      probe: "SR6.IC.Types.Probe",
      scramble: "SR6.IC.Types.Scramble",
      shocker: "SR6.IC.Types.Shocker",
      sleuther: "SR6.IC.Types.Sleuther",
      sparky: "SR6.IC.Types.Sparky",
      tar_baby: "SR6.IC.Types.TarBaby",
      track: "SR6.IC.Types.Track"
    }
  },
  character: {
    types: {
      human: "SR6.Character.Types.Human",
      elf: "SR6.Character.Types.Elf",
      ork: "SR6.Character.Types.Ork",
      dwarf: "SR6.Character.Types.Dwarf",
      troll: "SR6.Character.Types.Troll"
    }
  },
  /**
   * The available range weapon modes for to SR5#424
   *
   * These are the mode selectors on the weapon. The term 'fire mode'
   * is only used to describe as the combination of weapon mode and action
   * used, causing a specific fire mode.
   *
   * NOTE: This list is also used for sorting order of ranged weapon mode.
   *       Alter it with care.
   */
  rangeWeaponMode: [
    "single_shot",
    "semi_auto",
    "burst_fire",
    "full_auto"
  ],
  rangeWeaponModeLabel: {
    "single_shot": "SR6.Weapon.Mode.SingleShot",
    "semi_auto": "SR6.Weapon.Mode.SemiAuto",
    "burst_file": "SR6.Weapon.Mode.BurstFire",
    "full_auto": "SR6.Weapon.Mode.FullAuto"
  },
  /**
   * The preconfigured default Shadowrun firemodes according to SR5#180
   *
   * These are separate from ranged weapon modes but depend on the selected
   * ranged weapon mode.
   */
  fireModes: [
    {
      label: "SR6.Weapon.Mode.SingleShot",
      value: 1,
      recoil: false,
      defense: 0,
      suppression: false,
      action: "simple",
      mode: "single_shot"
    },
    {
      label: "SR6.Weapon.Mode.SemiAutoShort",
      value: 1,
      recoil: true,
      defense: 0,
      suppression: false,
      action: "simple",
      mode: "semi_auto"
    },
    {
      label: "SR6.Weapon.Mode.SemiAutoBurst",
      value: 3,
      recoil: true,
      defense: -2,
      suppression: false,
      action: "complex",
      mode: "semi_auto"
    },
    {
      label: "SR6.Weapon.Mode.BurstFire",
      value: 3,
      recoil: true,
      defense: -2,
      suppression: false,
      action: "simple",
      mode: "burst_fire"
    },
    {
      label: "SR6.Weapon.Mode.BurstFireLong",
      value: 6,
      recoil: true,
      defense: -5,
      suppression: false,
      action: "complex",
      mode: "burst_fire"
    },
    {
      label: "SR6.Weapon.Mode.FullAutoShort",
      value: 6,
      recoil: true,
      defense: -5,
      suppression: false,
      action: "simple",
      mode: "full_auto"
    },
    {
      label: "SR6.Weapon.Mode.FullAutoLong",
      value: 10,
      recoil: true,
      defense: -9,
      suppression: false,
      action: "complex",
      mode: "full_auto"
    },
    {
      label: "SR6.Suppressing",
      value: 20,
      recoil: false,
      defense: 0,
      suppression: true,
      action: "complex",
      mode: "full_auto"
    }
  ],
  /**
   * Active/AdvancedEffect apply To types and their labels.
   *
   * actor is the default Foundry apply to type of ActiveEffects and will be affect actor data.
   */
  effectApplyTo: {
    "actor": "SR6.FOUNDRY.Actor",
    // 'item': 'SR6.FOUNDRY.Item', // Disabled, as systems nested item approach brings issues.
    "targeted_actor": "SR6.ActiveEffect.ApplyTos.TargetedActor",
    "test_all": "SR6.Test",
    "test_item": "SR6.ActiveEffect.ApplyTos.TestItem",
    "modifier": "SR6.Modifier"
  },
  itemSubTypeIconOverrides: {
    action: {},
    adept_power: {
      "adept-spell": "spell/spell"
    },
    ammo: {
      "ammo": "",
      "arrow": "",
      "bola": "",
      "bolt": "",
      "grenade": "",
      "micro-torpedo": "",
      "minigrenade": "",
      "missile": "",
      "rocket": "",
      "torpedo-grenade": ""
    },
    armor: {
      "armor": "",
      "cloaks": "",
      "clothing": "",
      "high-fashion-armor-clothing": "",
      "specialty-armor": ""
    },
    bioware: {
      "basic": "bioware/bioware",
      "bio-weapons": "",
      "biosculpting": "",
      "chemical-gland-modifications": "",
      "complimentary-genetics": "",
      "cosmetic-bioware": "",
      "cultured": "",
      "environmental-microadaptation": "",
      "exotic-metaglands": "",
      "genetic-restoration": "",
      "immunization": "",
      "orthoskin-upgrades": "",
      "phenotype-adjustment": "bioware/biosculpting",
      "symbionts": "bioware/cultured",
      "transgenic-alteration": "bioware/transgenic-alteration",
      "transgenics": ""
    },
    complex_form: {},
    contact: {},
    critter_power: {
      "mana": "",
      "physical": "critter_power/critter_power"
    },
    cyberware: {
      "auto-injector-mods": "",
      "bodyware": "",
      "cosmetic-enhancement": "bioware/cosmetic-bioware",
      "cyber-implant-weapon": "",
      "cyber-implant-weapon-accessory": "",
      "cyberlimb": "",
      "cyberlimb-accessory": "",
      "cyberlimb-enhancement": "",
      "cybersuite": "",
      "earware": "",
      "eyeware": "",
      "hard-nanoware": "",
      "headware": "cyberware/cyberware",
      "nanocybernetics": "cyberware/hard-nanoware",
      "soft-nanoware": "cyberware/hard-nanoware",
      "special-biodrone-cyberware": ""
    },
    device: {
      "commlink": "device",
      "cyberdeck": "",
      "rcc": ""
    },
    echo: {},
    equipment: {
      "alchemical-tools": "",
      "appearance-modification": "",
      "armor-enhancements": "",
      "audio-devices": "",
      "audio-enhancements": "",
      "autosofts": "equipment/software",
      "biotech": "",
      "booster-chips": "",
      "breaking-and-entering-gear": "",
      "btls": "",
      "chemicals": "",
      "commlink-accessories": "",
      "commlink-apps": "equipment/software",
      "commlink-cyberdeck-form-factors": "",
      "communications-and-countermeasures": "equipment/pi-tac",
      "contracts-upkeep": "",
      "critter-gear": "",
      "currency": "",
      "custom-cyberdeck-attributes": "",
      "cyberdeck-modules": "",
      "cyberterminals": "equipment/pi-tac",
      "disguises": "equipment/appearance-modification",
      "drug-grades": "",
      "drugs": "",
      "electronic-accessories": "",
      "electronic-modification": "",
      "electronic-parts": "",
      "electronics-accessories": "",
      "entertainment": "",
      "explosives": "",
      "extraction-devices": "",
      "foci": "",
      "food": "",
      "formulae": "",
      "grapple-gun": "",
      "hard-nanoware": "cyberware/hard-nanoware",
      "housewares": "",
      "id-credsticks": "",
      "magical-compounds": "",
      "magical-supplies": "",
      "matrix-accessories": "",
      "metatype-specific": "",
      "miscellany": "",
      "musical-instruments": "",
      "nanogear": "cyberware/hard-nanoware",
      "paydata": "",
      "pi-tac": "",
      "pi-tac-programs": "equipment/software",
      "printing": "",
      "reporter-gear": "",
      "rfid-tags": "equipment/pi-tac",
      "security-devices": "",
      "sensor-functions": "",
      "sensor-housings": "",
      "sensors": "equipment/pi-tac",
      "services": "",
      "skillsofts": "equipment/software",
      "software": "",
      "software-tweaks": "equipment/software",
      "survival-gear": "",
      "tailored-perfume-cologne": "",
      "tools": "",
      "tools-of-the-trade": "",
      "toxins": "",
      "vision-devices": "",
      "vision-enhancements": ""
    },
    host: {},
    lifestyle: {},
    metamagic: {},
    modification: {
      "barrel": "",
      "other": "",
      "side": "",
      "stock": "",
      "top": "",
      "under": "modification/modification"
    },
    program: {
      "common_program": "",
      "hacking_program": ""
    },
    quality: {
      "negative": "",
      "positive": ""
    },
    sin: {},
    spell: {
      "combat": "",
      "detection": "",
      "enchantments": "",
      "health": "",
      "illusion": "",
      "manipulation": ""
    },
    ritual: {},
    sprite_power: {},
    weapon: {
      // Options before : in name are 'Grenade', 'Minigrenade', 'Rocket', 'Missile', 'Torpedo Grenade', 'Micro-Torpedo'
      "melee": "",
      "ranged": "",
      "thrown": "",
      "assault-cannons": "",
      "assault-rifles": "",
      "bio-weapon": "cyberware/cyber-implant-weapon",
      "blades": "",
      "bows": "",
      "carbines": "",
      "clubs": "",
      "crossbows": "",
      "cyberweapon": "cyberware/cyber-implant-weapon",
      "exotic-melee-weapons": "",
      "exotic-ranged-weapons": "",
      "flamethrowers": "",
      "gear": "equipment/equipment",
      "grenade-launchers": "",
      "grenade": "ammo/grenade",
      "heavy-machine-guns": "weapon/assault-cannons",
      "heavy-pistols": "",
      "holdouts": "",
      "improvised-weapons": "",
      "laser-weapons": "",
      "light-machine-guns": "weapon/assault-cannons",
      "light-pistols": "",
      "machine-pistols": "",
      "medium-machine-guns": "weapon/assault-cannons",
      "micro-drone-weapons": "",
      "micro-torpedo": "ammo/micro-torpedo",
      "minigrenade": "ammo/minigrenade",
      "missile": "ammo/missile",
      "missile-launchers": "",
      "quality": "quality/quality",
      "rocket": "ammo/rocket",
      "shotguns": "",
      "sniper-rifles": "",
      "sporting-rifles": "weapon/carbines",
      "submachine-guns": "",
      "tasers": "",
      "torpedo-grenade": "ammo/torpedo-grenade",
      "unarmed": "",
      "underbarrel-weapons": "modification/modification"
    }
  }
};

// src/module/actor/flows/SkillFlow.ts
var SkillFlow = class _SkillFlow {
  static {
    __name(this, "SkillFlow");
  }
  /**
   * Handle everything around how a skill should be defaulted
   * @param skill
   * @param parts
   */
  static handleDefaulting(skill, parts) {
    if (!SkillRules.mustDefaultToRoll(skill)) return;
    if (!_SkillFlow.allowDefaultingRoll(skill)) {
      ui.notifications?.warn(game.i18n.localize("SR6.Warnings.SkillCantBeDefault"));
      return;
    }
    SkillRules.addDefaultingPart(parts);
  }
  /**
   * Check if either the system settings or skill configuration allow for a skill to be defaulted.
   * @param skill
   * @return true will allow a role on the skill that needs defaulting.
   */
  static allowDefaultingRoll(skill) {
    const allowUnimproviseable = game.settings.get(SYSTEM_NAME, FLAGS.OnlyAllowRollOnDefaultableSkills) === false;
    if (allowUnimproviseable)
      return true;
    return SkillRules.allowDefaultingRoll(skill);
  }
  static allowRoll(skill) {
    if (SkillRules.mustDefaultToRoll(skill) && _SkillFlow.allowDefaultingRoll(skill)) {
      return true;
    }
    return SkillRules.allowRoll(skill);
  }
  static isCustomSkill(skill) {
    return skill.name !== void 0 && skill.name !== "";
  }
  static isLegacySkill(skill) {
    return !_SkillFlow.isCustomSkill(skill);
  }
};

// src/module/item/flows/ActionFlow.ts
var ActionFlow = class _ActionFlow {
  static {
    __name(this, "ActionFlow");
  }
  /**
   * Calculate action damage configuration based on flat damage field and possible dynamic attribute modification.
   *
   * @param damage The damage field as defined within the ActionData
   * @param actor The actor to use should a dynamic calculation be needed.
   * @param item
   */
  static calcDamageData(damage, actor, item) {
    damage = foundry.utils.duplicate(damage);
    if (!actor) return damage;
    if (item) {
      damage.source = _ActionFlow._damageSource(actor, item);
    }
    this._applyModifiableValue(damage, actor);
    damage.value = Helpers.calcTotal(damage, { min: 0 });
    this._applyModifiableValue(damage.ap, actor);
    damage.ap.value = Helpers.calcTotal(damage.ap, { min: 0 });
    return damage;
  }
  static _applyModifiableValue(value, actor) {
    const attribute = actor.findAttribute(value.attribute);
    if (!attribute) return;
    if (!value.base_formula_operator) {
      console.error(`Unsupported formula operator: '${value.base_formula_operator}' used. Falling back to 'add'.`);
      value.base_formula_operator = "add";
    }
    switch (value.base_formula_operator) {
      case "add":
        PartsList.AddUniquePart(value.mod, attribute.label, attribute.value);
        break;
      case "subtract":
        PartsList.AddUniquePart(value.mod, attribute.label, -attribute.value);
        break;
      case "multiply":
        PartsList.AddUniquePart(value.mod, "SR6.Value", value.base * attribute.value - value.base);
        break;
      case "divide":
        PartsList.AddUniquePart(value.mod, "SR6.BaseValue", value.base * -1);
        const denominator = attribute.value === 0 ? 1 : attribute.value;
        PartsList.AddUniquePart(value.mod, "SR6.Value", Math.floor(value.base / denominator));
        break;
    }
  }
  /**
   * Damage that's caused by an item can later be used to determine how that damage should be applied
   *
   * @param actor The actor used to determine damage
   * @param item The item from which damage's been determined from.
   */
  static _damageSource(actor, item) {
    return {
      actorId: actor.id || "",
      itemId: item.id || "",
      itemName: item.name || "",
      itemType: item.type
    };
  }
  /**
   * Does an action based damage contain any damaging content.
   *
   * @param damage Any Shadowrun.DamageData taken from an template action section
   *
   * @returns true, when the user configured damage contains any parts.
   */
  static hasDamage(damage) {
    if (damage.base !== 0) return true;
    if (damage.attribute) return true;
    if (damage.type) return true;
    if (damage.element) return true;
    return false;
  }
  /**
   * Collect all active skills either from global context or from within a given document.
   *
   * Normalize custom and legacy skills to a single format.
   * Legacy skills have no name, but use their name as id.
   * Custom skills have a name but their id is random.
   *
   * @param actor An optional actor to retrieve skills from (including custom skills)
   * @param skillName An optional skill that should be included in the selection, even if it's missing from the global list.
   * @returns Sorted list of skills with a name : label key-value structure for select elements on sheets.
   */
  static sortedActiveSkills(actor, skillName) {
    if (!actor || actor.isIC()) {
      const globalSkills = foundry.utils.deepClone(SR6.activeSkills);
      _ActionFlow._injectMissingCustomSkill(globalSkills, skillName);
      return Helpers.sortConfigValuesByTranslation(globalSkills);
    }
    const activeSkills = actor.getActiveSkills();
    const skills = {};
    for (const [id, skill] of Object.entries(activeSkills)) {
      const key = skill.name || id;
      const label = skill.label || skill.name;
      skills[key] = label;
    }
    _ActionFlow._injectMissingCustomSkill(skills, skillName);
    return Helpers.sortConfigValuesByTranslation(skills);
  }
  /**
   * Insert the given skill as a default skill in case it's missing.
   *
   * This is needed for sidebar items, that dont have local custom skills like owned items, to still
   * show the custom skill in the sill selection.
   *
   * @param skills The set of active skills to be used.
   * @param skillName The skill name to be injected.
   */
  static _injectMissingCustomSkill(skills, skillName) {
    if (!skillName) return;
    const foundCustomSkill = Object.values(skills).some((name3) => name3 === skillName);
    if (foundCustomSkill) return;
    if (skillName && !skills[skillName]) skills[skillName] = skillName;
  }
};

// src/module/tests/TestCreator.ts
var TestCreator = {
  /**
   * A helper method to create a SuccessTest from a simple pool value, without
   * actor / item involvement.
   *
   * TODO: fromPool as a name for 'from values' doesn't quite describe the method anymore, since a pool doesn't need to be given.
   * @param values The values to use for the test.
   * @param options See TestOptions documentation.
   */
  fromPool: /* @__PURE__ */ __name(function(values = { pool: 0, limit: 0, threshold: 0 }, options) {
    const data = TestCreator._minimalTestData();
    data.pool.base = values.pool;
    data.threshold.base = values.threshold || 0;
    data.limit.base = values.limit || 0;
    const successTestCls = TestCreator._getTestClass("SuccessTest");
    return new successTestCls(data, void 0, options);
  }, "fromPool"),
  /**
   * Create a Test from action item configuration.
   *
   * @param item Any item type that defines an action.
   * @param actor The actor to use for the resulting SR6Roll,
   *              will default to the items parent otherwise.
   * @param options See SuccessTestOptions documentation.
   *
   * @returns Tries to create a SuccessTest from given action item or undefined if it failed.
   */
  fromItem: /* @__PURE__ */ __name(async function(item, actor, options) {
    if (!actor) actor = item.parent;
    if (!(actor instanceof SR6Actor)) {
      console.error("Shadowrun 6e | A SuccessTest can only be created with an explicit Actor or Item with an actor parent.");
      return;
    }
    const action = item.getAction();
    if (!action) return;
    if (!action.test) {
      action.test = "SuccessTest";
      console.warn(`Shadowrun 6e | An action without a defined test handler defaulted to ${"SuccessTest"}`);
    }
    if (!game["shadowrun6-elysium"].tests.hasOwnProperty(action.test)) {
      console.error(`Shadowrun 6e | Test registration for test ${action.test} is missing`);
      return;
    }
    const cls = TestCreator._getTestClass(action.test);
    const data = await TestCreator._getTestDataFromItemAction(cls, item, actor);
    const documents = { item, actor };
    return new cls(data, documents, options);
  }, "fromItem"),
  /**
   * Create a test from action data only, when not having an item.
   *
   * @param action The action data to use for the test.
   * @param actor The actor to use for retrieving source values defined within the action.
   * @param options See TestOptions documentation.
   */
  fromAction: /* @__PURE__ */ __name(async function(action, actor, options) {
    if (!action.test) {
      action.test = "SuccessTest";
      console.warn(`Shadowrun 6e | An action without a defined test handler defaulted to ${"SuccessTest"}`);
    }
    if (!game["shadowrun6-elysium"].tests.hasOwnProperty(action.test)) {
      console.error(`Shadowrun 6e | Test registration for test ${action.test} is missing`);
      return;
    }
    const cls = TestCreator._getTestClass(action.test);
    const data = await TestCreator._prepareTestDataWithAction(action, actor, TestCreator._minimalTestData());
    const documents = { actor };
    return new cls(data, documents, options);
  }, "fromAction"),
  /**
   * Create a test using an Action item stored in any collection
   * @param packName The package / compendium name to search for the action
   * @param actionName The items name within the given packName
   * @param actor The actor used to roll the test with
   * @param options General TestOptions
   */
  fromPackAction: /* @__PURE__ */ __name(async function(packName, actionName, actor, options) {
    const item = await Helpers.getPackAction(packName, actionName);
    if (!item) {
      console.error(`Shadowrun5 | The pack ${packName} doesn't include an item ${actionName}`);
      return;
    }
    return TestCreator.fromItem(item, actor, options);
  }, "fromPackAction"),
  /**
   * Create a test implementation from a past test included within a message
   *
   * @param id The message id to retrieve test data from.
   */
  fromMessage: /* @__PURE__ */ __name(async function(id, options) {
    const flagData = TestCreator.getTestDataFromMessage(id);
    return this._fromMessageTestData(flagData, options);
  }, "fromMessage"),
  /**
   * Retrieve possible test data from a given message id.
   *
   * If you need the test implementation, use @fromMessage instead.
   *
   * @param id The message id to retrieve test data from.
   * @returns Raw test data from message flags or undefined if none found.
   */
  getTestDataFromMessage(id) {
    const message = game.messages?.get(id);
    if (!message) {
      console.error(`Shadowrun 6e | Couldn't find a message for id ${id} to create a message action`);
      return;
    }
    const flagData = message.getFlag(SYSTEM_NAME, FLAGS.Test);
    if (!flagData) return;
    return flagData;
  },
  /**
   * Create a test implementation directly from a message flags test data.
   * @param testData
   * @returns
   */
  _fromMessageTestData: /* @__PURE__ */ __name(function(testData, options) {
    testData = foundry.utils.duplicate(testData);
    if (!testData || !testData.rolls) return;
    const rolls = testData.rolls.map((roll) => SR6Roll.fromData(roll));
    const documents = { rolls };
    options = options ?? testData.data.options;
    return TestCreator.fromTestData(testData.data, documents, options);
  }, "_fromMessageTestData"),
  /**
   * Create a test implementation for a specific action on a message.
   *
   * This can be an opposed test, resist or followup test.
   *
   * @param id The id of the to be used message.
   * @param testClsName The test class name to be used with the message test data.
   * @param options See TestOptions documentation.
   */
  fromMessageAction: /* @__PURE__ */ __name(async function(id, testClsName, options) {
    if (!game.user) return;
    const message = game.messages?.get(id);
    if (!message) {
      console.error(`Shadowrun 6e | Couldn't find a message for id ${id} to create a message action`);
      return;
    }
    const testData = foundry.utils.duplicate(message.getFlag(SYSTEM_NAME, FLAGS.Test));
    if (!testData || !testData.data || !testData.rolls) {
      console.error(`Shadowrun 6e | Message with id ${id} doesn't have valid test data in it's flags.`);
      return;
    }
    const testClass = TestCreator._getTestClass(testClsName);
    if (!testClass) {
      console.error(`Shadowrun 6e | Couldn't find a registered test implementation for ${testClsName}`);
      return;
    }
    let actors = await Helpers.getOpposedTestActors(testData.data);
    if (actors.filter((actor) => !actor).length > 0) {
      ui.notifications?.warn("TOKEN.WarningNoActor", { localize: true });
      return;
    }
    actors = actors.filter((actor) => actor.isOwner);
    if (actors.length === 0 && game.user.character) {
      actors.push(game.user.character);
    }
    if (actors.length === 0) {
      ui.notifications?.warn(game.i18n.localize("SR6.Warnings.TokenSelectionNeeded"));
    } else {
      console.log("Shadowrun 6e | Casting an opposed test using these actors", actors, testData);
    }
    for (const actor of actors) {
      const data = await testClass._getOpposedActionTestData(testData.data, actor, id);
      if (!data) return;
      const documents = { actor };
      const test = new testClass(data, documents, options);
      await test.execute();
    }
  }, "fromMessageAction"),
  /**
   * Helper method to create a test implementation from given test data directly.
   *
   * Test values will be taken from data and not refreshed from the source actor.
   *
   * @param data The TestData of some test implementation within test registry.
   * @param documents Documents to connect test to. These don't have to match the ones originally used and
   *                  won't be used for retrieving source values.
   * @param options Optional test options.
   */
  fromTestData: /* @__PURE__ */ __name(function(data, documents, options) {
    const type = data.type || "SuccessTest";
    const cls = TestCreator._getTestClass(type);
    return new cls(data, documents, options);
  }, "fromTestData"),
  /**
   * Use any kind of opposed test to create a resist test based on that.
   *
   * This can be used for damage resistance tests.
   *
   * Within a typical success test, opposed test and resist test flow, this will
   * happen after both main and opposed test have finished. The resiting test will be
   * executed in context of both with the actor of the opposed test as source.
   *
   * The original action provides both the opposing and resiting test.
   *
   * @param opposed The opposed test to create a resist test with.
   * @param options See TestOptions documentation.
   */
  fromOpposedTestResistTest: /* @__PURE__ */ __name(async function(opposed, options) {
    const opposedData = foundry.utils.duplicate(opposed.data);
    if (!opposedData?.against?.opposed?.resist?.test) return console.error(`Shadowrun 6e | Given test doesn't define an opposed resist test`, opposed);
    if (!opposed.actor) return console.error(`Shadowrun 6e | A ${opposed.title} can't operate without a populated actor given`);
    const resistTestCls = TestCreator._getTestClass(opposedData.against.opposed.resist.test);
    const data = await TestCreator._getOpposedResistTestData(resistTestCls, opposedData, opposed.actor, opposed.data.messageUuid);
    const documents = { actor: opposed.actor };
    return new resistTestCls(data, documents, options);
  }, "fromOpposedTestResistTest"),
  /**
   * Use any kind of test to create a followup test based on that.
   *
   * This can be used for drain tests.
   *
   * TODO: Describe a clear separation between resist and follow up test use cases.
   *
   * @param test Any test implementation with an action providing a follow up test.
   * @param options See TestOptions documentation.
   */
  fromFollowupTest: /* @__PURE__ */ __name(async function(test, options) {
    if (!test?.data?.action?.followed?.test) return;
    if (!test.item) return console.error(`Shadowrun 6e | Test doesn't have a populated item document`);
    if (!test.actor) return console.error(`Shadowrun 6e | Test doesn't have a populated actor document`);
    const testCls = TestCreator._getTestClass(test.data.action.followed.test);
    if (!testCls) return console.error(`Shadowrun 6e | A ${test.constructor.name} has a unregistered follow up test configured`, this);
    const data = TestCreator._minimalTestData();
    data.title = testCls.title;
    data.previousMessageId = test.data.messageUuid;
    data.against = test.data;
    const action = TestCreator._mergeMinimalActionDataInOrder(
      DataDefaults.actionRollData({ test: testCls.name }),
      await testCls._getDocumentTestAction(test.item, test.actor),
      testCls._getDefaultTestAction()
    );
    const testData = await testCls._prepareActionTestData(action, test.actor, data);
    testData.following = test.data;
    const documents = { item: test.item, actor: test.actor };
    return new testCls(testData, documents, options);
  }, "fromFollowupTest"),
  /*
   * Prompt the user for a default SuccessTest.
   */
  promptSuccessTest: /* @__PURE__ */ __name(async function() {
    const lastPoolValue = Number(game.user?.getFlag(SYSTEM_NAME, FLAGS.LastRollPromptValue)) || 0;
    const test = TestCreator.fromPool({ pool: lastPoolValue });
    await test.execute();
    if (test.evaluated) {
      await game.user?.setFlag(SYSTEM_NAME, FLAGS.LastRollPromptValue, test.pool.value);
    }
  }, "promptSuccessTest"),
  /**
   * Return a test class from the global registry.
   *
   * @param testName A Test class constructor name registered as a test.
   */
  _getTestClass: /* @__PURE__ */ __name(function(testName) {
    if (!testName) return;
    if (!game["shadowrun6-elysium"].tests.hasOwnProperty(testName)) {
      console.error(`Shadowrun 6e | Tried getting a Test Class ${testName}, which isn't registered in: `, game["shadowrun6-elysium"].tests);
      return;
    }
    return game["shadowrun6-elysium"].tests[testName];
  }, "_getTestClass"),
  /**
   * Return test data based on an items action.
   *
   * @param testCls A test class implementation to use for retrieving action data.
   * @param item
   * @param actor
   */
  _getTestDataFromItemAction: /* @__PURE__ */ __name(async function(testCls, item, actor) {
    const data = TestCreator._minimalTestData();
    let action = item.getAction();
    if (!action || !actor) {
      return data;
    }
    action = TestCreator._mergeMinimalActionDataInOrder(
      action,
      await testCls._getDocumentTestAction(item, actor),
      testCls._getDefaultTestAction()
    );
    return await TestCreator._prepareTestDataWithAction(action, actor, data);
  }, "_getTestDataFromItemAction"),
  /**
   * An opposed resist test is related to the result of an opposed test.
   *
   * This can be a physical damage resist test and will be derived from configuration
   * of the original test that's being opposed.
   *
   * @param resistTestCls The resist test class to be used.
   * @param opposedData The opposing test, including the original test being opposed.
   * @param actor The actor doing the testing.
   * @param previousMessageId The Message id of the originating opposing test.
   */
  _getOpposedResistTestData: /* @__PURE__ */ __name(async function(resistTestCls, opposedData, actor, previousMessageId) {
    if (!opposedData.against.opposed.resist.test) {
      console.error(`Shadowrun 6e | Supplied test action doesn't contain an resist test in it's opposed test configuration`, opposedData, this);
      return;
    }
    if (!actor) {
      console.error(`Shadowrun 6e | Can't resolve opposed test values due to missing actor`, resistTestCls);
    }
    const data = TestCreator._minimalTestData();
    data.previousMessageId = previousMessageId;
    data.following = opposedData;
    data.targetActorsUuid = [];
    let action = DataDefaults.actionRollData({
      ...opposedData.against.opposed.resist
    });
    action = TestCreator._mergeMinimalActionDataInOrder(
      action,
      resistTestCls._getDocumentTestAction(),
      resistTestCls._getDefaultTestAction()
    );
    return await TestCreator._prepareTestDataWithAction(action, actor, data);
  }, "_getOpposedResistTestData"),
  /**
   * Prepare test data with source values based on action data.
   *
   * @param action Action data to prepare test data with.
   * @param actor Actor to use for retrieving source values and execute test with.
   * @param data Any test implementations resulting basic test data.
   */
  _prepareTestDataWithAction: /* @__PURE__ */ __name(async function(action, actor, data) {
    data.action = action;
    const pool = new PartsList(data.pool.mod);
    if (action.skill) {
      const skill = actor.getSkill(action.skill) ?? actor.getSkill(action.skill, { byLabel: true });
      if (skill && !SkillFlow.allowRoll(skill)) ui.notifications?.warn("SR6.Warnings.SkillCantBeDefault", { localize: true });
      if (skill) pool.addUniquePart(skill.label || skill.name, SkillRules.level(skill));
      if (action.spec) pool.addUniquePart("SR6.Specialization", SkillRules.SpecializationModifier);
    }
    if (action.attribute) {
      const attribute = actor.getAttribute(action.attribute);
      if (attribute) pool.addPart(attribute.label, attribute.value);
      if (attribute && actor._isMatrixAttribute(action.attribute)) actor._addMatrixParts(pool, true);
    }
    if (!action.skill && action.attribute2) {
      const attribute = actor.getAttribute(action.attribute2);
      if (attribute) pool.addPart(attribute.label, attribute.value);
      if (attribute && actor._isMatrixAttribute(action.attribute2)) actor._addMatrixParts(pool, true);
    }
    if (action.mod) {
      data.modifiers.mod = PartsList.AddUniquePart(data.modifiers.mod, "SR6.DicePoolModifier", action.mod);
    }
    if (action.dice_pool_mod) {
      action.dice_pool_mod.forEach((mod) => PartsList.AddUniquePart(data.modifiers.mod, mod.name, mod.value));
    }
    if (action.armor) {
      const armor3 = actor.getArmor();
      data.pool.mod = PartsList.AddUniquePart(data.pool.mod, "SR6.Armor", armor3.value);
    }
    if (action.limit.base) {
      data.limit.base = Number(action.limit.base);
    }
    if (action.threshold.base) {
      data.threshold.base = Number(action.threshold.base);
    }
    if (ActionFlow.hasDamage(action.damage)) {
      data.damage = foundry.utils.duplicate(action.damage);
    }
    if (action.opposed.test) {
      data.opposed = action.opposed;
    }
    const modifiers = {};
    for (const modifier of data.action.modifiers) {
      if (modifier.includes(".")) {
        const segments = modifier.split(".");
        if (segments.length > 2) console.error("Shadowrun 6e | Action contained a partial modifier with more than two segments", modifier, data.action);
        const [category3, applicable] = segments;
        modifiers[category3] = modifiers[category3] ?? [];
        modifiers[category3].push(applicable);
      } else {
        modifiers[modifier] = modifiers[modifier] ?? [];
      }
    }
    for (const [name3, applicable] of Object.entries(modifiers)) {
      const label = SR6.modifierTypes[name3];
      const options = { applicable };
      const value = actor.modifiers.totalFor(name3, options);
      data.modifiers.mod = PartsList.AddUniquePart(data.modifiers.mod, label, value);
    }
    data.extended = action.extended;
    return data;
  }, "_prepareTestDataWithAction"),
  /**
   * Return minimal viable test data without test specific customization.
   */
  _minimalTestData: /* @__PURE__ */ __name(function() {
    return {
      pool: DataDefaults.valueData({ label: "SR6.DicePool" }),
      limit: DataDefaults.valueData({ label: "SR6.Limit" }),
      threshold: DataDefaults.valueData({ label: "SR6.Threshold" }),
      damage: DataDefaults.damageData(),
      modifiers: DataDefaults.valueData({ label: "SR6.Labels.Action.Modifiers" }),
      values: {},
      action: DataDefaults.actionRollData(),
      opposed: {}
    };
  }, "_minimalTestData"),
  /**
   * Merge multiple MinimalActionData objects into one action object. This will only look at keys within a minimal action,
   * not all action keys.
   *
   * A value of a minimal action will only overwrite the main action value if that is not set.
   *
   * For example:
   * A: action.skill == '' will be overwritten by minimalAction.skill == 'Spellcasting'
   * B: action.skill == 'ritual_spellcasting' won't be overwritten by minimalAction.skill == 'Spellcasting'
   * C: action.armor == true will be overwritten by minimalAction.armor == false
   *
   * @param sourceAction Main action, as defined by user input.
   * @param defaultActions List of partial actions, as defined by test implementations.
   * @returns A copy of the main action with all minimalActions properties applied in order of arguments.
   */
  _mergeMinimalActionDataInOrder: /* @__PURE__ */ __name(function(sourceAction, ...defaultActions) {
    const resultAction = foundry.utils.duplicate(sourceAction);
    for (const defaultAction of defaultActions) {
      if (Object.keys(defaultAction).length === 0) continue;
      for (const key of Object.keys(DataDefaults.minimalActionData())) {
        if (TestCreator._keepItemActionValue(sourceAction, defaultAction, key)) continue;
        resultAction[key] = defaultAction[key];
      }
    }
    return resultAction;
  }, "_mergeMinimalActionDataInOrder"),
  /**
   * Should an action value be kept even if a default action defines another value?
   *
   * This comparison checks either a simple value against defaults OR checks values grouped as a
   * logical unit (skill+attribute/2)
   *
   * @param action The original action data.
   * @param defaultAction A partial action that may provide values to apply to the main action.
   * @param key The action key to take the value from
   * @returns true for when the original action value should be kept, false if it's to be overwritten.
   */
  _keepItemActionValue(action, defaultAction, key) {
    if (!defaultAction.hasOwnProperty(key)) return true;
    const skillSection = ["skill", "attribute", "attribute2", "armor"];
    if (skillSection.includes(key)) {
      const noneDefault = skillSection.some((sectionKey) => TestCreator._actionHasNoneDefaultValue(action, sectionKey));
      return noneDefault;
    }
    return TestCreator._actionHasNoneDefaultValue(action, key);
  },
  /**
   * Determine if the field value behind the action property 'key' is of a none-default value.
   *
   * This can be used to determine if a user / automated change has been made.
   *
   * @param action Any action configuration.
   * @param key A key of action configuration within action parameter
   * @returns false, when the value behind key is a default value. true, when it's a custom value.
   */
  _actionHasNoneDefaultValue(action, key) {
    if (!action.hasOwnProperty(key)) return false;
    const value = action[key];
    const type = foundry.utils.getType(value);
    if (type === "string") return value.length > 0;
    if (type === "Array") return value.length > 0;
    if (type === "boolean" && key === "armor") return action[key] === true;
    return false;
  },
  /**
   * Determine if a test's dialog should NOT be shown, when executing a test.
   *
   * @param event A PointerEvent by user interaction
   */
  shouldHideDialog(event) {
    if (!event) return false;
    const bindings = game.keybindings.get("shadowrun6-elysium", "hide-test-dialog");
    for (const binding of bindings) {
      return event[binding.key] === true;
    }
    return false;
  },
  /**
   * Determine if a test's dialog should be shown, when executing a test.
   *
   * @param event A PointerEvent by user interaction
   */
  shouldShowDialog(event) {
    return !TestCreator.shouldHideDialog(event);
  },
  /**
   * Determine if instead of rolling an item based test, only the item's description should be posted as a chat message.
   *
   * @param event A PointerEvent by user interaction
   */
  shouldPostItemDescription(event) {
    if (!event) return false;
    const bindings = game.keybindings.get("shadowrun6-elysium", "show-item-card");
    for (const binding of bindings) {
      return event[binding.key] === true;
    }
    return false;
  }
};

// src/module/item/ChatData.ts
var ChatData = {
  call_in_action: /* @__PURE__ */ __name((system, labels, props) => {
    switch (system.actor_type) {
      case "sprite":
        if (system.sprite.type) props.push(`${game.i18n.localize("SR6.Compilation.SpriteType")} ${game.i18n.localize(SR6.spriteTypes[system.sprite.type])}`);
        if (system.sprite.level) props.push(`${game.i18n.localize("SR6.Level")} ${system.sprite.level}`);
        return;
      case "spirit":
        if (system.spirit.type) props.push(`${game.i18n.localize("SR6.Summoning.SpiritType")} ${game.i18n.localize(SR6.spiritTypes[system.spirit.type])}`);
        if (system.spirit.force) props.push(`${game.i18n.localize("SR6.Force")} ${system.spirit.force}`);
        return;
    }
  }, "call_in_action"),
  action: /* @__PURE__ */ __name((system, labels, props) => {
    if (system.action) {
      const labelStringList = [];
      if (system.action.skill) {
        labelStringList.push(Helpers.label(system.action.skill));
        labelStringList.push(Helpers.label(system.action.attribute));
      } else if (system.action.attribute2) {
        labelStringList.push(Helpers.label(system.action.attribute));
        labelStringList.push(Helpers.label(system.action.attribute2));
      } else if (system.action.attribute) {
        labelStringList.push(Helpers.label(system.action.attribute));
      }
      if (system.action.mod) {
        labelStringList.push(`${game.i18n.localize("SR6.ItemMod")} (${system.action.mod})`);
      }
      if (labelStringList.length) {
        labels.roll = labelStringList.join(" + ");
      }
      if (system.action.opposed.type) {
        const { opposed } = system.action;
        if (opposed.type !== "custom") labels.opposedRoll = `vs. ${Helpers.label(opposed.type)}`;
        else if (opposed.skill) labels.opposedRoll = `vs. ${Helpers.label(opposed.skill)}+${Helpers.label(opposed.attribute)}`;
        else if (opposed.attribute2) labels.opposedRoll = `vs. ${Helpers.label(opposed.attribute)}+${Helpers.label(opposed.attribute2)}`;
        else if (opposed.attribute) labels.opposedRoll = `vs. ${Helpers.label(opposed.attribute)}`;
      }
      if (system.action.type !== "" && system.action.type !== "varies" && system.action.type !== "none") {
        props.push(`${Helpers.label(`${game.i18n.localize(SR6.actionTypes[system.action.type])}`)} ${game.i18n.localize("SR6.Action")}`);
      }
      if (system.action.limit) {
        const { limit } = system.action;
        const attribute = limit.attribute ? `[${game.i18n.localize(SR6.limits[limit.attribute])}]` : "";
        const limitVal = limit.value ? limit.value : "";
        let limitStr = "";
        if (attribute) {
          limitStr += attribute;
        }
        if (limitVal) {
          if (attribute) {
            limitStr += " + ";
          }
          limitStr += limitVal;
        }
        if (limitStr) {
          props.push(`${game.i18n.localize("SR6.Limit")} ${limitStr}`);
        }
      }
      if (system.action.damage.type.value) {
        const { damage } = system.action;
        let damageString = "";
        let elementString = "";
        let operator = SR6.actionDamageFormulaOperators[damage.base_formula_operator] ?? "";
        let attribute = damage.attribute ? `${game.i18n.localize(SR6.attributes[damage.attribute])} ${operator} ` : "";
        if (damage.value || attribute) {
          const type = damage.type.value ? game.i18n.localize(SR6.damageTypes[damage.type.value]).toUpperCase().charAt(0) : "";
          damageString = `${game.i18n.localize("SR6.DV")} ${attribute}${damage.value}${type}`;
        }
        if (damage.element.value) {
          if (damage.value) {
            if (damage.element.value === "electricity") {
              damageString += ` (${game.i18n.localize(SR6.elementTypes.electricity).toLowerCase().charAt(0)})`;
            } else {
              elementString = Helpers.label(game.i18n.localize(SR6.elementTypes[damage.element.value]));
            }
          } else {
            elementString = Helpers.label(game.i18n.localize(SR6.elementTypes[damage.element.value]));
          }
        }
        if (damageString) props.push(damageString);
        if (elementString) props.push(elementString);
        const ap = damage.ap;
        operator = SR6.actionDamageFormulaOperators[ap.base_formula_operator] ?? "";
        attribute = ap.attribute ? `${game.i18n.localize(SR6.attributes[ap.attribute])} ${operator} ` : "";
        if (ap.value || attribute) {
          props.push(`${game.i18n.localize("SR6.AP")} ${attribute}${damage.ap.value}`);
        }
      }
    }
  }, "action"),
  sin: /* @__PURE__ */ __name((system, labels, props) => {
    if (system.technology.rating) props.push(`${game.i18n.localize("SR6.Rating")} ${system.technology.rating}`);
    system.licenses.forEach((license) => {
      if (license.rtg) props.push(`${license.name} ${game.i18n.localize("SR6.Rating").charAt(0)}${license.rtg}`);
    });
  }, "sin"),
  contact: /* @__PURE__ */ __name((system, labels, props) => {
    props.push(system.type);
    props.push(`${game.i18n.localize("SR6.Contact.Connection")} ${system.connection}`);
    props.push(`${game.i18n.localize("SR6.Contact.Loyalty")} ${system.loyalty}`);
    if (system.blackmail) {
      props.push(game.i18n.localize("SR6.Contact.Blackmail"));
    }
    if (system.family) {
      props.push(game.i18n.localize("SR6.Contact.Family"));
    }
  }, "contact"),
  lifestyle: /* @__PURE__ */ __name((system, labels, props) => {
    props.push(game.i18n.localize(SR6.lifestyleTypes[system.type]));
    if (system.cost) props.push(`\xA5${system.cost}`);
    if (system.comforts) props.push(`${game.i18n.localize("SR6.LifestyleComforts")} ${system.comforts}`);
    if (system.security) props.push(`${game.i18n.localize("SR6.LifestyleSecurity")} ${system.security}`);
    if (system.neighborhood) props.push(`${game.i18n.localize("SR6.LifestyleNeighborhood")} ${system.neighborhood}`);
    if (system.guests) props.push(`${game.i18n.localize("SR6.LifestyleGuests")} ${system.guests}`);
  }, "lifestyle"),
  adept_power: /* @__PURE__ */ __name((system, labels, props) => {
    ChatData.action(system, labels, props);
    props.push(`${game.i18n.localize("SR6.PP")} ${system.pp}`);
    props.push(Helpers.label(game.i18n.localize(SR6.adeptPower.types[system.type])));
  }, "adept_power"),
  armor: /* @__PURE__ */ __name((system, labels, props) => {
    if (system.armor) {
      if (system.armor.value) props.push(`${game.i18n.localize("SR6.Armor")} ${system.armor.mod ? "+" : ""}${system.armor.value}`);
      if (system.armor.acid) props.push(`${game.i18n.localize("SR6.ElementAcid")} ${system.armor.acid}`);
      if (system.armor.cold) props.push(`${game.i18n.localize("SR6.ElementCold")} ${system.armor.cold}`);
      if (system.armor.fire) props.push(`${game.i18n.localize("SR6.ElementFire")} ${system.armor.fire}`);
      if (system.armor.electricity) props.push(`${game.i18n.localize("SR6.ElementElectricity")} ${system.armor.electricity}`);
      if (system.armor.radiation) props.push(`${game.i18n.localize("SR6.ElementRadiation")} ${system.armor.radiation}`);
    }
  }, "armor"),
  ammo: /* @__PURE__ */ __name((system, labels, props) => {
    if (system.damageType) props.push(`${game.i18n.localize("SR6.DamageType")} ${game.i18n.localize(SR6.damageTypes[system.damageType])}`);
    if (system.damage) props.push(`${game.i18n.localize("SR6.DamageValue")} ${system.damage}`);
    if (system.element) props.push(`${game.i18n.localize("SR6.Element")} ${game.i18n.localize(SR6.elementTypes[system.element])}`);
    if (system.ap) props.push(`${game.i18n.localize("SR6.AP")} ${system.ap}`);
    if (system.blast.radius) props.push(`${game.i18n.localize("SR6.BlastRadius")} ${system.blast.radius}m`);
    if (system.blast.dropoff) props.push(`${game.i18n.localize("SR6.Dropoff")} ${system.blast.dropoff}/m`);
  }, "ammo"),
  program: /* @__PURE__ */ __name((system, labels, props) => {
    props.push(game.i18n.localize(SR6.programTypes[system.type]));
  }, "program"),
  complex_form: /* @__PURE__ */ __name((system, labels, props) => {
    ChatData.action(system, labels, props);
    props.push(game.i18n.localize(SR6.matrixTargets[system.target]));
    props.push(`${system.duration}`);
    const { fade } = system;
    if (fade > 0) props.push(`${game.i18n.localize("SR6.Fade")} ${game.i18n.localize("SR6.Level").charAt(0)}+${fade}`);
    else if (fade < 0) props.push(`${game.i18n.localize("SR6.Fade")} ${game.i18n.localize("SR6.Level").charAt(0)}${fade}`);
    else props.push(`${game.i18n.localize("SR6.Fade")} ${game.i18n.localize("SR6.Level").charAt(0)}`);
  }, "complex_form"),
  cyberware: /* @__PURE__ */ __name((system, labels, props) => {
    ChatData.action(system, labels, props);
    ChatData.armor(system, labels, props);
    if (system.essence) props.push(`${game.i18n.localize("SR6.AttrEssence").substring(0, 3)} ${system.essence}`);
  }, "cyberware"),
  bioware: /* @__PURE__ */ __name((system, labels, props) => {
    ChatData.action(system, labels, props);
    ChatData.armor(system, labels, props);
    if (system.essence) props.push(`${game.i18n.localize("SR6.AttrEssence").substring(0, 3)} ${system.essence}`);
  }, "bioware"),
  device: /* @__PURE__ */ __name((system, labels, props) => {
    if (system.technology && system.technology.rating) props.push(`${game.i18n.localize("SR6.Rating")} ${system.technology.rating}`);
    if (system.category === "cyberdeck" || system.category === "rcc") {
      for (const attribute of Object.values(system.atts)) {
        props.push(`${Helpers.label(`${game.i18n.localize(SR6.matrixAttributes[attribute.att])}`)} ${attribute.value}`);
      }
    }
    if (system.category === "commlink") {
      for (const attribute of Object.values(system.atts)) {
        if (attribute.value) props.push(`${Helpers.label(`${game.i18n.localize(SR6.matrixAttributes[attribute.att])}`)} ${attribute.value}`);
      }
    }
  }, "device"),
  equipment: /* @__PURE__ */ __name((system, labels, props) => {
    ChatData.action(system, labels, props);
    if (system.technology && system.technology.rating) props.push(`${game.i18n.localize("SR6.Rating")} ${system.technology.rating}`);
  }, "equipment"),
  quality: /* @__PURE__ */ __name((system, labels, props) => {
    ChatData.action(system, labels, props);
    props.push(Helpers.label(game.i18n.localize(SR6.qualityTypes[system.type])));
    if (system.rating) props.push(`${game.i18n.localize("SR6.Rating")} ${system.rating}`);
  }, "quality"),
  sprite_power: /* @__PURE__ */ __name((system, labels, props) => {
    ChatData.action(system, labels, props);
  }, "sprite_power"),
  critter_power: /* @__PURE__ */ __name((system, labels, props) => {
    props.push(game.i18n.localize(SR6.critterPower.types[system.powerType]));
    props.push(game.i18n.localize(SR6.critterPower.durations[system.duration]));
    props.push(game.i18n.localize(SR6.critterPower.ranges[system.range]));
    if (system.rating) props.push(`${game.i18n.localize("SR6.Rating")} ${system.rating}`);
    ChatData.action(system, labels, props);
  }, "critter_power"),
  // add properties for spell data, follow order in book
  spell: /* @__PURE__ */ __name((system, labels, props) => {
    props.push(game.i18n.localize(SR6.spellCategories[system.category]), game.i18n.localize(SR6.spellTypes[system.type]));
    if (system.category === "combat") {
      props.push(game.i18n.localize(SR6.combatSpellTypes[system.combat.type]));
    } else if (system.category === "health") {
    } else if (system.category === "illusion") {
      props.push(game.i18n.localize(SR6.illusionSpellTypes[system.illusion.type]));
      props.push(game.i18n.localize(SR6.illusionSpellSenses[system.illusion.sense]));
    } else if (system.category === "manipulation") {
      if (system.manipulation.damaging) props.push(game.i18n.localize("SR6.Spell.ManipulationDamaging"));
      if (system.manipulation.mental) props.push(game.i18n.localize("SR6.Spell.ManipulationMental"));
      if (system.manipulation.environmental) props.push(game.i18n.localize("SR6.Spell.ManipulationEnvironmental"));
      if (system.manipulation.physical) props.push(game.i18n.localize("SR6.Spell.ManipulationPhysical"));
    } else if (system.category === "detection") {
      props.push(game.i18n.localize(SR6.detectionSpellTypes[system.detection.type]));
      props.push(system.detection.passive ? game.i18n.localize("SR6.Passive") : game.i18n.localize("SR6.Active"));
      if (system.detection.extended) props.push(game.i18n.localize("SR6.DetectionSpellExtended"));
    }
    props.push(game.i18n.localize(SR6.spellRanges[system.range]));
    ChatData.action(system, labels, props);
    props.push(game.i18n.localize(SR6.durations[system.duration]));
    const { drain } = system;
    if (drain > 0) props.push(game.i18n.format("SR6.QuickInfo.DrainForce", { sign: "+", drain }));
    else if (drain < 0) props.push(game.i18n.format("SR6.QuickInfo.DrainForce", { sign: "", drain }));
    else props.push(game.i18n.format("SR6.QuickInfo.DrainForce", { sign: "", drain: "" }));
    labels.roll = "Cast";
  }, "spell"),
  ritual: /* @__PURE__ */ __name((system, labels, props) => {
    props.push(game.i18n.localize(SR6.spellTypes[system.type]));
    props.push(system.descriptors);
    ChatData.action(system, labels, props);
  }, "ritual"),
  weapon: /* @__PURE__ */ __name((system, labels, props, item) => {
    ChatData.action(system, labels, props);
    for (let i2 = 0; i2 < props.length; i2++) {
      const prop = props[i2];
      if (prop.includes("Limit")) {
        props[i2] = prop.replace("Limit", game.i18n.localize("SR6.Accuracy"));
      }
    }
    const equippedAmmo = item.getEquippedAmmo();
    if (equippedAmmo && system.ammo && system.ammo.current?.max) {
      if (equippedAmmo) {
        const ammoData = equippedAmmo.system;
        const { current, spare_clips } = system.ammo;
        if (equippedAmmo.name) props.push(`${equippedAmmo.name} (${current.value}/${current.max})`);
        if (ammoData.blast.radius) props.push(`${game.i18n.localize("SR6.BlastRadius")} ${ammoData.blast.radius}m`);
        if (ammoData.blast.dropoff) props.push(`${game.i18n.localize("SR6.Dropoff")} ${ammoData.blast.dropoff}/m`);
        if (spare_clips && spare_clips.max) props.push(`${game.i18n.localize("SR6.SpareClips")} (${spare_clips.value}/${spare_clips.max})`);
      }
    }
    if (system.technology?.conceal?.value) {
      props.push(`${game.i18n.localize("SR6.Conceal")} ${system.technology.conceal.value}`);
    }
    if (system.category === "range") {
      if (system.range.rc) {
        let rcString = `${game.i18n.localize("SR6.RecoilCompensation")} ${system.range.rc.value}`;
        if (item?.actor) {
          rcString += ` (${game.i18n.localize("SR6.Total")} ${item.totalRecoilCompensation})`;
        }
        props.push(rcString);
      }
      if (system.range.modes) {
        const newModes = [];
        const { modes } = system.range;
        if (modes.single_shot) newModes.push("SR6.Weapon.Mode.SingleShotShort");
        if (modes.semi_auto) newModes.push("SR6.Weapon.Mode.SemiAutoShort");
        if (modes.burst_fire) newModes.push("SR6.Weapon.Mode.BurstFireShort");
        if (modes.full_auto) newModes.push("SR6.Weapon.Mode.FullAutoShort");
        props.push(newModes.map((m2) => game.i18n.localize(m2)).join("/"));
      }
      if (system.range.ranges) {
        const { short, medium, long, extreme, category: category3, attribute } = system.range.ranges;
        const categoryLabel = game.i18n.localize(SR6.weaponRangeCategories[category3]?.label ?? "");
        let output = `${categoryLabel} (${short}/${medium}/${long}/${extreme})`;
        if (attribute) {
          output += `/${attribute}`;
        }
        props.push(output);
      }
    } else if (system.category === "melee") {
      if (system.melee.reach) {
        const reachString = `${game.i18n.localize("SR6.Reach")} ${system.melee.reach}`;
        const accIndex = props.findIndex((p2) => p2.includes("Accuracy"));
        if (accIndex > -1) {
          props.splice(accIndex + 1, 0, reachString);
        } else {
          props.push(reachString);
        }
      }
    } else if (system.category === "thrown") {
      const { blast } = system.thrown;
      if (blast?.radius) props.push(`${game.i18n.localize("SR6.BlastRadius")} ${blast.radius}m`);
      if (blast?.dropoff) props.push(`${game.i18n.localize("SR6.Dropoff")} ${blast.dropoff}/m`);
      if (system.thrown.ranges) {
        const mult = system.thrown.ranges.attribute && item?.actor ? item.actor.system.attributes[system.thrown.ranges.attribute].value : 1;
        const ranges = [system.thrown.ranges.short, system.thrown.ranges.medium, system.thrown.ranges.long, system.thrown.ranges.extreme];
        props.push(ranges.map((v2) => v2 * mult).join("/"));
      }
    }
    const equippedMods = item.getEquippedMods();
    if (equippedMods) {
      equippedMods.forEach((mod) => {
        props.push(`${mod.name}`);
      });
    }
  }, "weapon")
};

// src/module/sockets.ts
var SocketMessage = class _SocketMessage {
  static {
    __name(this, "SocketMessage");
  }
  static _createMessage(type, data, userId) {
    return { type, data, userId };
  }
  static async emit(type, data) {
    if (!game.socket) return;
    const message = _SocketMessage._createMessage(type, data);
    console.trace("Shadowrun 6e | Emitting shadowrun6-elysium system socket message", message);
    await game.socket.emit(SYSTEM_SOCKET, message);
  }
  static async emitForGM(type, data) {
    if (!game.socket || !game.user || !game.users) return;
    if (game.user.isGM) return console.error("Active user is GM! Aborting socket message...");
    _SocketMessage._assertActiveGMUser();
    const gmUser = game.users.find((user) => user.isGM);
    if (!gmUser) return console.error("No active GM user! One GM must be active for this action to work.");
    const message = _SocketMessage._createMessage(type, data, gmUser.id);
    console.trace("Shadowrun 6e | Emitting shadowrun6-elysium system socket message", message);
    await game.socket.emit(SYSTEM_SOCKET, message);
  }
  /**
   * Assert at least one active GM user to avoid confusing bugs when none is present and gm socket message
   * arent handeled.
   * 
   * If that's the case, also inform users to avoid confusion.
   */
  static _assertActiveGMUser() {
    if (!game.users) return;
    for (const user of game.users) {
      if (user.active && user.isGM) return;
    }
    ui.notifications?.error("There is no active GM user to perform this action. Please ask your GM to logon.");
    throw new Error("Shadowrun 6e | No active GM user found.");
  }
};

// src/module/item/flows/NetworkDeviceFlow.ts
var NetworkDeviceFlow = class _NetworkDeviceFlow {
  static {
    __name(this, "NetworkDeviceFlow");
  }
  /**
   * Abstract away Foundry uuid system to allow for further implementation changes and typing restrictions.
   *
   * @param target Whatever Document you want to link to.
   */
  static buildLink(target) {
    return target.uuid;
  }
  //Pass-through to resolveLink for cases in which we know it will return an item and not an actor
  static async resolveItemLink(link) {
    return await this.resolveLink(link);
  }
  /**
   * Repacking FoundryVTT fromUuid without async promise to make it usable in sync functions.
   *
   * @param link
   */
  static async resolveLink(link) {
    if (!link) return;
    return await fromUuid(link);
  }
  static async emitAddNetworkControllerSocketMessage(controller, networkDeviceLink) {
    const controllerLink = _NetworkDeviceFlow.buildLink(controller);
    await SocketMessage.emitForGM(FLAGS.addNetworkController, { controllerLink, networkDeviceLink });
  }
  /**
   * Handle socket messages adding a device to the device list of network
   * @param message
   */
  static async _handleAddNetworkControllerSocketMessage(message) {
    console.log("Shadowrun 6e | Handle add network controller socket message", message);
    if (!game.user?.isGM) return console.error(`Shadowrun 6e | Abort handling of message. Current user isn't a GM`, game.user);
    const controller = await _NetworkDeviceFlow.resolveItemLink(message.data.controllerLink);
    const device = await _NetworkDeviceFlow.resolveLink(message.data.networkDeviceLink);
    if (!controller || !device) return console.error("Shadowrun 6e | Either the networks controller or device did not resolve.");
    await _NetworkDeviceFlow._handleAddDeviceToNetwork(controller, device);
  }
  /**
   * Connect a device to a network controller.
   *
   * A network controller is the device managing the PAN/WAN.
   * A network device is to be added to the network managed by the controller.
   *
   * @param controller
   * @param device
   */
  static async addDeviceToNetwork(controller, device) {
    console.log(`SR6: Elysium | Adding an the item ${device.name} to the controller ${controller.name}`, controller, device);
    if (controller.id === device.id) return console.warn("Shadowrun 6e | A device cant be its own network controller");
    if (!device.canBeNetworkDevice) return ui.notifications?.error(game.i18n.localize("SR6.Errors.CanOnlyAddTechnologyItemsToANetwork"));
    if (!controller.canBeNetworkController) return;
    if (_NetworkDeviceFlow._currentUserCanModifyDevice(controller) && _NetworkDeviceFlow._currentUserCanModifyDevice(device))
      await _NetworkDeviceFlow._handleAddDeviceToNetwork(controller, device);
    else
      await _NetworkDeviceFlow.emitAddNetworkControllerSocketMessage(controller, device.uuid);
  }
  /**
   * Handle everything around adding a device to a controller, including removing it from already connected networks.
   *
   * Note: This method needs GM access
   *
   * @param controller
   * @param device
   */
  static async _handleAddDeviceToNetwork(controller, device) {
    if (!_NetworkDeviceFlow._currentUserCanModifyDevice(controller) && !_NetworkDeviceFlow._currentUserCanModifyDevice(device)) return console.error(`User isn't owner or GM of this device`, controller);
    const controllerData = controller.asDevice || controller.asHost;
    if (!controllerData) return console.error(`Device isn't capable of accepting network devices`, controller);
    const networkController = device.getNetworkController();
    if (networkController) await _NetworkDeviceFlow._removeDeviceFromController(device);
    const controllerLink = _NetworkDeviceFlow.buildLink(controller);
    await _NetworkDeviceFlow._setControllerFromLink(device, controllerLink);
    const networkDeviceLink = _NetworkDeviceFlow.buildLink(device);
    const networkDevices = controllerData.system.networkDevices;
    if (networkDevices.includes(networkDeviceLink)) return;
    return _NetworkDeviceFlow._setDevicesOnController(controller, [...networkDevices, networkDeviceLink]);
  }
  /**
       * This method is removing a device from the controller devices list. It doesn't remove the controller reference itself.
  
       * @param device A network device that's connected to a controller.
       */
  static async removeDeviceFromController(device) {
    if (!device) return;
    console.log(`Shadowrun 6e | Removing device ${device.name} from its controller`);
    await _NetworkDeviceFlow._removeDeviceFromController(device);
    await _NetworkDeviceFlow._removeControllerFromDevice(device);
  }
  /**
   * Remove a single device (given as a link) from a controllers network and disconnect the device from the controller.
   *
   * @param controller
   * @param deviceLink
   */
  static async removeDeviceLinkFromNetwork(controller, deviceLink) {
    console.log(`Shadowrun 6e | Removing device with uuid ${deviceLink} from network`);
    const controllerData = controller.asController();
    const device = await _NetworkDeviceFlow.resolveLink(deviceLink);
    if (device) {
      const networkController = device.getNetworkController();
      if (networkController) await _NetworkDeviceFlow._removeControllerFromDevice(device);
    }
    if (!controllerData) return;
    const deviceLinks = controllerData.system.networkDevices.filter((existingLink) => existingLink !== deviceLink);
    await _NetworkDeviceFlow._setDevicesOnController(controller, deviceLinks);
  }
  /**
   * Clear a controllers network, disconnecting it's devices from the controller and the controller
   * from it's devices.
   *
   * @param controller
   */
  static async removeAllDevicesFromNetwork(controller) {
    console.log(`Shadowrun 6e | Removing all devices from network ${controller.name}`);
    await _NetworkDeviceFlow._removeControllerFromAllDevices(controller);
    await _NetworkDeviceFlow._removeAllDevicesFromController(controller);
  }
  static async _setControllerFromLink(device, controllerLink) {
    if (!device.canBeNetworkDevice) return console.error("Shadowrun 6e | Given device cant be part of a network", device);
    await device.setNetworkController(controllerLink);
  }
  /**
   * As part of the deleteItem FoundryVTT event this method will called by all active users, even if they lack permission.
   * @param device The device to remove a connected controller from.
   * @private
   */
  static async _removeControllerFromDevice(device) {
    if (!device.canBeNetworkDevice) return console.error("Shadowrun 6e | Given device cant be part of a network", device);
    if (!_NetworkDeviceFlow._currentUserCanModifyDevice(device)) return;
    await device.setNetworkController("");
  }
  static async _setDevicesOnController(controller, deviceLinks) {
    if (!controller.canBeNetworkController) return console.error("Shadowrun 6e | Given device cant control a network", controller);
    await controller.update({ "system.networkDevices": deviceLinks });
  }
  static async _removeAllDevicesFromController(controller) {
    if (!controller.canBeNetworkController) return console.error("Shadowrun 6e | Given device cant control a network", controller);
    await controller.update({ "system.networkDevices": [] });
  }
  /**
   * As part of the deleteItem FoundryVTT event this method will be called by all active users, even if they lack permission.
   * @param device The device that is to be removed from the network controller.
   * @private
   */
  static async _removeDeviceFromController(device) {
    if (!device.canBeNetworkDevice) return console.error("Shadowrun 6e | Given device cant be part of a network", device);
    const networkController = device.getNetworkController();
    if (!networkController) return;
    const controller = await _NetworkDeviceFlow.resolveItemLink(networkController);
    if (!controller) return;
    if (!_NetworkDeviceFlow._currentUserCanModifyDevice(controller)) return;
    const controllerData = controller.asController();
    if (!controllerData) return;
    const deviceLink = _NetworkDeviceFlow.buildLink(device);
    const deviceLinks = controllerData.system.networkDevices.filter((existingLink) => existingLink !== deviceLink);
    await _NetworkDeviceFlow._setDevicesOnController(controller, deviceLinks);
  }
  static async _removeControllerFromAllDevices(controller) {
    if (!controller.canBeNetworkController) return console.error("Shadowrun 6e | Given device cant control a network", controller);
    const controllerData = controller.asController();
    if (!controllerData) return;
    const networkDevices = controllerData.system.networkDevices;
    if (networkDevices) {
      const devices = [];
      for (const deviceLink of networkDevices) {
        const device = await _NetworkDeviceFlow.resolveLink(deviceLink);
        if (device) devices.push(device);
      }
      for (const device of devices) {
        if (!device) continue;
        await _NetworkDeviceFlow._removeControllerFromDevice(device);
      }
    }
  }
  /**
   * Return all network devices connected to a controller.
   *
   *
   * @param controller
   */
  static async getNetworkDevices(controller) {
    const devices = [];
    const controllerData = controller.asController();
    if (!controllerData) return devices;
    for (const link of controllerData.system.networkDevices) {
      const device = await _NetworkDeviceFlow.resolveLink(link);
      if (device) devices.push(device);
      else console.warn(`SR6: Elysium | Controller ${controller.name} has a network device ${link} that doesn't exist anymore`);
    }
    return devices;
  }
  /**
   * Note: This handler will be called for all active users, even if they lack permission to alter item data.
   *       This can result in lingering network devices or controllers, when no GM or device owner is active.
   *
   * @param item This can be a network controller or device or neither.
   * @param data
   * @param id
   */
  static async handleOnDeleteItem(item, data, id) {
    console.debug(`Shadowrun 6e | Checking for network on deleted item ${item.name}`, item);
    if (item.canBeNetworkController) return await _NetworkDeviceFlow._removeControllerFromAllDevices(item);
    if (item.canBeNetworkDevice) return await _NetworkDeviceFlow._removeDeviceFromController(item);
  }
  static _currentUserCanModifyDevice(device) {
    return game.user?.isGM || device.isOwner;
  }
};

// src/module/item/prep/HostPrep.ts
function HostDataPreparation(system) {
  HostPrep.setDeviceCategory(system);
  HostPrep.prepareMatrixAttributes(system);
}
__name(HostDataPreparation, "HostDataPreparation");
var HostPrep = class {
  static {
    __name(this, "HostPrep");
  }
  static setDeviceCategory(system) {
    system.category = "host";
  }
  /**
   * Apply host matrix attribute rating.
   * 
   * Allow for custom attribute selections by user circumventing the rules.
   * 
   * This also allows for Kill Code#42 alternative host attribute values.
   * 
   * @param system
   */
  static prepareMatrixAttributes(system) {
    const { customAttributes } = system;
    const hostAttributeRatings = MatrixRules.hostMatrixAttributeRatings(system.rating);
    Object.values(system.atts).forEach((attribute) => {
      attribute.value = customAttributes ? attribute.value : hostAttributeRatings.pop();
      attribute.editable = customAttributes;
    });
  }
};

// src/module/utils/links.ts
var LinksHelpers = class _LinksHelpers {
  static {
    __name(this, "LinksHelpers");
  }
  /**
   * Determine if the given string contains a PDF pattern.
   *
   * @param candidate The string that might contain a PDF pattern like SR5 123
   */
  static isPDF(candidate) {
    if (!candidate) return false;
    return candidate.split(" ").length === 2;
  }
  /**
   * Determine if given string contains a url pattern.
   *
   * Parsing an url is expensive and doing so on UUIDs for JournalEntryPages will kill the browser :)
   * Therefore we assume what is not anything else, might be a url.
   *
   * @param candidate The string that might contain a url
   * @returns true, when candidate contains a url pattern
   */
  static isURL(candidate) {
    if (!candidate) return false;
    if (_LinksHelpers.isPDF(candidate)) return false;
    if (_LinksHelpers.isUuid(candidate)) return false;
    return true;
  }
  /**
   * Determine if given string contains a valid uuid pattern.
   *
   * FoundryVTT doesn't provide a method to check if a string is a valid uuid.
   * We assume a uuid will end on a 16 digit id and will contain at least one dot.
   *
   * @param candidate A string containing a Document.uuid
   * @returns true, when candidate contains a valid uuid pattern
   */
  static isUuid(candidate) {
    if (!candidate) return false;
    return !!foundry.utils.parseUuid(candidate).collection;
  }
  /**
   * Resolve given uuid for better handling for different document types.
   * @param source
   */
  static async resolveUuid(source3) {
    const resolvedUuid = foundry.utils.parseUuid(source3);
    const uuid = resolvedUuid.uuid.split("#")[0];
    const anchor = resolvedUuid.uuid.split("#")[1];
    const document2 = await fromUuid(uuid);
    return { document: document2, resolvedUuid, anchor };
  }
  /**
   * Use the items source field to open it as another browser tab.
   *
   * This is meant to allow for wikis to be used as sources.
   */
  static openSourceURL(source3) {
    if (source3 === "") {
      ui.notifications?.error("SR6.SourceFieldEmptyError", { localize: true });
    }
    window.open(source3);
  }
  /**
   * Use the items source field to try matching it against a PDF document and display that within FoundryVTT.
   */
  static openSourcePDF(source3) {
    if (!ui["pdfpager"]) {
      ui.notifications?.warn("SR6.DIALOG.MissingModuleContent", { localize: true });
      return;
    }
    if (!source3) {
      ui.notifications?.error("SR6.SourceFieldEmptyError", { localize: true });
      return;
    }
    const [code, page3] = source3.split(" ");
    ui.pdfpager.openPDFByCode(code, { page: parseInt(page3) });
  }
  /**
   * Open the document associated with the given uuid.
   *
   * @param source
   */
  static async openSourceByUuid(source3) {
    if (!source3) return;
    const { document: document2, resolvedUuid, anchor } = await _LinksHelpers.resolveUuid(source3);
    if (!document2) {
      ui.notifications?.error("SR6.SourceFieldEmptyError", { localize: true });
      return;
    }
    try {
      if (document2 instanceof SR6Item || document2 instanceof SR6Actor || document2 instanceof JournalEntry) {
        document2.sheet?.render(true);
      } else if (document2 instanceof JournalEntryPage) {
        document2.parent.sheet.render(true, { pageId: document2.id, anchor: anchor ?? void 0 });
      } else {
        ui.notifications?.error(`The document has no associated sheet.`);
      }
    } catch (error) {
      ui.notifications?.error(`Error opening the sheet for UUID: ${resolvedUuid.uuid}`, error);
    }
  }
  /**
   * Use the items source field and try different means of opening it.
   */
  static async openSource(source3) {
    if (_LinksHelpers.isPDF(source3)) {
      return _LinksHelpers.openSourcePDF(source3);
    }
    if (_LinksHelpers.isUuid(source3)) {
      return await _LinksHelpers.openSourceByUuid(source3);
    }
    if (_LinksHelpers.isURL(source3)) {
      return _LinksHelpers.openSourceURL(source3);
    }
  }
};

// src/module/item/prep/functions/TechnologyPrep.ts
var TechnologyPrep = {
  /**
   * Calculate the device condition monitor
   *
   * See SR5#228 'Matrix Damage'
   * @param technology The system technology section to be altered
   */
  prepareConditionMonitor(technology) {
    if (technology.condition_monitor === void 0) {
      technology.condition_monitor = { value: 0, max: 0, label: "" };
    }
    const rating = typeof technology.rating === "string" ? 0 : technology.rating;
    technology.condition_monitor.max = 8 + Math.ceil(rating / 2);
  },
  /**
   * Calculate a devices ability to conceal.
   *
   * See SR5#419 'Concealing Gear'
   * @param technology The system technology section to be altered
   * @param equippedMods Those item mods that are equipped.
   */
  prepareConceal(technology, equippedMods) {
    if (!technology.conceal) technology.conceal = { base: 0, value: 0, mod: [] };
    const concealParts = new PartsList();
    equippedMods.forEach((mod) => {
      if (mod.system.conceal && mod.system.conceal > 0) {
        concealParts.addUniquePart(mod.name, mod.system.conceal);
      }
    });
    technology.conceal.mod = concealParts.list;
    technology.conceal.value = Helpers.calcTotal(technology.conceal);
  }
};

// src/module/item/prep/SinPrep.ts
var SinPrep = {
  prepareBaseData(system) {
    SinPrep.prepareLicenseData(system);
  },
  prepareLicenseData(system) {
    if (typeof system.licenses === "object") {
      system.licenses = Object.values(system.licenses);
    }
  }
};

// src/module/item/prep/functions/ActionPrep.ts
var ActionPrep = {
  /**
   * Main preparation method for actions prep.
   * @param action The ActionRollData to alter.
   * @param item The item to use as a source.
   * @param equippedMods Equipped modifications on that item.
   * @param equippedAmmo Equipped ammunition on that item.
   */
  prepareData(action, item, equippedMods, equippedAmmo) {
    ActionPrep.clearMods(action);
    ActionPrep.prepareDamageSource(action, item);
    ActionPrep.prepareWithMods(action, equippedMods);
    ActionPrep.prepareWithAmmo(action, equippedAmmo);
    ActionPrep.calculateValues(action);
  },
  /**
   * remove any possible previous mods that might have been introduced by preparation or alteration in system data.
   *
   * @param action The ActionRollData to alter.
   */
  clearMods(action) {
    action.alt_mod = 0;
    action.limit.mod = [];
    action.damage.mod = [];
    action.damage.ap.mod = [];
    action.dice_pool_mod = [];
  },
  /**
   * Provide the action damage a source for the damage calculation.
   *
   * @param action The ActionRollData to alter.
   * @param item The item to use as a source.
   */
  prepareDamageSource(action, item) {
    if (!item.actor?.system) return;
    action.damage.source = {
      actorId: item.actor.id,
      itemId: item.id,
      itemName: item.name,
      itemType: item.type
    };
  },
  /**
   * Prepare weapon action data effects of the quipped ammo item.
   * @param action The systems data action property to be altered.
   * @param equippedAmmo The equipped ammunition item
   */
  prepareWithAmmo(action, equippedAmmo) {
    if (!equippedAmmo) {
      action.damage.element.value = action.damage.element.base;
      action.damage.type.value = action.damage.type.base;
      return;
    }
    const ammoData = equippedAmmo.system;
    const limitParts = new PartsList(action.limit.mod);
    if (ammoData.replaceDamage) {
      action.damage.override = { name: equippedAmmo.name, value: Number(ammoData.damage) };
    } else {
      action.damage.mod = PartsList.AddUniquePart(action.damage.mod, equippedAmmo.name, ammoData.damage);
    }
    action.damage.ap.mod = PartsList.AddUniquePart(action.damage.ap.mod, equippedAmmo.name, ammoData.ap);
    if (ammoData.accuracy) limitParts.addUniquePart(equippedAmmo.name, ammoData.accuracy);
    if (ammoData.element) {
      action.damage.element.value = ammoData.element;
    } else {
      action.damage.element.value = action.damage.element.base;
    }
    if (ammoData.damageType) {
      action.damage.type.value = ammoData.damageType;
    } else {
      action.damage.type.value = action.damage.type.base;
    }
    action.limit.mod = limitParts.list;
  },
  /**
   * Prepare general action data.
   *
   * This is used for all item type having actions and includes weapon value calculation as well.
   *
   * @param action The systems data action property to be altered.
   * @param equippedMods Those item mods that are equipped
   */
  prepareWithMods(action, equippedMods) {
    if (action.damage.base_formula_operator === "+") {
      action.damage.base_formula_operator = "add";
    }
    const limitParts = new PartsList(action.limit.mod);
    const dpParts = new PartsList(action.dice_pool_mod);
    equippedMods.forEach((mod) => {
      const modification = mod.asModification();
      if (!modification) return;
      if (modification.system.accuracy) limitParts.addUniquePart(mod.name, modification.system.accuracy);
      if (modification.system.dice_pool) dpParts.addUniquePart(mod.name, modification.system.dice_pool);
    });
    action.limit.mod = limitParts.list;
    action.dice_pool_mod = dpParts.list;
  },
  /**
   * Calculate the total values of action data.
   *
   * @param action To be altered action data.
   */
  calculateValues(action) {
    action.damage.value = Helpers.calcTotal(action.damage);
    action.damage.ap.value = Helpers.calcTotal(action.damage.ap);
    action.limit.value = Helpers.calcTotal(action.limit);
  }
};

// src/module/item/prep/functions/RangePrep.ts
var RangePrep = {
  prepareData(range, equippedMods) {
    RangePrep.clearMods(range);
    RangePrep.prepareRecoilCompensation(range, equippedMods);
  },
  clearMods(range) {
    range.rc.mod = [];
  },
  /**
   * Prepare a ranged weapons recoil compensation.
   *
   * @param range The system range data for weapons to be altered.
   * @param equippedMods Those item mods that are equipped.
   */
  prepareRecoilCompensation(range, equippedMods) {
    const rangeParts = new PartsList();
    equippedMods.forEach((mod) => {
      if (mod.system.rc) rangeParts.addPart(mod.name, mod.system.rc);
    });
    range.rc.mod = rangeParts.list;
    range.rc.value = Helpers.calcTotal(range.rc);
  }
};

// src/module/item/prep/AdeptPowerPrep.ts
var AdeptPowerPrep = {
  prepareBaseData(system) {
    AdeptPowerPrep.prepareType(system);
  },
  /**
   * Determine Adept Power Type based on action type.
   * @param action 
   */
  prepareType(system) {
    system.type = system.action.type ? "active" : "passive";
  }
};

// src/module/rules/SoakRules.ts
var SoakRules = class {
  static {
    __name(this, "SoakRules");
  }
  /**
   * Reduces the damage value based on net hits and damage data and actor special rules
   *
   * @remarks
   * Make sure that you first call modifyDamageType before you call this method
   * to determine the correct damage type (physical, stun, matrix)
   *
   * @param damageData The incoming damage
   * @param hits The number of hits on the soak tests
   * @returns The updated damage data
   */
  static reduceDamage(actor, damageData, hits) {
    if (damageData.type.value === "stun" && actor.isVehicle()) {
      return Helpers.reduceDamageByHits(damageData, damageData.value, "SR6.VehicleStunImmunity");
    }
    return Helpers.reduceDamageByHits(damageData, hits, "SR6.SoakTest");
  }
  /**
   * Turns physical damage to stun damage based on the damage and armor
   * @param damage The incoming damage
   * @param actor The actor affected by the damage
   * @returns The updated damage data
   */
  static modifyPhysicalDamageForArmor(damage, actor) {
    const updatedDamage = foundry.utils.duplicate(damage);
    if (damage.type.value === "physical") {
      if (!actor.isCharacter() && !actor.isSpirit() && !actor.isCritter() && !actor.isVehicle()) {
        return updatedDamage;
      }
      const modifiedArmor = actor.getModifiedArmor(damage);
      if (modifiedArmor) {
        const armorWillChangeDamageType = modifiedArmor.value > damage.value;
        if (armorWillChangeDamageType) {
          updatedDamage.type.value = "stun";
        }
      }
    }
    return updatedDamage;
  }
  /**
   * Turns matrix damage to biofeedback based on the actor state
   * @param damage The incoming damage
   * @param actor The actor affected by the damage
   * @returns The updated damage data
   */
  static modifyMatrixDamageForBiofeedback(damage, actor) {
    const updatedDamage = foundry.utils.duplicate(damage);
    if (damage.type.value === "matrix") {
      const actorData = actor.system;
      if (!actor.isCharacter()) {
        return updatedDamage;
      }
      if (actorData.initiative.perception === "matrix") {
        if (actorData.matrix.hot_sim) {
          updatedDamage.type.value = "physical";
        } else {
          updatedDamage.type.value = "stun";
        }
      }
    }
    return updatedDamage;
  }
};

// src/module/rules/CombatRules.ts
var CombatRules = class _CombatRules {
  static {
    __name(this, "CombatRules");
  }
  static iniOrderCanDoAnotherPass(scores) {
    for (const score of scores) {
      if (_CombatRules.iniScoreCanDoAnotherPass(score)) return true;
    }
    return false;
  }
  /**
   * Check if there is another initiative pass possible with the given score.
   * @param score
   * @return true means another initiative pass is possible
   */
  static iniScoreCanDoAnotherPass(score) {
    return _CombatRules.reduceIniResultAfterPass(score) > 0;
  }
  /**
   * Reduce the given initiative score according to @PDF SR5#159
   * @param score This given score can't be reduced under zero.
   */
  static reduceIniResultAfterPass(score) {
    return Math.max(score + SR.combat.INI_RESULT_MOD_AFTER_INI_PASS, 0);
  }
  /**
   * Reduce the initiative score according to the current initiative pass @PDF SR5#160.
   * @param score
   * @param pass The current initiative pass. Each combat round starts at the initiative pass of 1.
   */
  static reduceIniOnLateSpawn(score, pass) {
    pass = Math.max(pass - 1, 0);
    score = Math.max(score, 0);
    const reducedScore = score + pass * SR.combat.INI_RESULT_MOD_AFTER_INI_PASS;
    return _CombatRules.getValidInitiativeScore(reducedScore);
  }
  /**
   * Return a valid initiative score on updates or score changes
   *
   * @param score The initiative score after it's been updated.
   * @returns A valid initiative score
   */
  static getValidInitiativeScore(score) {
    return Math.max(score, 0);
  }
  /**
   * Determine if an attack hits the defender based on their hits.
   *
   * According to combat sequence (SR5#173) part defend.
   *
   * @param attackerHits
   * @param defenderHits
   * @returns true, when the attack hits.
   */
  static attackHits(attackerHits, defenderHits) {
    return attackerHits > defenderHits;
  }
  /**
   * Determine if an attack grazes the defender.
   *
   * According to combat sequence (SR5#173) part defend.
   *
   * @param attackerHits
   * @param defenderHits
   * @returns true, when the attack grazes.
   */
  static attackGrazes(attackerHits, defenderHits) {
    return attackerHits === defenderHits;
  }
  /**
   * Determine if an attack misses the defender based on their hits.
   *
   * According to combat sequence (SR5#173) part defend.
   *
   * @param attackerHits
   * @param defenderHits
   * @returns true, when the attack hits.
   */
  static attackMisses(attackerHits, defenderHits) {
    return !_CombatRules.attackHits(attackerHits, defenderHits);
  }
  /**
   * Modify Damage according to combat sequence (SR5#173) part defend. Successful attack.
   *
   * @param defender The active defender
   * @param attackerHits The attackers hits. Should be a positive number.
   * @param defenderHits The attackers hits. Should be a positive number.
   * @param damage Incoming damage to be modified
   * @return A new damage object for modified damage.
   */
  static modifyDamageAfterHit(defender, attackerHits, defenderHits, damage) {
    let modified = foundry.utils.duplicate(damage);
    if (attackerHits < 0) attackerHits = 0;
    if (defenderHits < 0) defenderHits = 0;
    PartsList.AddUniquePart(modified.mod, "SR6.Attacker", attackerHits);
    PartsList.AddUniquePart(modified.mod, "SR6.Defender", -defenderHits);
    modified.value = Helpers.calcTotal(modified, { min: 0 });
    modified = _CombatRules.modifyDamageTypeAfterHit(modified, defender);
    return modified;
  }
  /**
   * Check if vehicle wouldn't take any damage due to vehicle armor rules (SR5#199)
   * @param incomingDamage The incoming damage
   * @param attackerHits The attackers hits. Should be a positive number.
   * @param defenderHits The attackers hits. Should be a positive number.
   * @param actor The active defender
   */
  static isBlockedByVehicleArmor(incomingDamage, attackerHits, defenderHits, actor) {
    if (!actor.isVehicle()) {
      return false;
    }
    return _CombatRules.isDamageLessThanArmor(incomingDamage, attackerHits, defenderHits, actor);
  }
  /**
   * Check if actor wouldn't take any damage due to hardened armor rules (SR5#397)
   * @param incomingDamage The incoming damage
   * @param attackerHits The attackers hits. Should be a positive number.
   * @param defenderHits The attackers hits. Should be a positive number.
   * @param actor The active defender
   */
  static isBlockedByHardenedArmor(incomingDamage, attackerHits = 0, defenderHits = 0, actor) {
    const armor3 = actor.getArmor(incomingDamage);
    if (!armor3.hardened) {
      return false;
    }
    return _CombatRules.isDamageLessThanArmor(incomingDamage, attackerHits, defenderHits, actor);
  }
  /**
   * Check if incoming damage (modified by net hits) is less than the actor's armor (modified by AP).
   * Used for vehicle armor, hardened armor, and physical -> stun damage logic
   * @param incomingDamage The incoming damage
   * @param attackerHits The attackers hits. Should be a positive number.
   * @param defenderHits The attackers hits. Should be a positive number.
   * @param actor The active defender
   */
  static isDamageLessThanArmor(incomingDamage, attackerHits, defenderHits, actor) {
    const modifiedDamage = _CombatRules.modifyDamageAfterHit(actor, attackerHits, defenderHits, incomingDamage);
    const modifiedAv = actor.getArmor(incomingDamage).value;
    const modifiedDv = modifiedDamage.value;
    return modifiedDv < modifiedAv;
  }
  /**
   * Check if vehicle wouldn't take any damage due to non-electric stun damage
   * @param incomingDamage The incoming damage
   * @param actor The active defender
   */
  static doesNoPhysicalDamageToVehicle(incomingDamage, actor) {
    return actor.isVehicle() && incomingDamage.type.value === "stun" && incomingDamage.element.value !== "electricity";
  }
  /**
   * Modify damage according to suppression defense (SR5#179). Successful attack.
   *
   * In case of suppression a successful attack just does weapon damage (base + ammunition)
   *
   * @param damage The incoming weapon damage of the attack, unaltered.
   */
  static modifyDamageAfterSuppressionHit(damage) {
    return foundry.utils.duplicate(damage);
  }
  /**
   * Modify damage according to combat sequence (SR5#173 part defend. Missing attack.
   * @param damage Incoming damage to be modified
   * @param isHitWithNoDamage Optional parameter used for physical defense tests when attack hits but will deal no damage
   * @return A new damage object for modified damage.
   */
  static modifyDamageAfterMiss(damage, isHitWithNoDamage) {
    const modifiedDamage = foundry.utils.duplicate(damage);
    modifiedDamage.override = { name: "SR6.TestResults.Success", value: 0 };
    Helpers.calcTotal(modifiedDamage, { min: 0 });
    modifiedDamage.ap.override = { name: "SR6.TestResults.Success", value: 0 };
    Helpers.calcTotal(modifiedDamage.ap);
    modifiedDamage.type.value = "";
    if (!isHitWithNoDamage) {
      modifiedDamage.element.value = "";
    }
    return modifiedDamage;
  }
  /**
   * Modify damage according to combat sequence (SR5#173 part defend B). Damage resistance.
   *
   * @param actor The actor resisting the damage
   * @param damage Incoming damage to be modified.
   * @param hits The resisting tests hits
   * @return A new damage object for modified damage.
   */
  static modifyDamageAfterResist(actor, damage, hits) {
    if (hits < 0) hits = 0;
    let { modified } = SoakRules.reduceDamage(actor, damage, hits);
    Helpers.calcTotal(modified, { min: 0 });
    return modified;
  }
  /**
   * Modify amor according to combat sequence (SR5#173) part defend.
   *
   * @param armor An armor value to be modified.
   * @param damage The damage containing the armor penetration to be applied.
   * @returns A new armor value for modified armor
   */
  static modifyArmorAfterHit(armor3, damage) {
    const modifiedArmor = foundry.utils.duplicate(armor3);
    if (damage.ap.value <= 0) return modifiedArmor;
    console.error("Check if ap is a negative value or positive value during weapon item configuration");
    PartsList.AddUniquePart(modifiedArmor.mod, "SR6.AP", damage.ap.value);
    modifiedArmor.value = Helpers.calcTotal(modifiedArmor, { min: 0 });
    return modifiedArmor;
  }
  /**
   * Changes the damage type based on the incoming damage type and the actor state (armor, matrix perception..)
   * @param damage The incoming damage
   * @param actor The actor affected by the damage
   * @returns The updated damage data
   */
  static modifyDamageTypeAfterHit(damage, actor) {
    let updatedDamage = foundry.utils.duplicate(damage);
    if (actor.isVehicle() && updatedDamage.element.value === "electricity" && updatedDamage.type.value === "stun") {
      updatedDamage.type.value = "physical";
    }
    const damageSourceItem = Helpers.findDamageSource(damage);
    if (damageSourceItem && damageSourceItem.isDirectCombatSpell) {
      return updatedDamage;
    }
    updatedDamage = SoakRules.modifyPhysicalDamageForArmor(updatedDamage, actor);
    return SoakRules.modifyMatrixDamageForBiofeedback(updatedDamage, actor);
  }
  /**
   * Determine the amount of initiative score modifier change.
   *
   * According to SR5#170 'Wound Modifiers'.
   *
   * @param woundModBefore A negative wound modifier, before taking latest damage.
   * @param woundModAfter A negative wound modifier, after taking latest damage.
   * @return An to be applied initiative score modifier
   */
  static combatInitiativeScoreModifierAfterDamage(woundModBefore, woundModAfter) {
    return Math.min(woundModBefore, 0) - Math.min(woundModAfter, 0);
  }
  /**
   * Can a defense mode be used with a specific initiative score
   *
   * @param iniScore The combatants ini score
   * @param defenseIniScoreMod  The defense modes ini score modifier
   */
  static canUseActiveDefense(iniScore, defenseIniScoreMod) {
    return Math.max(iniScore, 0) + Math.min(defenseIniScoreMod, 0) < 0;
  }
  /**
   * Calculate defense modifier for multiple previous attacks in a combat turn.
   *
   * See SR5#189 'Defense Modifiers Table'.
   *
   * @param attacks Amount of attacks within the current combat turn
   * @returns A negative modifier or zero to be applied on physical defense tests.
   */
  static defenseModifierForPreviousAttacks(attacks) {
    return Math.max(attacks, 0) * -1;
  }
  /**
   * Calculate the initiative score adjustment to be made for damage taken during active combat
   *
   * See SR6.160 'Changing Initiative'
   *
   * @param woundsBefore Wound modifier (-2) before damage has been taken
   * @param woundsAfter Wound modifier (-3) after damage has been taken
   */
  static initiativeScoreWoundAdjustment(woundsBefore, woundsAfter) {
    return woundsAfter - woundsBefore;
  }
};

// src/module/rules/MeleeRules.ts
var MeleeRules = class {
  static {
    __name(this, "MeleeRules");
  }
  /**
   * Determine melee defense reach modifier according to Meele Attack (SR5#186)
   *
   * @param incomingReach The attackers reach value
   * @param defendingReach The defenders reach value
   */
  static defenseReachModifier(incomingReach, defendingReach) {
    return defendingReach - incomingReach;
  }
};

// src/module/apps/dialogs/FormDialog.ts
var FormDialog = class extends Dialog {
  static {
    __name(this, "FormDialog");
  }
  constructor(data, options) {
    super(data, options);
    const { templateData, templatePath } = data;
    this._templateData = templateData;
    this._templatePath = templatePath;
    this._onAfterClose = data.onAfterClose || this.onAfterClose;
    this.selection = this._emptySelection();
    this._selectionPromise = new Promise((resolve, reject) => {
      this._selectionResolve = resolve;
      this._selectionReject = reject;
    });
  }
  async close() {
    await super.close();
    if (this.canceled) {
      setTimeout(() => this._selectionResolve(this.selection), 250);
    }
  }
  activateListeners(html) {
    super.activateListeners(html);
    html.on("change", "input,select,textarea", this._onChangeInput.bind(this));
  }
  async submit(button) {
    this.selectedButton = button.name ?? button.label;
    this.applyFormData();
    super.submit(button);
    await this.afterSubmit("jQuery" in this.options ? this.element : this.element[0]);
  }
  async afterSubmit(html) {
    this.selection = await this._onAfterClose(html, this.selectedButton);
    setTimeout(() => this._selectionResolve(this.selection), 250);
  }
  /**
   * Allow Foundry Sheet behavior for dialogs with complex forms.
   * @returns
   */
  applyFormData() {
    if (!this.options.applyFormChangesOnSubmit) return;
    if (!this.form) throw new Error(`The FormApplication subclass has no registered form element`);
    const fd = new FormDataExtended(this.form, { editors: {} });
    const data = fd.object;
    this._updateData(data);
  }
  _updateData(data) {
    foundry.utils.mergeObject(this.data.templateData, data);
  }
  //@ts-expect-error
  getData() {
    this.data.buttons = this.data.buttons || this.buttons;
    this._amendButtonsWithName(this.data.buttons);
    const data = super.getData();
    return foundry.utils.mergeObject(data, {
      ...this.data,
      content: ""
    });
  }
  /**
   * Dialog button object to be rendered underneath dialog content.
   * Follows Dialog.data.buttons typing.
   */
  get buttons() {
    return {};
  }
  /**
   * Template file to render the inner dialog content with.
   * Will be given FormDialog.data to render.
   */
  get templateContent() {
    return "";
  }
  async select() {
    await this.render(true);
    if (this._selectionPromise === void 0 || this.selection === void 0) {
      return this._emptySelection();
    }
    return await this._selectionPromise;
  }
  _emptySelection() {
    return {};
  }
  /** Dialog has been confirmed and something has been selected.
   */
  get selected() {
    return !this.canceled;
  }
  /** Dialog has been canceled and nothing has been selected.
   *
   * Will also report cancel if a cancel button has been defined.
   */
  get canceled() {
    return !this.selectedButton || this.selectedButton === "cancel";
  }
  /** @override */
  static getButtons() {
    return {};
  }
  /** Allow for the selected button to be addressed by its key, not it's localized label.
   */
  _amendButtonsWithName(buttons) {
    Object.keys(buttons).forEach((name3) => buttons[name3].name = name3);
  }
  /**
   * See FormApplication._renderInner
   */
  async _renderInner(data) {
    const templatePath = data.templatePath || this.templateContent;
    if (templatePath)
      data.content = await renderTemplate(
        data.templatePath || this.templateContent,
        data.templateData || data
      );
    const html = await super._renderInner(data);
    this.form = html.filter((i2, el) => el instanceof HTMLFormElement)[0];
    if (!this.form) this.form = html.find("form")[0];
    return html;
  }
  /**
   * Based on FormDialog.options configuration apply changes to data.
   */
  async _onChangeInput(event) {
    const el = event.target;
    if (this.options.applyFormChangesOnSubmit) {
      this.applyFormData();
      this.render();
    }
  }
  /**
   * Sub dialogs should override this method for custom handling of closing dialog.
   */
  onAfterClose(html) {
  }
};

// src/module/apps/dialogs/DamageApplicationDialog.ts
var DamageApplicationDialog = class _DamageApplicationDialog extends FormDialog {
  static {
    __name(this, "DamageApplicationDialog");
  }
  constructor(actors, damage, options) {
    const dialogData = _DamageApplicationDialog.getDialogData(actors, damage);
    super(dialogData, options);
  }
  static get defaultOptions() {
    const options = super.defaultOptions;
    options.id = "damage-application";
    options.classes = ["sr6", "form-dialog"];
    options.resizable = true;
    options.height = "auto";
    return options;
  }
  static getDialogData(actors, damage) {
    const title = game.i18n.localize("SR6.DamageApplication.Title");
    const templatePath = "systems/shadowrun6-elysium/dist/templates/apps/dialogs/damage-application.html";
    const actorDamage = actors.map((a2) => {
      return { actor: a2 };
    });
    const templateData = {
      damage,
      actorDamage
    };
    const buttons = {
      damage: {
        label: game.i18n.localize("SR6.DamageApplication.ApplyDamage")
      }
    };
    const onAfterClose = /* @__PURE__ */ __name(() => actorDamage, "onAfterClose");
    return {
      title,
      templatePath,
      templateData,
      onAfterClose,
      buttons,
      default: "damage"
    };
  }
};

// src/module/actor/flows/DamageApplicationFlow.ts
var DamageApplicationFlow = class _DamageApplicationFlow {
  static {
    __name(this, "DamageApplicationFlow");
  }
  /**
   * Runs the flow to apply damage to multiple actors with user interaction
   * This will also take care of changing the damage type if necessary
   * @param actors The actors that are affected
   * @param damage The damage the actors will receive
   */
  async runApplyDamage(actors, damage) {
    const damageApplicationDialog = await new DamageApplicationDialog(actors, damage);
    await damageApplicationDialog.select();
    if (damageApplicationDialog.canceled) {
      return;
    }
    actors.forEach((actor) => {
      this.applyDamageToActor(actor, damage);
    });
  }
  /** Apply all types of damage to the actor.
   *
   * @param damage The damage to apply. Stun damage will be turned to physical for grunts.
   */
  async applyDamageToActor(actor, damage) {
    if (damage.value <= 0) {
      return;
    }
    damage = this.changeStunToPhysicalForGrunts(actor, damage);
    await actor.addDamage(damage);
  }
  changeStunToPhysicalForGrunts(actor, damage) {
    const updatedDamage = foundry.utils.duplicate(damage);
    if (!actor.isGrunt()) {
      return updatedDamage;
    }
    if (damage.type.value === "stun") {
      updatedDamage.type.value = "physical";
    }
    return updatedDamage;
  }
  static handleRenderChatMessage(app, html, data) {
    html.on("click", ".apply-damage", (event) => _DamageApplicationFlow.chatMessageActionApplyDamage(html, event));
  }
  /**
   * When triggered from a chat message
   * @param html
   * @param event
   * @returns
   */
  static async chatMessageActionApplyDamage(html, event) {
    event.stopPropagation();
    event.preventDefault();
    const applyDamage = $(event.currentTarget);
    const value = Number(applyDamage.data("damageValue"));
    const type = String(applyDamage.data("damageType"));
    const ap = Number(applyDamage.data("damageAp"));
    const element = String(applyDamage.data("damageElement"));
    let damage = Helpers.createDamageData(value, type, ap, element);
    let actors = Helpers.getSelectedActorsOrCharacter();
    if (actors.length === 0) {
      const messageId = html.data("messageId");
      const test = await TestCreator.fromMessage(messageId);
      if (!test) return;
      await test.populateDocuments();
      if (test.hasTargets) test.targets.forEach((target) => actors.push(target.actor));
      else actors.push(test.actor);
    }
    if (actors.length === 0) {
      ui.notifications?.warn(game.i18n.localize("SR6.Warnings.TokenSelectionNeeded"));
      return;
    }
    await new _DamageApplicationFlow().runApplyDamage(actors, damage);
  }
};

// src/module/apps/dialogs/TestDialog.ts
var TestDialog = class extends FormDialog {
  static {
    __name(this, "TestDialog");
  }
  // @ts-expect-error // TODO: default option value with all the values...
  constructor(data, options = {}, listeners = []) {
    options.applyFormChangesOnSubmit = true;
    super(data, options);
    this.listeners = listeners;
  }
  static get defaultOptions() {
    const options = super.defaultOptions;
    options.id = "test-dialog";
    options.classes = ["sr6", "form-dialog"];
    options.resizable = true;
    options.height = "auto";
    options.width = "auto";
    return options;
  }
  activateListeners(html) {
    super.activateListeners(html);
    html.find(".entity-link").on("click", Helpers.renderEntityLinkSheet);
    this._injectExternalActiveListeners(html);
  }
  /**
   * Inject the listeners while binding local `this` to them.
   */
  _injectExternalActiveListeners(html) {
    for (const listener of this.listeners) {
      html.find(listener.query).on(listener.on, (event) => listener.callback.bind(this.data.test)(event, this));
    }
  }
  /**
   * Overwrite this method to provide an alternative template for the dialog inner content.
   *
   * data.templatePath work's the same and can be used as well.
   */
  get templateContent() {
    return "systems/shadowrun6-elysium/dist/templates/apps/dialogs/success-test-dialog.html";
  }
  //@ts-expect-error
  getData() {
    const data = super.getData();
    data.rollMode = data.test.data.options?.rollMode;
    data.rollModes = CONFIG.Dice.rollModes;
    data.default = "roll";
    data.config = SR6;
    return data;
  }
  /**
   * Overwrite this method to provide the dialog application title.
   */
  get title() {
    const data = this.data;
    return game.i18n.localize(data.test.title);
  }
  /**
   * Overwrite this method to provide dialog buttons.
   */
  get buttons() {
    return {
      roll: {
        label: game.i18n.localize("SR6.Roll"),
        icon: '<i class="fas fa-dice-six"></i>'
      },
      cancel: {
        label: game.i18n.localize("SR6.Dialogs.Common.Cancel")
      }
    };
  }
  /**
   * Callback for after the dialog has closed.
   * @param html
   */
  onAfterClose(html) {
    return this.data.test.data;
  }
  /**
   * Update ValueField data used on the template and alter automatic calculation with manual override values, where
   * necessary.
   *
   * @param data An object with keys in Foundry UpdateData style {'key.key.key': value}
   */
  _updateData(data) {
    if (this.selectedButton === "cancel") return;
    Object.entries(data).forEach(([key, value]) => {
      const valueField = foundry.utils.getProperty(this.data, key);
      if (foundry.utils.getType(valueField) !== "Object" || !valueField.hasOwnProperty("mod")) return;
      delete data[key];
      if (valueField.value === value) return;
      if (value === null || value === "")
        delete valueField.override;
      else
        valueField.override = { name: "SR6.ManualOverride", value: Number(value) };
    });
    foundry.utils.mergeObject(this.data, data);
    this.data.test.prepareBaseValues();
    this.data.test.calculateBaseValues();
    this.data.test.validateBaseValues();
  }
};

// src/module/template.ts
var Template = class extends MeasuredTemplate {
  static {
    __name(this, "Template");
  }
  /**
   * Track the timestamp when the last mouse move event was captured.
   */
  #moveTime = 0;
  /* -------------------------------------------- */
  /**
   * The initially active CanvasLayer to re-activate after the workflow is complete.
   */
  #initialLayer;
  /* -------------------------------------------- */
  /**
   * Track the bound event handlers so they can be properly canceled later.
   */
  #events;
  /**
   * Create a template preview based on given items blast data.
   *
   * This is factory method to create a new template instance.
   *
   * @param item Item containing any blast data.
   * @param onComplete Handler to call when template is placed.
   * @returns Template instance. Not drawn on scene.
   */
  static fromItem(item, onComplete) {
    if (!canvas.scene) return;
    const blast = item.getBlastData();
    const templateShape = "circle";
    const templateData = {
      t: templateShape,
      user: game.user?.id,
      direction: 0,
      x: 0,
      y: 0,
      fillColor: game.user?.color,
      distance: blast?.radius || 1,
      // Adhere to DataModel validation.
      dropoff: blast?.dropoff || 0
    };
    const cls = CONFIG.MeasuredTemplate.documentClass;
    const template = new cls(templateData, { parent: canvas.scene });
    const object = new this(template);
    object.item = item;
    object.onComplete = onComplete;
    return object;
  }
  /**
   * Draw a preview of this Template instance on the currently active scene.
   */
  async drawPreview() {
    if (!canvas.ready || !this.layer.preview) return;
    const initialLayer = canvas.activeLayer;
    if (!initialLayer) return;
    await this.draw();
    this.layer.activate();
    this.layer.preview.addChild(this);
    return this.activatePreviewListeners(initialLayer);
  }
  activatePreviewListeners(initialLayer) {
    return new Promise((resolve, reject) => {
      if (!canvas.ready || !canvas.stage || !canvas.app) return;
      this.#initialLayer = initialLayer;
      this.#events = {
        cancel: this._onCancelPlacement.bind(this),
        confirm: this._onConfirmPlacement.bind(this),
        move: this._onMovePlacement.bind(this),
        resolve,
        reject,
        rotate: this._onRotatePlacement.bind(this)
      };
      canvas.stage?.on("mousemove", this.#events.move);
      canvas.stage?.on("mousedown", this.#events.confirm);
      canvas.app.view.oncontextmenu = this.#events.cancel;
      canvas.app.view.onwheel = this.#events.rotate;
    });
  }
  /**
   * Shared code for when template placement ends by being confirmed or canceled.
  * @param {Event} event  Triggering event that ended the placement.
  */
  async _finishPlacement(event) {
    if (!canvas.stage || !canvas.app) return;
    this.layer._onDragLeftCancel(event);
    canvas.stage.off("mousemove", this.#events.move);
    canvas.stage.off("mousedown", this.#events.confirm);
    canvas.app.view.oncontextmenu = null;
    canvas.app.view.onwheel = null;
    this.#initialLayer.activate();
    if (this.onComplete) this.onComplete();
  }
  /* -------------------------------------------- */
  /**
   * Move the template preview when the mouse moves.
   * @param {Event} event  Triggering mouse event.
   */
  _onMovePlacement(event) {
    event.stopPropagation();
    const now = Date.now();
    if (now - this.#moveTime <= 20) return;
    const center = event.data.getLocalPosition(this.layer);
    const interval = canvas.grid.type === CONST.GRID_TYPES.GRIDLESS ? 0 : 2;
    const snapped = canvas.grid.getSnappedPosition(center.x, center.y, interval);
    this.document.updateSource({ x: snapped.x, y: snapped.y });
    this.refresh();
    this.#moveTime = now;
  }
  /* -------------------------------------------- */
  /**
   * Rotate the template preview by 3 increments when the mouse wheel is rotated.
   * @param {Event} event  Triggering mouse event.
   */
  _onRotatePlacement(event) {
    if (event.ctrlKey) event.preventDefault();
    event.stopPropagation();
    const delta = canvas.grid.type > CONST.GRID_TYPES.SQUARE ? 30 : 15;
    const snap = event.shiftKey ? delta : 5;
    const update = { direction: this.document.direction + snap * Math.sign(event.deltaY) };
    this.document.updateSource(update);
    this.refresh();
  }
  /* -------------------------------------------- */
  /**
   * Confirm placement when the left mouse button is clicked.
   * @param {Event} event  Triggering mouse event.
   */
  async _onConfirmPlacement(event) {
    await this._finishPlacement(event);
    const interval = canvas.grid.type === CONST.GRID_TYPES.GRIDLESS ? 0 : 2;
    const destination = canvas.grid.getSnappedPosition(this.document.x, this.document.y, interval);
    this.document.updateSource(destination);
    this.#events.resolve(canvas.scene.createEmbeddedDocuments("MeasuredTemplate", [this.document.toObject()]));
  }
  /* -------------------------------------------- */
  /**
   * Cancel placement when the right mouse button is clicked.
   * @param {Event} event  Triggering mouse event.
   */
  async _onCancelPlacement(event) {
    await this._finishPlacement(event);
    this.#events.reject();
  }
};

// src/module/rules/TestRules.ts
var TestRules = {
  /**
   * The modifier value applied for each extended test iteration
   */
  extendedModifierValue: -1,
  /**
   * Calculate the modifier for the next extended test run.
   *
   * @param current The current extended test modifier or zero.
   */
  calcNextExtendedModifier: /* @__PURE__ */ __name((current = 0) => {
    return current + TestRules.extendedModifierValue;
  }, "calcNextExtendedModifier"),
  /**
   * Can a test be extended using the given pool value
   * @param pool The pool of the test to be extended.
   * @param threshold The extended test threshold to be met
   * @param extendedHits The summed up hits across all test iterations
   * @returns When true, test can be extended.
   */
  canExtendTest: /* @__PURE__ */ __name((pool, threshold, extendedHits) => {
    if (threshold > 0)
      return extendedHits < threshold && pool > 0;
    return pool > 0;
  }, "canExtendTest"),
  /**
   * Has a Success Test been successful?
   * @param hits Amount of hits (reduced by limit) scored on a test
   * @param threshold Threshold to reach for a test. 0 should none be applied.
   * @returns true, when hits vs threshold score a success
   */
  success: /* @__PURE__ */ __name((hits, threshold) => {
    hits = Math.max(hits, 0);
    threshold = Math.max(threshold, 0);
    if (threshold > 0) return hits >= threshold;
    else return hits > 0;
  }, "success"),
  /**
   * Has a Success Test glitched?
   *
   * @param glitches The amount of dice with glitch value
   * @param pool The amount of dice used for the test as a whole
   * @returns If true, the given success test values result in a glitched test
   */
  glitched: /* @__PURE__ */ __name((glitches, pool) => {
    glitches = Math.max(glitches, 0);
    pool = Math.max(pool, 1);
    return glitches > Math.floor(pool / 2);
  }, "glitched"),
  /**
   * Has a Success Test glitched critically?
   *
   * @param hits Amount of hits achieved
   * @param glitched Has a test been glitched?
   */
  criticalGlitched: /* @__PURE__ */ __name((hits, glitched) => {
    return hits === 0 && glitched;
  }, "criticalGlitched")
};

// node_modules/@yaireo/tagify/dist/tagify.esm.js
var t = "&#8203;";
function e(t2, e2) {
  (null == e2 || e2 > t2.length) && (e2 = t2.length);
  for (var i2 = 0, n2 = new Array(e2); i2 < e2; i2++) n2[i2] = t2[i2];
  return n2;
}
__name(e, "e");
function i(t2) {
  return function(t3) {
    if (Array.isArray(t3)) return e(t3);
  }(t2) || function(t3) {
    if ("undefined" != typeof Symbol && null != t3[Symbol.iterator] || null != t3["@@iterator"]) return Array.from(t3);
  }(t2) || function(t3, i2) {
    if (!t3) return;
    if ("string" == typeof t3) return e(t3, i2);
    var n2 = Object.prototype.toString.call(t3).slice(8, -1);
    "Object" === n2 && t3.constructor && (n2 = t3.constructor.name);
    if ("Map" === n2 || "Set" === n2) return Array.from(n2);
    if ("Arguments" === n2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return e(t3, i2);
  }(t2) || function() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }();
}
__name(i, "i");
var n = { isEnabled: /* @__PURE__ */ __name(function() {
  var t2;
  return null === (t2 = window.TAGIFY_DEBUG) || void 0 === t2 || t2;
}, "isEnabled"), log: /* @__PURE__ */ __name(function() {
  for (var t2 = arguments.length, e2 = new Array(t2), n2 = 0; n2 < t2; n2++) e2[n2] = arguments[n2];
  var s2;
  this.isEnabled() && (s2 = console).log.apply(s2, ["[Tagify]:"].concat(i(e2)));
}, "log"), warn: /* @__PURE__ */ __name(function() {
  for (var t2 = arguments.length, e2 = new Array(t2), n2 = 0; n2 < t2; n2++) e2[n2] = arguments[n2];
  var s2;
  this.isEnabled() && (s2 = console).warn.apply(s2, ["[Tagify]:"].concat(i(e2)));
}, "warn") };
var s = /* @__PURE__ */ __name(function(t2, e2, i2, n2) {
  return t2 = "" + t2, e2 = "" + e2, n2 && (t2 = t2.trim(), e2 = e2.trim()), i2 ? t2 == e2 : t2.toLowerCase() == e2.toLowerCase();
}, "s");
var a = /* @__PURE__ */ __name(function(t2, e2) {
  return t2 && Array.isArray(t2) && t2.map(function(t3) {
    return o(t3, e2);
  });
}, "a");
function o(t2, e2) {
  var i2, n2 = {};
  for (i2 in t2) e2.indexOf(i2) < 0 && (n2[i2] = t2[i2]);
  return n2;
}
__name(o, "o");
function r(t2) {
  return new DOMParser().parseFromString(t2.trim(), "text/html").body.firstElementChild;
}
__name(r, "r");
function l(t2, e2) {
  for (e2 = e2 || "previous"; t2 = t2[e2 + "Sibling"]; ) if (3 == t2.nodeType) return t2;
}
__name(l, "l");
function d(t2) {
  return "string" == typeof t2 ? t2.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/`|'/g, "&#039;") : t2;
}
__name(d, "d");
function c(t2) {
  var e2 = Object.prototype.toString.call(t2).split(" ")[1].slice(0, -1);
  return t2 === Object(t2) && "Array" != e2 && "Function" != e2 && "RegExp" != e2 && "HTMLUnknownElement" != e2;
}
__name(c, "c");
function u(t2, e2, i2) {
  var n2, s2;
  function a2(t3, e3) {
    for (var i3 in e3) if (e3.hasOwnProperty(i3)) {
      if (c(e3[i3])) {
        c(t3[i3]) ? a2(t3[i3], e3[i3]) : t3[i3] = Object.assign({}, e3[i3]);
        continue;
      }
      if (Array.isArray(e3[i3])) {
        t3[i3] = Object.assign([], e3[i3]);
        continue;
      }
      t3[i3] = e3[i3];
    }
  }
  __name(a2, "a");
  return n2 = t2, (null != (s2 = Object) && "undefined" != typeof Symbol && s2[Symbol.hasInstance] ? s2[Symbol.hasInstance](n2) : n2 instanceof s2) || (t2 = {}), a2(t2, e2), i2 && a2(t2, i2), t2;
}
__name(u, "u");
function g() {
  var t2 = [], e2 = {}, i2 = true, n2 = false, s2 = void 0;
  try {
    for (var a2, o2 = arguments[Symbol.iterator](); !(i2 = (a2 = o2.next()).done); i2 = true) {
      var r2 = a2.value, l2 = true, d2 = false, u2 = void 0;
      try {
        for (var g2, h2 = r2[Symbol.iterator](); !(l2 = (g2 = h2.next()).done); l2 = true) {
          var p2 = g2.value;
          c(p2) ? e2[p2.value] || (t2.push(p2), e2[p2.value] = 1) : t2.includes(p2) || t2.push(p2);
        }
      } catch (t3) {
        d2 = true, u2 = t3;
      } finally {
        try {
          l2 || null == h2.return || h2.return();
        } finally {
          if (d2) throw u2;
        }
      }
    }
  } catch (t3) {
    n2 = true, s2 = t3;
  } finally {
    try {
      i2 || null == o2.return || o2.return();
    } finally {
      if (n2) throw s2;
    }
  }
  return t2;
}
__name(g, "g");
function h(t2) {
  return String.prototype.normalize ? "string" == typeof t2 ? t2.normalize("NFD").replace(/[\u0300-\u036f]/g, "") : void 0 : t2;
}
__name(h, "h");
var p = /* @__PURE__ */ __name(function() {
  return /(?=.*chrome)(?=.*android)/i.test(navigator.userAgent);
}, "p");
function f() {
  return ("10000000-1000-4000-8000" + -1e11).replace(/[018]/g, function(t2) {
    return (t2 ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> t2 / 4).toString(16);
  });
}
__name(f, "f");
function m(t2) {
  var e2;
  return b.call(this, t2) && (null == t2 || null === (e2 = t2.classList) || void 0 === e2 ? void 0 : e2.contains(this.settings.classNames.tag));
}
__name(m, "m");
function v(t2) {
  return b.call(this, t2) && (null == t2 ? void 0 : t2.closest(this.settings.classNames.tagSelector));
}
__name(v, "v");
function b(t2) {
  return (null == t2 ? void 0 : t2.closest(this.settings.classNames.namespaceSelector)) === this.DOM.scope;
}
__name(b, "b");
function w(t2, e2) {
  var i2 = window.getSelection();
  return e2 = e2 || i2.getRangeAt(0), "string" == typeof t2 && (t2 = document.createTextNode(t2)), e2 && (e2.deleteContents(), e2.insertNode(t2)), t2;
}
__name(w, "w");
function y(t2, e2, i2) {
  return t2 ? (e2 && (t2.__tagifyTagData = i2 ? e2 : u({}, t2.__tagifyTagData || {}, e2)), t2.__tagifyTagData) : (n.warn("tag element doesn't exist", { tagElm: t2, data: e2 }), e2);
}
__name(y, "y");
function T(t2) {
  if (t2 && t2.parentNode) {
    var e2 = t2, i2 = window.getSelection(), n2 = i2.getRangeAt(0);
    i2.rangeCount && (n2.setStartAfter(e2), n2.collapse(true), i2.removeAllRanges(), i2.addRange(n2));
  }
}
__name(T, "T");
function O(t2, e2) {
  t2.forEach(function(t3) {
    if (y(t3.previousSibling) || !t3.previousSibling) {
      var i2 = document.createTextNode("\u200B");
      t3.before(i2), e2 && T(i2);
    }
  });
}
__name(O, "O");
var D = { delimiters: ",", pattern: null, tagTextProp: "value", maxTags: 1 / 0, callbacks: {}, addTagOnBlur: true, addTagOn: ["blur", "tab", "enter"], onChangeAfterBlur: true, duplicates: false, whitelist: [], blacklist: [], enforceWhitelist: false, userInput: true, focusable: true, keepInvalidTags: false, createInvalidTags: true, mixTagsAllowedAfter: /,|\.|\:|\s/, mixTagsInterpolator: ["[[", "]]"], backspace: true, skipInvalid: false, pasteAsTags: true, editTags: { clicks: 2, keepInvalid: true }, transformTag: /* @__PURE__ */ __name(function() {
}, "transformTag"), trim: true, a11y: { focusableTags: false }, mixMode: { insertAfterTag: "\xA0" }, autoComplete: { enabled: true, rightKey: false, tabKey: false }, classNames: { namespace: "tagify", mixMode: "tagify--mix", selectMode: "tagify--select", input: "tagify__input", focus: "tagify--focus", tagNoAnimation: "tagify--noAnim", tagInvalid: "tagify--invalid", tagNotAllowed: "tagify--notAllowed", scopeLoading: "tagify--loading", hasMaxTags: "tagify--hasMaxTags", hasNoTags: "tagify--noTags", empty: "tagify--empty", inputInvalid: "tagify__input--invalid", dropdown: "tagify__dropdown", dropdownWrapper: "tagify__dropdown__wrapper", dropdownHeader: "tagify__dropdown__header", dropdownFooter: "tagify__dropdown__footer", dropdownItem: "tagify__dropdown__item", dropdownItemActive: "tagify__dropdown__item--active", dropdownItemHidden: "tagify__dropdown__item--hidden", dropdownItemSelected: "tagify__dropdown__item--selected", dropdownInital: "tagify__dropdown--initial", tag: "tagify__tag", tagText: "tagify__tag-text", tagX: "tagify__tag__removeBtn", tagLoading: "tagify__tag--loading", tagEditing: "tagify__tag--editable", tagFlash: "tagify__tag--flash", tagHide: "tagify__tag--hide" }, dropdown: { classname: "", enabled: 2, maxItems: 10, searchKeys: ["value", "searchBy"], fuzzySearch: true, caseSensitive: false, accentedSearch: true, includeSelectedTags: false, escapeHTML: true, highlightFirst: true, closeOnSelect: true, clearOnSelect: true, position: "all", appendTarget: null }, hooks: { beforeRemoveTag: /* @__PURE__ */ __name(function() {
  return Promise.resolve();
}, "beforeRemoveTag"), beforePaste: /* @__PURE__ */ __name(function() {
  return Promise.resolve();
}, "beforePaste"), suggestionClick: /* @__PURE__ */ __name(function() {
  return Promise.resolve();
}, "suggestionClick"), beforeKeyDown: /* @__PURE__ */ __name(function() {
  return Promise.resolve();
}, "beforeKeyDown") } };
function x(t2, e2, i2) {
  return e2 in t2 ? Object.defineProperty(t2, e2, { value: i2, enumerable: true, configurable: true, writable: true }) : t2[e2] = i2, t2;
}
__name(x, "x");
function S(t2) {
  for (var e2 = 1; e2 < arguments.length; e2++) {
    var i2 = null != arguments[e2] ? arguments[e2] : {}, n2 = Object.keys(i2);
    "function" == typeof Object.getOwnPropertySymbols && (n2 = n2.concat(Object.getOwnPropertySymbols(i2).filter(function(t3) {
      return Object.getOwnPropertyDescriptor(i2, t3).enumerable;
    }))), n2.forEach(function(e3) {
      x(t2, e3, i2[e3]);
    });
  }
  return t2;
}
__name(S, "S");
function I(t2, e2) {
  return e2 = null != e2 ? e2 : {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(t2, Object.getOwnPropertyDescriptors(e2)) : function(t3, e3) {
    var i2 = Object.keys(t3);
    if (Object.getOwnPropertySymbols) {
      var n2 = Object.getOwnPropertySymbols(t3);
      e3 && (n2 = n2.filter(function(e4) {
        return Object.getOwnPropertyDescriptor(t3, e4).enumerable;
      })), i2.push.apply(i2, n2);
    }
    return i2;
  }(Object(e2)).forEach(function(i2) {
    Object.defineProperty(t2, i2, Object.getOwnPropertyDescriptor(e2, i2));
  }), t2;
}
__name(I, "I");
function M(t2, e2) {
  (null == e2 || e2 > t2.length) && (e2 = t2.length);
  for (var i2 = 0, n2 = new Array(e2); i2 < e2; i2++) n2[i2] = t2[i2];
  return n2;
}
__name(M, "M");
function E(t2, e2, i2) {
  return e2 in t2 ? Object.defineProperty(t2, e2, { value: i2, enumerable: true, configurable: true, writable: true }) : t2[e2] = i2, t2;
}
__name(E, "E");
function N(t2) {
  return function(t3) {
    if (Array.isArray(t3)) return M(t3);
  }(t2) || function(t3) {
    if ("undefined" != typeof Symbol && null != t3[Symbol.iterator] || null != t3["@@iterator"]) return Array.from(t3);
  }(t2) || function(t3, e2) {
    if (!t3) return;
    if ("string" == typeof t3) return M(t3, e2);
    var i2 = Object.prototype.toString.call(t3).slice(8, -1);
    "Object" === i2 && t3.constructor && (i2 = t3.constructor.name);
    if ("Map" === i2 || "Set" === i2) return Array.from(i2);
    if ("Arguments" === i2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i2)) return M(t3, e2);
  }(t2) || function() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }();
}
__name(N, "N");
function _() {
  for (var t2 in this.dropdown = {}, this._dropdown) this.dropdown[t2] = "function" == typeof this._dropdown[t2] ? this._dropdown[t2].bind(this) : this._dropdown[t2];
  this.dropdown.refs(), this.DOM.dropdown.__tagify = this;
}
__name(_, "_");
var A;
var C;
var k = (A = function(t2) {
  for (var e2 = 1; e2 < arguments.length; e2++) {
    var i2 = null != arguments[e2] ? arguments[e2] : {}, n2 = Object.keys(i2);
    "function" == typeof Object.getOwnPropertySymbols && (n2 = n2.concat(Object.getOwnPropertySymbols(i2).filter(function(t3) {
      return Object.getOwnPropertyDescriptor(i2, t3).enumerable;
    }))), n2.forEach(function(e3) {
      E(t2, e3, i2[e3]);
    });
  }
  return t2;
}({}, { events: { binding: /* @__PURE__ */ __name(function() {
  var t2 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0], e2 = this.dropdown.events.callbacks, i2 = this.listeners.dropdown = this.listeners.dropdown || { position: this.dropdown.position.bind(this, null), onKeyDown: e2.onKeyDown.bind(this), onMouseOver: e2.onMouseOver.bind(this), onMouseLeave: e2.onMouseLeave.bind(this), onClick: e2.onClick.bind(this), onScroll: e2.onScroll.bind(this) }, n2 = t2 ? "addEventListener" : "removeEventListener";
  "manual" != this.settings.dropdown.position && (document[n2]("scroll", i2.position, true), window[n2]("resize", i2.position), window[n2]("keydown", i2.onKeyDown)), this.DOM.dropdown[n2]("mouseover", i2.onMouseOver), this.DOM.dropdown[n2]("mouseleave", i2.onMouseLeave), this.DOM.dropdown[n2]("mousedown", i2.onClick), this.DOM.dropdown.content[n2]("scroll", i2.onScroll);
}, "binding"), callbacks: { onKeyDown: /* @__PURE__ */ __name(function(t2) {
  var e2 = this;
  if (this.state.hasFocus && !this.state.composing) {
    var i2 = this.settings, s2 = i2.dropdown.includeSelectedTags, a2 = this.DOM.dropdown.querySelector(i2.classNames.dropdownItemActiveSelector), o2 = this.dropdown.getSuggestionDataByNode(a2), r2 = "mix" == i2.mode, l2 = "select" == i2.mode;
    i2.hooks.beforeKeyDown(t2, { tagify: this }).then(function(d2) {
      switch (t2.key) {
        case "ArrowDown":
        case "ArrowUp":
        case "Down":
        case "Up":
          t2.preventDefault();
          var c2 = e2.dropdown.getAllSuggestionsRefs(), u2 = "ArrowUp" == t2.key || "Up" == t2.key;
          a2 && (a2 = e2.dropdown.getNextOrPrevOption(a2, !u2)), a2 && a2.matches(i2.classNames.dropdownItemSelector) || (a2 = c2[u2 ? c2.length - 1 : 0]), e2.dropdown.highlightOption(a2, true);
          break;
        case "PageUp":
        case "PageDown":
          var g2;
          t2.preventDefault();
          var h2 = e2.dropdown.getAllSuggestionsRefs(), p2 = Math.floor(e2.DOM.dropdown.content.clientHeight / (null === (g2 = h2[0]) || void 0 === g2 ? void 0 : g2.offsetHeight)) || 1, f2 = "PageUp" === t2.key;
          if (a2) {
            var m2 = h2.indexOf(a2), v2 = f2 ? Math.max(0, m2 - p2) : Math.min(h2.length - 1, m2 + p2);
            a2 = h2[v2];
          } else a2 = h2[0];
          e2.dropdown.highlightOption(a2, true);
          break;
        case "Home":
        case "End":
          t2.preventDefault();
          var b2 = e2.dropdown.getAllSuggestionsRefs();
          a2 = b2["Home" === t2.key ? 0 : b2.length - 1], e2.dropdown.highlightOption(a2, true);
          break;
        case "Escape":
        case "Esc":
          e2.dropdown.hide();
          break;
        case "ArrowRight":
          if (e2.state.actions.ArrowLeft || i2.autoComplete.rightKey) return;
        case "Tab":
          var w2 = !i2.autoComplete.rightKey || !i2.autoComplete.tabKey;
          if (!r2 && !l2 && a2 && w2 && !e2.state.editing && o2) {
            t2.preventDefault();
            var y2 = e2.dropdown.getMappedValue(o2);
            return e2.state.autoCompleteData = o2, e2.input.autocomplete.set.call(e2, y2), false;
          }
          return true;
        case "Enter":
          t2.preventDefault(), e2.state.actions.selectOption = true, setTimeout(function() {
            return e2.state.actions.selectOption = false;
          }, 100), i2.hooks.suggestionClick(t2, { tagify: e2, tagData: o2, suggestionElm: a2 }).then(function() {
            if (a2) {
              var i3 = s2 ? a2 : e2.dropdown.getNextOrPrevOption(a2, !u2), n2 = i3.getAttribute("value");
              e2.dropdown.selectOption(a2, t2, function() {
                i3 = e2.dropdown.getSuggestionNodeByValue(n2), e2.dropdown.highlightOption(i3);
              });
            } else e2.dropdown.hide(), r2 || e2.addTags(e2.state.inputText.trim(), true);
          }).catch(function(t3) {
            return n.warn(t3);
          });
          break;
        case "Backspace":
          if (r2 || e2.state.editing.scope) return;
          var T2 = e2.input.raw.call(e2);
          "" != T2 && 8203 != T2.charCodeAt(0) || (true === i2.backspace ? e2.removeTags() : "edit" == i2.backspace && setTimeout(e2.editTag.bind(e2), 0));
      }
    });
  }
}, "onKeyDown"), onMouseOver: /* @__PURE__ */ __name(function(t2) {
  var e2 = t2.target.closest(this.settings.classNames.dropdownItemSelector);
  this.dropdown.highlightOption(e2);
}, "onMouseOver"), onMouseLeave: /* @__PURE__ */ __name(function(t2) {
  this.dropdown.highlightOption();
}, "onMouseLeave"), onClick: /* @__PURE__ */ __name(function(t2) {
  var e2 = this;
  if (0 == t2.button && t2.target != this.DOM.dropdown && t2.target != this.DOM.dropdown.content) {
    var i2 = t2.target.closest(this.settings.classNames.dropdownItemSelector), s2 = this.dropdown.getSuggestionDataByNode(i2);
    this.state.actions.selectOption = true, setTimeout(function() {
      return e2.state.actions.selectOption = false;
    }, 100), this.settings.hooks.suggestionClick(t2, { tagify: this, tagData: s2, suggestionElm: i2 }).then(function() {
      i2 ? e2.dropdown.selectOption(i2, t2) : e2.dropdown.hide();
    }).catch(function(t3) {
      return n.warn(t3);
    });
  }
}, "onClick"), onScroll: /* @__PURE__ */ __name(function(t2) {
  var e2 = t2.target, i2 = e2.scrollTop / (e2.scrollHeight - e2.parentNode.clientHeight) * 100;
  this.trigger("dropdown:scroll", { percentage: Math.round(i2) });
}, "onScroll") } }, refilter: /* @__PURE__ */ __name(function(t2) {
  t2 = t2 || this.state.dropdown.query || "", this.suggestedListItems = this.dropdown.filterListItems(t2), this.dropdown.fill(), this.suggestedListItems.length || this.dropdown.hide(), this.trigger("dropdown:updated", this.DOM.dropdown);
}, "refilter"), getSuggestionDataByNode: /* @__PURE__ */ __name(function(t2) {
  for (var e2, i2 = t2 && t2.getAttribute("value"), n2 = this.suggestedListItems.length; n2--; ) {
    if (c(e2 = this.suggestedListItems[n2]) && e2.value == i2) return e2;
    if (e2 == i2) return { value: e2 };
  }
}, "getSuggestionDataByNode"), getSuggestionNodeByValue: /* @__PURE__ */ __name(function(t2) {
  return this.dropdown.getAllSuggestionsRefs().find(function(e2) {
    return e2.getAttribute("value") === t2;
  });
}, "getSuggestionNodeByValue"), getNextOrPrevOption: /* @__PURE__ */ __name(function(t2) {
  var e2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i2 = this.dropdown.getAllSuggestionsRefs(), n2 = i2.findIndex(function(e3) {
    return e3 === t2;
  });
  return e2 ? i2[n2 + 1] : i2[n2 - 1];
}, "getNextOrPrevOption"), highlightOption: /* @__PURE__ */ __name(function(t2, e2) {
  var i2, n2 = this.settings.classNames.dropdownItemActive;
  if (this.state.ddItemElm && (this.state.ddItemElm.classList.remove(n2), this.state.ddItemElm.removeAttribute("aria-selected")), !t2) return this.state.ddItemData = null, this.state.ddItemElm = null, void this.input.autocomplete.suggest.call(this);
  i2 = this.dropdown.getSuggestionDataByNode(t2), this.state.ddItemData = i2, this.state.ddItemElm = t2, t2.classList.add(n2), t2.setAttribute("aria-selected", true), e2 && (t2.parentNode.scrollTop = t2.clientHeight + t2.offsetTop - t2.parentNode.clientHeight), this.settings.autoComplete && (this.input.autocomplete.suggest.call(this, i2), this.dropdown.position());
}, "highlightOption"), selectOption: /* @__PURE__ */ __name(function(t2, e2, i2) {
  var n2 = this, s2 = this.settings, a2 = s2.dropdown.includeSelectedTags, o2 = s2.dropdown, r2 = o2.clearOnSelect, l2 = o2.closeOnSelect;
  if (!t2) return this.addTags(this.state.inputText, true), void (l2 && this.dropdown.hide());
  e2 = e2 || {};
  var d2 = t2.getAttribute("value"), c2 = "noMatch" == d2, g2 = "mix" == s2.mode, h2 = this.suggestedListItems.find(function(t3) {
    var e3;
    return (null !== (e3 = t3.value) && void 0 !== e3 ? e3 : t3) == d2;
  });
  if (this.trigger("dropdown:select", { data: h2, elm: t2, event: e2 }), h2 || c2) {
    if (this.state.editing) {
      var p2 = this.normalizeTags([h2])[0];
      h2 = s2.transformTag.call(this, p2) || p2, this.onEditTagDone(null, u({ __isValid: true }, h2));
    } else this[g2 ? "addMixTags" : "addTags"]([h2 || this.input.raw.call(this)], r2);
    (g2 || this.DOM.input.parentNode) && (setTimeout(function() {
      n2.DOM.input.focus(), n2.toggleFocusClass(true);
    }), l2 && setTimeout(this.dropdown.hide.bind(this)), a2 ? i2 && i2() : (t2.addEventListener("transitionend", function() {
      n2.dropdown.fillHeaderFooter(), setTimeout(function() {
        t2.remove(), n2.dropdown.refilter(), i2 && i2();
      }, 100);
    }, { once: true }), t2.classList.add(this.settings.classNames.dropdownItemHidden)));
  } else l2 && setTimeout(this.dropdown.hide.bind(this));
}, "selectOption"), selectAll: /* @__PURE__ */ __name(function(t2) {
  this.suggestedListItems.length = 0, this.dropdown.hide(), this.dropdown.filterListItems("");
  var e2 = this.dropdown.filterListItems("");
  return t2 || (e2 = this.state.dropdown.suggestions), this.addTags(e2, true), this;
}, "selectAll"), filterListItems: /* @__PURE__ */ __name(function(t2, e2) {
  var i2, n2, s2, a2, o2, r2, l2 = /* @__PURE__ */ __name(function() {
    var t3, l3, d3 = void 0, u3 = void 0;
    t3 = m2[T2], n2 = (null != (l3 = Object) && "undefined" != typeof Symbol && l3[Symbol.hasInstance] ? l3[Symbol.hasInstance](t3) : t3 instanceof l3) ? m2[T2] : { value: m2[T2] };
    var v3, b3 = !Object.keys(n2).some(function(t4) {
      return y2.includes(t4);
    }) ? ["value"] : y2;
    g2.fuzzySearch && !e2.exact ? (a2 = b3.reduce(function(t4, e3) {
      return t4 + " " + (n2[e3] || "");
    }, "").toLowerCase().trim(), g2.accentedSearch && (a2 = h(a2), r2 = h(r2)), d3 = 0 == a2.indexOf(r2), u3 = a2 === r2, v3 = a2, s2 = r2.toLowerCase().split(" ").every(function(t4) {
      return v3.includes(t4.toLowerCase());
    })) : (d3 = true, s2 = b3.some(function(t4) {
      var i3 = "" + (n2[t4] || "");
      return g2.accentedSearch && (i3 = h(i3), r2 = h(r2)), g2.caseSensitive || (i3 = i3.toLowerCase()), u3 = i3 === r2, e2.exact ? i3 === r2 : 0 == i3.indexOf(r2);
    })), o2 = !g2.includeSelectedTags && i2.isTagDuplicate(c(n2) ? n2.value : n2), s2 && !o2 && (u3 && d3 ? f2.push(n2) : "startsWith" == g2.sortby && d3 ? p2.unshift(n2) : p2.push(n2));
  }, "l"), d2 = this, u2 = this.settings, g2 = u2.dropdown, p2 = (e2 = e2 || {}, []), f2 = [], m2 = u2.whitelist, v2 = g2.maxItems >= 0 ? g2.maxItems : 1 / 0, b2 = g2.includeSelectedTags, w2 = "function" == typeof g2.sortby, y2 = g2.searchKeys, T2 = 0;
  if (!(t2 = "select" == u2.mode && this.value.length && this.value[0][u2.tagTextProp] == t2 ? "" : t2) || !y2.length) {
    p2 = b2 ? m2 : m2.filter(function(t3) {
      return !d2.isTagDuplicate(c(t3) ? t3.value : t3);
    });
    var O2 = w2 ? g2.sortby(p2, r2) : p2.slice(0, v2);
    return this.state.dropdown.suggestions = O2, O2;
  }
  for (r2 = g2.caseSensitive ? "" + t2 : ("" + t2).toLowerCase(); T2 < m2.length; T2++) i2 = this, l2();
  this.state.dropdown.suggestions = f2.concat(p2);
  O2 = w2 ? g2.sortby(f2.concat(p2), r2) : f2.concat(p2).slice(0, v2);
  return this.state.dropdown.suggestions = O2, O2;
}, "filterListItems"), getMappedValue: /* @__PURE__ */ __name(function(t2) {
  var e2 = this.settings.dropdown.mapValueTo;
  return e2 ? "function" == typeof e2 ? e2(t2) : t2[e2] || t2.value : t2.value;
}, "getMappedValue"), createListHTML: /* @__PURE__ */ __name(function(t2) {
  var e2 = this;
  return u([], t2).map(function(t3, i2) {
    "string" != typeof t3 && "number" != typeof t3 || (t3 = { value: t3 });
    var n2 = e2.dropdown.getMappedValue(t3);
    return n2 = "string" == typeof n2 && e2.settings.dropdown.escapeHTML ? d(n2) : n2, e2.settings.templates.dropdownItem.apply(e2, [I(S({}, t3), { mappedValue: n2 }), e2]);
  }).join("");
}, "createListHTML") }), C = null != (C = { refs: /* @__PURE__ */ __name(function() {
  this.DOM.dropdown = this.parseTemplate("dropdown", [this.settings]), this.DOM.dropdown.content = this.DOM.dropdown.querySelector("[data-selector='tagify-suggestions-wrapper']");
}, "refs"), getHeaderRef: /* @__PURE__ */ __name(function() {
  return this.DOM.dropdown.querySelector("[data-selector='tagify-suggestions-header']");
}, "getHeaderRef"), getFooterRef: /* @__PURE__ */ __name(function() {
  return this.DOM.dropdown.querySelector("[data-selector='tagify-suggestions-footer']");
}, "getFooterRef"), getAllSuggestionsRefs: /* @__PURE__ */ __name(function() {
  return N(this.DOM.dropdown.content.querySelectorAll(this.settings.classNames.dropdownItemSelector));
}, "getAllSuggestionsRefs"), show: /* @__PURE__ */ __name(function(t2) {
  var e2, i2, n2, a2 = this, o2 = this.settings, r2 = "mix" == o2.mode && !o2.enforceWhitelist, l2 = !o2.whitelist || !o2.whitelist.length, d2 = "manual" == o2.dropdown.position;
  if (t2 = void 0 === t2 ? this.state.inputText : t2, !(l2 && !r2 && !o2.templates.dropdownItemNoMatch || false === o2.dropdown.enabled || this.state.isLoading || this.settings.readonly)) {
    if (clearTimeout(this.dropdownHide__bindEventsTimeout), this.suggestedListItems = this.dropdown.filterListItems(t2), t2 && !this.suggestedListItems.length && (this.trigger("dropdown:noMatch", t2), o2.templates.dropdownItemNoMatch && (n2 = o2.templates.dropdownItemNoMatch.call(this, { value: t2 }))), !n2) {
      if (this.suggestedListItems.length) t2 && r2 && !this.state.editing.scope && !s(this.suggestedListItems[0].value, t2) && this.suggestedListItems.unshift({ value: t2 });
      else {
        if (!t2 || !r2 || this.state.editing.scope) return this.input.autocomplete.suggest.call(this), void this.dropdown.hide();
        this.suggestedListItems = [{ value: t2 }];
      }
      i2 = "" + (c(e2 = this.suggestedListItems[0]) ? e2.value : e2), o2.autoComplete && i2 && 0 == i2.indexOf(t2) && this.input.autocomplete.suggest.call(this, e2);
    }
    this.dropdown.fill(n2), o2.dropdown.highlightFirst && this.dropdown.highlightOption(this.DOM.dropdown.content.querySelector(o2.classNames.dropdownItemSelector)), this.state.dropdown.visible || setTimeout(this.dropdown.events.binding.bind(this)), this.state.dropdown.visible = t2 || true, this.state.dropdown.query = t2, this.setStateSelection(), d2 || setTimeout(function() {
      a2.dropdown.position(), a2.dropdown.render();
    }), setTimeout(function() {
      a2.trigger("dropdown:show", a2.DOM.dropdown);
    });
  }
}, "show"), hide: /* @__PURE__ */ __name(function(t2) {
  var e2 = this, i2 = this.DOM, n2 = i2.scope, s2 = i2.dropdown, a2 = "manual" == this.settings.dropdown.position && !t2;
  if (s2 && document.body.contains(s2) && !a2) return window.removeEventListener("resize", this.dropdown.position), this.dropdown.events.binding.call(this, false), n2.setAttribute("aria-expanded", false), s2.parentNode.removeChild(s2), setTimeout(function() {
    e2.state.dropdown.visible = false;
  }, 100), this.state.dropdown.query = this.state.ddItemData = this.state.ddItemElm = this.state.selection = null, this.state.tag && this.state.tag.value.length && (this.state.flaggedTags[this.state.tag.baseOffset] = this.state.tag), this.trigger("dropdown:hide", s2), this;
}, "hide"), toggle: /* @__PURE__ */ __name(function(t2) {
  this.dropdown[this.state.dropdown.visible && !t2 ? "hide" : "show"]();
}, "toggle"), getAppendTarget: /* @__PURE__ */ __name(function() {
  var t2 = this.settings.dropdown;
  return "function" == typeof t2.appendTarget ? t2.appendTarget() : t2.appendTarget;
}, "getAppendTarget"), render: /* @__PURE__ */ __name(function() {
  var t2, e2, i2, n2 = this, s2 = (t2 = this.DOM.dropdown, (i2 = t2.cloneNode(true)).style.cssText = "position:fixed; top:-9999px; opacity:0", document.body.appendChild(i2), e2 = i2.clientHeight, i2.parentNode.removeChild(i2), e2), a2 = this.settings, o2 = this.dropdown.getAppendTarget();
  return false === a2.dropdown.enabled || (this.DOM.scope.setAttribute("aria-expanded", true), document.body.contains(this.DOM.dropdown) || (this.DOM.dropdown.classList.add(a2.classNames.dropdownInital), this.dropdown.position(s2), o2.appendChild(this.DOM.dropdown), setTimeout(function() {
    return n2.DOM.dropdown.classList.remove(a2.classNames.dropdownInital);
  }))), this;
}, "render"), fill: /* @__PURE__ */ __name(function(t2) {
  t2 = "string" == typeof t2 ? t2 : this.dropdown.createListHTML(t2 || this.suggestedListItems);
  var e2, i2 = this.settings.templates.dropdownContent.call(this, t2);
  this.DOM.dropdown.content.innerHTML = (e2 = i2) ? e2.replace(/\>[\r\n ]+\</g, "><").split(/>\s+</).join("><").trim() : "";
}, "fill"), fillHeaderFooter: /* @__PURE__ */ __name(function() {
  var t2 = this.dropdown.filterListItems(this.state.dropdown.query), e2 = this.parseTemplate("dropdownHeader", [t2]), i2 = this.parseTemplate("dropdownFooter", [t2]), n2 = this.dropdown.getHeaderRef(), s2 = this.dropdown.getFooterRef();
  e2 && (null == n2 || n2.parentNode.replaceChild(e2, n2)), i2 && (null == s2 || s2.parentNode.replaceChild(i2, s2));
}, "fillHeaderFooter"), position: /* @__PURE__ */ __name(function(t2) {
  var e2 = this.settings.dropdown, i2 = this.dropdown.getAppendTarget();
  if ("manual" != e2.position && i2) {
    var n2, s2, a2, o2, r2, l2, d2, c2, u2, g2 = this.DOM.dropdown, h2 = e2.RTL, p2 = i2 === document.body, f2 = i2 === this.DOM.scope, m2 = p2 ? window.pageYOffset : i2.scrollTop, v2 = document.fullscreenElement || document.webkitFullscreenElement || document.documentElement, b2 = v2.clientHeight, w2 = Math.max(v2.clientWidth || 0, window.innerWidth || 0) > 480 ? e2.position : "all", y2 = this.DOM["input" == w2 ? "input" : "scope"];
    if (t2 = t2 || g2.clientHeight, this.state.dropdown.visible) {
      if ("text" == w2 ? (a2 = (n2 = function() {
        var t3 = document.getSelection();
        if (t3.rangeCount) {
          var e3, i3, n3 = t3.getRangeAt(0), s3 = n3.startContainer, a3 = n3.startOffset;
          if (a3 > 0) return (i3 = document.createRange()).setStart(s3, a3 - 1), i3.setEnd(s3, a3), { left: (e3 = i3.getBoundingClientRect()).right, top: e3.top, bottom: e3.bottom };
          if (s3.getBoundingClientRect) return s3.getBoundingClientRect();
        }
        return { left: -9999, top: -9999 };
      }()).bottom, s2 = n2.top, o2 = n2.left, r2 = "auto") : (l2 = function(t3) {
        var e3 = 0, i3 = 0;
        for (t3 = t3.parentNode; t3 && t3 != v2; ) e3 += t3.offsetTop || 0, i3 += t3.offsetLeft || 0, t3 = t3.parentNode;
        return { top: e3, left: i3 };
      }(i2), n2 = y2.getBoundingClientRect(), s2 = f2 ? -1 : n2.top - l2.top, a2 = (f2 ? n2.height : n2.bottom - l2.top) - 1, o2 = f2 ? -1 : n2.left - l2.left, r2 = n2.width + "px"), !p2) {
        var T2 = function() {
          for (var t3 = 0, i3 = e2.appendTarget.parentNode; i3; ) t3 += i3.scrollTop || 0, i3 = i3.parentNode;
          return t3;
        }();
        s2 += T2, a2 += T2;
      }
      var O2;
      s2 = Math.floor(s2), a2 = Math.ceil(a2), c2 = ((d2 = null !== (O2 = e2.placeAbove) && void 0 !== O2 ? O2 : b2 - n2.bottom < t2) ? s2 : a2) + m2, u2 = "left: ".concat(o2 + (h2 && n2.width || 0) + window.pageXOffset, "px;"), g2.style.cssText = "".concat(u2, "; top: ").concat(c2, "px; min-width: ").concat(r2, "; max-width: ").concat(r2), g2.setAttribute("placement", d2 ? "top" : "bottom"), g2.setAttribute("position", w2);
    }
  }
}, "position") }) ? C : {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(A, Object.getOwnPropertyDescriptors(C)) : function(t2, e2) {
  var i2 = Object.keys(t2);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(t2);
    e2 && (n2 = n2.filter(function(e3) {
      return Object.getOwnPropertyDescriptor(t2, e3).enumerable;
    })), i2.push.apply(i2, n2);
  }
  return i2;
}(Object(C)).forEach(function(t2) {
  Object.defineProperty(A, t2, Object.getOwnPropertyDescriptor(C, t2));
}), A);
var L = "@yaireo/tagify/";
var P = { empty: "empty", exceed: "number of tags exceeded", pattern: "pattern mismatch", duplicate: "already exists", notAllowed: "not allowed" };
var j = { wrapper: /* @__PURE__ */ __name(function(e2, i2) {
  return '<tags class="'.concat(i2.classNames.namespace, " ").concat(i2.mode ? "".concat(i2.classNames[i2.mode + "Mode"]) : "", " ").concat(e2.className, '"\n                    ').concat(i2.readonly ? "readonly" : "", "\n                    ").concat(i2.disabled ? "disabled" : "", "\n                    ").concat(i2.required ? "required" : "", "\n                    ").concat("select" === i2.mode ? "spellcheck='false'" : "", '\n                    tabIndex="-1">\n                    ').concat(this.settings.templates.input.call(this), "\n                ").concat(t, "\n        </tags>");
}, "wrapper"), input: /* @__PURE__ */ __name(function() {
  var e2 = this.settings, i2 = e2.placeholder || t;
  return "<span ".concat(!e2.readonly && e2.userInput ? "contenteditable" : "", ' tabIndex="0" data-placeholder="').concat(i2, '" aria-placeholder="').concat(e2.placeholder || "", '"\n                    class="').concat(e2.classNames.input, '"\n                    role="textbox"\n                    autocapitalize="false"\n                    autocorrect="off"\n                    aria-autocomplete="both"\n                    aria-multiline="').concat("mix" == e2.mode, '"></span>');
}, "input"), tag: /* @__PURE__ */ __name(function(t2, e2) {
  var i2 = e2.settings;
  return '<tag title="'.concat(t2.title || t2.value, `"
                    contenteditable='false'
                    tabIndex="`).concat(i2.a11y.focusableTags ? 0 : -1, '"\n                    class="').concat(i2.classNames.tag, " ").concat(t2.class || "", '"\n                    ').concat(this.getAttributes(t2), `>
            <x title='' tabIndex="`).concat(i2.a11y.focusableTags ? 0 : -1, '" class="').concat(i2.classNames.tagX, `" role='button' aria-label='remove tag'></x>
            <div>
                <span `).concat("select" === i2.mode && i2.userInput ? "contenteditable='true'" : "", ` autocapitalize="false" autocorrect="off" spellcheck='false' class="`).concat(i2.classNames.tagText, '">').concat(t2[i2.tagTextProp] || t2.value, "</span>\n            </div>\n        </tag>");
}, "tag"), dropdown: /* @__PURE__ */ __name(function(t2) {
  var e2 = t2.dropdown, i2 = "manual" == e2.position;
  return '<div class="'.concat(i2 ? "" : t2.classNames.dropdown, " ").concat(e2.classname, '" role="listbox" aria-labelledby="dropdown" dir="').concat(e2.RTL ? "rtl" : "", `">
                    <div data-selector='tagify-suggestions-wrapper' class="`).concat(t2.classNames.dropdownWrapper, '"></div>\n                </div>');
}, "dropdown"), dropdownContent: /* @__PURE__ */ __name(function(t2) {
  var e2 = this.settings.templates, i2 = this.state.dropdown.suggestions;
  return "\n            ".concat(e2.dropdownHeader.call(this, i2), "\n            ").concat(t2, "\n            ").concat(e2.dropdownFooter.call(this, i2), "\n        ");
}, "dropdownContent"), dropdownItem: /* @__PURE__ */ __name(function(t2) {
  return "<div ".concat(this.getAttributes(t2), "\n                    class='").concat(this.settings.classNames.dropdownItem, " ").concat(this.isTagDuplicate(t2.value) ? this.settings.classNames.dropdownItemSelected : "", " ").concat(t2.class || "", `'
                    tabindex="0"
                    role="option">`).concat(t2.mappedValue || t2.value, "</div>");
}, "dropdownItem"), dropdownHeader: /* @__PURE__ */ __name(function(t2) {
  return `<header data-selector='tagify-suggestions-header' class="`.concat(this.settings.classNames.dropdownHeader, '"></header>');
}, "dropdownHeader"), dropdownFooter: /* @__PURE__ */ __name(function(t2) {
  var e2 = t2.length - this.settings.dropdown.maxItems;
  return e2 > 0 ? `<footer data-selector='tagify-suggestions-footer' class="`.concat(this.settings.classNames.dropdownFooter, '">\n                ').concat(e2, " more items. Refine your search.\n            </footer>") : "";
}, "dropdownFooter"), dropdownItemNoMatch: null };
function V(t2, e2) {
  (null == e2 || e2 > t2.length) && (e2 = t2.length);
  for (var i2 = 0, n2 = new Array(e2); i2 < e2; i2++) n2[i2] = t2[i2];
  return n2;
}
__name(V, "V");
function R(t2, e2) {
  return null != e2 && "undefined" != typeof Symbol && e2[Symbol.hasInstance] ? !!e2[Symbol.hasInstance](t2) : t2 instanceof e2;
}
__name(R, "R");
function F(t2, e2) {
  return function(t3) {
    if (Array.isArray(t3)) return t3;
  }(t2) || function(t3, e3) {
    var i2 = null == t3 ? null : "undefined" != typeof Symbol && t3[Symbol.iterator] || t3["@@iterator"];
    if (null != i2) {
      var n2, s2, a2 = [], o2 = true, r2 = false;
      try {
        for (i2 = i2.call(t3); !(o2 = (n2 = i2.next()).done) && (a2.push(n2.value), !e3 || a2.length !== e3); o2 = true) ;
      } catch (t4) {
        r2 = true, s2 = t4;
      } finally {
        try {
          o2 || null == i2.return || i2.return();
        } finally {
          if (r2) throw s2;
        }
      }
      return a2;
    }
  }(t2, e2) || function(t3, e3) {
    if (!t3) return;
    if ("string" == typeof t3) return V(t3, e3);
    var i2 = Object.prototype.toString.call(t3).slice(8, -1);
    "Object" === i2 && t3.constructor && (i2 = t3.constructor.name);
    if ("Map" === i2 || "Set" === i2) return Array.from(i2);
    if ("Arguments" === i2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i2)) return V(t3, e3);
  }(t2, e2) || function() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }();
}
__name(F, "F");
function H(t2, e2) {
  (null == e2 || e2 > t2.length) && (e2 = t2.length);
  for (var i2 = 0, n2 = new Array(e2); i2 < e2; i2++) n2[i2] = t2[i2];
  return n2;
}
__name(H, "H");
function B(t2, e2, i2) {
  return e2 in t2 ? Object.defineProperty(t2, e2, { value: i2, enumerable: true, configurable: true, writable: true }) : t2[e2] = i2, t2;
}
__name(B, "B");
function W(t2, e2) {
  return null != e2 && "undefined" != typeof Symbol && e2[Symbol.hasInstance] ? !!e2[Symbol.hasInstance](t2) : t2 instanceof e2;
}
__name(W, "W");
function U(t2, e2) {
  return e2 = null != e2 ? e2 : {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(t2, Object.getOwnPropertyDescriptors(e2)) : function(t3, e3) {
    var i2 = Object.keys(t3);
    if (Object.getOwnPropertySymbols) {
      var n2 = Object.getOwnPropertySymbols(t3);
      e3 && (n2 = n2.filter(function(e4) {
        return Object.getOwnPropertyDescriptor(t3, e4).enumerable;
      })), i2.push.apply(i2, n2);
    }
    return i2;
  }(Object(e2)).forEach(function(i2) {
    Object.defineProperty(t2, i2, Object.getOwnPropertyDescriptor(e2, i2));
  }), t2;
}
__name(U, "U");
function q(t2) {
  return function(t3) {
    if (Array.isArray(t3)) return H(t3);
  }(t2) || function(t3) {
    if ("undefined" != typeof Symbol && null != t3[Symbol.iterator] || null != t3["@@iterator"]) return Array.from(t3);
  }(t2) || function(t3, e2) {
    if (!t3) return;
    if ("string" == typeof t3) return H(t3, e2);
    var i2 = Object.prototype.toString.call(t3).slice(8, -1);
    "Object" === i2 && t3.constructor && (i2 = t3.constructor.name);
    if ("Map" === i2 || "Set" === i2) return Array.from(i2);
    if ("Arguments" === i2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i2)) return H(t3, e2);
  }(t2) || function() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }();
}
__name(q, "q");
var K = { customBinding: /* @__PURE__ */ __name(function() {
  var t2 = this;
  this.customEventsList.forEach(function(e2) {
    t2.on(e2, t2.settings.callbacks[e2]);
  });
}, "customBinding"), binding: /* @__PURE__ */ __name(function() {
  var t2, e2 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0], i2 = this.settings, n2 = this.events.callbacks, s2 = e2 ? "addEventListener" : "removeEventListener";
  if (!this.state.mainEvents || !e2) {
    for (var a2 in this.state.mainEvents = e2, e2 && !this.listeners.main && (this.events.bindGlobal.call(this), this.settings.isJQueryPlugin && jQuery(this.DOM.originalInput).on("tagify.removeAllTags", this.removeAllTags.bind(this))), t2 = this.listeners.main = this.listeners.main || { keydown: ["input", n2.onKeydown.bind(this)], click: ["scope", n2.onClickScope.bind(this)], dblclick: "select" != i2.mode && ["scope", n2.onDoubleClickScope.bind(this)], paste: ["input", n2.onPaste.bind(this)], drop: ["input", n2.onDrop.bind(this)], compositionstart: ["input", n2.onCompositionStart.bind(this)], compositionend: ["input", n2.onCompositionEnd.bind(this)] }) t2[a2] && this.DOM[t2[a2][0]][s2](a2, t2[a2][1]);
    var o2 = this.listeners.main.inputMutationObserver || new MutationObserver(n2.onInputDOMChange.bind(this));
    o2.disconnect(), "mix" == i2.mode && o2.observe(this.DOM.input, { childList: true }), this.events.bindOriginaInputListener.call(this);
  }
}, "binding"), bindOriginaInputListener: /* @__PURE__ */ __name(function(t2) {
  var e2 = (t2 || 0) + 500;
  this.listeners.main && (clearInterval(this.listeners.main.originalInputValueObserverInterval), this.listeners.main.originalInputValueObserverInterval = setInterval(this.events.callbacks.observeOriginalInputValue.bind(this), e2));
}, "bindOriginaInputListener"), bindGlobal: /* @__PURE__ */ __name(function(t2) {
  var e2, i2 = this.events.callbacks, n2 = t2 ? "removeEventListener" : "addEventListener";
  if (this.listeners && (t2 || !this.listeners.global)) {
    this.listeners.global = this.listeners.global || [{ type: this.isIE ? "keydown" : "input", target: this.DOM.input, cb: i2[this.isIE ? "onInputIE" : "onInput"].bind(this) }, { type: "keydown", target: window, cb: i2.onWindowKeyDown.bind(this) }, { type: "focusin", target: this.DOM.scope, cb: i2.onFocusBlur.bind(this) }, { type: "focusout", target: this.DOM.scope, cb: i2.onFocusBlur.bind(this) }, { type: "click", target: document, cb: i2.onClickAnywhere.bind(this), useCapture: true }];
    var s2 = true, a2 = false, o2 = void 0;
    try {
      for (var r2, l2 = this.listeners.global[Symbol.iterator](); !(s2 = (r2 = l2.next()).done); s2 = true) (e2 = r2.value).target[n2](e2.type, e2.cb, !!e2.useCapture);
    } catch (t3) {
      a2 = true, o2 = t3;
    } finally {
      try {
        s2 || null == l2.return || l2.return();
      } finally {
        if (a2) throw o2;
      }
    }
  }
}, "bindGlobal"), unbindGlobal: /* @__PURE__ */ __name(function() {
  this.events.bindGlobal.call(this, true);
}, "unbindGlobal"), callbacks: { onFocusBlur: /* @__PURE__ */ __name(function(t2) {
  var e2, i2, n2 = this.settings, s2 = v.call(this, t2.relatedTarget), a2 = m.call(this, t2.relatedTarget), o2 = t2.target.classList.contains(n2.classNames.tagX), r2 = "focusin" == t2.type, l2 = "focusout" == t2.type;
  o2 && "mix" != n2.mode && this.DOM.input.focus(), s2 && r2 && !a2 && !o2 && this.toggleFocusClass(this.state.hasFocus = +/* @__PURE__ */ new Date());
  var d2 = t2.target ? this.trim(this.DOM.input.textContent) : "", c2 = null === (i2 = this.value) || void 0 === i2 || null === (e2 = i2[0]) || void 0 === e2 ? void 0 : e2[n2.tagTextProp], u2 = n2.dropdown.enabled >= 0, g2 = { relatedTarget: t2.relatedTarget }, h2 = this.state.actions.selectOption && (u2 || !n2.dropdown.closeOnSelect), p2 = this.state.actions.addNew && u2;
  if (l2) {
    if (t2.relatedTarget === this.DOM.scope) return this.dropdown.hide(), void this.DOM.input.focus();
    this.postUpdate(), n2.onChangeAfterBlur && this.triggerChangeEvent();
  }
  if (!(h2 || p2 || o2)) if (this.state.hasFocus = !(!r2 && !s2) && +/* @__PURE__ */ new Date(), this.toggleFocusClass(this.state.hasFocus), "mix" != n2.mode) {
    if (r2) {
      if (!n2.focusable) return;
      var f2 = 0 === n2.dropdown.enabled && !this.state.dropdown.visible, b2 = !a2 || "select" === n2.mode, w2 = this.DOM.scope.querySelector(this.settings.classNames.tagTextSelector);
      return this.trigger("focus", g2), void (f2 && b2 && (this.dropdown.show(this.value.length ? "" : void 0), this.events.callbacks.onDoubleClickScope.call(this, t2), this.setRangeAtStartEnd(false, w2)));
    }
    if (l2) {
      if (this.trigger("blur", g2), this.loading(false), "select" == n2.mode) {
        if (this.value.length) {
          var y2 = this.getTagElms()[0];
          d2 = this.trim(y2.textContent);
        }
        c2 === d2 && (d2 = "");
      }
      d2 && !this.state.actions.selectOption && n2.addTagOnBlur && n2.addTagOn.includes("blur") && this.addTags(d2, true);
    }
    s2 || (this.DOM.input.removeAttribute("style"), this.dropdown.hide());
  } else r2 ? this.trigger("focus", g2) : l2 && (this.trigger("blur", g2), this.loading(false), this.dropdown.hide(), this.state.dropdown.visible = void 0, this.setStateSelection());
}, "onFocusBlur"), onCompositionStart: /* @__PURE__ */ __name(function(t2) {
  this.state.composing = true;
}, "onCompositionStart"), onCompositionEnd: /* @__PURE__ */ __name(function(t2) {
  this.state.composing = false;
}, "onCompositionEnd"), onWindowKeyDown: /* @__PURE__ */ __name(function(t2) {
  var e2, i2 = this.settings, n2 = document.activeElement, s2 = v.call(this, n2) && this.DOM.scope.contains(n2), a2 = n2 === this.DOM.input, o2 = s2 && n2.hasAttribute("readonly"), r2 = this.DOM.scope.querySelector(this.settings.classNames.tagTextSelector), l2 = this.state.dropdown.visible;
  if (("Tab" === t2.key && l2 || this.state.hasFocus || s2 && !o2) && !a2) {
    e2 = n2.nextElementSibling;
    var d2 = t2.target.classList.contains(i2.classNames.tagX);
    switch (t2.key) {
      case "Backspace":
        i2.readonly || this.state.editing || (this.removeTags(n2), (e2 || this.DOM.input).focus());
        break;
      case "Enter":
        if (d2) return void this.removeTags(t2.target.parentNode);
        i2.a11y.focusableTags && m.call(this, n2) && setTimeout(this.editTag.bind(this), 0, n2);
        break;
      case "ArrowDown":
        this.state.dropdown.visible || "mix" == i2.mode || this.dropdown.show();
        break;
      case "Tab":
        null == r2 || r2.focus();
    }
  }
}, "onWindowKeyDown"), onKeydown: /* @__PURE__ */ __name(function(t2) {
  var e2 = this, i2 = this.settings;
  if (!this.state.composing && i2.userInput) {
    "select" == i2.mode && i2.enforceWhitelist && this.value.length && "Tab" != t2.key && t2.preventDefault();
    var n2 = this.trim(t2.target.textContent);
    this.trigger("keydown", { event: t2 }), i2.hooks.beforeKeyDown(t2, { tagify: this }).then(function(s2) {
      if ("mix" == i2.mode) {
        switch (t2.key) {
          case "Left":
          case "ArrowLeft":
            e2.state.actions.ArrowLeft = true;
            break;
          case "Delete":
          case "Backspace":
            if (e2.state.editing) return;
            var a2 = document.getSelection(), o2 = "Delete" == t2.key && a2.anchorOffset == (a2.anchorNode.length || 0), r2 = a2.anchorNode.previousSibling, d2 = 1 == a2.anchorNode.nodeType || !a2.anchorOffset && r2 && 1 == r2.nodeType && a2.anchorNode.previousSibling;
            !function(t3) {
              var e3 = document.createElement("div");
              t3.replace(/\&#?[0-9a-z]+;/gi, function(t4) {
                return e3.innerHTML = t4, e3.innerText;
              });
            }(e2.DOM.input.innerHTML);
            var c2, u2, g2, h2 = e2.getTagElms(), f2 = 1 === a2.anchorNode.length && a2.anchorNode.nodeValue == String.fromCharCode(8203);
            if ("edit" == i2.backspace && d2) return c2 = 1 == a2.anchorNode.nodeType ? null : a2.anchorNode.previousElementSibling, setTimeout(e2.editTag.bind(e2), 0, c2), void t2.preventDefault();
            if (p() && W(d2, Element)) return g2 = l(d2), d2.hasAttribute("readonly") || d2.remove(), e2.DOM.input.focus(), void setTimeout(function() {
              T(g2), e2.DOM.input.click();
            });
            if ("BR" == a2.anchorNode.nodeName) return;
            if ((o2 || d2) && 1 == a2.anchorNode.nodeType ? u2 = 0 == a2.anchorOffset ? o2 ? h2[0] : null : h2[Math.min(h2.length, a2.anchorOffset) - 1] : o2 ? u2 = a2.anchorNode.nextElementSibling : W(d2, Element) && (u2 = d2), 3 == a2.anchorNode.nodeType && !a2.anchorNode.nodeValue && a2.anchorNode.previousElementSibling && t2.preventDefault(), (d2 || o2) && !i2.backspace) return void t2.preventDefault();
            if ("Range" != a2.type && !a2.anchorOffset && a2.anchorNode == e2.DOM.input && "Delete" != t2.key) return void t2.preventDefault();
            if ("Range" != a2.type && u2 && u2.hasAttribute("readonly")) return void T(l(u2));
            "Delete" == t2.key && f2 && y(a2.anchorNode.nextSibling) && e2.removeTags(a2.anchorNode.nextSibling);
        }
        return true;
      }
      var m2 = "manual" == i2.dropdown.position;
      switch (t2.key) {
        case "Backspace":
          "select" == i2.mode && i2.enforceWhitelist && e2.value.length ? e2.removeTags() : e2.state.dropdown.visible && "manual" != i2.dropdown.position || "" != t2.target.textContent && 8203 != n2.charCodeAt(0) || (true === i2.backspace ? e2.removeTags() : "edit" == i2.backspace && setTimeout(e2.editTag.bind(e2), 0));
          break;
        case "Esc":
        case "Escape":
          if (e2.state.dropdown.visible) return;
          t2.target.blur();
          break;
        case "Down":
        case "ArrowDown":
          e2.state.dropdown.visible || e2.dropdown.show();
          break;
        case "ArrowRight":
          var v2 = e2.state.inputSuggestion || e2.state.ddItemData;
          if (v2 && i2.autoComplete.rightKey) return void e2.addTags([v2], true);
          break;
        case "Tab":
          return true;
        case "Enter":
          if (e2.state.dropdown.visible && !m2) return;
          t2.preventDefault();
          var b2 = e2.state.autoCompleteData || n2;
          setTimeout(function() {
            e2.state.dropdown.visible && !m2 || e2.state.actions.selectOption || !i2.addTagOn.includes(t2.key.toLowerCase()) || (e2.addTags([b2], true), e2.state.autoCompleteData = null);
          });
      }
    }).catch(function(t3) {
      return t3;
    });
  }
}, "onKeydown"), onInput: /* @__PURE__ */ __name(function(t2) {
  this.postUpdate();
  var e2 = this.settings;
  if ("mix" == e2.mode) return this.events.callbacks.onMixTagsInput.call(this, t2);
  var i2 = this.input.normalize.call(this, void 0, { trim: false }), n2 = i2.length >= e2.dropdown.enabled, s2 = { value: i2, inputElm: this.DOM.input }, a2 = this.validateTag({ value: i2 });
  "select" == e2.mode && this.toggleScopeValidation(a2), s2.isValid = a2, this.state.inputText != i2 && (this.input.set.call(this, i2, false), -1 != i2.search(e2.delimiters) ? this.addTags(i2) && this.input.set.call(this) : e2.dropdown.enabled >= 0 && this.dropdown[n2 ? "show" : "hide"](i2), this.trigger("input", s2));
}, "onInput"), onMixTagsInput: /* @__PURE__ */ __name(function(t2) {
  var e2, i2, n2, s2, a2, o2, r2, l2, d2 = this, c2 = this.settings, g2 = this.value.length, h2 = this.getTagElms(), f2 = document.createDocumentFragment(), m2 = window.getSelection().getRangeAt(0), v2 = [].map.call(h2, function(t3) {
    return y(t3).value;
  });
  if ("deleteContentBackward" == t2.inputType && p() && this.events.callbacks.onKeydown.call(this, { target: t2.target, key: "Backspace" }), O(this.getTagElms()), this.value.slice().forEach(function(t3) {
    t3.readonly && !v2.includes(t3.value) && f2.appendChild(d2.createTagElem(t3));
  }), f2.childNodes.length && (m2.insertNode(f2), this.setRangeAtStartEnd(false, f2.lastChild)), h2.length != g2) return this.value = [].map.call(this.getTagElms(), function(t3) {
    return y(t3);
  }), void this.update({ withoutChangeEvent: true });
  if (this.hasMaxTags()) return true;
  if (window.getSelection && (o2 = window.getSelection()).rangeCount > 0 && 3 == o2.anchorNode.nodeType) {
    if ((m2 = o2.getRangeAt(0).cloneRange()).collapse(true), m2.setStart(o2.focusNode, 0), n2 = (e2 = m2.toString().slice(0, m2.endOffset)).split(c2.pattern).length - 1, (i2 = e2.match(c2.pattern)) && (s2 = e2.slice(e2.lastIndexOf(i2[i2.length - 1]))), s2) {
      if (this.state.actions.ArrowLeft = false, this.state.tag = { prefix: s2.match(c2.pattern)[0], value: s2.replace(c2.pattern, "") }, this.state.tag.baseOffset = o2.baseOffset - this.state.tag.value.length, l2 = this.state.tag.value.match(c2.delimiters)) return this.state.tag.value = this.state.tag.value.replace(c2.delimiters, ""), this.state.tag.delimiters = l2[0], this.addTags(this.state.tag.value, c2.dropdown.clearOnSelect), void this.dropdown.hide();
      a2 = this.state.tag.value.length >= c2.dropdown.enabled;
      try {
        r2 = (r2 = this.state.flaggedTags[this.state.tag.baseOffset]).prefix == this.state.tag.prefix && r2.value[0] == this.state.tag.value[0], this.state.flaggedTags[this.state.tag.baseOffset] && !this.state.tag.value && delete this.state.flaggedTags[this.state.tag.baseOffset];
      } catch (t3) {
      }
      (r2 || n2 < this.state.mixMode.matchedPatternCount) && (a2 = false);
    } else this.state.flaggedTags = {};
    this.state.mixMode.matchedPatternCount = n2;
  }
  setTimeout(function() {
    d2.update({ withoutChangeEvent: true }), d2.trigger("input", u({}, d2.state.tag, { textContent: d2.DOM.input.textContent })), d2.state.tag && d2.dropdown[a2 ? "show" : "hide"](d2.state.tag.value);
  }, 10);
}, "onMixTagsInput"), onInputIE: /* @__PURE__ */ __name(function(t2) {
  var e2 = this;
  setTimeout(function() {
    e2.events.callbacks.onInput.call(e2, t2);
  });
}, "onInputIE"), observeOriginalInputValue: /* @__PURE__ */ __name(function() {
  this.DOM.originalInput.parentNode || this.destroy(), this.DOM.originalInput.value != this.DOM.originalInput.tagifyValue && this.loadOriginalValues();
}, "observeOriginalInputValue"), onClickAnywhere: /* @__PURE__ */ __name(function(t2) {
  if (t2.target != this.DOM.scope && !this.DOM.scope.contains(t2.target)) {
    this.toggleFocusClass(false), this.state.hasFocus = false;
    var e2 = t2.target.closest(this.settings.classNames.dropdownSelector);
    (null == e2 ? void 0 : e2.__tagify) != this && this.dropdown.hide();
  }
}, "onClickAnywhere"), onClickScope: /* @__PURE__ */ __name(function(t2) {
  var e2 = this.settings, i2 = t2.target.closest("." + e2.classNames.tag), n2 = t2.target === this.DOM.scope, s2 = +/* @__PURE__ */ new Date() - this.state.hasFocus;
  if (n2 && "select" != e2.mode) this.DOM.input.focus();
  else {
    if (!t2.target.classList.contains(e2.classNames.tagX)) return i2 && !this.state.editing ? (this.trigger("click", { tag: i2, index: this.getNodeIndex(i2), data: y(i2), event: t2 }), void (1 !== e2.editTags && 1 !== e2.editTags.clicks && "select" != e2.mode || this.events.callbacks.onDoubleClickScope.call(this, t2))) : void (t2.target == this.DOM.input && ("mix" == e2.mode && this.fixFirefoxLastTagNoCaret(), s2 > 500 || !e2.focusable) ? this.state.dropdown.visible ? this.dropdown.hide() : 0 === e2.dropdown.enabled && "mix" != e2.mode && this.dropdown.show(this.value.length ? "" : void 0) : "select" != e2.mode || 0 !== e2.dropdown.enabled || this.state.dropdown.visible || (this.events.callbacks.onDoubleClickScope.call(this, U(function(t3) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var i3 = null != arguments[e3] ? arguments[e3] : {}, n3 = Object.keys(i3);
        "function" == typeof Object.getOwnPropertySymbols && (n3 = n3.concat(Object.getOwnPropertySymbols(i3).filter(function(t4) {
          return Object.getOwnPropertyDescriptor(i3, t4).enumerable;
        }))), n3.forEach(function(e4) {
          B(t3, e4, i3[e4]);
        });
      }
      return t3;
    }({}, t2), { target: this.getTagElms()[0] })), !e2.userInput && this.dropdown.show()));
    this.removeTags(t2.target.parentNode);
  }
}, "onClickScope"), onPaste: /* @__PURE__ */ __name(function(t2) {
  var e2 = this;
  t2.preventDefault();
  var i2, n2, s2, a2 = this.settings;
  if ("select" == a2.mode && a2.enforceWhitelist || !a2.userInput) return false;
  a2.readonly || (n2 = t2.clipboardData || window.clipboardData, s2 = n2.getData("Text"), a2.hooks.beforePaste(t2, { tagify: this, pastedText: s2, clipboardData: n2 }).then(function(a3) {
    void 0 === a3 && (a3 = s2), a3 && (e2.injectAtCaret(a3, window.getSelection().getRangeAt(0)), "mix" == e2.settings.mode ? e2.events.callbacks.onMixTagsInput.call(e2, t2) : e2.settings.pasteAsTags ? i2 = e2.addTags(e2.state.inputText + a3, true) : (e2.state.inputText = a3, e2.dropdown.show(a3))), e2.trigger("paste", { event: t2, pastedText: s2, clipboardData: n2, tagsElems: i2 });
  }).catch(function(t3) {
    return t3;
  }));
}, "onPaste"), onDrop: /* @__PURE__ */ __name(function(t2) {
  t2.preventDefault();
}, "onDrop"), onEditTagInput: /* @__PURE__ */ __name(function(t2, e2) {
  var i2, n2 = t2.closest("." + this.settings.classNames.tag), s2 = this.getNodeIndex(n2), a2 = y(n2), o2 = this.input.normalize.call(this, t2), r2 = (B(i2 = {}, this.settings.tagTextProp, o2), B(i2, "__tagId", a2.__tagId), i2), l2 = this.validateTag(r2);
  this.editTagChangeDetected(u(a2, r2)) || true !== t2.originalIsValid || (l2 = true), n2.classList.toggle(this.settings.classNames.tagInvalid, true !== l2), a2.__isValid = l2, n2.title = true === l2 ? a2.title || a2.value : l2, o2.length >= this.settings.dropdown.enabled && (this.state.editing && (this.state.editing.value = o2), this.dropdown.show(o2)), this.trigger("edit:input", { tag: n2, index: s2, data: u({}, this.value[s2], { newValue: o2 }), event: e2 });
}, "onEditTagInput"), onEditTagPaste: /* @__PURE__ */ __name(function(t2, e2) {
  var i2 = (e2.clipboardData || window.clipboardData).getData("Text");
  e2.preventDefault();
  var n2 = w(i2);
  this.setRangeAtStartEnd(false, n2);
}, "onEditTagPaste"), onEditTagClick: /* @__PURE__ */ __name(function(t2, e2) {
  this.events.callbacks.onClickScope.call(this, e2);
}, "onEditTagClick"), onEditTagFocus: /* @__PURE__ */ __name(function(t2) {
  this.state.editing = { scope: t2, input: t2.querySelector("[contenteditable]") };
}, "onEditTagFocus"), onEditTagBlur: /* @__PURE__ */ __name(function(t2, e2) {
  var i2 = m.call(this, e2.relatedTarget);
  if ("select" == this.settings.mode && i2 && e2.relatedTarget.contains(e2.target)) this.dropdown.hide();
  else if (this.state.editing && (this.state.hasFocus || this.toggleFocusClass(), this.DOM.scope.contains(document.activeElement) || this.trigger("blur", {}), this.DOM.scope.contains(t2))) {
    var n2, s2, a2, o2 = this.settings, r2 = t2.closest("." + o2.classNames.tag), l2 = y(r2), d2 = this.input.normalize.call(this, t2), c2 = (B(n2 = {}, o2.tagTextProp, d2), B(n2, "__tagId", l2.__tagId), n2), g2 = l2.__originalData, h2 = this.editTagChangeDetected(u(l2, c2)), p2 = this.validateTag(c2);
    if (d2) if (h2) {
      var f2;
      if (s2 = this.hasMaxTags(), a2 = u({}, g2, (B(f2 = {}, o2.tagTextProp, this.trim(d2)), B(f2, "__isValid", p2), f2)), o2.transformTag.call(this, a2, g2), true !== (p2 = (!s2 || true === g2.__isValid) && this.validateTag(a2))) {
        if (this.trigger("invalid", { data: a2, tag: r2, message: p2 }), o2.editTags.keepInvalid) return;
        o2.keepInvalidTags ? a2.__isValid = p2 : a2 = g2;
      } else o2.keepInvalidTags && (delete a2.title, delete a2["aria-invalid"], delete a2.class);
      this.onEditTagDone(r2, a2);
    } else this.onEditTagDone(r2, g2);
    else this.onEditTagDone(r2);
  }
}, "onEditTagBlur"), onEditTagkeydown: /* @__PURE__ */ __name(function(t2, e2) {
  if (!this.state.composing) switch (this.trigger("edit:keydown", { event: t2 }), t2.key) {
    case "Esc":
    case "Escape":
      this.state.editing = false, !!e2.__tagifyTagData.__originalData.value ? e2.parentNode.replaceChild(e2.__tagifyTagData.__originalHTML, e2) : e2.remove();
      break;
    case "Enter":
    case "Tab":
      t2.preventDefault();
      setTimeout(function() {
        return t2.target.blur();
      }, 0);
  }
}, "onEditTagkeydown"), onDoubleClickScope: /* @__PURE__ */ __name(function(t2) {
  var e2, i2, n2 = t2.target.closest("." + this.settings.classNames.tag), s2 = y(n2), a2 = this.settings;
  n2 && false !== s2.editable && (e2 = n2.classList.contains(this.settings.classNames.tagEditing), i2 = n2.hasAttribute("readonly"), a2.readonly || e2 || i2 || !this.settings.editTags || !a2.userInput || (this.events.callbacks.onEditTagFocus.call(this, n2), this.editTag(n2)), this.toggleFocusClass(true), "select" != a2.mode && this.trigger("dblclick", { tag: n2, index: this.getNodeIndex(n2), data: y(n2) }));
}, "onDoubleClickScope"), onInputDOMChange: /* @__PURE__ */ __name(function(t2) {
  var e2 = this;
  t2.forEach(function(t3) {
    t3.addedNodes.forEach(function(t4) {
      if ("<div><br></div>" == t4.outerHTML) t4.replaceWith(document.createElement("br"));
      else if (1 == t4.nodeType && t4.querySelector(e2.settings.classNames.tagSelector)) {
        var i3, n2 = document.createTextNode("");
        3 == t4.childNodes[0].nodeType && "BR" != t4.previousSibling.nodeName && (n2 = document.createTextNode("\n")), (i3 = t4).replaceWith.apply(i3, q([n2].concat(q(q(t4.childNodes).slice(0, -1))))), T(n2);
      } else if (m.call(e2, t4)) {
        var s2;
        if (3 != (null === (s2 = t4.previousSibling) || void 0 === s2 ? void 0 : s2.nodeType) || t4.previousSibling.textContent || t4.previousSibling.remove(), t4.previousSibling && "BR" == t4.previousSibling.nodeName) {
          t4.previousSibling.replaceWith("\n\u200B");
          for (var a2 = t4.nextSibling, o2 = ""; a2; ) o2 += a2.textContent, a2 = a2.nextSibling;
          o2.trim() && T(t4.previousSibling);
        } else t4.previousSibling && !y(t4.previousSibling) || t4.before("\u200B");
      }
    }), t3.removedNodes.forEach(function(t4) {
      t4 && "BR" == t4.nodeName && m.call(e2, i2) && (e2.removeTags(i2), e2.fixFirefoxLastTagNoCaret());
    });
  });
  var i2 = this.DOM.input.lastChild;
  i2 && "" == i2.nodeValue && i2.remove(), i2 && "BR" == i2.nodeName || this.DOM.input.appendChild(document.createElement("br"));
}, "onInputDOMChange") } };
function z(t2, e2) {
  (null == e2 || e2 > t2.length) && (e2 = t2.length);
  for (var i2 = 0, n2 = new Array(e2); i2 < e2; i2++) n2[i2] = t2[i2];
  return n2;
}
__name(z, "z");
function X(t2, e2, i2) {
  return e2 in t2 ? Object.defineProperty(t2, e2, { value: i2, enumerable: true, configurable: true, writable: true }) : t2[e2] = i2, t2;
}
__name(X, "X");
function J(t2, e2) {
  return null != e2 && "undefined" != typeof Symbol && e2[Symbol.hasInstance] ? !!e2[Symbol.hasInstance](t2) : t2 instanceof e2;
}
__name(J, "J");
function G(t2) {
  for (var e2 = 1; e2 < arguments.length; e2++) {
    var i2 = null != arguments[e2] ? arguments[e2] : {}, n2 = Object.keys(i2);
    "function" == typeof Object.getOwnPropertySymbols && (n2 = n2.concat(Object.getOwnPropertySymbols(i2).filter(function(t3) {
      return Object.getOwnPropertyDescriptor(i2, t3).enumerable;
    }))), n2.forEach(function(e3) {
      X(t2, e3, i2[e3]);
    });
  }
  return t2;
}
__name(G, "G");
function $2(t2) {
  return function(t3) {
    if (Array.isArray(t3)) return z(t3);
  }(t2) || function(t3) {
    if ("undefined" != typeof Symbol && null != t3[Symbol.iterator] || null != t3["@@iterator"]) return Array.from(t3);
  }(t2) || function(t3, e2) {
    if (!t3) return;
    if ("string" == typeof t3) return z(t3, e2);
    var i2 = Object.prototype.toString.call(t3).slice(8, -1);
    "Object" === i2 && t3.constructor && (i2 = t3.constructor.name);
    if ("Map" === i2 || "Set" === i2) return Array.from(i2);
    if ("Arguments" === i2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i2)) return z(t3, e2);
  }(t2) || function() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }();
}
__name($2, "$");
function Q(t2, e2) {
  if (!t2) {
    n.warn("input element not found", t2);
    var i2 = new Proxy(this, { get: /* @__PURE__ */ __name(function() {
      return function() {
        return i2;
      };
    }, "get") });
    return i2;
  }
  if (t2.__tagify) return n.warn("input element is already Tagified - Same instance is returned.", t2), t2.__tagify;
  var s2;
  u(this, function(t3) {
    var e3 = document.createTextNode(""), i3 = {};
    function s3(t4, i4, n2) {
      n2 && i4.split(/\s+/g).forEach(function(i5) {
        return e3[t4 + "EventListener"].call(e3, i5, n2);
      });
    }
    __name(s3, "s");
    return { removeAllCustomListeners: /* @__PURE__ */ __name(function() {
      Object.entries(i3).forEach(function(t4) {
        var e4 = F(t4, 2), i4 = e4[0];
        e4[1].forEach(function(t5) {
          return s3("remove", i4, t5);
        });
      }), i3 = {};
    }, "removeAllCustomListeners"), off: /* @__PURE__ */ __name(function(t4, e4) {
      return t4 && (e4 ? s3("remove", t4, e4) : t4.split(/\s+/g).forEach(function(t5) {
        var e5;
        null === (e5 = i3[t5]) || void 0 === e5 || e5.forEach(function(e6) {
          return s3("remove", t5, e6);
        }), delete i3[t5];
      })), this;
    }, "off"), on: /* @__PURE__ */ __name(function(t4, e4) {
      return e4 && "function" == typeof e4 && (t4.split(/\s+/g).forEach(function(t5) {
        Array.isArray(i3[t5]) ? i3[t5].push(e4) : i3[t5] = [e4];
      }), s3("add", t4, e4)), this;
    }, "on"), trigger: /* @__PURE__ */ __name(function(i4, s4, a2) {
      var o2;
      if (a2 = a2 || { cloneData: true }, i4) if (t3.settings.isJQueryPlugin) "remove" == i4 && (i4 = "removeTag"), jQuery(t3.DOM.originalInput).triggerHandler(i4, [s4]);
      else {
        try {
          var r2 = "object" == typeof s4 ? s4 : { value: s4 };
          if ((r2 = a2.cloneData ? u({}, r2) : r2).tagify = this, s4.event && (r2.event = this.cloneEvent(s4.event)), R(s4, Object)) for (var l2 in s4) R(s4[l2], HTMLElement) && (r2[l2] = s4[l2]);
          o2 = new CustomEvent(i4, { detail: r2 });
        } catch (t4) {
          n.warn(t4);
        }
        e3.dispatchEvent(o2);
      }
    }, "trigger") };
  }(this)), this.isFirefox = /firefox|fxios/i.test(navigator.userAgent) && !/seamonkey/i.test(navigator.userAgent), this.isIE = window.document.documentMode, e2 = e2 || {}, this.getPersistedData = (s2 = e2.id, function(t3) {
    var e3;
    if (s2) {
      var i3, n2 = "/" + t3;
      if (1 === (null === (e3 = localStorage) || void 0 === e3 ? void 0 : e3.getItem(L + s2 + "/v"))) try {
        i3 = JSON.parse(localStorage[L + s2 + n2]);
      } catch (t4) {
      }
      return i3;
    }
  }), this.setPersistedData = function(t3) {
    var e3;
    return t3 ? (null === (e3 = localStorage) || void 0 === e3 || e3.setItem(L + t3 + "/v", 1), function(e4, i3) {
      var n2, s3 = "/" + i3, a2 = JSON.stringify(e4);
      e4 && i3 && (null === (n2 = localStorage) || void 0 === n2 || n2.setItem(L + t3 + s3, a2), dispatchEvent(new Event("storage")));
    }) : function() {
    };
  }(e2.id), this.clearPersistedData = /* @__PURE__ */ function(t3) {
    return function(e3) {
      var i3 = L + "/" + t3 + "/";
      if (e3) localStorage.removeItem(i3 + e3);
      else for (var n2 in localStorage) n2.includes(i3) && localStorage.removeItem(n2);
    };
  }(e2.id), this.applySettings(t2, e2), this.state = { inputText: "", editing: false, composing: false, actions: {}, mixMode: {}, dropdown: {}, flaggedTags: {} }, this.value = [], this.listeners = {}, this.DOM = {}, this.build(t2), _.call(this), this.getCSSVars(), this.loadOriginalValues(), this.events.customBinding.call(this), this.events.binding.call(this), t2.autofocus && this.DOM.input.focus(), t2.__tagify = this;
}
__name(Q, "Q");
Q.prototype = { _dropdown: k, placeCaretAfterNode: T, getSetTagData: y, helpers: { sameStr: s, removeCollectionProp: a, omit: o, isObject: c, parseHTML: r, escapeHTML: d, extend: u, concatWithoutDups: g, getUID: f, isNodeTag: m }, customEventsList: ["change", "add", "remove", "invalid", "input", "paste", "click", "keydown", "focus", "blur", "edit:input", "edit:beforeUpdate", "edit:updated", "edit:start", "edit:keydown", "dropdown:show", "dropdown:hide", "dropdown:select", "dropdown:updated", "dropdown:noMatch", "dropdown:scroll"], dataProps: ["__isValid", "__removed", "__originalData", "__originalHTML", "__tagId"], trim: /* @__PURE__ */ __name(function(t2) {
  return this.settings.trim && t2 && "string" == typeof t2 ? t2.trim() : t2;
}, "trim"), parseHTML: r, templates: j, parseTemplate: /* @__PURE__ */ __name(function(t2, e2) {
  return r((t2 = this.settings.templates[t2] || t2).apply(this, e2));
}, "parseTemplate"), set whitelist(t2) {
  var e2 = t2 && Array.isArray(t2);
  this.settings.whitelist = e2 ? t2 : [], this.setPersistedData(e2 ? t2 : [], "whitelist");
}, get whitelist() {
  return this.settings.whitelist;
}, set userInput(t2) {
  this.settings.userInput = !!t2, this.setContentEditable(!!t2);
}, get userInput() {
  return this.settings.userInput;
}, generateClassSelectors: /* @__PURE__ */ __name(function(t2) {
  var e2 = /* @__PURE__ */ __name(function(e3) {
    var i3 = e3;
    Object.defineProperty(t2, i3 + "Selector", { get: /* @__PURE__ */ __name(function() {
      return "." + this[i3].split(" ")[0];
    }, "get") });
  }, "e");
  for (var i2 in t2) e2(i2);
}, "generateClassSelectors"), applySettings: /* @__PURE__ */ __name(function(t2, e2) {
  var i2, n2;
  D.templates = this.templates;
  var s2 = u({}, D, "mix" == e2.mode ? { dropdown: { position: "text" } } : {}), a2 = this.settings = u({}, s2, e2);
  if (a2.disabled = t2.hasAttribute("disabled"), a2.readonly = a2.readonly || t2.hasAttribute("readonly"), a2.placeholder = d(t2.getAttribute("placeholder") || a2.placeholder || ""), a2.required = t2.hasAttribute("required"), this.generateClassSelectors(a2.classNames), this.isIE && (a2.autoComplete = false), ["whitelist", "blacklist"].forEach(function(e3) {
    var i3 = t2.getAttribute("data-" + e3);
    i3 && J(i3 = i3.split(a2.delimiters), Array) && (a2[e3] = i3);
  }), "autoComplete" in e2 && !c(e2.autoComplete) && (a2.autoComplete = D.autoComplete, a2.autoComplete.enabled = e2.autoComplete), "mix" == a2.mode && (a2.pattern = a2.pattern || /@/, a2.autoComplete.rightKey = true, a2.delimiters = e2.delimiters || null, a2.tagTextProp && !a2.dropdown.searchKeys.includes(a2.tagTextProp) && a2.dropdown.searchKeys.push(a2.tagTextProp)), t2.pattern) try {
    a2.pattern = new RegExp(t2.pattern);
  } catch (t3) {
  }
  if (a2.delimiters) {
    a2._delimiters = a2.delimiters;
    try {
      a2.delimiters = new RegExp(this.settings.delimiters, "g");
    } catch (t3) {
    }
  }
  a2.disabled && (a2.userInput = false), this.TEXTS = G({}, P, a2.texts || {}), "select" == a2.mode && (a2.dropdown.includeSelectedTags = true), ("select" != a2.mode || (null === (i2 = e2.dropdown) || void 0 === i2 ? void 0 : i2.enabled)) && a2.userInput || (a2.dropdown.enabled = 0), a2.dropdown.appendTarget = (null === (n2 = e2.dropdown) || void 0 === n2 ? void 0 : n2.appendTarget) || document.body, void 0 === a2.dropdown.includeSelectedTags && (a2.dropdown.includeSelectedTags = a2.duplicates);
  var o2 = this.getPersistedData("whitelist");
  Array.isArray(o2) && (this.whitelist = Array.isArray(a2.whitelist) ? g(a2.whitelist, o2) : o2);
}, "applySettings"), getAttributes: /* @__PURE__ */ __name(function(t2) {
  var e2, i2 = this.getCustomAttributes(t2), n2 = "";
  for (e2 in i2) n2 += " " + e2 + (void 0 !== t2[e2] ? '="'.concat(i2[e2], '"') : "");
  return n2;
}, "getAttributes"), getCustomAttributes: /* @__PURE__ */ __name(function(t2) {
  if (!c(t2)) return "";
  var e2, i2 = {};
  for (e2 in t2) "__" != e2.slice(0, 2) && "class" != e2 && t2.hasOwnProperty(e2) && void 0 !== t2[e2] && (i2[e2] = d(t2[e2]));
  return i2;
}, "getCustomAttributes"), setStateSelection: /* @__PURE__ */ __name(function() {
  var t2 = window.getSelection(), e2 = { anchorOffset: t2.anchorOffset, anchorNode: t2.anchorNode, range: t2.getRangeAt && t2.rangeCount && t2.getRangeAt(0) };
  return this.state.selection = e2, e2;
}, "setStateSelection"), getCSSVars: /* @__PURE__ */ __name(function() {
  var t2, e2, i2, n2 = getComputedStyle(this.DOM.scope, null);
  this.CSSVars = { tagHideTransition: (t2 = function(t3) {
    if (!t3) return {};
    var e3 = (t3 = t3.trim().split(" ")[0]).split(/\d+/g).filter(function(t4) {
      return t4;
    }).pop().trim();
    return { value: +t3.split(e3).filter(function(t4) {
      return t4;
    })[0].trim(), unit: e3 };
  }((i2 = "tag-hide-transition", n2.getPropertyValue("--" + i2))), e2 = t2.value, "s" == t2.unit ? 1e3 * e2 : e2) };
}, "getCSSVars"), build: /* @__PURE__ */ __name(function(t2) {
  var e2 = this.DOM, i2 = t2.closest("label");
  this.settings.mixMode.integrated ? (e2.originalInput = null, e2.scope = t2, e2.input = t2) : (e2.originalInput = t2, e2.originalInput_tabIndex = t2.tabIndex, e2.scope = this.parseTemplate("wrapper", [t2, this.settings]), e2.input = e2.scope.querySelector(this.settings.classNames.inputSelector), t2.parentNode.insertBefore(e2.scope, t2), t2.tabIndex = -1), i2 && i2.setAttribute("for", "");
}, "build"), destroy: /* @__PURE__ */ __name(function() {
  var t2;
  this.events.unbindGlobal.call(this), null === (t2 = this.DOM.scope.parentNode) || void 0 === t2 || t2.removeChild(this.DOM.scope), this.DOM.originalInput.tabIndex = this.DOM.originalInput_tabIndex, delete this.DOM.originalInput.__tagify, this.dropdown.hide(true), this.removeAllCustomListeners(), clearTimeout(this.dropdownHide__bindEventsTimeout), clearInterval(this.listeners.main.originalInputValueObserverInterval);
}, "destroy"), loadOriginalValues: /* @__PURE__ */ __name(function(t2) {
  var e2, i2 = this.settings;
  if (this.state.blockChangeEvent = true, void 0 === t2) {
    var n2 = this.getPersistedData("value");
    t2 = n2 && !this.DOM.originalInput.value ? n2 : i2.mixMode.integrated ? this.DOM.input.textContent : this.DOM.originalInput.value;
  }
  if (this.removeAllTags(), t2) if ("mix" == i2.mode) this.parseMixTags(t2), (e2 = this.DOM.input.lastChild) && "BR" == e2.tagName || this.DOM.input.insertAdjacentHTML("beforeend", "<br>");
  else {
    try {
      J(JSON.parse(t2), Array) && (t2 = JSON.parse(t2));
    } catch (t3) {
    }
    this.addTags(t2, true).forEach(function(t3) {
      return t3 && t3.classList.add(i2.classNames.tagNoAnimation);
    });
  }
  else this.postUpdate();
  this.state.lastOriginalValueReported = i2.mixMode.integrated ? "" : this.DOM.originalInput.value;
}, "loadOriginalValues"), cloneEvent: /* @__PURE__ */ __name(function(t2) {
  var e2 = {};
  for (var i2 in t2) "path" != i2 && (e2[i2] = t2[i2]);
  return e2;
}, "cloneEvent"), loading: /* @__PURE__ */ __name(function(t2) {
  return this.state.isLoading = t2, this.DOM.scope.classList[t2 ? "add" : "remove"](this.settings.classNames.scopeLoading), this;
}, "loading"), tagLoading: /* @__PURE__ */ __name(function(t2, e2) {
  return t2 && t2.classList[e2 ? "add" : "remove"](this.settings.classNames.tagLoading), this;
}, "tagLoading"), toggleClass: /* @__PURE__ */ __name(function(t2, e2) {
  "string" == typeof t2 && this.DOM.scope.classList.toggle(t2, e2);
}, "toggleClass"), toggleScopeValidation: /* @__PURE__ */ __name(function(t2) {
  var e2 = true === t2 || void 0 === t2;
  !this.settings.required && t2 && t2 === this.TEXTS.empty && (e2 = true), this.toggleClass(this.settings.classNames.tagInvalid, !e2), this.DOM.scope.title = e2 ? "" : t2;
}, "toggleScopeValidation"), toggleFocusClass: /* @__PURE__ */ __name(function(t2) {
  this.toggleClass(this.settings.classNames.focus, !!t2);
}, "toggleFocusClass"), setPlaceholder: /* @__PURE__ */ __name(function(t2) {
  var e2 = this;
  ["data", "aria"].forEach(function(i2) {
    return e2.DOM.input.setAttribute("".concat(i2, "-placeholder"), t2);
  });
}, "setPlaceholder"), triggerChangeEvent: /* @__PURE__ */ __name(function() {
  if (!this.settings.mixMode.integrated) {
    var t2 = this.DOM.originalInput, e2 = this.state.lastOriginalValueReported !== t2.value, i2 = new CustomEvent("change", { bubbles: true });
    e2 && (this.state.lastOriginalValueReported = t2.value, i2.simulated = true, t2._valueTracker && t2._valueTracker.setValue(Math.random()), t2.dispatchEvent(i2), this.trigger("change", this.state.lastOriginalValueReported), t2.value = this.state.lastOriginalValueReported);
  }
}, "triggerChangeEvent"), events: K, fixFirefoxLastTagNoCaret: /* @__PURE__ */ __name(function() {
}, "fixFirefoxLastTagNoCaret"), setRangeAtStartEnd: /* @__PURE__ */ __name(function(t2, e2) {
  if (e2) {
    t2 = "number" == typeof t2 ? t2 : !!t2, e2 = e2.lastChild || e2;
    var i2 = document.getSelection();
    if (J(i2.focusNode, Element) && !this.DOM.input.contains(i2.focusNode)) return true;
    try {
      i2.rangeCount >= 1 && ["Start", "End"].forEach(function(n2) {
        return i2.getRangeAt(0)["set" + n2](e2, t2 || e2.length);
      });
    } catch (t3) {
      console.warn(t3);
    }
  }
}, "setRangeAtStartEnd"), insertAfterTag: /* @__PURE__ */ __name(function(t2, e2) {
  if (e2 = e2 || this.settings.mixMode.insertAfterTag, t2 && t2.parentNode && e2) return e2 = "string" == typeof e2 ? document.createTextNode(e2) : e2, t2.parentNode.insertBefore(e2, t2.nextSibling), e2;
}, "insertAfterTag"), editTagChangeDetected: /* @__PURE__ */ __name(function(t2) {
  var e2 = t2.__originalData;
  for (var i2 in e2) if (!this.dataProps.includes(i2) && t2[i2] != e2[i2]) return true;
  return false;
}, "editTagChangeDetected"), getTagTextNode: /* @__PURE__ */ __name(function(t2) {
  return t2.querySelector(this.settings.classNames.tagTextSelector);
}, "getTagTextNode"), setTagTextNode: /* @__PURE__ */ __name(function(t2, e2) {
  this.getTagTextNode(t2).innerHTML = d(e2);
}, "setTagTextNode"), editTag: /* @__PURE__ */ __name(function(t2, e2) {
  var i2 = this;
  t2 = t2 || this.getLastTag(), e2 = e2 || {};
  var s2 = this.settings, a2 = this.getTagTextNode(t2), o2 = this.getNodeIndex(t2), r2 = y(t2), l2 = this.events.callbacks, d2 = true, c2 = "select" == s2.mode;
  if (!c2 && this.dropdown.hide(), a2) {
    if (!J(r2, Object) || !("editable" in r2) || r2.editable) return r2 = y(t2, { __originalData: u({}, r2), __originalHTML: t2.cloneNode(true) }), y(r2.__originalHTML, r2.__originalData), a2.setAttribute("contenteditable", true), t2.classList.add(s2.classNames.tagEditing), this.events.callbacks.onEditTagFocus.call(this, t2), a2.addEventListener("click", l2.onEditTagClick.bind(this, t2)), a2.addEventListener("blur", l2.onEditTagBlur.bind(this, this.getTagTextNode(t2))), a2.addEventListener("input", l2.onEditTagInput.bind(this, a2)), a2.addEventListener("paste", l2.onEditTagPaste.bind(this, a2)), a2.addEventListener("keydown", function(e3) {
      return l2.onEditTagkeydown.call(i2, e3, t2);
    }), a2.addEventListener("compositionstart", l2.onCompositionStart.bind(this)), a2.addEventListener("compositionend", l2.onCompositionEnd.bind(this)), e2.skipValidation || (d2 = this.editTagToggleValidity(t2)), a2.originalIsValid = d2, this.trigger("edit:start", { tag: t2, index: o2, data: r2, isValid: d2 }), a2.focus(), !c2 && this.setRangeAtStartEnd(false, a2), 0 === s2.dropdown.enabled && !c2 && this.dropdown.show(), this.state.hasFocus = true, this;
  } else n.warn("Cannot find element in Tag template: .", s2.classNames.tagTextSelector);
}, "editTag"), editTagToggleValidity: /* @__PURE__ */ __name(function(t2, e2) {
  var i2;
  if (e2 = e2 || y(t2)) return (i2 = !("__isValid" in e2) || true === e2.__isValid) || this.removeTagsFromValue(t2), this.update(), t2.classList.toggle(this.settings.classNames.tagNotAllowed, !i2), e2.__isValid = i2, e2.__isValid;
  n.warn("tag has no data: ", t2, e2);
}, "editTagToggleValidity"), onEditTagDone: /* @__PURE__ */ __name(function(t2, e2) {
  t2 = t2 || this.state.editing.scope, e2 = e2 || {};
  var i2, n2, s2 = this.settings, a2 = { tag: t2, index: this.getNodeIndex(t2), previousData: y(t2), data: e2 };
  this.trigger("edit:beforeUpdate", a2, { cloneData: false }), this.state.editing = false, delete e2.__originalData, delete e2.__originalHTML, t2 && t2.parentNode && ((void 0 !== (n2 = e2[s2.tagTextProp]) ? null === (i2 = (n2 += "").trim) || void 0 === i2 ? void 0 : i2.call(n2) : s2.tagTextProp in e2 ? void 0 : e2.value) ? (t2 = this.replaceTag(t2, e2), this.editTagToggleValidity(t2, e2), s2.a11y.focusableTags ? t2.focus() : "select" != s2.mode && T(t2)) : this.removeTags(t2)), this.trigger("edit:updated", a2), s2.dropdown.closeOnSelect && this.dropdown.hide(), this.settings.keepInvalidTags && this.reCheckInvalidTags();
}, "onEditTagDone"), replaceTag: /* @__PURE__ */ __name(function(t2, e2) {
  e2 && "" !== e2.value && void 0 !== e2.value || (e2 = t2.__tagifyTagData), e2.__isValid && 1 != e2.__isValid && u(e2, this.getInvalidTagAttrs(e2, e2.__isValid));
  var i2 = this.createTagElem(e2);
  return t2.parentNode.replaceChild(i2, t2), this.updateValueByDOMTags(), i2;
}, "replaceTag"), updateValueByDOMTags: /* @__PURE__ */ __name(function() {
  var t2 = this;
  this.value.length = 0;
  var e2 = this.settings.classNames, i2 = [e2.tagNotAllowed.split(" ")[0], e2.tagHide];
  [].forEach.call(this.getTagElms(), function(e3) {
    $2(e3.classList).some(function(t3) {
      return i2.includes(t3);
    }) || t2.value.push(y(e3));
  }), this.update(), this.dropdown.refilter();
}, "updateValueByDOMTags"), injectAtCaret: /* @__PURE__ */ __name(function(t2, e2) {
  var i2;
  if (e2 = e2 || (null === (i2 = this.state.selection) || void 0 === i2 ? void 0 : i2.range), "string" == typeof t2 && (t2 = document.createTextNode(t2)), !e2 && t2) return this.appendMixTags(t2), this;
  var n2 = w(t2, e2);
  return this.setRangeAtStartEnd(false, n2), this.updateValueByDOMTags(), this.update(), this;
}, "injectAtCaret"), input: { set: /* @__PURE__ */ __name(function() {
  var t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "", e2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i2 = this.settings, n2 = i2.dropdown.closeOnSelect;
  this.state.inputText = t2, e2 && (this.DOM.input.innerHTML = d("" + t2), t2 && this.toggleClass(i2.classNames.empty, !this.DOM.input.innerHTML)), !t2 && n2 && this.dropdown.hide.bind(this), this.input.autocomplete.suggest.call(this), this.input.validate.call(this);
}, "set"), raw: /* @__PURE__ */ __name(function() {
  return this.DOM.input.textContent;
}, "raw"), validate: /* @__PURE__ */ __name(function() {
  var t2 = !this.state.inputText || true === this.validateTag({ value: this.state.inputText });
  return this.DOM.input.classList.toggle(this.settings.classNames.inputInvalid, !t2), t2;
}, "validate"), normalize: /* @__PURE__ */ __name(function(t2, e2) {
  var i2 = t2 || this.DOM.input, n2 = [];
  i2.childNodes.forEach(function(t3) {
    return 3 == t3.nodeType && n2.push(t3.nodeValue);
  }), n2 = n2.join("\n");
  try {
    n2 = n2.replace(/(?:\r\n|\r|\n)/g, this.settings.delimiters.source.charAt(0));
  } catch (t3) {
  }
  return n2 = n2.replace(/\s/g, " "), (null == e2 ? void 0 : e2.trim) ? this.trim(n2) : n2;
}, "normalize"), autocomplete: { suggest: /* @__PURE__ */ __name(function(t2) {
  if (this.settings.autoComplete.enabled) {
    "object" != typeof (t2 = t2 || { value: "" }) && (t2 = { value: t2 });
    var e2 = this.dropdown.getMappedValue(t2);
    if ("number" != typeof e2) {
      var i2 = this.state.inputText.toLowerCase(), n2 = e2.substr(0, this.state.inputText.length).toLowerCase(), s2 = e2.substring(this.state.inputText.length);
      e2 && this.state.inputText && n2 == i2 ? (this.DOM.input.setAttribute("data-suggest", s2), this.state.inputSuggestion = t2) : (this.DOM.input.removeAttribute("data-suggest"), delete this.state.inputSuggestion);
    }
  }
}, "suggest"), set: /* @__PURE__ */ __name(function(t2) {
  var e2 = this.DOM.input.getAttribute("data-suggest"), i2 = t2 || (e2 ? this.state.inputText + e2 : null);
  return !!i2 && ("mix" == this.settings.mode ? this.replaceTextWithNode(document.createTextNode(this.state.tag.prefix + i2)) : (this.input.set.call(this, i2), this.setRangeAtStartEnd(false, this.DOM.input)), this.input.autocomplete.suggest.call(this), this.dropdown.hide(), true);
}, "set") } }, getTagIdx: /* @__PURE__ */ __name(function(t2) {
  return this.value.findIndex(function(e2) {
    return e2.__tagId == (t2 || {}).__tagId;
  });
}, "getTagIdx"), getNodeIndex: /* @__PURE__ */ __name(function(t2) {
  var e2 = 0;
  if (t2) for (; t2 = t2.previousElementSibling; ) e2++;
  return e2;
}, "getNodeIndex"), getTagElms: /* @__PURE__ */ __name(function() {
  for (var t2 = arguments.length, e2 = new Array(t2), i2 = 0; i2 < t2; i2++) e2[i2] = arguments[i2];
  var n2 = "." + $2(this.settings.classNames.tag.split(" ")).concat($2(e2)).join(".");
  return [].slice.call(this.DOM.scope.querySelectorAll(n2));
}, "getTagElms"), getLastTag: /* @__PURE__ */ __name(function() {
  var t2 = this.settings.classNames, e2 = this.DOM.scope.querySelectorAll("".concat(t2.tagSelector, ":not(.").concat(t2.tagHide, "):not([readonly])"));
  return e2[e2.length - 1];
}, "getLastTag"), isTagDuplicate: /* @__PURE__ */ __name(function(t2, e2, i2) {
  var n2 = 0, a2 = true, o2 = false, r2 = void 0;
  try {
    for (var l2, d2 = this.value[Symbol.iterator](); !(a2 = (l2 = d2.next()).done); a2 = true) {
      var c2 = l2.value;
      s(this.trim("" + t2), c2.value, e2) && i2 != c2.__tagId && n2++;
    }
  } catch (t3) {
    o2 = true, r2 = t3;
  } finally {
    try {
      a2 || null == d2.return || d2.return();
    } finally {
      if (o2) throw r2;
    }
  }
  return n2;
}, "isTagDuplicate"), getTagIndexByValue: /* @__PURE__ */ __name(function(t2) {
  var e2 = this, i2 = [], n2 = this.settings.dropdown.caseSensitive;
  return this.getTagElms().forEach(function(a2, o2) {
    a2.__tagifyTagData && s(e2.trim(a2.__tagifyTagData.value), t2, n2) && i2.push(o2);
  }), i2;
}, "getTagIndexByValue"), getTagElmByValue: /* @__PURE__ */ __name(function(t2) {
  var e2 = this.getTagIndexByValue(t2)[0];
  return this.getTagElms()[e2];
}, "getTagElmByValue"), flashTag: /* @__PURE__ */ __name(function(t2) {
  var e2 = this;
  t2 && (t2.classList.add(this.settings.classNames.tagFlash), setTimeout(function() {
    t2.classList.remove(e2.settings.classNames.tagFlash);
  }, 100));
}, "flashTag"), isTagBlacklisted: /* @__PURE__ */ __name(function(t2) {
  return t2 = this.trim(t2.toLowerCase()), this.settings.blacklist.filter(function(e2) {
    return ("" + e2).toLowerCase() == t2;
  }).length;
}, "isTagBlacklisted"), isTagWhitelisted: /* @__PURE__ */ __name(function(t2) {
  return !!this.getWhitelistItem(t2);
}, "isTagWhitelisted"), getWhitelistItem: /* @__PURE__ */ __name(function(t2, e2, i2) {
  e2 = e2 || "value";
  var n2, a2 = this.settings;
  return (i2 = i2 || a2.whitelist).some(function(i3) {
    var o2 = "object" == typeof i3 ? i3[e2] || i3.value : i3;
    if (s(o2, t2, a2.dropdown.caseSensitive, a2.trim)) return n2 = "object" == typeof i3 ? i3 : { value: i3 }, true;
  }), n2 || "value" != e2 || "value" == a2.tagTextProp || (n2 = this.getWhitelistItem(t2, a2.tagTextProp, i2)), n2;
}, "getWhitelistItem"), validateTag: /* @__PURE__ */ __name(function(t2) {
  var e2 = this.settings, i2 = "value" in t2 ? "value" : e2.tagTextProp, n2 = this.trim(t2[i2] + "");
  return (t2[i2] + "").trim() ? "mix" != e2.mode && e2.pattern && J(e2.pattern, RegExp) && !e2.pattern.test(n2) ? this.TEXTS.pattern : !e2.duplicates && this.isTagDuplicate(n2, e2.dropdown.caseSensitive, t2.__tagId) ? this.TEXTS.duplicate : this.isTagBlacklisted(n2) || e2.enforceWhitelist && !this.isTagWhitelisted(n2) ? this.TEXTS.notAllowed : !e2.validate || e2.validate(t2) : this.TEXTS.empty;
}, "validateTag"), getInvalidTagAttrs: /* @__PURE__ */ __name(function(t2, e2) {
  return { "aria-invalid": true, class: "".concat(t2.class || "", " ").concat(this.settings.classNames.tagNotAllowed).trim(), title: e2 };
}, "getInvalidTagAttrs"), hasMaxTags: /* @__PURE__ */ __name(function() {
  return this.value.length >= this.settings.maxTags && this.TEXTS.exceed;
}, "hasMaxTags"), setReadonly: /* @__PURE__ */ __name(function(t2, e2) {
  var i2 = this.settings;
  this.DOM.scope.contains(document.activeElement) && document.activeElement.blur(), i2[e2 || "readonly"] = t2, this.DOM.scope[(t2 ? "set" : "remove") + "Attribute"](e2 || "readonly", true), this.settings.userInput = true, this.setContentEditable(!t2);
}, "setReadonly"), setContentEditable: /* @__PURE__ */ __name(function(t2) {
  this.DOM.input.contentEditable = t2, this.DOM.input.tabIndex = t2 ? 0 : -1;
}, "setContentEditable"), setDisabled: /* @__PURE__ */ __name(function(t2) {
  this.setReadonly(t2, "disabled");
}, "setDisabled"), normalizeTags: /* @__PURE__ */ __name(function(t2) {
  var e2 = this, i2 = this.settings, n2 = i2.whitelist, s2 = i2.delimiters, a2 = i2.mode, o2 = i2.tagTextProp, r2 = [], l2 = !!n2 && J(n2[0], Object), d2 = Array.isArray(t2), g2 = d2 && t2[0].value, h2 = /* @__PURE__ */ __name(function(t3) {
    return (t3 + "").split(s2).reduce(function(t4, i3) {
      var n3, s3 = e2.trim(i3);
      return s3 && t4.push((X(n3 = {}, o2, s3), X(n3, "value", s3), n3)), t4;
    }, []);
  }, "h");
  if ("number" == typeof t2 && (t2 = t2.toString()), "string" == typeof t2) {
    if (!t2.trim()) return [];
    t2 = h2(t2);
  } else d2 && (t2 = t2.reduce(function(t3, i3) {
    if (c(i3)) {
      var n3 = u({}, i3);
      o2 in n3 || (o2 = "value"), n3[o2] = e2.trim(n3[o2]), (n3[o2] || 0 === n3[o2]) && t3.push(n3);
    } else if (null != i3 && "" !== i3 && void 0 !== i3) {
      var s3;
      (s3 = t3).push.apply(s3, $2(h2(i3)));
    }
    return t3;
  }, []));
  return l2 && !g2 && (t2.forEach(function(t3) {
    var i3 = r2.map(function(t4) {
      return t4.value;
    }), n3 = e2.dropdown.filterListItems.call(e2, t3[o2], { exact: true });
    e2.settings.duplicates || (n3 = n3.filter(function(t4) {
      return !i3.includes(t4.value);
    }));
    var s3 = n3.length > 1 ? e2.getWhitelistItem(t3[o2], o2, n3) : n3[0];
    s3 && J(s3, Object) ? r2.push(s3) : "mix" != a2 && (null == t3.value && (t3.value = t3[o2]), r2.push(t3));
  }), r2.length && (t2 = r2)), t2;
}, "normalizeTags"), parseMixTags: /* @__PURE__ */ __name(function(t2) {
  var e2 = this, i2 = this.settings, n2 = i2.mixTagsInterpolator, s2 = i2.duplicates, a2 = i2.transformTag, o2 = i2.enforceWhitelist, r2 = i2.maxTags, l2 = i2.tagTextProp, d2 = [];
  t2 = t2.split(n2[0]).map(function(t3, i3) {
    var c3, u2, g2, h2 = t3.split(n2[1]), p2 = h2[0], f2 = d2.length == r2;
    try {
      if (p2 == +p2) throw Error;
      u2 = JSON.parse(p2);
    } catch (t4) {
      u2 = e2.normalizeTags(p2)[0] || { value: p2 };
    }
    if (a2.call(e2, u2), f2 || !(h2.length > 1) || o2 && !e2.isTagWhitelisted(u2.value) || !s2 && e2.isTagDuplicate(u2.value)) {
      if (t3) return i3 ? n2[0] + t3 : t3;
    } else u2[c3 = u2[l2] ? l2 : "value"] = e2.trim(u2[c3]), g2 = e2.createTagElem(u2), d2.push(u2), g2.classList.add(e2.settings.classNames.tagNoAnimation), h2[0] = g2.outerHTML, e2.value.push(u2);
    return h2.join("");
  }).join(""), this.DOM.input.innerHTML = t2, this.DOM.input.appendChild(document.createTextNode("")), this.DOM.input.normalize();
  var c2 = this.getTagElms();
  return c2.forEach(function(t3, e3) {
    return y(t3, d2[e3]);
  }), this.update({ withoutChangeEvent: true }), O(c2, this.state.hasFocus), t2;
}, "parseMixTags"), replaceTextWithNode: /* @__PURE__ */ __name(function(t2, e2) {
  if (this.state.tag || e2) {
    e2 = e2 || this.state.tag.prefix + this.state.tag.value;
    var i2, n2, s2 = this.state.selection || window.getSelection(), a2 = s2.anchorNode, o2 = this.state.tag.delimiters ? this.state.tag.delimiters.length : 0;
    return a2.splitText(s2.anchorOffset - o2), -1 == (i2 = a2.nodeValue.lastIndexOf(e2)) ? true : (n2 = a2.splitText(i2), t2 && a2.parentNode.replaceChild(t2, n2), true);
  }
}, "replaceTextWithNode"), prepareNewTagNode: /* @__PURE__ */ __name(function(t2, e2) {
  e2 = e2 || {};
  var i2 = this.settings, n2 = [], s2 = {}, a2 = Object.assign({}, t2, { value: t2.value + "" });
  if (t2 = Object.assign({}, a2), i2.transformTag.call(this, t2), t2.__isValid = this.hasMaxTags() || this.validateTag(t2), true !== t2.__isValid) {
    if (e2.skipInvalid) return;
    if (u(s2, this.getInvalidTagAttrs(t2, t2.__isValid), { __preInvalidData: a2 }), t2.__isValid == this.TEXTS.duplicate && this.flashTag(this.getTagElmByValue(t2.value)), !i2.createInvalidTags) return void n2.push(t2.value);
  }
  return "readonly" in t2 && (t2.readonly ? s2["aria-readonly"] = true : delete t2.readonly), { tagElm: this.createTagElem(t2, s2), tagData: t2, aggregatedInvalidInput: n2 };
}, "prepareNewTagNode"), postProcessNewTagNode: /* @__PURE__ */ __name(function(t2, e2) {
  var i2 = this, n2 = this.settings, s2 = e2.__isValid;
  s2 && true === s2 ? this.value.push(e2) : (this.trigger("invalid", { data: e2, index: this.value.length, tag: t2, message: s2 }), n2.keepInvalidTags || setTimeout(function() {
    return i2.removeTags(t2, true);
  }, 1e3)), this.dropdown.position();
}, "postProcessNewTagNode"), selectTag: /* @__PURE__ */ __name(function(t2, e2) {
  var i2 = this;
  if (!this.settings.enforceWhitelist || this.isTagWhitelisted(e2.value)) {
    this.state.actions.selectOption && setTimeout(function() {
      return i2.setRangeAtStartEnd(false, i2.DOM.input);
    });
    var n2 = this.getLastTag();
    return n2 ? this.replaceTag(n2, e2) : this.appendTag(t2), this.value[0] = e2, this.update(), this.trigger("add", { tag: t2, data: e2 }), [t2];
  }
}, "selectTag"), addEmptyTag: /* @__PURE__ */ __name(function(t2) {
  var e2 = u({ value: "" }, t2 || {}), i2 = this.createTagElem(e2);
  y(i2, e2), this.appendTag(i2), this.editTag(i2, { skipValidation: true }), this.toggleFocusClass(true);
}, "addEmptyTag"), addTags: /* @__PURE__ */ __name(function(t2, e2, i2) {
  var n2 = this, s2 = [], a2 = this.settings, o2 = [], r2 = document.createDocumentFragment(), l2 = [];
  if (!t2 || 0 == t2.length) return s2;
  switch (t2 = this.normalizeTags(t2), a2.mode) {
    case "mix":
      return this.addMixTags(t2);
    case "select":
      e2 = false, this.removeAllTags();
  }
  return this.DOM.input.removeAttribute("style"), t2.forEach(function(t3) {
    var e3 = n2.prepareNewTagNode(t3, { skipInvalid: i2 || a2.skipInvalid });
    if (e3) {
      var d2 = e3.tagElm;
      if (t3 = e3.tagData, o2 = e3.aggregatedInvalidInput, s2.push(d2), "select" == a2.mode) return n2.selectTag(d2, t3);
      r2.appendChild(d2), n2.postProcessNewTagNode(d2, t3), l2.push({ tagElm: d2, tagData: t3 });
    }
  }), this.appendTag(r2), l2.forEach(function(t3) {
    var e3 = t3.tagElm, i3 = t3.tagData;
    return n2.trigger("add", { tag: e3, index: n2.getTagIdx(i3), data: i3 });
  }), this.update(), t2.length && e2 && (this.input.set.call(this, a2.createInvalidTags ? "" : o2.join(a2._delimiters)), this.setRangeAtStartEnd(false, this.DOM.input)), this.dropdown.refilter(), s2;
}, "addTags"), addMixTags: /* @__PURE__ */ __name(function(t2) {
  var e2 = this;
  if ((t2 = this.normalizeTags(t2))[0].prefix || this.state.tag) return this.prefixedTextToTag(t2[0]);
  var i2 = document.createDocumentFragment();
  return t2.forEach(function(t3) {
    var n2 = e2.prepareNewTagNode(t3);
    i2.appendChild(n2.tagElm), e2.insertAfterTag(n2.tagElm), e2.postProcessNewTagNode(n2.tagElm, n2.tagData);
  }), this.appendMixTags(i2), i2.children;
}, "addMixTags"), appendMixTags: /* @__PURE__ */ __name(function(t2) {
  var e2 = !!this.state.selection;
  e2 ? this.injectAtCaret(t2) : (this.DOM.input.focus(), (e2 = this.setStateSelection()).range.setStart(this.DOM.input, e2.range.endOffset), e2.range.setEnd(this.DOM.input, e2.range.endOffset), this.DOM.input.appendChild(t2), this.updateValueByDOMTags(), this.update());
}, "appendMixTags"), prefixedTextToTag: /* @__PURE__ */ __name(function(t2) {
  var e2, i2, n2, s2 = this, a2 = this.settings, o2 = null === (e2 = this.state.tag) || void 0 === e2 ? void 0 : e2.delimiters;
  if (t2.prefix = t2.prefix || this.state.tag ? this.state.tag.prefix : (a2.pattern.source || a2.pattern)[0], n2 = this.prepareNewTagNode(t2), i2 = n2.tagElm, this.replaceTextWithNode(i2) || this.DOM.input.appendChild(i2), setTimeout(function() {
    return i2.classList.add(s2.settings.classNames.tagNoAnimation);
  }, 300), this.update(), !o2) {
    var r2 = this.insertAfterTag(i2) || i2;
    setTimeout(T, 0, r2);
  }
  return this.state.tag = null, this.postProcessNewTagNode(i2, n2.tagData), i2;
}, "prefixedTextToTag"), appendTag: /* @__PURE__ */ __name(function(t2) {
  var e2 = this.DOM, i2 = e2.input;
  e2.scope.insertBefore(t2, i2);
}, "appendTag"), createTagElem: /* @__PURE__ */ __name(function(t2, e2) {
  t2.__tagId = f();
  var i2, n2 = u({}, t2, G({ value: d(t2.value + "") }, e2));
  return function(t3) {
    for (var e3, i3 = document.createNodeIterator(t3, NodeFilter.SHOW_TEXT, null, false); e3 = i3.nextNode(); ) e3.textContent.trim() || e3.parentNode.removeChild(e3);
  }(i2 = this.parseTemplate("tag", [n2, this])), y(i2, t2), i2;
}, "createTagElem"), reCheckInvalidTags: /* @__PURE__ */ __name(function() {
  var t2 = this, e2 = this.settings;
  this.getTagElms(e2.classNames.tagNotAllowed).forEach(function(i2, n2) {
    var s2 = y(i2), a2 = t2.hasMaxTags(), o2 = t2.validateTag(s2), r2 = true === o2 && !a2;
    if ("select" == e2.mode && t2.toggleScopeValidation(o2), r2) return s2 = s2.__preInvalidData ? s2.__preInvalidData : { value: s2.value }, t2.replaceTag(i2, s2);
    i2.title = a2 || o2;
  });
}, "reCheckInvalidTags"), removeTags: /* @__PURE__ */ __name(function(t2, e2, i2) {
  var n2, s2 = this, a2 = this.settings;
  if (t2 = t2 && J(t2, HTMLElement) ? [t2] : J(t2, Array) ? t2 : t2 ? [t2] : [this.getLastTag()].filter(function(t3) {
    return t3;
  }), n2 = t2.reduce(function(t3, e3) {
    e3 && "string" == typeof e3 && (e3 = s2.getTagElmByValue(e3));
    var i3 = y(e3);
    return e3 && i3 && !i3.readonly && t3.push({ node: e3, idx: s2.getTagIdx(i3), data: y(e3, { __removed: true }) }), t3;
  }, []), i2 = "number" == typeof i2 ? i2 : this.CSSVars.tagHideTransition, "select" == a2.mode && (i2 = 0, this.input.set.call(this)), 1 == n2.length && "select" != a2.mode && n2[0].node.classList.contains(a2.classNames.tagNotAllowed) && (e2 = true), n2.length) return a2.hooks.beforeRemoveTag(n2, { tagify: this }).then(function() {
    var t3 = /* @__PURE__ */ __name(function(t4) {
      t4.node.parentNode && (t4.node.parentNode.removeChild(t4.node), e2 ? a2.keepInvalidTags && this.trigger("remove", { tag: t4.node, index: t4.idx }) : (this.trigger("remove", { tag: t4.node, index: t4.idx, data: t4.data }), this.dropdown.refilter(), this.dropdown.position(), this.DOM.input.normalize(), a2.keepInvalidTags && this.reCheckInvalidTags()));
    }, "t");
    i2 && i2 > 10 && 1 == n2.length ? function(e3) {
      e3.node.style.width = parseFloat(window.getComputedStyle(e3.node).width) + "px", document.body.clientTop, e3.node.classList.add(a2.classNames.tagHide), setTimeout(t3.bind(this), i2, e3);
    }.call(s2, n2[0]) : n2.forEach(t3.bind(s2)), e2 || (s2.removeTagsFromValue(n2.map(function(t4) {
      return t4.node;
    })), s2.update(), "select" == a2.mode && a2.userInput && s2.setContentEditable(true));
  }).catch(function(t3) {
  });
}, "removeTags"), removeTagsFromDOM: /* @__PURE__ */ __name(function() {
  this.getTagElms().forEach(function(t2) {
    return t2.remove();
  });
}, "removeTagsFromDOM"), removeTagsFromValue: /* @__PURE__ */ __name(function(t2) {
  var e2 = this;
  (t2 = Array.isArray(t2) ? t2 : [t2]).forEach(function(t3) {
    var i2 = y(t3), n2 = e2.getTagIdx(i2);
    n2 > -1 && e2.value.splice(n2, 1);
  });
}, "removeTagsFromValue"), removeAllTags: /* @__PURE__ */ __name(function(t2) {
  var e2 = this;
  t2 = t2 || {}, this.value = [], "mix" == this.settings.mode ? this.DOM.input.innerHTML = "" : this.removeTagsFromDOM(), this.dropdown.refilter(), this.dropdown.position(), this.state.dropdown.visible && setTimeout(function() {
    e2.DOM.input.focus();
  }), "select" == this.settings.mode && (this.input.set.call(this), this.settings.userInput && this.setContentEditable(true)), this.update(t2);
}, "removeAllTags"), postUpdate: /* @__PURE__ */ __name(function() {
  this.state.blockChangeEvent = false;
  var t2, e2, i2 = this.settings, n2 = i2.classNames, s2 = "mix" == i2.mode ? i2.mixMode.integrated ? this.DOM.input.textContent : this.DOM.originalInput.value.trim() : this.value.length + this.input.raw.call(this).length;
  (this.toggleClass(n2.hasMaxTags, this.value.length >= i2.maxTags), this.toggleClass(n2.hasNoTags, !this.value.length), this.toggleClass(n2.empty, !s2), "select" == i2.mode) && this.toggleScopeValidation(null === (e2 = this.value) || void 0 === e2 || null === (t2 = e2[0]) || void 0 === t2 ? void 0 : t2.__isValid);
}, "postUpdate"), setOriginalInputValue: /* @__PURE__ */ __name(function(t2) {
  var e2 = this.DOM.originalInput;
  this.settings.mixMode.integrated || (e2.value = t2, e2.tagifyValue = e2.value, this.setPersistedData(t2, "value"));
}, "setOriginalInputValue"), update: /* @__PURE__ */ __name(function(t2) {
  clearTimeout(this.debouncedUpdateTimeout), this.debouncedUpdateTimeout = setTimeout(function() {
    var e2 = this.getInputValue();
    this.setOriginalInputValue(e2), this.settings.onChangeAfterBlur && (t2 || {}).withoutChangeEvent || this.state.blockChangeEvent || this.triggerChangeEvent();
    this.postUpdate();
  }.bind(this), 100), this.events.bindOriginaInputListener.call(this, 100);
}, "update"), getInputValue: /* @__PURE__ */ __name(function() {
  var t2 = this.getCleanValue();
  return "mix" == this.settings.mode ? this.getMixedTagsAsString(t2) : t2.length ? this.settings.originalInputValueFormat ? this.settings.originalInputValueFormat(t2) : JSON.stringify(t2) : "";
}, "getInputValue"), getCleanValue: /* @__PURE__ */ __name(function(t2) {
  return a(t2 || this.value, this.dataProps);
}, "getCleanValue"), getMixedTagsAsString: /* @__PURE__ */ __name(function() {
  var t2 = "", e2 = this, i2 = this.settings, n2 = i2.originalInputValueFormat || JSON.stringify, s2 = i2.mixTagsInterpolator;
  return (/* @__PURE__ */ __name(function i3(a2) {
    a2.childNodes.forEach(function(a3) {
      if (1 == a3.nodeType) {
        var r2 = y(a3);
        if ("BR" == a3.tagName && (t2 += "\r\n"), r2 && m.call(e2, a3)) {
          if (r2.__removed) return;
          t2 += s2[0] + n2(o(r2, e2.dataProps)) + s2[1];
        } else a3.getAttribute("style") || ["B", "I", "U"].includes(a3.tagName) ? t2 += a3.textContent : "DIV" != a3.tagName && "P" != a3.tagName || (t2 += "\r\n", i3(a3));
      } else t2 += a3.textContent;
    });
  }, "i"))(this.DOM.input), t2;
}, "getMixedTagsAsString") }, Q.prototype.removeTag = Q.prototype.removeTags;

// src/module/utils/sheets.ts
function createTagify(input, options = {}) {
  const tagify = new Q(input, {
    enforceWhitelist: options.enforceWhitelist ?? true,
    editTags: false,
    skipInvalid: true,
    dropdown: {
      maxItems: options.maxItems,
      fuzzySearch: true,
      enabled: 0,
      searchKeys: ["id", "value"]
    }
  });
  tagify.whitelist = options.whitelist ?? [];
  tagify.addTags(options.tags ?? []);
  return tagify;
}
__name(createTagify, "createTagify");
function createTagifyOnInput(element, values, maxItems, tags, onChangeCallback, options) {
  options = options ?? {};
  const whitelist = values.map((value) => ({ value: game.i18n.localize(value.label), id: value.id }));
  const tagify = createTagify(element, { whitelist, maxItems, tags, ...options });
  if (onChangeCallback) $(element).on("change", onChangeCallback);
  return tagify;
}
__name(createTagifyOnInput, "createTagifyOnInput");
var tagsToIds = /* @__PURE__ */ __name((tags) => tags.map((tag) => tag.id), "tagsToIds");
var tagifyFlagsToIds = /* @__PURE__ */ __name((effect, flag) => {
  const value = effect.getFlag(SYSTEM_NAME, flag);
  if (!value) return [];
  const tags = JSON.parse(value);
  return tagsToIds(tags);
}, "tagifyFlagsToIds");
function parseDropData(event) {
  try {
    return JSON.parse(event.dataTransfer.getData("text/plain"));
  } catch (error) {
    return console.log("Shadowrun 6e | Dropping a document onto an item sheet caused this error", error);
  }
}
__name(parseDropData, "parseDropData");

// src/module/effect/SR6ActiveEffect.ts
var SR6ActiveEffect = class _SR6ActiveEffect extends ActiveEffect {
  static {
    __name(this, "SR6ActiveEffect");
  }
  /**
   * Can be used to determine if the origin of the effect is a document owned by another document.
   *
   * A use case would be to check if the effect is applied by an actor owned item.
   *
   * The current approach is a bit simple, due to the limited effect use. Should there be a time of effects applied to
   * items, this would need change.
   */
  get isOriginOwned() {
    if (!this.origin) return false;
    const path = this.origin.split(".");
    if (path[0] === "Scene" && path.length === 6) return true;
    if (path[0] === "Actor" && path.length === 4) return true;
    return false;
  }
  get source() {
    return this.origin ? fromUuidSync(this.origin) : null;
  }
  get isActorOwned() {
    return this.parent instanceof SR6Actor;
  }
  get isItemOwned() {
    return this.parent instanceof SR6Item;
  }
  /**
   * Always returns the parent actor of the effect, even if the effect is applied to an item.
   */
  get actor() {
    if (this.parent instanceof SR6Actor) return this.parent;
    if (this.parent instanceof SR6Item) return this.parent?.parent;
    return null;
  }
  /**
   * Use to display this effect on sheet, including a possible parent item structure.
   */
  get sheetName() {
    if (this.parent instanceof SR6Actor) return this.name;
    return `${this.parent?.name} \xBB ${this.name}`;
  }
  /**
   * Render the sheet of the active effect source
   */
  renderSourceSheet() {
    return this.source?.sheet?.render(true);
  }
  async toggleDisabled() {
    return this.update({ disabled: !this.disabled });
  }
  async disable(disabled) {
    return this.update({ disabled });
  }
  //@ts-expect-error // TODO: foundry-vtt-types
  _applyCustom(actor, change, current, delta, changes) {
    return this._applyModify(actor, change, current, delta, changes);
  }
  /**
   * Apply a modification to a ModifiableValue.
   * Both direct key matches to the whole value and indirect matches to a value property are supported.
   *
   * @protected
   */
  _applyModify(actor, change, current, delta, changes) {
    const value = foundry.utils.getProperty(actor, change.key);
    if (this._isKeyModifiableValue(actor, change.key)) {
      value.mod.push({ name: this.name, value: Number(change.value) });
      return null;
    }
    const nodes = change.key.split(".");
    nodes.pop();
    const indirectKey = nodes.join(".");
    if (this._isKeyModifiableValue(actor, indirectKey)) {
      const value2 = foundry.utils.getProperty(actor, indirectKey);
      value2.mod.push({ name: this.name, value: Number(change.value) });
      return null;
    }
    if (value === void 0) return null;
    return super._applyAdd(actor, change, current, delta, changes);
  }
  /**
   * Overriding can be tricky if the overwritten value is a ModifiableValue with derived values.
   *
   * To keep the ActiveEffect workflow simple and still allow to override values that aren't a ModifiableValue,
   * check for such values and give the ActorDataPreparation flow some hints.
   *
   * To complicate things, there are some use cases when overwriting an actual property of a ValueField
   * is needed. The SR5 uneducated quality needs to override the canDefault field of a skill.
   *
   * @protected
   */
  //@ts-expect-error // TODO: foundry-vtt-types
  _applyOverride(actor, change, current, delta, changes) {
    if (this._isKeyModifiableValue(actor, change.key)) {
      const value = foundry.utils.getProperty(actor, change.key);
      value.override = { name: this.name, value: Number(change.value) };
      value.value = change.value;
      return null;
    }
    return super._applyOverride(actor, change, current, delta, changes);
  }
  _isKeyModifiableValue(actor, key) {
    const possibleValue = foundry.utils.getProperty(actor, key);
    const possibleValueType = foundry.utils.getType(possibleValue);
    return possibleValue && possibleValueType === "Object" && Helpers.objectHasKeys(possibleValue, this.minValueKeys);
  }
  /**
   * Match against these keys, as the exact ModifiableValue layout might be different from time to time.
   */
  get minValueKeys() {
    return ["value", "mod"];
  }
  /**
   * Apply to target configured for this effect.
   *
   * @returns Either the configured value or 'actor' as a default.
   */
  get applyTo() {
    return this.getFlag(SYSTEM_NAME, "applyTo") || "actor";
  }
  /**
   * Some effects should only be applied depending on their parent items wireless status.
   *
   * When this flag is set, the parent item wireless status is taken into account.
   */
  get onlyForWireless() {
    return this.getFlag(SYSTEM_NAME, "onlyForWireless") || false;
  }
  /**
   * Some effects should only be applied depending on their parent items enabled status.
   *
   * When this flag is set, the parent item enabled status is taken into account.
   */
  get onlyForEquipped() {
    return this.getFlag(SYSTEM_NAME, "onlyForEquipped") || false;
  }
  /**
   * Some modifier effects should only be applied if they're applied for their parent items test.
   *
   * When this flag is set, this effect shouldn't apply always.
   */
  get onlyForItemTest() {
    return this.getFlag(SYSTEM_NAME, "onlyForItemTest") || false;
  }
  /**
   * Determine if this effect has been created using the test effect application flow
   * typically reserved for targeted_actor effects.
   *
   * @returns true, when the effect has been applied by a test.
   */
  get appliedByTest() {
    return this.getFlag(SYSTEM_NAME, "appliedByTest") || false;
  }
  get selectionTests() {
    return tagifyFlagsToIds(this, "selection_tests");
  }
  get selectionCategories() {
    return tagifyFlagsToIds(this, "selection_categories");
  }
  get selectionSkills() {
    return tagifyFlagsToIds(this, "selection_skills");
  }
  get selectionAttributes() {
    return tagifyFlagsToIds(this, "selection_attributes");
  }
  get selectionLimits() {
    return tagifyFlagsToIds(this, "selection_limits");
  }
  get isSuppressed() {
    if (!(this.parent instanceof SR6Item)) return false;
    if (this.onlyForEquipped && !this.parent.isEquipped()) return true;
    if (this.onlyForWireless && !this.parent.isWireless()) return true;
    return false;
  }
  /**
   * Determine if this effect is meant to be applied to the actor it's existing on.
   *
   * Some effects are meant to be applied to other actors, and those shouldn't apply or show
   * on the actor that will cause them.
   *
   * Especially targeted_actor effects are meant to be applied to another actor acted upon but not the one acting.
   *
   * @return true, when the effect is meant to be applied to the actor it's existing on.
   */
  get appliesToLocalActor() {
    const actor = this.actor;
    if (!actor) return false;
    if (this.applyTo === "targeted_actor") {
      return this.appliedByTest;
    }
    return true;
  }
  /**
   * Inject features into default FoundryVTT ActiveEffect implementation.
   *
   * - dynamic source properties as change values
   * - apply to non-Actor objects
   *
   * @param object
   * @param change
   */
  apply(object, change) {
    const source3 = CONFIG.ActiveEffect.legacyTransferral ? this.source : this.parent;
    _SR6ActiveEffect.resolveDynamicChangeValue(source3, change);
    if (object instanceof SR6Actor) {
      return super.apply(object, change);
    }
    this._applyToObject(object, change);
  }
  /**
   * Resolve a dynamic change value to the actual numerical value.
   *
   * A dynamic change value follows the same rules as a Foundry roll formula (including dice pools).
   *
   * So a change could have the key of 'system.attributes.body' with the mode Modify and a dynamic value of
   * '@system.technology.rating * 3'. The dynamic property path would be taken from either the source or parent
   * document of the effect before the resolved value would be applied onto the target document / object.
   *
   * @param source Any object style value, either a Foundry document or a plain object
   * @param change A singular EffectChangeData object
   */
  static resolveDynamicChangeValue(source3, change) {
    if (foundry.utils.getType(change.value) !== "string") return;
    if (change.value.length === 0) return;
    const expression = Roll.replaceFormulaData(change.value, source3);
    const value = Roll.validate(expression) ? Roll.safeEval(expression) : change.value;
    if (value === void 0) change.value = "0";
    else change.value = value.toString();
  }
  /**
   * Handle application for none-Document objects
   * @param object
   * @param change
   * @returns
   */
  _applyToObject(object, change) {
    const current = foundry.utils.getProperty(object, change.key) ?? null;
    const target = foundry.utils.getProperty(object, change.key) ?? null;
    let targetType = foundry.utils.getType(target);
    let delta;
    try {
      if (targetType === "Array") {
        const innerType = target.length ? foundry.utils.getType(target[0]) : "string";
        delta = this._castArray(change.value, innerType);
      } else delta = this._castDelta(change.value, targetType);
    } catch (err) {
      console.warn(`Test [${object.constructor.name}] | Unable to parse active effect change for ${change.key}: "${change.value}"`);
      return;
    }
    const modes = CONST.ACTIVE_EFFECT_MODES;
    const changes = {};
    switch (change.mode) {
      case modes.ADD:
        this._applyAdd(object, change, current, delta, changes);
        break;
      case modes.MULTIPLY:
        this._applyMultiply(object, change, current, delta, changes);
        break;
      case modes.OVERRIDE:
        this._applyOverride(object, change, current, delta, changes);
        break;
      case modes.UPGRADE:
      case modes.DOWNGRADE:
        this._applyUpgrade(object, change, current, delta, changes);
        break;
      default:
        this._applyCustom(object, change, current, delta, changes);
        break;
    }
    foundry.utils.mergeObject(object, changes);
    return changes;
  }
  /**
   * Override Foundry effect data migration to avoid data => system migration.
   *
   * Since the system provides autocomplete-inline-properties as a relationship and
   * has it configured to provide system as the default key, the Foundry migration
   * shouldn't be necessary. The migration hinders effects with apply-to test.
   *
   * All migrations here are taken from FoundryVtt common.js BaseActiveEffect#migrateData
   * for v11.315
   */
  // @ts-expect-error foundry-vtt-types v10
  static migrateData(data) {
    this._addDataFieldMigration(data, "label", "name", (d2) => d2.label || "Unnamed Effect");
    return data;
  }
};

// src/module/effects.ts
async function onManageActiveEffect(event, owner) {
  event.preventDefault();
  const icon = event.currentTarget;
  const item = event.currentTarget.closest(".list-item-effect");
  const effect = item.dataset.itemId ? owner.effects.get(item.dataset.itemId) : null;
  switch (icon.dataset.action) {
    case "create":
      return owner.createEmbeddedDocuments("ActiveEffect", [{
        label: game.i18n.localize("SR6.ActiveEffect.New"),
        // icon: "icons/svg/aura.svg",
        origin: owner.uuid
      }]);
    case "edit":
      return effect.sheet.render(true);
    case "delete":
      const userConsented = await Helpers.confirmDeletion();
      if (!userConsented) return;
      return effect.delete();
    case "toggle":
      return effect.toggleDisabled();
    case "open-origin":
      return effect.renderSourceSheet();
    default:
      return;
  }
}
__name(onManageActiveEffect, "onManageActiveEffect");
async function onManageItemActiveEffect(event) {
  event.preventDefault();
  const icon = event.currentTarget;
  const listItem = event.currentTarget.closest(".list-item-effect");
  const uuid = listItem.dataset.itemId;
  if (effectUuidIsNestedItem(uuid)) return ui.notifications.error("Effects on nested items can't be managed. Move the item to the sidebar to manage.");
  const effect = await fromUuid(uuid);
  if (!effect) return;
  switch (icon.dataset.action) {
    case "edit":
      return effect.sheet.render(true);
    case "toggle":
      return effect.toggleDisabled();
    case "open-origin":
      return effect.parent?.sheet?.render(true);
    default:
      return;
  }
}
__name(onManageItemActiveEffect, "onManageItemActiveEffect");
function effectUuidIsNestedItem(uuid) {
  return (uuid.match(/Item./g) || []).length >= 2;
}
__name(effectUuidIsNestedItem, "effectUuidIsNestedItem");
function prepareSortedEffects(effects, byKey = "name") {
  return effects.sort((a2, b2) => a2[byKey].localeCompare(b2[byKey]));
}
__name(prepareSortedEffects, "prepareSortedEffects");
function prepareSortedItemEffects(document2, options = {}) {
  const enabledEffects = [];
  for (const effect of allApplicableItemsEffects(document2, options)) {
    enabledEffects.push(effect);
  }
  return prepareSortedEffects(enabledEffects, "sheetName");
}
__name(prepareSortedItemEffects, "prepareSortedItemEffects");
function* allApplicableDocumentEffects(document2, options = {}) {
  const applyTo = options.applyTo ?? [];
  for (const effect of document2.effects) {
    if (applyTo.length > 0 && !applyTo.includes(effect.applyTo)) continue;
    yield effect;
  }
}
__name(allApplicableDocumentEffects, "allApplicableDocumentEffects");
function* allApplicableItemsEffects(document2, options = {}) {
  const applyTo = options.applyTo ?? [];
  const nestedItems = options.nestedItems ?? true;
  for (const item of document2.items) {
    for (const effect of item.effects) {
      if (applyTo.length > 0 && !applyTo.includes(effect.applyTo)) continue;
      yield effect;
    }
    if (!nestedItems) continue;
    if (document2 instanceof SR6Item) continue;
    for (const nestedItem of item.items) {
      for (const effect of nestedItem.effects) {
        if (applyTo.length > 0 && !applyTo.includes(effect.applyTo)) continue;
        yield effect;
      }
    }
  }
}
__name(allApplicableItemsEffects, "allApplicableItemsEffects");

// src/module/effect/flows/SuccessTestEffectsFlow.ts
var SuccessTestEffectsFlow = class _SuccessTestEffectsFlow {
  static {
    __name(this, "SuccessTestEffectsFlow");
  }
  /**
   * Create a test flow for a given test.
   *
   * @param test This flow will be applied to this test given. It's up to the test to call the apply method.
   */
  constructor(test) {
    this.test = test;
  }
  /**
   * Duplicate Foundry apply logic, but with custom handling for SR5ActiveEffects within a SuccessTest context.
   *
   * NOTE: Since effects are applied as none unique modifiers, applying them multiple times is possible.
   *       Changes can't be applied as unique modifiers as they're names are not unique.
   */
  applyAllEffects() {
    if (this.test.extendedRoll) return;
    const changes = [];
    for (const effect of this.allApplicableEffects()) {
      if (!effect.active) continue;
      if (this._skipEffectForTestLimitations(effect)) continue;
      changes.push(...effect.changes.map((change) => {
        const c2 = foundry.utils.deepClone(change);
        c2.key = c2.key.replace("system.", "data.");
        c2.effect = effect;
        c2.priority = c2.priority ?? c2.mode * 10;
        return c2;
      }));
    }
    changes.sort((a2, b2) => a2.priority - b2.priority);
    for (const change of changes) {
      if (!change.key) continue;
      change.effect.apply(this.test, change);
    }
  }
  /**
   * Should this effect be skipped for this test?
   *
   * Check all limitations of the effect against the test.
   *
   * There is a few special cases to consider:
   * - effects limit a category (skill, attribute), but the test doesn't use that category.
   *   in that case the effect shouldn't apply.
   * - effects that don't limit the test type, shouldn't apply to opposed tests
   *   however, if a test limitation is used, it should still apply.
   *
   * @param effect An apply-to 'test_all' effect with possible test limitations.
   * @returns
   */
  _skipEffectForTestLimitations(effect) {
    const tests = effect.selectionTests;
    if (tests.length === 0 && this.test.opposing) return true;
    if (tests.length > 0 && !tests.includes(this.test.type)) return true;
    const categories = effect.selectionCategories;
    const testCategories = this.test.data.categories;
    if (categories.length > 0 && !categories.find((category3) => testCategories.includes(category3))) return true;
    const skills = effect.selectionSkills;
    const skillId = this.test.data.action.skill;
    const skillName = this.test.actor?.getSkill(skillId)?.name || skillId;
    if (skills.length > 0 && !skills.includes(skillName)) return true;
    const attributes = effect.selectionAttributes;
    const attribute = this.test.data.action.attribute;
    const attribute2 = this.test.data.action.attribute2;
    if (attributes.length > 0 && attribute && !attributes.includes(attribute)) return true;
    if (attributes.length > 0 && attribute2 && !attributes.includes(attribute2)) return true;
    if (attributes.length > 0 && !attribute && !attribute2) return true;
    const limits = effect.selectionLimits;
    const limit = this.test.data.action.limit.attribute;
    if (limits.length > 0 && !limits.includes(limit)) return true;
    return false;
  }
  /**
   * Create Effects of applyTo 'test_all' after a success test has finished.
   *
   * This only applies for SuccessTest that aren't opposed.
   * Opposed tests have their own flow of creating effects on the target actor.
   *
   * Before creating effects onto the target actor, resolve the dynamic values from the source context
   * of the opposed test causing the effects. When created on the target actor, the values can't be resolved
   * as there is no good reference to the causing test anymore.
   *
   * Therefore effects on the original item can have dynamic values, while the created effects are copies with
   *
   * @param actor The actor to create the effects on.
   */
  async createTargetActorEffects(actor) {
    const effectsData = this._collectTargetActorEffectsData();
    if (!effectsData || effectsData.length === 0) return;
    for (const effectData of effectsData) {
      effectData["flags.shadowrun6-elysium.appliedByTest"] = true;
    }
    if (!game.user?.isGM) {
      await this._sendCreateTargetedEffectsSocketMessage(actor, effectsData);
    } else {
      await _SuccessTestEffectsFlow._createTargetedEffectsAsGM(actor, effectsData);
    }
  }
  _collectTargetActorEffectsData() {
    const actor = this.test.actor;
    if (actor === void 0 || this.test.item === void 0) return;
    const effectsData = [];
    for (const effect of allApplicableDocumentEffects(this.test.item, { applyTo: ["targeted_actor"] })) {
      const effectData = effect.toObject();
      effectData.changes = effectData.changes.map((change) => {
        SR6ActiveEffect.resolveDynamicChangeValue(this.test, change);
        return change;
      });
      effectsData.push(effectData);
    }
    for (const effect of allApplicableItemsEffects(this.test.item, { applyTo: ["targeted_actor"], nestedItems: false })) {
      const effectData = effect.toObject();
      effectData.changes = effectData.changes.map((change) => {
        SR6ActiveEffect.resolveDynamicChangeValue(this.test, change);
        return change;
      });
      effectsData.push(effectData);
    }
    console.debug(`SR6: Elysium | To be created effects on target actor ${actor.name}`, effectsData);
    return effectsData;
  }
  /**
   * Create a set of effects on the targeted actor, user must have permissions.
   * @param actor The actor to create the effects on.
   * @param effectsData The effects data to be applied;
   */
  static async _createTargetedEffectsAsGM(actor, effectsData) {
    const alias = game.user?.name;
    const linkedTokens = actor.getActiveTokens(true) || [];
    const token = linkedTokens.length === 1 ? linkedTokens[0].id : void 0;
    const effects = await actor.createEmbeddedDocuments("ActiveEffect", effectsData);
    const templateData = {
      effects,
      speaker: {
        actor,
        alias,
        token
      }
    };
    const content = await renderTemplate("systems/shadowrun6-elysium/dist/templates/chat/test-effects-message.hbs", templateData);
    const messageData = {
      content
    };
    await ChatMessage.create(messageData);
    return effects;
  }
  /**
   * Send out a socket message to a connected GM to create actor effects.
   * @param actor The actor to create the effects on.
   * @param effectsData The effects data to be applied;
   */
  async _sendCreateTargetedEffectsSocketMessage(actor, effectsData) {
    await SocketMessage.emitForGM(FLAGS.CreateTargetedEffects, { actorUuid: actor.uuid, effectsData });
  }
  /**
   * Handle a sent socket message to create effects on a target actor.
   * @param {string} message.actorUuid Must contain the uuid of the actor to create the effects on.
   * @param {ActiveEffectData[]} message.effectsData Must contain a list of effects data to be applied.
   * @returns
   */
  static async _handleCreateTargetedEffectsSocketMessage(message) {
    if (!message.data.hasOwnProperty("actorUuid") && !message.data.hasOwnProperty("effectsData")) {
      console.error(`Shadowrun 6e | ${this.name} Socket Message is missing necessary properties`, message);
      return;
    }
    if (!message.data.effectsData.length) return;
    const actor = await fromUuid(message.data.actorUuid);
    return await _SuccessTestEffectsFlow._createTargetedEffectsAsGM(actor, message.data.effectsData);
  }
  /**
   * Reduce effects on test actor and item to those applicable to this test.
   *
   * Since Foundry Core uses a generator, keep this pattern for consistency.
   *
   */
  *allApplicableEffects() {
    if (!this.test.actor) return;
    for (const effect of allApplicableDocumentEffects(this.test.actor, { applyTo: ["test_all"] })) {
      yield effect;
    }
    for (const effect of allApplicableItemsEffects(this.test.actor, { applyTo: ["test_all"] })) {
      yield effect;
    }
    if (!this.test.item) return;
    for (const effect of allApplicableDocumentEffects(this.test.item, { applyTo: ["test_item"] })) {
      yield effect;
    }
    for (const effect of allApplicableItemsEffects(this.test.item, { applyTo: ["test_item"] })) {
      yield effect;
    }
  }
  /**
   * Reduce all item effects to those applicable to target actors as part of a success vs opposed test flow.
   */
  *allApplicableEffectsToTargetActor() {
    if (!this.test.item) return;
    for (const effect of this.test.item.effects) {
      if (effect.applyTo === "targeted_actor") yield effect;
    }
  }
};

// src/module/actor/flows/GmOnlyMessageContentFlow.ts
var GmOnlyMessageContentFlow = {
  /**
   * Add chat listener for GM only content.
   */
  async chatMessageListeners(message, html, data) {
    await GmOnlyMessageContentFlow.showGmOnlyContent(message, html, data);
  },
  /**
   * Should GMOnly content be applied or not?
   *
   * With no actor given, only general user and settings will influence the result.
   *
   * @param actor A optional actor reference
   * @returns true, when GMOnlyContent is to be used for chat message.
   */
  applyGmOnlyContent(actor) {
    const enableFeature = game.settings.get(SYSTEM_NAME, FLAGS.HideGMOnlyChatContent);
    return enableFeature && !!game.user && game.user.isGM && !!actor;
  },
  /**
   * Callback handler for the Foundry 'renderChatMessage' hook.
   *
   * Looks for chat messages containing success test data and show or hide
   * any GM only content within their html depending on the user.
   *
   * @param message The message to show gm-only-content for
   * @param html The DOM elements of the chat message contents
   * @param data The message data used to render the chat message
   */
  async showGmOnlyContent(message, html, data) {
    const testData = TestCreator.getTestDataFromMessage(message.id);
    if (!testData?.data) return;
    const actorUuid = testData.data.sourceActorUuid;
    const actor = await fromUuid(actorUuid);
    if (!actor || !game.user) {
      html.find(".gm-only-content").removeClass("gm-only-content");
      ui.chat.scrollBottom();
    } else if (game.user.isGM || game.user.isTrusted || actor.isOwner) {
      html.find(".gm-only-content").removeClass("gm-only-content");
      ui.chat.scrollBottom();
    }
  }
};

// src/module/tests/SuccessTest.ts
var SuccessTest = class _SuccessTest {
  static {
    __name(this, "SuccessTest");
  }
  constructor(data, documents, options) {
    this.actor = documents?.actor;
    this.item = documents?.item;
    this.rolls = documents?.rolls || [];
    this.targets = [];
    options = options || {};
    this.data = this._prepareData(data, options);
    this.effects = new SuccessTestEffectsFlow(this);
    this.calculateBaseValues();
    console.debug(`Shadowrun 6e | Created ${this.constructor.name} Test`, this);
  }
  /**
   * Make sure a test has a complete data structure, even if supplied data doesn't fully provide that.
   *
   * Any Test should be usable simply by instantiating it with empty TestData
   *
   * @param data
   * @param options
   */
  _prepareData(data, options) {
    data.type = data.type || this.type;
    data.targetActorsUuid = data.targetActorsUuid || Helpers.getUserTargets().map((token) => token.actor?.uuid).filter((uuid) => !!uuid);
    data.sourceActorUuid = data.sourceActorUuid || this.actor?.uuid;
    data.sourceItemUuid = data.sourceItemUuid || this.item?.uuid;
    data.title = data.title || this.constructor.label;
    options.rollMode = this._prepareRollMode(data, options);
    options.showDialog = options.showDialog !== void 0 ? options.showDialog : true;
    options.showMessage = options.showMessage !== void 0 ? options.showMessage : true;
    data.options = options;
    data.evaluated = data.evaluated ?? false;
    data.pushTheLimit = data.pushTheLimit !== void 0 ? data.pushTheLimit : false;
    data.secondChance = data.secondChance !== void 0 ? data.secondChance : false;
    data.pool = data.pool || DataDefaults.valueData({ label: "SR6.DicePool" });
    data.threshold = data.threshold || DataDefaults.valueData({ label: "SR6.Threshold" });
    data.limit = data.limit || DataDefaults.valueData({ label: "SR6.Limit" });
    data.values = data.values || {};
    data.values.hits = data.values.hits || DataDefaults.valueData({ label: "SR6.Hits" });
    data.values.extendedHits = data.values.extendedHits || DataDefaults.valueData({ label: "SR6.ExtendedHits" });
    data.values.netHits = data.values.netHits || DataDefaults.valueData({ label: "SR6.NetHits" });
    data.values.glitches = data.values.glitches || DataDefaults.valueData({ label: "SR6.Glitches" });
    data.manualHits = data.manualHits || DataDefaults.valueData({ label: "SR6.ManualHits" });
    data.manualGlitches = data.manualGlitches || DataDefaults.valueData({ label: "SR6.ManualGlitches" });
    data.opposed = data.opposed || void 0;
    data.modifiers = this._prepareModifiersData(data.modifiers);
    data.damage = data.damage || DataDefaults.damageData();
    data.extendedRoll = data.extendedRoll || false;
    console.debug("Shadowrun 6e | Prepared test data", data);
    return data;
  }
  /**
   * The tests roll mode can be given by specific option, action setting or global configuration.
   * @param options The test options for the whole test
   */
  _prepareRollMode(data, options) {
    if (options.rollMode !== void 0) return options.rollMode;
    if (data.action && data.action.roll_mode) return data.action.roll_mode;
    else return game.settings.get(CORE_NAME, CORE_FLAGS.RollMode);
  }
  /**
   * Prepare a default modifier object.
   *
   * This should be used for whenever a Test doesn't modifiers specified externally.
   */
  _prepareModifiersData(modifiers) {
    return modifiers || DataDefaults.valueData({ label: "SR6.Labels.Action.Modifiers" });
  }
  /**
   * Overwrite this method to alter the title of test dialogs and messages.
   */
  get title() {
    return `${game.i18n.localize(this.constructor.label)}`;
  }
  /**
   * Determine the type of success test for this implementation.
   *
   * By default this will be the class constructor name.
   * NOTE: This breaks for a build pipeline using minification. This is due to
   * , currently, the test registry using the runtime constructor name vs the compile time
   * class name.
   */
  get type() {
    return this.constructor.name;
  }
  /**
   * Get the label for this test type used for i18n.
   */
  static get label() {
    return `SR6.Tests.${this.name}`;
  }
  /**
   * Helper to determine if this test has been fully evaluated at least once.
   */
  get evaluated() {
    return this.data.evaluated;
  }
  /**
   * FoundryVTT serializer method to embed this test into a document (ChatMessage).
   *
   * Foundry expects Roll data to serialize into rolls.
   * The system expects Test data to serialize into data.
   * @returns
   */
  toJSON() {
    return {
      data: this.data,
      // Use Roll.toJSON() to inject 'class' property. Foundry relies on this to build it's classes.
      rolls: this.rolls.map((roll) => roll.toJSON())
    };
  }
  /**
   * Get the lowest side for a Shadowrun 5 die to count as a success
   */
  static get lowestSuccessSide() {
    return Math.min(...SR.die.success);
  }
  /**
   * Get the lowest side for a Shadowrun 5 die to count as a glitch.
   */
  static get lowestGlitchSide() {
    return Math.min(...SR.die.glitch);
  }
  /**
   * Get a possible globally defined default action set for this test class.
   */
  static _getDefaultTestAction() {
    return {};
  }
  /**
   * Get a document defined action set for this test class.
   *
   * Subclasses can use this to provide actor or item based action configurations that aren't
   * directly part of the action template.
   *
   * @param item The item holding the action configuration.
   * @param actor The actor used for value calculation.
   */
  static async _getDocumentTestAction(item, actor) {
    return {};
  }
  static async _prepareActionTestData(action, actor, data) {
    return TestCreator._prepareTestDataWithAction(action, actor, data);
  }
  /**
   * Create test data from an opposed message action.
   *
   * This method is meant to be overridden if this testing class supports
   * testing against an opposed message action.
   *
   * If this test class doesn't support this opposed message actions it will
   * return undefined.
   *
   * @param testData The original test that's opposed.
   * @param actor The actor for this opposing test.
   * @param previousMessageId The id this message action is sourced from.
   */
  static async _getOpposedActionTestData(testData, actor, previousMessageId) {
    console.error(`Shadowrun 6e | Testing Class ${this.name} doesn't support opposed message actions`);
    return;
  }
  /**
   * Determine if this test has any kind of modifier types active
   */
  get hasModifiers() {
    return this.data.modifiers.mod.length > 0;
  }
  /**
   * Create the default formula for this test based on it's pool
   *
   * FoundryVTT documentation:
   * shadowrun6-elysium: SR6#44
   *
   */
  get formula() {
    const pool = Helpers.calcTotal(this.data.pool, { min: 0 });
    return this.buildFormula(pool, this.hasPushTheLimit);
  }
  /**
   * Build a Foundry Roll formula string
   *
   * Dice:       https://foundryvtt.com/article/dice-advanced/
   * Modifiers:  https://foundryvtt.com/article/dice-modifiers/
   *
   * @param dice Amount of d6 to use.
   * @param explode Should the d6 be exploded.
   * @returns The complete formula string.
   */
  buildFormula(dice, explode) {
    const explodeFormula = explode ? "x6" : "";
    return `(${dice})d6cs>=${_SuccessTest.lowestSuccessSide}${explodeFormula}`;
  }
  /**
   * Give a representation of this success test in the common Shadowrun 5 description style.
   * The code given is meant to provide information about value sources. Should a user overwrite
   * these values during dialog review, keep those hidden.
   *
   * Automatics + Agility + 3 (3) [2 + Physical]
   */
  get code() {
    let pool = this.pool.mod.filter((mod) => mod.value !== 0).map((mod) => `${game.i18n.localize(mod.name)} ${mod.value}`);
    let threshold = this.threshold.override ? [game.i18n.localize(this.threshold.override.name)] : this.threshold.mod.map((mod) => game.i18n.localize(mod.name));
    let limit = this.limit.override ? [game.i18n.localize(this.limit.override.name)] : this.limit.mod.map((mod) => game.i18n.localize(mod.name));
    if (this.pool.base > 0 && !this.pool.override) pool.push(String(this.pool.base));
    if (this.threshold.base > 0 && !this.threshold.override) threshold.push(String(this.threshold.base));
    if (this.limit.base > 0 && !this.limit.override) limit.push(String(this.limit.base));
    let code = pool.join(" + ").trim() || `${this.pool.value}`;
    if (threshold.length > 0 && this.threshold.value > 0) code = `${code} (${threshold.join(" + ").trim()})`;
    if (limit.length > 0 && this.limit.value > 0) code = `${code} [${limit.join(" + ").trim()}]`;
    return code;
  }
  /**
   * Determine if this test can have a human-readable shadowrun test code representation.
   *
   * All parts of the test code can be dynamic, any will do.
   */
  get hasCode() {
    return this.pool.mod.length > 0 || this.threshold.mod.length > 0 || this.limit.mod.length > 0;
  }
  /**
   * Helper method to create the main SR6Roll.
   */
  createRoll() {
    const roll = new SR6Roll(this.formula);
    this.rolls.push(roll);
    return roll;
  }
  /**
   * Allow other implementations to override what TestDialog template to use.
   */
  get _dialogTemplate() {
    return "systems/shadowrun6-elysium/dist/templates/apps/dialogs/success-test-dialog.html";
  }
  /**
   * Allow other implementations to override what ChatMessage template to use.
   */
  get _chatMessageTemplate() {
    return "systems/shadowrun6-elysium/dist/templates/rolls/success-test-message.html";
  }
  /**
   * What TestDialog class to use for this test type?
   *
   * If you only need to display differing data you can also only define a different _dialogTemplate
   * @override This method if you want to use a different TestDialog.
   */
  _createTestDialog() {
    return new TestDialog({ test: this, templatePath: this._dialogTemplate }, void 0, this._testDialogListeners());
  }
  /**
   * Allow other implementations to add listeners to the TestDialog HTML, changing
   * it's behavior without the need to sub-class TestDialog.
   */
  _testDialogListeners() {
    return [];
  }
  /**
   * Suppress dialog during execution
   */
  hideDialog() {
    if (!this.data.options) this.data.options = {};
    this.data.options.showDialog = false;
  }
  /**
   * Show the dialog class for this test type and alter test according to user selection.
   */
  async showDialog() {
    if (!this.data.options?.showDialog) return true;
    const dialog = this._createTestDialog();
    const data = await dialog.select();
    if (dialog.canceled) {
      await this.cleanupAfterExecutionCancel();
      return false;
    }
    this.data = data;
    await this.saveUserSelectionAfterDialog();
    this.prepareBaseValues();
    this.calculateBaseValues();
    return true;
  }
  /**
   * Override this method if there needs to be some cleanup after a user has canceled a dialog
   * but before the tests actual execution.
   */
  async cleanupAfterExecutionCancel() {
  }
  /**
   * Override this method if you want to save any document data after a user has selected values
   * during user facing dialog.
   */
  async saveUserSelectionAfterDialog() {
  }
  /**
   * The general base value preparation. This will be re applied at multiple points before execution.
   */
  prepareBaseValues() {
    this.prepareDocumentModifiers();
    this.prepareTestModifiers();
    this.applyPushTheLimit();
    this.applyPoolModifiers();
  }
  /**
   * Handle chosen modifier types and apply them to the pool modifiers.
   *
   * NOTE: To keep this.pool.mod and this.modifiers.mod in sync, never remove
   *       a modifier. Rather set it to zero, causing it to not be shown.
   */
  applyPoolModifiers() {
    const pool = new PartsList(this.pool.mod);
    pool.removePart("SR6.Labels.Action.Modifiers");
    if (this.data.modifiers.override) {
      for (const modifier of this.data.modifiers.mod) {
        pool.removePart(modifier.name);
      }
      pool.addUniquePart("SR6.Labels.Action.Modifiers", this.data.modifiers.override.value);
      return;
    }
    for (const modifier of this.data.modifiers.mod) {
      pool.addUniquePart(modifier.name, modifier.value);
    }
  }
  /**
   * To assure all test values are full integers, round all value parts.
   * Don't round the total as this will lead to some values shown as decimals and some as
   * integers.
   *
   * Instead Shadowrun 5e rules expect all individual values to be rounded before use.
   * We use the 'Note on Rounding' on SR5#48 as a guideline.
   */
  roundBaseValueParts() {
    const roundAllMods = /* @__PURE__ */ __name((value) => {
      value.base = Math.ceil(value.base);
      if (value.override) value.override.value = Math.ceil(value.override.value);
      value.mod.forEach((mod) => mod.value = Math.ceil(mod.value));
    }, "roundAllMods");
    roundAllMods(this.data.modifiers);
    roundAllMods(this.data.pool);
    roundAllMods(this.data.threshold);
    roundAllMods(this.data.limit);
  }
  /**
   * Calculate only the base test that can be calculated before the test has been evaluated.
   *
   * This will be re applied at multiple points before execution.
   */
  calculateBaseValues() {
    this.roundBaseValueParts();
    this.data.modifiers.value = Helpers.calcTotal(this.data.modifiers);
    this.data.pool.value = Helpers.calcTotal(this.data.pool, { min: 0 });
    this.data.threshold.value = Helpers.calcTotal(this.data.threshold, { min: 0 });
    this.data.limit.value = Helpers.calcTotal(this.data.limit, { min: 0 });
    this.data.manualHits.value = Helpers.calcTotal(this.data.manualHits, { min: 0 });
    this.data.manualGlitches.value = Helpers.calcTotal(this.data.manualGlitches, { min: 0 });
    this.data.damage.ap.value = Helpers.calcTotal(this.data.damage.ap);
    console.debug(`Shadowrun 6e | Calculated base values for ${this.constructor.name}`, this.data);
  }
  /**
   * Allow implementations to validate values before execution.
   */
  validateBaseValues() {
  }
  /**
   * Helper method to evaluate the internal SR6Roll and SuccessTest values.
   */
  async evaluate() {
    if (!this.usingManualRoll) {
      for (const roll of this.rolls) {
        if (!roll._evaluated)
          await roll.evaluate();
      }
    }
    this.data.evaluated = true;
    this.calculateDerivedValues();
    return this;
  }
  /**
   * Allow subclasses to populate a test before execution and any other steps.
   */
  async populateTests() {
  }
  /**
   * Rehydrate this test with Documents, should they be missing.
   * This can happen when a test is created from a ChatMessage.
   */
  async populateDocuments() {
    if (!this.actor && this.data.sourceActorUuid) {
      const document2 = await fromUuid(this.data.sourceActorUuid) || void 0;
      this.actor = document2 instanceof TokenDocument ? document2.actor : document2;
    }
    if (!this.item && this.data.sourceItemUuid)
      this.item = await fromUuid(this.data.sourceItemUuid) || void 0;
    if (this.targets.length === 0 && this.data.targetActorsUuid) {
      this.targets = [];
      for (const uuid of this.data.targetActorsUuid) {
        const document2 = await fromUuid(uuid);
        if (!document2) continue;
        const token = document2 instanceof SR6Actor ? document2.getToken() : document2;
        if (!(token instanceof TokenDocument)) continue;
        this.targets.push(token);
      }
    }
  }
  /**
   * Prepare missing data based on tests Documents before anything else is done.
   */
  async prepareDocumentData() {
    this.data.damage = ActionFlow.calcDamageData(this.data.damage, this.actor, this.item);
  }
  /**
   * What Action Categories should be used for this test by default.
   *
   * NOTE: These categories can be overwritten by the source action used to create a test instance.
   * Override this method if you test implementation needs to define different default categories.
   */
  get testCategories() {
    return [];
  }
  /**
   * What modifiers should be used for this test type by default.
   *
   * NOTE: These modifiers are routed through ModifierFlow.totalFor()
   */
  get testModifiers() {
    return ["global", "wounds"];
  }
  /**
   * Prepare this tests categories.
   *
   * By default categories are taken from the test implementation but can be overwritten by the source action.
   *
   * Test categories must be ready before active effects are applied as they rely on this data to be present.
   */
  prepareTestCategories() {
    this.data.categories = this.data.action.categories || this.testCategories;
  }
  /**
   * Prepare modifiers based on connected documents.
   *
   * Documents MUST've been be populated before hand.
   *
   * Main purpose is to populate the configured modifiers for this test based on actor / items used.
   */
  prepareDocumentModifiers() {
    this.prepareActorModifiers();
    this.prepareItemModifiers();
  }
  /**
   * Allow implementations to overwrite default modifiers after document modifiers have been applied to influence
   * pool calculation.
   */
  prepareTestModifiers() {
  }
  /**
   * Prepare general modifiers based on the actor, as defined within the action or test implementation.
   */
  prepareActorModifiers() {
    if (!this.actor) return;
    if (this.data.action.modifiers.length > 0) return;
    for (const type of this.testModifiers) {
      const { name: name3, value } = this.prepareActorModifier(this.actor, type);
      PartsList.AddUniquePart(this.data.modifiers.mod, name3, value, true);
    }
  }
  /**
   * Prepare a single modifier.
   *
   * Extend this method should you want to alter a single modifiers application.
   *
   * @param actor The actor to fetch modifier information for.
   * @param type The modifier type to be prepared.
   */
  prepareActorModifier(actor, type) {
    const options = { test: this, reapply: true };
    const value = actor.modifiers.totalFor(type, options);
    const name3 = this._getModifierTypeLabel(type);
    return { name: name3, value };
  }
  _getModifierTypeLabel(type) {
    return SR6.modifierTypes[type];
  }
  /**
   * Allow subclasses to alter test modifiers based on the item used for casting.
   */
  prepareItemModifiers() {
  }
  /**
   * Calculate the total of all values.
   */
  calculateDerivedValues() {
    this.data.values.hits = this.calculateHits();
    this.data.values.extendedHits = this.calculateExtendedHits();
    this.data.values.netHits = this.calculateNetHits();
    this.data.values.glitches = this.calculateGlitches();
    console.debug(`Shadowrun 6e | Calculated derived values for ${this.constructor.name}`, this.data);
  }
  /**
   * Helper to get the pool value for this success test.
   */
  get pool() {
    return this.data.pool;
  }
  /**
   * Helper to get the total limit value for this success test.
   */
  get limit() {
    return this.data.limit;
  }
  /**
   * Helper to determine if this success test uses a limit.
   *
   * NOTE: Limits will NEVER apply when the ApplyLimit setting is set accordingly.
   */
  get hasLimit() {
    const applyLimit = game.settings.get(SYSTEM_NAME, FLAGS.ApplyLimits);
    return applyLimit && !this.hasPushTheLimit && this.limit.value > 0;
  }
  /**
   * Helper to determine if the hits have been lowered by the limit.
   *
   * This will compare actual roll hits, without applied limit.
   */
  get hasReducedHits() {
    return this.hits.value > this.limit.value;
  }
  /**
   * Helper to get the total threshold value for this success test.
   */
  get threshold() {
    return this.data.threshold;
  }
  /**
   * Helper to determine if this success test uses a threshold.
   */
  get hasThreshold() {
    return this.threshold.value > 0;
  }
  /**
   * Helper to determine if this success test has a damage value.
   */
  get hasDamage() {
    return this.data.action.damage.value !== 0 && this.data.action.damage.type.value !== "";
  }
  /**
   * Helper to get the net hits value for this success test with a possible threshold.
   */
  calculateNetHits() {
    const hits = this.extended ? this.extendedHits : this.hits;
    const base = this.hasThreshold ? Math.max(hits.value - this.threshold.value, 0) : hits.value;
    const netHits = DataDefaults.valueData({
      label: "SR6.NetHits",
      base
    });
    netHits.value = Helpers.calcTotal(netHits, { min: 0 });
    return netHits;
  }
  get netHits() {
    return this.data.values.netHits;
  }
  /**
   * Helper to get the hits value for this success test with a possible limit.
   */
  calculateHits() {
    const rollHits = this.usingManualRoll ? this.manualHits.value : this.rolls.reduce((hits, roll) => hits + roll.hits, 0);
    this.hits.base = rollHits;
    this.hits.value = Helpers.calcTotal(this.hits, { min: 0 });
    this.hits.value = this.hasLimit ? Math.min(this.limit.value, this.hits.value) : this.hits.value;
    return this.hits;
  }
  get hits() {
    return this.data.values.hits;
  }
  get extendedHits() {
    return this.data.values.extendedHits || DataDefaults.valueData({ label: "SR6.ExtendedHits" });
  }
  get manualHits() {
    return this.data.manualHits;
  }
  get manualGlitches() {
    return this.data.manualGlitches;
  }
  get hitsIcon() {
    return this.data.hitsIcon;
  }
  get appendedHits() {
    return this.hits.mod.find((mod) => mod.name === "SR6.AppendedHits")?.value;
  }
  // In the case we've added appended hits, we want to separately display the hits value and the appended hits (ie. "7 + 5" instead of "12")
  get displayHits() {
    return this.hits.value - (this.appendedHits || 0);
  }
  // Hide dice pool and roll results as they are not relevant to the success of the test
  get autoSuccess() {
    return !!this.data.autoSuccess;
  }
  /**
   * Depending on system settings allow manual hits to skip automated roll.
   */
  get allowManualHits() {
    return game.settings.get(SYSTEM_NAME, FLAGS.ManualRollOnSuccessTest);
  }
  /**
   * Determine if this success test must automated roll or can use a manual roll given by user.
   */
  get usingManualRoll() {
    return this.allowManualHits && (Boolean(this.data.manualHits.override) || Boolean(this.data.manualGlitches.override));
  }
  /**
   * Helper to get the glitches values for this success test.
   */
  calculateGlitches() {
    const rollGlitches = this.usingManualRoll ? this.manualGlitches.value : this.rolls.reduce((glitches2, roll) => glitches2 + roll.glitches, 0);
    const glitches = DataDefaults.valueData({
      label: "SR6.Glitches",
      base: rollGlitches
    });
    glitches.value = Helpers.calcTotal(glitches, { min: 0 });
    return glitches;
  }
  /**
   * Gather hits across multiple extended test executions.
   */
  calculateExtendedHits() {
    if (!this.extended) return DataDefaults.valueData({ label: "SR6.ExtendedHits" });
    const extendedHits = this.extendedHits;
    extendedHits.mod = PartsList.AddPart(extendedHits.mod, "SR6.Hits", this.hits.value);
    Helpers.calcTotal(extendedHits, { min: 0 });
    return extendedHits;
  }
  /**
   * Check if this test is currently being extended.
   */
  get extended() {
    return this.canBeExtended && this.data.extended;
  }
  /**
   * Check if this test is on it's first or an extended roll.
   */
  get extendedRoll() {
    return this.data.extendedRoll;
  }
  /**
   * Can this test type be extended or not?
   *
   * If false, will hide extended dialog settings.
   */
  get canBeExtended() {
    return true;
  }
  get glitches() {
    return this.data.values.glitches;
  }
  /**
   * Helper to check if the current test state is glitched.
   */
  get glitched() {
    return TestRules.glitched(this.glitches.value, this.pool.value);
  }
  /**
   * Helper to check if the current test state is critically glitched.
   */
  get criticalGlitched() {
    return TestRules.criticalGlitched(this.hits.value, this.glitched);
  }
  /**
   * Check if the current test state is successful.
   *
   * @returns true on a successful test
   */
  get success() {
    const hits = this.extended ? this.extendedHits : this.hits;
    return TestRules.success(hits.value, this.threshold.value);
  }
  /**
   * Check if the current test state is unsuccessful.
   *
   * @returns true on a failed test
   */
  get failure() {
    if (this.extended && this.threshold.value === 0) return true;
    if (this.extendedHits.value > 0 && this.threshold.value > 0) return this.extendedHits.value < this.threshold.value;
    return !this.success;
  }
  /**
   * Use this method for subclasses which can't reasonably be successful.
   */
  get canSucceed() {
    if (!this.extended) return true;
    return this.extended && this.hasThreshold;
  }
  /**
   * Use this method for subclasses which can't reasonably fail.
   */
  get canFail() {
    return true;
  }
  /**
   * While a test might be successful with a zero threshold, it's
   * unclear if it's meant to be a success.
   *
   * Tests that don't know their threshold, either by GM secrecy or
   * following opposed tests not yet thrown, shouldn't show user
   * their successful.
   */
  get showSuccessLabel() {
    return this.success && this.hasThreshold;
  }
  /**
   * How to call a successful test of this type.
   */
  get successLabel() {
    return "SR6.TestResults.Success";
  }
  /**
   * How to call a failed test of this type.
   */
  get failureLabel() {
    if (this.extended) return "SR6.TestResults.Results";
    return "SR6.TestResults.Failure";
  }
  /**
   * Helper to check if opposing tests exist for this test.
   */
  get opposed() {
    return !!this.data.opposed && this.data.opposed.test !== void 0 && this.data.opposed.test !== "";
  }
  /**
   * Determine if this test is opposing another test.
   */
  get opposing() {
    return false;
  }
  /**
   * Helper to get an items action result information.
   */
  get results() {
    if (!this.item) return;
    return this.item.getActionResult();
  }
  /**
   * Determine if this test has any targets selected using FoundryVTT targeting.
   */
  get hasTargets() {
    return this.targets.length > 0;
  }
  /**
   * Has this test been derived from an action?
   *
   * This can either be from an items action or a pre-configured action.
   */
  get hasAction() {
    return !foundry.utils.isEmpty(this.data.action);
  }
  /**
   * TODO: This method results in an ugly description.
   *
   */
  get description() {
    const poolPart = this.pool.value;
    const thresholdPart = this.hasThreshold ? `(${this.threshold.value})` : "";
    const limitPart = this.hasLimit ? `[${this.limit.value}]` : "";
    return `${poolPart} ${thresholdPart} ${limitPart}`;
  }
  get hasPushTheLimit() {
    return this.data.pushTheLimit;
  }
  get hasSecondChance() {
    return this.data.secondChance;
  }
  /**
   * Determine if this test can use second chance rules.
   *
   * Use this property to check if a existing test can use this edge rule.
   *
   * SR5#56.
   */
  get canSecondChance() {
    if (!this.evaluated) {
      console.error("SR6: Elysium | Second chance edge rules should not be applicable on initial cast");
      return false;
    }
    if (this.glitched) {
      ui.notifications?.warn("SR6.Warnings.CantSecondChanceAGlitch", { localize: true });
      return false;
    }
    if (this.hasPushTheLimit || this.hasSecondChance) {
      ui.notifications?.warn("SR6.Warnings.CantSpendMulitplePointsOfEdge", { localize: true });
      return false;
    }
    return true;
  }
  /**
   * Determine if this test can use push the limit rules
   *
   * Use this property to check if a existing test can use this edge rule.
   *
   * SR5#56.
   */
  get canPushTheLimit() {
    if (this.hasPushTheLimit || this.hasSecondChance) {
      ui.notifications?.warn("SR6.Warnings.CantSpendMulitplePointsOfEdge", { localize: true });
      return false;
    }
    return true;
  }
  /**
   * Handle Edge rule 'push the limit', either adding edge before or after casting
   * and exploding sixes for either all dice or only edge dice.
   *
   * Check edge rules on SR5#56.
   *
   * If called without push the limit, all modifiers for it will be removed.
   */
  applyPushTheLimit() {
    if (!this.actor) return;
    const parts = new PartsList(this.pool.mod);
    if (!this.hasPushTheLimit) {
      parts.removePart("SR6.PushTheLimit");
      return;
    }
    const edge = this.actor.getEdge().value;
    parts.addUniquePart("SR6.PushTheLimit", edge, true);
    if (!this.evaluated) return;
    const explodeDice = true;
    const formula = this.buildFormula(edge, explodeDice);
    const roll = new SR6Roll(formula);
    this.rolls.push(roll);
  }
  /**
   * Handle Edge rules for 'second chance'.
   *
   * If called without second chance, all modifiers for it will be removed.
   */
  applySecondChance() {
    if (!this.actor) return;
    const parts = new PartsList(this.pool.mod);
    if (!this.hasSecondChance) {
      parts.removePart("SR6.SecondChance");
      return;
    }
    const lastRoll = this.rolls[this.rolls.length - 1];
    const dice = lastRoll.poolThrown - lastRoll.hits;
    if (dice <= 0) {
      ui.notifications?.warn("SR6.Warnings.CantSecondChanceWithoutNoneHits", { localize: true });
      return this;
    }
    parts.addUniquePart("SR6.SecondChance", dice, true);
    const formula = `${dice}d6`;
    const roll = new SR6Roll(formula);
    this.rolls.push(roll);
  }
  /**
   * Make sure ALL resources needed are available.
   *
   * This is checked before any resources are consumed.
   *
   * @returns true when enough resources are available to consume
   */
  canConsumeDocumentResources() {
    if (!this.actor) return true;
    if (this.hasPushTheLimit || this.hasSecondChance) {
      if (this.actor.getEdge().uses <= 0) {
        ui.notifications?.error(game.i18n.localize("SR6.MissingRessource.Edge"));
        return false;
      }
    }
    return true;
  }
  /**
   * Handle resulting resource consumption caused by this test.
   *
   * @return true when the resources could be consumed in appropriate amounts.
   */
  async consumeDocumentRessources() {
    if (!this.actor) return true;
    if (this.hasPushTheLimit || this.hasSecondChance) {
      await this.actor.useEdge();
    }
    return true;
  }
  /**
  * Consume resources according to whats configured for this world.
  * @returns true when the test can process
  */
  async consumeDocumentRessoucesWhenNeeded() {
    const mustHaveRessouces = game.settings.get(SYSTEM_NAME, FLAGS.MustHaveRessourcesOnTest);
    if (mustHaveRessouces) {
      if (!this.canConsumeDocumentResources()) return false;
    }
    return await this.consumeDocumentRessources();
  }
  /**
   * Executing a test will start all behaviors necessary to:
   * - Calculate its values
   * - Show and handle a user facing test dialog
   * - Render and show a resulting test message
   * - Evaluate all it's roles and consumption of items used
   * - Trigger resulting methods for all results, including success and failure
   *
   * Implementing classes should seek to change out methods used here, or within those methods, to alter test
   * behavior to their needs.
   *
   * When execute methods promise resolves this test and its chain is completed.
   *
   * NOTE: Currently none of these methods trigger Foundry hooks.
   */
  async execute() {
    await this.populateTests();
    await this.populateDocuments();
    this.prepareTestCategories();
    this.effects.applyAllEffects();
    await this.prepareDocumentData();
    this.prepareBaseValues();
    this.calculateBaseValues();
    this.validateBaseValues();
    const userConsented = await this.showDialog();
    if (!userConsented) return this;
    const actorConsumedResources = await this.consumeDocumentRessoucesWhenNeeded();
    if (!actorConsumedResources) return this;
    this.createRoll();
    await this.evaluate();
    await this.processResults();
    await this.toMessage();
    await this.afterTestComplete();
    return this;
  }
  /**
   * Handle Edge rule 'second chance' within this test according to SR5#56
   *
   * This is a execute method alternative.
   */
  async executeWithSecondChance() {
    console.debug(`Shadowrun 6e | ${this.constructor.name} will apply second chance rules`);
    if (!this.data.sourceActorUuid) {
      ui.notifications?.warn("SR6.Warnings.EdgeRulesCantBeAppliedOnTestsWithoutAnActor", { localize: true });
      return this;
    }
    if (!this.canSecondChance) return this;
    await this.populateDocuments();
    this.data.secondChance = true;
    this.applySecondChance();
    this.calculateBaseValues();
    this.validateBaseValues();
    const actorConsumedResources = await this.consumeDocumentRessoucesWhenNeeded();
    if (!actorConsumedResources) return this;
    this.data.secondChance = false;
    await this.evaluate();
    await this.processResults();
    await this.toMessage();
    await this.afterTestComplete();
    return this;
  }
  /**
   * A execute method alternative to handle Edge rule 'push the limit' within this test.
   */
  async executeWithPushTheLimit() {
    console.debug(`Shadowrun 6e | ${this.constructor.name} will push the limit rules`);
    if (!this.data.sourceActorUuid) {
      ui.notifications?.warn("SR6.Warnings.EdgeRulesCantBeAppliedOnTestsWithoutAnActor", { localize: true });
      return this;
    }
    if (!this.canPushTheLimit) return this;
    await this.populateDocuments();
    this.data.pushTheLimit = true;
    this.applyPushTheLimit();
    this.calculateBaseValues();
    this.validateBaseValues();
    const actorConsumedResources = await this.consumeDocumentRessoucesWhenNeeded();
    if (!actorConsumedResources) return this;
    await this.evaluate();
    await this.processResults();
    this.data.pushTheLimit = false;
    await this.toMessage();
    await this.afterTestComplete();
    return this;
  }
  /**
   * Allow subclasses to override behavior after a test has finished.
   *
   * This can be used to alter values after a test is over.
   */
  async processResults() {
    if (this.success) {
      await this.processSuccess();
    } else {
      await this.processFailure();
    }
  }
  /**
   * Allow subclasses to override behavior after a successful test result.
   *
   * This can be used to alter values after a test succeeded.
   * @override
   */
  async processSuccess() {
  }
  /**
   * Allow subclasses to override behavior after a failure test result
   *
   * This can be used to alter values after a test failed.
   * @override
   */
  async processFailure() {
  }
  /**
   * Allow subclasses to override behavior after a test is fully done. This will be called after processResults
   * and allows for additional processes to be triggered that don't affect this test itself.
   *
   * This can be used to trigger other processes like followup tests or saving values.
   */
  async afterTestComplete() {
    console.debug(`SR6: Elysium | Test ${this.constructor.name} completed.`, this);
    if (this.success) {
      await this.afterSuccess();
    } else {
      await this.afterFailure();
    }
    if (this.autoExecuteFollowupTest) {
      await this.executeFollowUpTest();
    }
    if (this.extended) {
      await this.executeAsExtended();
    }
  }
  /**
   * Allow subclasses to override followup behavior after a successful test result
   * @override
   */
  async afterSuccess() {
    if (this.opposing) return;
    if (this.opposed) return;
    for (const target of this.targets) {
      if (target.actor === null) continue;
      await this.effects.createTargetActorEffects(target.actor);
    }
  }
  /**
   * Allow subclasses to override followup behavior after a failed test result
   * @override
   */
  async afterFailure() {
  }
  /**
   * Allow a test to determine if it's follow up tests should auto cast after test completion.
   *
   * This could be set to false to allow for tests to NOT have an immediate auto cast, due to
   * current user casting and the user casting the follow differing.
   */
  get autoExecuteFollowupTest() {
    return true;
  }
  /**
   * Depending on the action configuration execute a followup test.
   */
  async executeFollowUpTest() {
    const test = await TestCreator.fromFollowupTest(this, this.data.options);
    if (!test) return;
    await test.execute();
  }
  /**
   * Should this test be an extended test, re-execute it until it can't be anymore.
   *
   * The first roll of extended test will use normal #execute, while the extended rolls
   * will pass through this, both for the action and chat message extension flow.
   */
  async executeAsExtended() {
    if (!this.canBeExtended) return;
    const data = foundry.utils.duplicate(this.data);
    if (!data.type) return;
    const pool = new PartsList(data.pool.mod);
    const currentModifierValue = pool.getPartValue("SR6.ExtendedTest") || 0;
    const nextModifierValue = TestRules.calcNextExtendedModifier(currentModifierValue);
    if (data.pool.override) {
      data.pool.override.value = Math.max(data.pool.override.value - 1, 0);
    } else {
      pool.addUniquePart("SR6.ExtendedTest", nextModifierValue);
    }
    Helpers.calcTotal(data.pool, { min: 0 });
    if (!TestRules.canExtendTest(data.pool.value, this.threshold.value, this.extendedHits.value)) {
      return ui.notifications?.warn("SR6.Warnings.CantExtendTestFurther", { localize: true });
    }
    await this.populateDocuments();
    const testCls = TestCreator._getTestClass(data.type);
    if (!testCls) return;
    data.evaluated = false;
    const test = new testCls(data, { actor: this.actor, item: this.item }, this.data.options);
    test.data.pushTheLimit = false;
    test.applyPushTheLimit();
    test.data.secondChance = false;
    test.applySecondChance();
    if (!test.extended) {
      test.data.extended = true;
      test.calculateExtendedHits();
    }
    test.data.extendedRoll = true;
    await test.execute();
    return test;
  }
  /**
   * DiceSoNice must be implemented locally to avoid showing dice on gmOnlyContent throws while also using
   * FoundryVTT ChatMessage of type roll for their content visibility behavior.
   *
   * https://gitlab.com/riccisi/foundryvtt-dice-so-nice/-/wikis/Integration
   */
  async rollDiceSoNice() {
    if (!game.dice3d || !game.user || !game.users) return;
    console.debug("SR6: Elysium | Initiating DiceSoNice throw");
    const roll = this.rolls[this.rolls.length - 1];
    let whisper = null;
    if (this.actor && GmOnlyMessageContentFlow.applyGmOnlyContent(this.actor)) {
      whisper = game.users.filter((user) => this.actor?.testUserPermission(user, "OWNER"));
    }
    if (this.data.options?.rollMode === "gmroll" || this.data.options?.rollMode === "blindroll") {
      whisper = whisper || [];
      whisper = [...game.users.filter((user) => user.isGM), ...whisper];
    }
    const blind = this.data.options?.rollMode === "blindroll";
    const synchronize = this.data.options?.rollMode === "publicroll";
    game.dice3d.showForRoll(roll, game.user, synchronize, whisper, blind, this.data.messageUuid);
  }
  /**
   * Post this success test as a message to the chat log.
   */
  async toMessage() {
    if (!this.data.options?.showMessage) return;
    const templateData = await this._prepareMessageTemplateData();
    const content = await renderTemplate(this._chatMessageTemplate, templateData);
    const messageData = await this._prepareMessageData(content);
    const options = { rollMode: this._rollMode };
    const message = await ChatMessage.create(messageData, options);
    if (!message) return;
    this.data.messageUuid = message.uuid;
    await this.saveToMessage();
    await this.rollDiceSoNice();
    return message;
  }
  /**
   * Prepare chat message content data for this success test card.
   *
   * @returns Chat Message template data.
   *
   * TODO: Add template data typing.
   */
  async _prepareMessageTemplateData() {
    const linkedTokens = this.actor?.getActiveTokens(true) || [];
    const token = linkedTokens.length >= 1 ? linkedTokens[0] : void 0;
    return {
      title: this.data.title,
      test: this,
      // Note: While ChatData uses ids, this uses full documents.
      speaker: {
        actor: this.actor,
        token
      },
      item: this.item,
      opposedActions: this._prepareOpposedActionsTemplateData(),
      followupActions: this._prepareFollowupActionsTemplateData(),
      resultActions: this._prepareResultActionsTemplateData(),
      previewTemplate: this._canPlaceBlastTemplate,
      showDescription: this._canShowDescription,
      description: await this.item?.getChatData() || "",
      // Some message segments are only meant for the gm, when the gm is the one creating the message.
      // When this test doesn't use an actor, don't worry about hiding anything.
      applyGmOnlyContent: GmOnlyMessageContentFlow.applyGmOnlyContent(this.actor),
      // Effects that should be shown in this tests message for manual drag & drop application.
      effects: []
    };
  }
  /**
   * Indicate if this test can be used to show the item description.
   */
  get _canShowDescription() {
    return true;
  }
  /**
   * Indicate if this test can be used to place a blast template using the shown chat message.
   *
   * This is indicated by the source items ability to cause an area of effect blast and which kind
   * of test is used.
   */
  get _canPlaceBlastTemplate() {
    return this.item?.hasBlastTemplate || false;
  }
  /**
   * This class should be used for the opposing test implementation.
   */
  get _opposedTestClass() {
    if (!this.data.opposed || !this.data.opposed.test) return;
    return TestCreator._getTestClass(this.data.opposed.test);
  }
  /**
   * Prepare opposed test action buttons.
   *
   * Currently, one opposed action is supported, however the template
   * is prepared to support multiple action buttons.
   */
  _prepareOpposedActionsTemplateData() {
    const testCls = this._opposedTestClass;
    if (!testCls) return [];
    const action = {
      // Store the test implementation registration name.
      test: testCls.name,
      label: testCls.label
    };
    if (this.data.opposed.mod) {
      action.label += ` ${this.data.opposed.mod}`;
    }
    return [action];
  }
  /**
   * Prepare followup actions a test allows. These are actions
   * meant to be taken following completion of this test.
   */
  _prepareFollowupActionsTemplateData() {
    const testCls = TestCreator._getTestClass(this.data.action.followed.test);
    if (!testCls) return [];
    return [{ label: testCls.label }];
  }
  /**
   * Prepare result action buttons
   */
  _prepareResultActionsTemplateData() {
    const actions = [];
    const actionResultData = this.results;
    if (!actionResultData) return actions;
    if (actionResultData.success.matrix.placeMarks) {
      actions.push({
        action: "placeMarks",
        label: "SR6.PlaceMarks",
        value: ""
      });
    }
    return actions;
  }
  /**
   * What ChatMessage rollMode is this test supposed to use?
   */
  get _rollMode() {
    return this.data.options?.rollMode ?? game.settings.get("core", "rollmode");
  }
  /**
   * Prepare chat message data for this success test card.
   *
   * @param content Pre rendered template content.
   */
  async _prepareMessageData(content) {
    const linkedTokens = this.actor?.getActiveTokens(true) || [];
    const token = linkedTokens.length === 1 ? linkedTokens[0].id : void 0;
    const actor = this.actor?.id;
    const alias = game.user?.name;
    const formula = `0d6`;
    const roll = new SR6Roll(formula);
    await roll.evaluate();
    const messageData = {
      user: game.user?.id,
      // Use type roll, for Foundry built in content visibility.
      type: CONST.CHAT_MESSAGE_TYPES.ROLL,
      speaker: {
        actor,
        alias,
        token
      },
      roll,
      content,
      // Manually build flag data to give renderChatMessage hook flag access.
      // This test data is needed for all subsequent testing based on this chat messages.
      flags: {
        // Add test data to message to allow ChatMessage hooks to access it.
        [SYSTEM_NAME]: { [FLAGS.Test]: this.toJSON() },
        "core.canPopout": true
      },
      sound: CONFIG.sounds.dice
    };
    ChatMessage.applyRollMode(messageData, this._rollMode);
    return messageData;
  }
  /**
   * Save this test to the given message uuid
   * @param uuid
   */
  async saveToMessage(uuid = this.data.messageUuid) {
    if (!uuid) return;
    const message = await fromUuid(uuid);
    await message?.setFlag(SYSTEM_NAME, FLAGS.Test, this.toJSON());
  }
  /**
   * Register listeners for ChatMessage html created by a SuccessTest.
   *
   * This listener needs to be registered to the 'renderChatMessage' FoundryVTT hook.
   *
   * @param message
   * @param html
   * @param data
   */
  static async chatMessageListeners(message, html, data) {
    html.find(".show-roll").on("click", this._chatToggleCardRolls);
    html.find(".show-description").on("click", this._chatToggleCardDescription);
    html.find(".chat-document-link").on("click", Helpers.renderEntityLinkSheet);
    html.find(".place-template").on("click", this._placeItemBlastZoneTemplate);
    html.find(".result-action").on("click", this._castResultAction);
    html.find(".chat-select-link").on("click", this._selectSceneToken);
    html.find(".test-action").on("click", this._castTestAction);
    DamageApplicationFlow.handleRenderChatMessage(message, html, data);
    await GmOnlyMessageContentFlow.chatMessageListeners(message, html, data);
  }
  /**
   * Select a Token on the current scene based on the link id.
   * @params event Any user PointerEvent
  */
  static async _selectSceneToken(event) {
    event.preventDefault();
    event.stopPropagation();
    if (!game || !game.ready || !canvas || !canvas.ready) return;
    const selectLink = $(event.currentTarget);
    const tokenId = selectLink.data("tokenId");
    const token = canvas.tokens?.get(tokenId);
    if (token && token instanceof Token) {
      token.control();
    } else {
      ui.notifications?.warn(game.i18n.localize("SR6.NoSelectableToken"));
    }
  }
  /**
   * Cast a item action from a chat message.
   *
   * @param event Any pointer event
   */
  static async _castTestAction(event) {
    event.preventDefault();
    const element = $(event.currentTarget);
    const uuid = element.data("uuid") ?? "";
    const item = await fromUuid(uuid);
    if (!item) return console.error("Shadowrun 6e | Item doesn't exist for uuid", uuid);
    item.castAction(event);
  }
  static async chatLogListeners(chatLog, html, data) {
    html.find(".chat-message").each(async (index, element) => {
      element = $(element);
      const id = element.data("messageId");
      const message = game.messages?.get(id);
      if (!message) return;
      await this.chatMessageListeners(message, element, message.toObject());
    });
  }
  /**
   * Items with an area of effect will allow users to place a measuring template matching the items blast values.
   *
   * @param event A PointerEvent triggered from anywhere within the chat-card
   */
  static async _placeItemBlastZoneTemplate(event) {
    event.preventDefault();
    event.stopPropagation();
    const element = $(event.currentTarget);
    const card = element.closest(".chat-message");
    const messageId = card.data("messageId");
    const test = await TestCreator.fromMessage(messageId);
    if (!test) return;
    await test.populateDocuments();
    if (!test.item) return;
    const template = Template.fromItem(test.item);
    if (!template) return;
    await template.drawPreview();
  }
  /**
   * Foundry ChatMessage context options (right click) used for all test types.
   * @param html
   * @param options
   */
  static chatMessageContextOptions(html, options) {
    const pushTheLimit = /* @__PURE__ */ __name(async (li) => {
      const messageId = li.data().messageId;
      const test = await TestCreator.fromMessage(messageId);
      if (!test) return console.error("Shadowrun 6e | Could not restore test from message");
      await test.executeWithPushTheLimit();
    }, "pushTheLimit");
    const secondChance = /* @__PURE__ */ __name(async (li) => {
      const messageId = li.data().messageId;
      const test = await TestCreator.fromMessage(messageId);
      if (!test) return console.error("Shadowrun 6e | Could not restore test from message");
      await test.executeWithSecondChance();
    }, "secondChance");
    const extendTest = /* @__PURE__ */ __name(async (li) => {
      const messageId = li.data().messageId;
      const test = await TestCreator.fromMessage(messageId);
      if (!test) return console.error("Shadowrun 6e | Could not restore test from message");
      if (!test.canBeExtended) {
        return ui.notifications?.warn("SR6.Warnings.CantExtendTest", { localize: true });
      }
      await test.executeAsExtended();
    }, "extendTest");
    const deleteOption = options.pop();
    options.push({
      name: game.i18n.localize("SR6.PushTheLimit"),
      callback: pushTheLimit,
      condition: true,
      icon: '<i class="fas fa-meteor"></i>'
    });
    options.push({
      name: game.i18n.localize("SR6.SecondChance"),
      callback: secondChance,
      condition: true,
      icon: '<i class="fas fa-meteor"></i>'
    });
    options.push({
      name: game.i18n.localize("SR6.Extend"),
      callback: extendTest,
      condition: true,
      icon: '<i class="fas fa-clock"></i>'
    });
    options.push(deleteOption);
    return options;
  }
  /**
   * By default, roll results are hidden in a chat card.
   *
   * This will hide / show them, when called with a card event.
   *
   * @param event Called from within a card html element.
   */
  static async _chatToggleCardRolls(event) {
    event.preventDefault();
    event.stopPropagation();
    const card = $(event.currentTarget).closest(".chat-card");
    const element = card.find(".dice-rolls");
    if (element.is(":visible")) element.slideUp(200);
    else element.slideDown(200);
  }
  /**
   * By default, item descriptions are hidden in a chat card.
   *
   * This will hide / show them, when called with a card event.
   * @param event A PointerEvent triggered anywhere from within a chat-card
   */
  static async _chatToggleCardDescription(event) {
    event.preventDefault();
    event.stopPropagation();
    const card = $(event.currentTarget).closest(".chat-card");
    const element = card.find(".card-description");
    if (element.is(":visible")) element.slideUp(200);
    else element.slideDown(200);
  }
  /**
   * A test message initiated an action for a test result, extract information from message and execute action.
   *
   * @param event A PointerEvent by user-interaction
   */
  static async _castResultAction(event) {
    event.preventDefault();
    event.stopPropagation();
    const element = $(event.currentTarget);
    const resultAction = element.data("action");
    const messageId = element.closest(".chat-message").data("messageId");
    const test = await TestCreator.fromMessage(messageId);
    if (!test) return console.error(`SR6: Elysium | Couldn't find both a result action ('${resultAction}') and extract test from message ('${messageId}')`);
    await test.populateDocuments();
    await ActionResultFlow.executeResult(resultAction, test);
  }
};

// src/module/tests/OpposedTest.ts
var OpposedTest = class _OpposedTest extends SuccessTest {
  static {
    __name(this, "OpposedTest");
  }
  constructor(data, documents, options) {
    super(data, documents, options);
    const AgainstCls = data.against ? TestCreator._getTestClass(data.against.type) : SuccessTest;
    this.against = new AgainstCls(data.against || {});
  }
  _prepareData(data, options) {
    data = super._prepareData(data, options);
    delete data.opposed;
    delete data.targetActorsUuid;
    data.values = data.values || {};
    data.values.againstNetHits = DataDefaults.valueData({ label: "SR6.NetHits" });
    return data;
  }
  /**
   * Before populating any documents for THIS test, populate the opposed tests documents first.
   */
  async populateTests() {
    await this.against.populateDocuments();
  }
  calculateDerivedValues() {
    super.calculateDerivedValues();
    this.data.values.againstNetHits = this.calculateAgainstNetHits();
  }
  /**
   * To have proper net hits values for the original test, we calculate it's netHits values after the opposed test
   * is finished.
   *
   * We don't change the original netHits to not interfere with the original test and allow it to still
   * report correct netHits against it's own (possible) threshold.
   */
  calculateAgainstNetHits() {
    const base = Math.max(this.against.hits.value - this.hits.value, 0);
    const againstNetHits = DataDefaults.valueData({ label: "SR6.NetHits", base });
    againstNetHits.value = Helpers.calcTotal(againstNetHits, { min: 0 });
    return againstNetHits;
  }
  static async _getOpposedActionTestData(againstData, actor, previousMessageId) {
    if (!againstData.opposed) {
      console.error(`Shadowrun 6e | Supplied test data doesn't contain an opposed action`, againstData, this);
      return;
    }
    if (againstData.opposed.type !== "") {
      console.warn(`Shadowrun 6e | Supplied test defines a opposed test type ${againstData.opposed.type} but only type '' is supported`, this);
    }
    if (!actor) {
      console.error(`Shadowrun 6e | Can't resolve opposed test values due to missing actor`, this);
      return;
    }
    const data = {
      // While not visible, when there is a description set, use it.
      title: againstData.opposed.description || void 0,
      previousMessageId,
      pool: DataDefaults.valueData({ label: "SR6.DicePool" }),
      limit: DataDefaults.valueData({ label: "SR6.Limit" }),
      threshold: DataDefaults.valueData({ label: "SR6.Threshold" }),
      //@ts-expect-error
      values: {},
      sourceItemUuid: againstData.sourceItemUuid,
      against: againstData
    };
    data.threshold.base = againstData.values.netHits.value;
    let action = DataDefaults.actionRollData();
    action = TestCreator._mergeMinimalActionDataInOrder(
      action,
      // Use action data from the original action at first.
      againstData.opposed,
      // Overwrite with the OpposedTest class default action, if any.
      this._getDefaultTestAction()
    );
    if (againstData.sourceItemUuid) {
      const item = await fromUuid(againstData.sourceItemUuid);
      if (item) {
        const itemAction = await this._getDocumentTestAction(item, actor);
        action = TestCreator._mergeMinimalActionDataInOrder(action, itemAction);
      }
    }
    return await this._prepareActionTestData(action, actor, data);
  }
  /**
   * Overwrite SuccessTest#opposed behavior as an OpposedTest can't have another opposed test.
   */
  get opposed() {
    return false;
  }
  /**
   * Overwrite SuccessTest#opposing behavior as an OpposedTest is opposing another test.
   */
  get opposing() {
    return true;
  }
  /**
   * This test type can't be extended.
   */
  get canBeExtended() {
    return false;
  }
  /**
   * Opposed tests shouldn't show item description from the active tests source item.
   */
  get _canShowDescription() {
    return false;
  }
  /**
   * Opposed tests can't cause any blast template.
   */
  get _canPlaceBlastTemplate() {
    return false;
  }
  /**
   * Derived net hits of the active vs opposed test pair.
   */
  get againstNetHits() {
    return this.data.values.againstNetHits;
  }
  /**
   * Apply opposed test modifiers based on the item implementation
   */
  prepareItemModifiers() {
    if (!this.item) return;
    const opposedMod = this.item.getOpposedTestMod();
    for (const modifier of opposedMod.list) {
      PartsList.AddUniquePart(this.data.modifiers.mod, modifier.name, modifier.value, true);
    }
  }
  /**
   * Using a message action cast an opposed test to that messages active test.
   *
   * @param event A PointerEvent by user interaction to trigger the test action.
   */
  static async _castOpposedAction(event) {
    event.preventDefault();
    const button = $(event.currentTarget);
    const card = button.closest(".chat-message");
    const messageId = card.data("messageId");
    const opposedActionTest = button.data("action");
    const showDialog = !TestCreator.shouldHideDialog(event);
    await TestCreator.fromMessageAction(messageId, opposedActionTest, { showDialog });
  }
  static async chatMessageListeners(message, html, data) {
    html.find(".opposed-action").on("click", _OpposedTest._castOpposedAction);
  }
  /**
   * Inject effects taken from the active original test and inject them into the opposed chat message.
   */
  async _prepareMessageTemplateData() {
    const templateData = await super._prepareMessageTemplateData();
    if (!this.against) return templateData;
    for (const effect of this.against.effects.allApplicableEffectsToTargetActor()) {
      templateData.effects.push(effect);
    }
    return templateData;
  }
  async afterFailure() {
    await super.afterFailure();
    const against = this.against;
    const actor = this.actor;
    if (against === void 0 && !this.opposing) return;
    if (actor === void 0) return;
    await this.effects.createTargetActorEffects(actor);
  }
};

// src/module/tests/DefenseTest.ts
var DefenseTest = class extends OpposedTest {
  static {
    __name(this, "DefenseTest");
  }
  _prepareData(data, options) {
    data = super._prepareData(data, options);
    const damage = data.against ? data.against.damage : DataDefaults.damageData();
    data.incomingDamage = foundry.utils.duplicate(damage);
    data.modifiedDamage = foundry.utils.duplicate(damage);
    return data;
  }
  get _chatMessageTemplate() {
    return "systems/shadowrun6-elysium/dist/templates/rolls/defense-test-message.html";
  }
  get successLabel() {
    return "SR6.TestResults.AttackDodged";
  }
  get failureLabel() {
    return "SR6.TestResults.AttackHits";
  }
  get testCategories() {
    return ["defense"];
  }
  /**
   * This test has changed the initiative score of its caster.
   */
  get hasChangedInitiative() {
    return this.data.iniMod !== void 0;
  }
  get initiativeModifier() {
    return this.data.iniMod || 0;
  }
};

// src/module/rules/ActiveDefenseRules.ts
var ActiveDefenseRules = {
  /**
   * What active defenses are available for the given item? Based on SR5#190 'Active Defenses'
   * @param weapon The equipped weapon used for the attack.
   * @param actor The actor performing the attack.
   */
  availableActiveDefenses: /* @__PURE__ */ __name((weapon, actor) => {
    const activeDefenses = {
      full_defense: {
        label: "SR6.FullDefense",
        value: actor.getFullDefenseAttribute()?.value,
        initMod: -10
      }
    };
    if (!weapon.isMeleeWeapon) return activeDefenses;
    activeDefenses["dodge"] = {
      label: "SR6.Dodge",
      value: actor.findActiveSkill("gymnastics")?.value,
      initMod: -5
    };
    activeDefenses["block"] = {
      label: "SR6.Block",
      value: actor.findActiveSkill("unarmed_combat")?.value,
      initMod: -5
    };
    activeDefenses["parry"] = {
      label: "SR6.Parry",
      weapon: weapon.name || "",
      value: actor.findActiveSkill(weapon.getActionSkill())?.value,
      initMod: -5
    };
    return activeDefenses;
  }, "availableActiveDefenses")
};

// src/module/tests/PhysicalDefenseTest.ts
var PhysicalDefenseTest = class extends DefenseTest {
  constructor() {
    super(...arguments);
    // Order is important in this array to determine which label is shown, determined by the first test whose function returns a truthy value
    this.noDamageConditions = [
      {
        test: /* @__PURE__ */ __name(() => this.actor !== void 0 && CombatRules.doesNoPhysicalDamageToVehicle(this.data.incomingDamage, this.actor), "test"),
        label: "SR6.TestResults.AttackDoesNoPhysicalDamageToVehicle"
      },
      {
        test: /* @__PURE__ */ __name(() => this.actor !== void 0 && CombatRules.isBlockedByVehicleArmor(this.data.incomingDamage, this.against.hits.value, this.hits.value, this.actor), "test"),
        label: "SR6.TestResults.AttackBlockedByVehicleArmor"
      },
      {
        test: /* @__PURE__ */ __name(() => this.actor !== void 0 && CombatRules.isBlockedByHardenedArmor(this.data.incomingDamage, this.against.hits.value, this.hits.value, this.actor), "test"),
        label: "SR6.TestResults.AttackBlockedByHardenedArmor"
      }
    ];
  }
  static {
    __name(this, "PhysicalDefenseTest");
  }
  _prepareData(data, options) {
    data = super._prepareData(data, options);
    data.cover = 0;
    data.activeDefense = "";
    data.activeDefenses = {};
    data.isMeleeAttack = false;
    data.defenseReach = 0;
    return data;
  }
  get _dialogTemplate() {
    return "systems/shadowrun6-elysium/dist/templates/apps/dialogs/physical-defense-test-dialog.html";
  }
  static _getDefaultTestAction() {
    return {
      "attribute": "reaction",
      "attribute2": "intuition"
    };
  }
  get testCategories() {
    return ["defense"];
  }
  get testModifiers() {
    return ["global", "wounds", "defense", "multi_defense"];
  }
  async prepareDocumentData() {
    this.prepareActiveDefense();
    this.prepareMeleeReach();
    await super.prepareDocumentData();
  }
  /**
   * Depending on the weapon used for attack different active defenses are available.
   */
  prepareActiveDefense() {
    if (!this.actor) return;
    const actor = this.actor;
    const weapon = this.against.item;
    if (weapon === void 0) return;
    this.data.activeDefenses = ActiveDefenseRules.availableActiveDefenses(weapon, actor);
    this._filterActiveDefenses();
  }
  prepareMeleeReach() {
    if (!this.against.item) return;
    this.data.isMeleeAttack = this.against.item.isMeleeWeapon;
    if (!this.data.isMeleeAttack) return;
    if (!this.actor) return;
    const equippedMeleeWeapons = this.actor.getEquippedWeapons().filter((weapon) => weapon.isMeleeWeapon);
    equippedMeleeWeapons.forEach((weapon) => {
      this.data.defenseReach = Math.max(this.data.defenseReach, weapon.getReach());
    });
    const attackData = this.against.data;
    const incomingReach = attackData.reach || 0;
    const defenseReach = this.data.defenseReach;
    this.data.defenseReach = MeleeRules.defenseReachModifier(incomingReach, defenseReach);
  }
  calculateBaseValues() {
    super.calculateBaseValues();
    this.applyIniModFromActiveDefense();
  }
  applyPoolModifiers() {
    this.applyPoolCoverModifier();
    this.applyPoolActiveDefenseModifier();
    this.applyPoolMeleeReachModifier();
    this.applyPoolRangedFireModModifier();
    super.applyPoolModifiers();
  }
  applyPoolCoverModifier() {
    this.data.cover = foundry.utils.getType(this.data.cover) === "string" ? Number(this.data.cover) : this.data.cover;
    PartsList.AddUniquePart(this.data.modifiers.mod, "SR6.Cover", this.data.cover);
  }
  applyPoolActiveDefenseModifier() {
    const defense = this.data.activeDefenses[this.data.activeDefense] || { label: "SR6.ActiveDefense", value: 0, init: 0 };
    PartsList.AddUniquePart(this.data.modifiers.mod, "SR6.ActiveDefense", defense.value);
  }
  applyPoolMeleeReachModifier() {
    if (!this.data.isMeleeAttack) return;
    PartsList.AddUniquePart(this.data.modifiers.mod, "SR6.Weapon.Reach", this.data.defenseReach);
  }
  /**
   * When defending against a ranged attack, see if any fire mode defense modifiers must be applied
   */
  applyPoolRangedFireModModifier() {
    if (!this.against.item) return;
    if (!this.against.item.isRangedWeapon) return;
    const fireMode = this.against.item.getLastFireMode();
    if (!fireMode.defense) return;
    PartsList.AddUniquePart(this.data.modifiers.mod, fireMode.label, Number(fireMode.defense));
  }
  get success() {
    return CombatRules.attackMisses(this.against.hits.value, this.hits.value);
  }
  get failure() {
    return CombatRules.attackHits(this.against.hits.value, this.hits.value);
  }
  getNoDamageCondition() {
    return this.noDamageConditions.find(({ test }) => test());
  }
  get failureLabel() {
    return this.getNoDamageCondition()?.label || super.failureLabel;
  }
  async processResults() {
    await super.processResults();
    await this.applyActorEffectsForDefense();
  }
  async processSuccess() {
    this.data.modifiedDamage = CombatRules.modifyDamageAfterMiss(this.data.incomingDamage);
    await super.processSuccess();
  }
  async processFailure() {
    if (!this.actor) return;
    if (this.getNoDamageCondition()) {
      this.data.modifiedDamage = CombatRules.modifyDamageAfterMiss(this.data.incomingDamage, true);
    } else {
      this.data.modifiedDamage = CombatRules.modifyDamageAfterHit(this.actor, this.against.hits.value, this.hits.value, this.data.incomingDamage);
    }
    await super.processFailure();
  }
  async afterFailure() {
    await super.afterFailure();
    if (this.getNoDamageCondition()) {
      return;
    }
    const test = await TestCreator.fromOpposedTestResistTest(this, this.data.options);
    if (!test) return;
    await test.execute();
  }
  canConsumeDocumentResources() {
    if (this.actor && this.data.iniMod && game.combat) {
      const combat = game.combat;
      const combatant = combat.getActorCombatant(this.actor);
      if (!combatant || !combatant.initiative) return true;
      if (combatant && combatant.initiative + this.data.iniMod < 0) {
        ui.notifications?.warn("SR6.MissingRessource.Initiative", { localize: true });
        return false;
      }
    }
    return super.canConsumeDocumentResources();
  }
  /**
   * Should an active defense be selected apply the initiative modifier to the defenders combat initiative.
   */
  applyIniModFromActiveDefense() {
    if (!this.actor) return;
    if (!this.data.activeDefense) return;
    const activeDefense = this.data.activeDefenses[this.data.activeDefense];
    if (!activeDefense) return;
    this.data.iniMod = activeDefense.initMod;
  }
  _prepareResultActionsTemplateData() {
    const actions = super._prepareResultActionsTemplateData();
    if (!this.data.activeDefense) return actions;
    const activeDefense = this.data.activeDefenses[this.data.activeDefense];
    if (!activeDefense) return actions;
    actions.push({
      action: "modifyCombatantInit",
      label: "SR6.Initiative",
      value: String(activeDefense.initMod)
    });
    return actions;
  }
  /**
   * Increase the actors multi defense modifier.
   */
  async applyActorEffectsForDefense() {
    if (!this.actor) return;
    this.actor.calculateNextDefenseMultiModifier();
  }
  /**
   * Based in combatants ini score, pre-filter available active defense modes.
   *
   * This behaviour can be disabled using the must have ressources setting.
   */
  _filterActiveDefenses() {
    if (!this.actor) return;
    const mustHaveRessouces = game.settings.get(SYSTEM_NAME, FLAGS.MustHaveRessourcesOnTest);
    if (!mustHaveRessouces) return;
    const iniScore = this.actor.combatInitiativeScore;
    Object.values(this.data.activeDefenses).forEach(
      (mode) => mode.disabled = CombatRules.canUseActiveDefense(iniScore, mode.initMod)
    );
  }
};

// src/module/item/flows/ActionResultFlow.ts
var ActionResultFlow = class _ActionResultFlow {
  static {
    __name(this, "ActionResultFlow");
  }
  /**
       * The handlers registered for specific result action.
       *
       * @returns A Map mapping action name to function handler
       */
  static get _handlersResultAction() {
    const handlers = /* @__PURE__ */ new Map();
    handlers.set("placeMarks", () => ui.notifications?.error("Placing marks currently isnt suported. Sorry!"));
    handlers.set("modifyCombatantInit", _ActionResultFlow._castInitModifierAction);
    return handlers;
  }
  /**
   * Handle execution of any action result action. :)
   *
   * NOTE: This is a horrible system and likely to be replaced someday...
   *
   * @param resultAction The action descriptor based on SuccessTest#_prepareResultActionsTemplateData.
   * @param test The SuccessTest subclass the action has been emitted from.
   */
  static async executeResult(resultAction, test) {
    const handler = _ActionResultFlow._handlersResultAction.get(resultAction);
    if (!handler)
      return console.error(`Shadowrun 6e | Action result ${resultAction} has not handler registered`);
    await handler(test);
  }
  /**
   * Matrix Marks are placed on either actors (persona, ic) or items (device, host, technology).
   */
  static async placeMatrixMarks(active3, targets, marks) {
    if (!MatrixRules.isValidMarksCount(marks)) {
      return ui.notifications?.warn(game.i18n.localize("SR6.Warnings.InvalidMarksCount"));
    }
    for (const target of targets) {
      await active3.setMarks(target, marks);
    }
  }
  /**
   * Modify the actors combatant according the test defined initiative modifier.
   *
   * @param test The test instance causing the initiative modification
   */
  static async _castInitModifierAction(test) {
    if (!(test instanceof PhysicalDefenseTest)) return;
    if (!test.data.iniMod) return;
    await test.actor?.changeCombatInitiative(test.data.iniMod);
  }
};

// src/module/item/flows/UpdateActionFlow.ts
var UpdateActionFlow = {
  /**
   * Alter action data changes on update.
   *
   * @param changeData The _update changes given by the event
   * @param item The item as context of what's being changed.
   */
  onUpdateAlterActionData(changeData, item) {
    UpdateActionFlow.onSkillUpdateAlterAttribute(changeData, item);
    UpdateActionFlow.onSkillUpdateAlterAttribute2(changeData, item);
  },
  /**
   * If a skill is selected, try to autofill the connect attribute of it.
   *
   * This differs for items on actors, as here we can access actual skill data.
   * For item outside of actors we can only use default values.
   * @param changeData  The _update changes given by the event
   * @param item The item as context of what's being changed.
   */
  onSkillUpdateAlterAttribute(changeData, item) {
    if (item.system.action?.attribute !== "") return;
    const skillIdOrLabel = foundry.utils.getProperty(changeData, "system.action.skill");
    if (skillIdOrLabel === void 0 || skillIdOrLabel === "") return;
    if (item.actor === null) {
      const skill = game.model.Actor.character.skills.active[skillIdOrLabel];
      if (skill === void 0) return;
      changeData["system.action.attribute"] = skill.attribute;
    } else {
      const skill = item.actor.getSkill(skillIdOrLabel) ?? item.actor.getSkillByLabel(skillIdOrLabel);
      if (skill === void 0) return;
      changeData["system.action.attribute"] = skill.attribute;
    }
  },
  /**
   * When a skill is changed, remove the second attribute, as it's not needed and might cause confusion
   * at different places.
   *
   * @param changeData The _update changes given by the event
   * @param item The item as context of what's being changed.
   */
  onSkillUpdateAlterAttribute2(changeData, item) {
    if (!foundry.utils.getProperty(changeData, "system.action.skill")) return;
    changeData["system.action.attribute2"] = "";
  },
  /**
   * Inject action test data into any item
   *
   * This method is designed to be called on _preCreate/_preUpdate/_preCreateEmbeddedDocuments
   *
   * Make sure to not mix up changeData and itemData
   *
   * Depending on the caller whatever was applied to the applyData parameter must be handled differently.
   * When called by _onCreate, it must be used as updateData using Document#update
   * When called by _preUpdate, it must be applied directly to changeData
   * When called before any DocumentData as been created, it can be applied directly to the source object before Document#create
   *
   * @param type The item type where operating on
   * @param changeData The changeData (partial or complete) that's been transmitted.
   * @param applyData An object to carry the altering data changes
   * @param item Optional item reference. This can't be given during the Chummer Item Import flow.
   */
  injectActionTestsIntoChangeData(type, changeData, applyData, item) {
    if (!changeData) return;
    const typeHandler = {
      "weapon": UpdateActionFlow.injectWeaponTestIntoChangeData,
      "spell": UpdateActionFlow.injectSpellTestIntoChangeData,
      "complex_form": UpdateActionFlow.injectComplexFormTestIntoChangeData,
      "call_in_action": UpdateActionFlow.injectCallInActionTestIntoChangeData
    };
    const handler = typeHandler[type];
    if (!handler) return;
    handler(type, changeData, applyData, item);
  },
  /**
   * See injectActionTestsIntoChangeData for documentation.
   */
  injectWeaponTestIntoChangeData(type, changeData, applyData) {
    if (changeData?.system?.category === void 0) return;
    if (changeData.system.category === "") {
      foundry.utils.setProperty(applyData, "system.action.test", "");
      return;
    }
    const test = SR6.weaponCategoryActiveTests[changeData.system.category];
    if (!test) {
      console.error(`Shadowrun 5 | There is no active test configured for the weapon category ${changeData.system.category}.`, changeData);
    }
    foundry.utils.setProperty(applyData, "system.action.test", test);
    foundry.utils.setProperty(applyData, "system.action.opposed.test", "PhysicalDefenseTest");
    foundry.utils.setProperty(applyData, "system.action.opposed.resist.test", "PhysicalResistTest");
  },
  /**
   * See injectActionTestsIntoChangeData for documentation.
   */
  injectSpellTestIntoChangeData(type, changeData, applyData) {
    if (changeData?.system?.category === void 0) return;
    if (changeData.system.category === "") {
      foundry.utils.setProperty(applyData, "system.action.test", "");
      return;
    }
    const test = SR6.activeTests[type];
    const opposedTest = SR6.opposedTests[type][changeData.system.category] || "OpposedTest";
    const resistTest = SR6.opposedResistTests[type][changeData.system.category] || "";
    const drainTest = SR6.followedTests[test] ?? "";
    foundry.utils.setProperty(applyData, "system.action.test", test);
    foundry.utils.setProperty(applyData, "system.action.opposed.test", opposedTest);
    foundry.utils.setProperty(applyData, "system.action.opposed.resist.test", resistTest);
    foundry.utils.setProperty(applyData, "system.action.followed.test", drainTest);
  },
  /**
   * See injectActionTestsIntoChangeData for documentation.
   */
  injectComplexFormTestIntoChangeData(type, changeData, applyData) {
    const test = SR6.activeTests[type];
    foundry.utils.setProperty(applyData, "system.action.test", test);
  },
  /**
   * See injectActionTestsIntoChangeData for documentation.
   */
  injectCallInActionTestIntoChangeData(type, changeData, applyData) {
    if (changeData.system?.actor_type === void 0) return;
    if (changeData.system.actor_type === "spirit") {
      foundry.utils.setProperty(applyData, "system.action.test", "SummonSpiritTest");
      foundry.utils.setProperty(applyData, "system.action.opposed.test", "OpposedSummonSpiritTest");
      foundry.utils.setProperty(applyData, "system.action.followed.test", "DrainTest");
    }
    if (changeData.system.actor_type === "sprite") {
      foundry.utils.setProperty(applyData, "system.action.test", "CompileSpriteTest");
      foundry.utils.setProperty(applyData, "system.action.opposed.test", "OpposedCompileSpriteTest");
      foundry.utils.setProperty(applyData, "system.action.followed.test", "FadeTest");
    }
    if (changeData.system.actor_type.length === 0) {
      foundry.utils.setProperty(applyData, "system.action.test", "");
      foundry.utils.setProperty(applyData, "system.action.opposed.test", "");
      foundry.utils.setProperty(applyData, "system.action.followed.test", "");
    }
  }
};

// src/module/item/SR6Item.ts
var SR6Item = class _SR6Item extends Item {
  constructor() {
    super(...arguments);
    // Item Sheet labels for quick info on an item dropdown.
    this.labels = {};
  }
  static {
    __name(this, "SR6Item");
  }
  // TODO: foundry-vtt-types v10
  /**
   * Return the owner of this item, which can either be
   * - an actor instance (Foundry default)
   * - an item instance (shadowrun custom) for embedded items
   *
   * If you need the actual actor owner, no matter how deep into item embedding, this current item is use SR5item.actorOwner
   */
  get actor() {
    return super.actor;
  }
  /**
   * Helper property to get an actual actor for an owned or embedded item. You'll need this for when you work with
   * embeddedItems, as they have their .actor property set to the item they're embedded into.
   *
   * NOTE: This helper is necessary since we have setup embedded items with an item owner, due to the current embedding
   *       workflow using item.update.isOwned condition within Item.update (foundry Item) to NOT trigger a global item
   *       update within the ItemCollection but instead have this.actor.updateEmbeddedEntities actually trigger SR6Item.updateEmbeddedEntities
   */
  get actorOwner() {
    if (!this.actor) return;
    if (this.actor instanceof SR6Actor) return this.actor;
    return this.actor.actorOwner;
  }
  get wrapper() {
    return new SR6ItemDataWrapper(this);
  }
  // Flag Functions
  getLastFireMode() {
    return this.getFlag(SYSTEM_NAME, FLAGS.LastFireMode) || DataDefaults.fireModeData();
  }
  async setLastFireMode(fireMode) {
    return this.setFlag(SYSTEM_NAME, FLAGS.LastFireMode, fireMode);
  }
  getLastSpellForce() {
    return this.getFlag(SYSTEM_NAME, FLAGS.LastSpellForce) || { value: 0 };
  }
  async setLastSpellForce(force) {
    return this.setFlag(SYSTEM_NAME, FLAGS.LastSpellForce, force);
  }
  getLastComplexFormLevel() {
    return this.getFlag(SYSTEM_NAME, FLAGS.LastComplexFormLevel) || { value: 0 };
  }
  async setLastComplexFormLevel(level) {
    return this.setFlag(SYSTEM_NAME, FLAGS.LastComplexFormLevel, level);
  }
  getLastFireRangeMod() {
    return this.getFlag(SYSTEM_NAME, FLAGS.LastFireRange) || { value: 0 };
  }
  async setLastFireRangeMod(environmentalMod) {
    return this.setFlag(SYSTEM_NAME, FLAGS.LastFireRange, environmentalMod);
  }
  /**
   * Return an Array of the Embedded Item Data
   */
  getNestedItems() {
    let items = this.getFlag(SYSTEM_NAME, FLAGS.EmbeddedItems);
    items = items ? items : [];
    if (items && !Array.isArray(items)) {
      items = Helpers.convertIndexedObjectToArray(items);
    }
    items = items.map((item) => {
      if (item.effects && !Array.isArray(item.effects)) {
        item.effects = Helpers.convertIndexedObjectToArray(item.effects);
      }
      return item;
    });
    return items;
  }
  /**
   * Set the embedded item data
   * @param items
   */
  async setNestedItems(items) {
    await this.setFlag(SYSTEM_NAME, FLAGS.EmbeddedItems, items);
  }
  async clearNestedItems() {
    await this.unsetFlag(SYSTEM_NAME, FLAGS.EmbeddedItems);
  }
  get hasOpposedRoll() {
    const action = this.getAction();
    if (!action) return false;
    return !!action.opposed.test;
  }
  get hasRoll() {
    const action = this.getAction();
    return !!(action && action.type !== "" && (action.skill || action.attribute || action.attribute2 || action.dice_pool_mod));
  }
  /**
   * Determine if a blast area should be placed using FoundryVTT area templates.
   */
  get hasBlastTemplate() {
    return this.isAreaOfEffect;
  }
  /**
   * PREPARE DATA CANNOT PULL FROM this.actor at ALL
   * - as of foundry v0.7.4, actor data isn't prepared by the time we prepare items
   * - this caused issues with Actions that have a Limit or Damage attribute and so those were moved
   */
  prepareData() {
    super.prepareData();
    this.prepareNestedItems();
    this.labels = {};
    const equippedMods = this.getEquippedMods();
    const equippedAmmo = this.getEquippedAmmo();
    const technology = this.getTechnologyData();
    if (technology) {
      TechnologyPrep.prepareConditionMonitor(technology);
      TechnologyPrep.prepareConceal(technology, equippedMods);
    }
    const action = this.getAction();
    if (action) {
      ActionPrep.prepareData(action, this, equippedMods, equippedAmmo);
    }
    const range = this.getWeaponRange();
    if (range && range.rc) {
      RangePrep.prepareData(range, equippedMods);
    }
    switch (this.type) {
      case "host":
        HostDataPreparation(this.system);
        break;
      case "adept_power":
        AdeptPowerPrep.prepareBaseData(this.system);
        break;
      case "sin":
        SinPrep.prepareBaseData(this.system);
        break;
    }
  }
  async postItemCard() {
    const options = {
      actor: this.actor,
      description: await this.getChatData(),
      item: this,
      previewTemplate: this.hasBlastTemplate,
      tests: this.getActionTests()
    };
    return await createItemChatMessage(options);
  }
  /**
   * Cast the action of this item as a Test.
   *
   * @param event A PointerEvent by user interaction.
   */
  async castAction(event) {
    const dontRollTest = TestCreator.shouldPostItemDescription(event) || !this.hasRoll;
    if (dontRollTest) return await this.postItemCard();
    if (!this.actor) return;
    const showDialog = !TestCreator.shouldHideDialog(event);
    const test = await TestCreator.fromItem(this, this.actor, { showDialog });
    if (!test) return;
    await test.execute();
  }
  /**
   * Create display only information for this item. Used on sheets, chat messages and more.
   * Both actor and item sheets.
   *
   * The original naming leans on the dnd5e systems use of it for chat messages.
   * NOTE: This is very legacy, difficult to read and should be improved upon.
   *
   * @param htmlOptions
   * @returns
   */
  async getChatData(htmlOptions = {}) {
    const system = foundry.utils.duplicate(this.system);
    const { labels } = this;
    if (!system.description) system.description = { chat: "", source: "", value: "" };
    if (!system.description.value) system.description.value = "";
    system.description.value = await TextEditor.enrichHTML(system.description.value, { ...htmlOptions });
    const props = [];
    const chatDataForItemType = ChatData[this.type];
    if (chatDataForItemType) chatDataForItemType(system, labels, props, this);
    system.properties = props.filter((p2) => !!p2);
    return system;
  }
  getActionTestName() {
    const testName = this.getRollName();
    return testName ? testName : game.i18n.localize("SR6.Action");
  }
  /**
   * Any item implementation can define a set of modifiers to be applied when used within an opposed test.
   *
   * NOTE: This is a legacy method of applied modifiers to opposed tests but works fine for now.
   */
  getOpposedTestMod() {
    const parts = new PartsList();
    if (this.hasOpposedTest()) {
      if (this.isAreaOfEffect) {
        parts.addUniquePart("SR6.Aoe", -2);
      }
    }
    return parts;
  }
  getBlastData(actionTestData) {
    if (this.isSpell && this.isAreaOfEffect) {
      const system = this.system;
      let distance = this.getLastSpellForce().value;
      if (actionTestData?.spell) {
        distance = actionTestData.spell.force;
      }
      if (system.extended) distance *= 10;
      const dropoff = 0;
      return {
        radius: distance,
        dropoff
      };
    } else if (this.isGrenade) {
      const system = this.system;
      const distance = system.thrown.blast.radius;
      const dropoff = system.thrown.blast.dropoff;
      return {
        radius: distance,
        dropoff
      };
    } else if (this.hasExplosiveAmmo) {
      const item = this.getEquippedAmmo();
      const ammo = item.asAmmo;
      if (!ammo) return { radius: 0, dropoff: 0 };
      const distance = ammo.system.blast.radius;
      const dropoff = ammo.system.blast.dropoff;
      return {
        radius: distance,
        dropoff
      };
    }
  }
  getEquippedAmmo() {
    const equippedAmmos = (this.items || []).filter((item) => item.isAmmo && item.isEquipped());
    return equippedAmmos[0];
  }
  getEquippedMods() {
    return (this.items || []).filter((item) => item.isWeaponModification && item.isEquipped());
  }
  get hasExplosiveAmmo() {
    const ammo = this.getEquippedAmmo();
    if (!ammo) return false;
    const system = ammo.system;
    return system.blast.radius > 0;
  }
  /**
   * Toggle equipment state of a single Modification item.
   * @param iid Modification item id to be equip toggled
   */
  async equipWeaponMod(iid) {
    await this.equipNestedItem(iid, "modification", { unequipOthers: false, toggle: true });
  }
  /**
   * Check if weapon has enough ammunition.
   *
   * @param rounds The amount of rounds to be fired
   * @returns Either the weapon has no ammo at all or not enough.
   */
  hasAmmo(rounds = 0) {
    return this.ammoLeft >= rounds;
  }
  /**
   * Amount of ammunition this weapon has currently available
   */
  get ammoLeft() {
    const ammo = this.wrapper.getAmmo();
    if (!ammo) return 0;
    return ammo.current.value;
  }
  /**
   * Use the weapons ammunition with the amount of bullets fired.
   * @param fired Amount of bullets fired.
   */
  async useAmmo(fired) {
    if (this.type !== "weapon") return;
    const value = Math.max(0, this.system.ammo.current.value - fired);
    return await this.update({ "system.ammo.current.value": value });
  }
  /**
   * Can this item (weapon, melee, ranged, whatever) use ammunition?
   *
   * @returns true, for weapons with ammunition.
   */
  get usesAmmo() {
    return this.system.ammo?.current.max !== 0 && this.system.ammo?.current.max !== null;
  }
  /**
   * Reload this weapon according to information in:
   * - its current clips
   * - its available spare clips (when given)
   * - its equipped ammo
   *
   * This method will only reload the weapon to the max amount of ammo available.
   *
   * TODO: Currently only the minimal amount of bullets is reloaded. For weapons using ejectable clips, this should be full clip capacity.
   */
  async reloadAmmo(partialReload) {
    const weapon = this.asWeapon;
    if (!weapon) return;
    const updateData = {};
    const ammo = this.getEquippedAmmo();
    const ammoItems = this.items.filter((item) => item.isAmmo).length;
    const remainingBullets = Number(weapon.system.ammo.current.value);
    const missingBullets = Math.max(0, weapon.system.ammo.current.max - remainingBullets);
    const partialReloadBulletsNeeded = Math.min(weapon.system.ammo.current.max - remainingBullets, RangedWeaponRules.partialReload(weapon.system.ammo.clip_type, this.actor.getAttribute("agility").value));
    const availableBullets = ammoItems > 0 ? Number(ammo.system.technology?.quantity) : weapon.system.ammo.current.max;
    if (weapon.system.ammo.spare_clips.value === 0 && weapon.system.ammo.spare_clips.max > 0) {
      ui.notifications?.info("SR6.Warnings.CantReloadWithoutSpareClip", { localize: true });
    }
    if (ammo && Number(ammo.system.technology?.quantity) === 0) {
      return ui.notifications?.warn("SR6.Warnings.CantReloadAtAllDueToAmmo", { localize: true });
    }
    if (ammo && Number(ammo.system.technology?.quantity) < missingBullets) {
      if (partialReload && partialReloadBulletsNeeded !== -1 && Number(ammo.system.technology?.quantity) < partialReloadBulletsNeeded) {
        ui.notifications?.info("SR6.Warnings.CantReloadPartialDueToAmmo", { localize: true });
      } else {
        ui.notifications?.info("SR6.Warnings.CantReloadFullyDueToAmmo", { localize: true });
      }
    }
    const reloadedBullets = Math.min(missingBullets, availableBullets, partialReload ? partialReloadBulletsNeeded : Infinity);
    if (weapon.system.ammo.spare_clips.max > 0) {
      updateData["system.ammo.spare_clips.value"] = Math.max(0, weapon.system.ammo.spare_clips.value - 1);
    }
    updateData["system.ammo.current.value"] = remainingBullets + reloadedBullets;
    await this.update(updateData);
    if (!ammo) return;
    await ammo.update({ "system.technology.quantity": Math.max(0, Number(ammo.system.technology?.quantity) - reloadedBullets) });
  }
  async equipNestedItem(id, type, options = {}) {
    const unequipOthers = options.unequipOthers || false;
    const toggle = options.toggle || false;
    const updateData = [];
    const ammoItems = this.items.filter((item) => item.type === type);
    for (const item of ammoItems) {
      if (!unequipOthers && item.id !== id) continue;
      const equip = toggle ? !item.system.technology.equipped : id === item.id;
      updateData.push({ _id: item.id, "system.technology.equipped": equip });
    }
    if (updateData) await this.updateNestedItems(updateData);
  }
  /**
   * Equip one ammo item exclusively.
   *
   * @param id Item id of the to be exclusively equipped ammo item.
   */
  async equipAmmo(id) {
    await this.equipNestedItem(id, "ammo", { unequipOthers: true });
  }
  async addNewLicense() {
    if (this.type !== "sin") return;
    const licenses = foundry.utils.getType(this.system.licenses) === "Object" ? (
      //@ts-expect-error TODO: foundry-vtt-types v10
      Object.values(this.system.licenses)
    ) : this.system.licenses;
    if (!licenses) return;
    licenses.push({
      name: "",
      rtg: "",
      description: ""
    });
    await this.update({ "system.licenses": licenses });
  }
  get isSin() {
    return this.wrapper.isSin();
  }
  get asSin() {
    if (this.isSin) {
      return this;
    }
  }
  get isLifestyle() {
    return this.wrapper.isLifestyle();
  }
  get asLifestyle() {
    if (this.isLifestyle) {
      return this;
    }
  }
  get isAmmo() {
    return this.wrapper.isAmmo();
  }
  get isAoEAmmo() {
    return this.wrapper.isAoEAmmo();
  }
  get asAmmo() {
    if (this.isAmmo) {
      return this;
    }
  }
  get isModification() {
    return this.wrapper.isModification();
  }
  asModification() {
    if (this.isModification) {
      return this;
    }
  }
  get isWeaponModification() {
    return this.wrapper.isWeaponModification();
  }
  get isArmorModification() {
    return this.wrapper.isArmorModification();
  }
  get isProgram() {
    return this.wrapper.isProgram();
  }
  get asProgram() {
    if (this.isProgram) {
      return this;
    }
  }
  get isQuality() {
    return this.wrapper.isQuality();
  }
  get asQuality() {
    if (this.isQuality) {
      return this;
    }
  }
  get isAdeptPower() {
    return this.type === "adept_power";
  }
  asAdeptPower() {
    if (this.isAdeptPower)
      return this;
  }
  get isHost() {
    return this.type === "host";
  }
  get asHost() {
    if (this.isHost) {
      return this;
    }
  }
  /**
   * SIN Item - remove a single license within this SIN
   *
   * @param index The license list index
   */
  async removeLicense(index) {
    if (this.type !== "sin") return;
    const licenses = this.system.licenses.splice(index, 1);
    await this.update({ "system.licenses": licenses });
  }
  isAction() {
    return this.wrapper.isAction();
  }
  asAction() {
    if (this.isAction()) {
      return this;
    }
  }
  async rollOpposedTest(target, attack3, event) {
    console.error(`SR6: Elysium | ${this.constructor.name}.rollOpposedTest is not supported anymore`);
  }
  async rollTestType(type, attack3, event, target) {
    if (type === "opposed") {
      await this.rollOpposedTest(target, attack3, event);
    }
    if (type === "action") {
      await this.castAction(event);
    }
  }
  /**
   * The item can be stored on a token on the current or another, given, scene.
   *
   * The chat message must contain a data attribute containing a 'SceneId.TokenId' mapping.
   * See chat.ts#getTokenSceneId for further context.
   *
   *
   * @param html
   */
  static getItemFromMessage(html) {
    if (!game || !game.scenes || !game.ready || !canvas || !canvas.ready || !canvas.scene) return;
    const card = html.find(".chat-card");
    let actor;
    const sceneTokenId = card.data("tokenId");
    if (sceneTokenId) actor = Helpers.getSceneTokenActor(sceneTokenId);
    else actor = game.actors?.get(card.data("actorId"));
    if (!actor) return;
    const itemId = card.data("itemId");
    return actor.items.get(itemId);
  }
  static getTargets() {
    if (!game.ready || !game.user) return;
    const { character } = game.user;
    const { controlled } = canvas.tokens;
    const targets = controlled.reduce((arr, t2) => t2.actor ? arr.concat([t2.actor]) : arr, []);
    if (character && controlled.length === 0) targets.push(character);
    if (!targets.length) throw new Error(`You must designate a specific Token as the roll target`);
    return targets;
  }
  getActionTests() {
    if (!this.hasRoll) return [];
    return [{
      label: this.getActionTestName(),
      uuid: this.uuid
    }];
  }
  getActionResult() {
    if (!this.isAction()) return;
    return this.wrapper.getActionResult();
  }
  /**
   * Create an item in this item
   * @param itemData
   * @param options
   *
   * //@ts-expect-error TODO: foundry-vtt-types v10 Rework method...
   */
  async createNestedItem(itemData, options = {}) {
    if (!Array.isArray(itemData)) itemData = [itemData];
    if (this.type === "weapon") {
      const currentItems = foundry.utils.duplicate(this.getNestedItems());
      itemData.forEach((ogItem) => {
        const item = foundry.utils.duplicate(ogItem);
        item._id = randomID(16);
        if (item.type === "ammo" || item.type === "modification") {
          if (item?.system?.technology?.equipped) {
            item.system.technology.equipped = false;
          }
          currentItems.push(item);
        }
      });
      await this.setNestedItems(currentItems);
    }
    this.prepareNestedItems();
    this.prepareData();
    this.render(false);
    return true;
  }
  /**
   * Prepare embeddedItems
   */
  prepareNestedItems() {
    this.items = this.items || [];
    const items = this.getNestedItems();
    if (!items) return;
    const loaded = this.items.reduce((object, item) => {
      object[item.id] = item;
      return object;
    }, {});
    const tempItems = items.map((item) => {
      const data = game.user ? { ownership: { [game.user.id]: CONST.DOCUMENT_OWNERSHIP_LEVELS.OWNER } } : {};
      item = foundry.utils.mergeObject(item, data);
      if (item._id in loaded) {
        const currentItem = loaded[item._id];
        currentItem.updateSource(item);
        currentItem.prepareData();
        return currentItem;
      } else {
        return new _SR6Item(item, { parent: this });
      }
    });
    this.items = tempItems;
  }
  // TODO: Rework to either use custom embeddedCollection or Map
  getOwnedItem(itemId) {
    const items = this.items;
    if (!items) return;
    return items.find((item) => item.id === itemId);
  }
  // TODO: Rework this method. It's complicated and obvious optimizations can be made. (find vs findIndex)
  async updateNestedItems(changes) {
    const items = foundry.utils.duplicate(this.getNestedItems());
    if (!items) return;
    changes = Array.isArray(changes) ? changes : [changes];
    if (!changes || changes.length === 0) return;
    changes.forEach((itemChanges) => {
      const index = items.findIndex((i2) => i2._id === itemChanges._id);
      if (index === -1) return;
      const item = items[index];
      delete itemChanges._id;
      if (item) {
        itemChanges = expandObject(itemChanges);
        foundry.utils.mergeObject(item, itemChanges);
        items[index] = item;
      }
    });
    await this.setNestedItems(items);
    this.prepareNestedItems();
    this.prepareData();
    this.render(false);
    return true;
  }
  /**
   * This method hooks into the Foundry Item.update approach and is called using this<Item>.actor.updateEmbeddedEntity.
   *
   * @param embeddedName
   * @param data
   * @param options
   */
  async updateEmbeddedEntity(embeddedName, data, options) {
    await this.updateNestedItems(data);
    return this;
  }
  /**
   * Remove an owned item
   * @param deleted
   * @returns {Promise<boolean>}
   */
  async deleteOwnedItem(deleted) {
    const items = foundry.utils.duplicate(this.getNestedItems());
    if (!items) return;
    const idx = items.findIndex((i2) => i2._id === deleted || Number(i2._id) === deleted);
    if (idx === -1) throw new Error(`SR6: Elysium | Couldn't find owned item ${deleted}`);
    items.splice(idx, 1);
    await this.clearNestedItems();
    await this.setNestedItems(items);
    await this.prepareNestedItems();
    await this.prepareData();
    await this.render(false);
    return true;
  }
  /**
   * Use the items source field and try different means of opening it.
   */
  async openSource() {
    const source3 = this.getSource();
    await LinksHelpers.openSource(source3);
  }
  get sourceIsUrl() {
    const source3 = this.getSource();
    return LinksHelpers.isURL(source3);
  }
  get sourceIsPDF() {
    const source3 = this.getSource();
    return LinksHelpers.isPDF(source3);
  }
  get sourceIsUuid() {
    const source3 = this.getSource();
    return LinksHelpers.isUuid(source3);
  }
  _canDealDamage() {
    const action = this.getAction();
    if (!action) return false;
    return !!action.damage.type.base;
  }
  getAction() {
    return this.wrapper.getAction();
  }
  getExtended() {
    const action = this.getAction();
    if (!action) return false;
    return action.extended;
  }
  getTechnologyData() {
    return this.wrapper.getTechnology();
  }
  getNetworkController() {
    return this.getTechnologyData()?.networkController;
  }
  async setNetworkController(networkController) {
    await this.update({ "system.technology.networkController": networkController });
  }
  getRange() {
    return this.wrapper.getRange();
  }
  getWeaponRange() {
    if (this.isRangedWeapon)
      return this.getRange();
  }
  getRollName() {
    if (this.isRangedWeapon) {
      return game.i18n.localize("SR6.RangeWeaponAttack");
    }
    if (this.isMeleeWeapon) {
      return game.i18n.localize("SR6.MeleeWeaponAttack");
    }
    if (this.isCombatSpell) {
      return game.i18n.localize("SR6.Spell.Attack");
    }
    if (this.isSpell) {
      return game.i18n.localize("SR6.Spell.Cast");
    }
    if (this.hasRoll) {
      return this.name;
    }
    return DEFAULT_ROLL_NAME;
  }
  /**
   * An attack with this weapon will create an area of effect / blast.
   *
   * There is a multitude of possibilities as to HOW an item can create an AoE,
   * both directly connected to the item and / or some of it's nested items.
   *
   */
  get isAreaOfEffect() {
    return this.wrapper.isAreaOfEffect() || this.hasExplosiveAmmo;
  }
  get isArmor() {
    return this.wrapper.isArmor();
  }
  get asArmor() {
    if (this.isArmor) {
      return this;
    }
  }
  get hasArmorBase() {
    return this.wrapper.hasArmorBase();
  }
  get hasArmorAccessory() {
    return this.wrapper.hasArmorAccessory();
  }
  get hasArmor() {
    return this.wrapper.hasArmor();
  }
  get isGrenade() {
    return this.wrapper.isGrenade();
  }
  get isWeapon() {
    return this.wrapper.isWeapon();
  }
  get asWeapon() {
    if (this.isWeapon) {
      return this;
    }
  }
  get isRangedWeapon() {
    return this.wrapper.isRangedWeapon();
  }
  get isMeleeWeapon() {
    return this.wrapper.isMeleeWeapon();
  }
  get isCyberware() {
    return this.wrapper.isCyberware();
  }
  get asCyberware() {
    if (this.isCyberware) {
      return this;
    }
  }
  get isCombatSpell() {
    return this.wrapper.isCombatSpell();
  }
  get isDirectCombatSpell() {
    return this.wrapper.isDirectCombatSpell();
  }
  get isIndirectCombatSpell() {
    return this.wrapper.isIndirectCombatSpell();
  }
  get isManaSpell() {
    return this.wrapper.isManaSpell();
  }
  get isPhysicalSpell() {
    return this.wrapper.isPhysicalSpell();
  }
  get isSpell() {
    return this.wrapper.isSpell();
  }
  get isUsingRangeCategory() {
    return this.wrapper.isUsingRangeCategory();
  }
  get asSpell() {
    if (this.isSpell) {
      return this;
    }
  }
  get isCallInAction() {
    return this.type === "call_in_action";
  }
  get asCallInAction() {
    if (this.isCallInAction) {
      return this;
    }
  }
  get isSummoning() {
    return this.type === "call_in_action" && this.system.actor_type === "spirit";
  }
  get isCompilation() {
    return this.type === "call_in_action" && this.system.actor_type === "sprite";
  }
  get isSpritePower() {
    return this.wrapper.isSpritePower();
  }
  get asSpritePower() {
    if (this.isSpritePower) {
      return this;
    }
  }
  get isBioware() {
    return this.wrapper.isBioware();
  }
  get isComplexForm() {
    return this.wrapper.isComplexForm();
  }
  get asComplexForm() {
    if (this.isComplexForm) {
      return this;
    }
  }
  get isContact() {
    return this.wrapper.isContact();
  }
  get asContact() {
    if (this.isContact) {
      return this;
    }
  }
  /**
  * Retrieve the actor document linked to this item.
  * e.g.: Contact items provide linked actors
  */
  async getLinkedActor() {
    const uuid = this.wrapper.getLinkedActorUuid();
    if (uuid && this.asContact && foundry.utils.parseUuid(uuid).documentType === "Actor") {
      return await fromUuid(uuid);
    }
  }
  get isCritterPower() {
    return this.wrapper.isCritterPower();
  }
  get asCritterPower() {
    if (this.isCritterPower) {
      return this;
    }
  }
  get isDevice() {
    return this.wrapper.isDevice();
  }
  get asDevice() {
    if (this.isDevice) {
      return this;
    }
  }
  asController() {
    return this.asHost || this.asDevice || void 0;
  }
  isEquipment() {
    return this.wrapper.isEquipment();
  }
  get asEquipment() {
    if (this.isEquipment()) {
      return this;
    }
  }
  isEquipped() {
    return this.wrapper.isEquipped();
  }
  isWireless() {
    return this.wrapper.isWireless();
  }
  isCyberdeck() {
    return this.wrapper.isCyberdeck();
  }
  isRCC() {
    return this.wrapper.isRCC();
  }
  isCommlink() {
    return this.wrapper.isCommlink();
  }
  isMatrixAction() {
    return this.wrapper.isMatrixAction();
  }
  getSource() {
    return this.wrapper.getSource();
  }
  setSource(source3) {
    if (!this.system.description) this.system.description = { chat: "", source: "", value: "" };
    this.update({ "system.description.source": source3 });
    this.render(true);
  }
  getConditionMonitor() {
    return this.wrapper.getConditionMonitor();
  }
  getRating() {
    return this.wrapper.getRating();
  }
  getArmorValue() {
    return this.wrapper.getArmorValue();
  }
  getArmorElements() {
    return this.wrapper.getArmorElements();
  }
  getEssenceLoss() {
    return this.wrapper.getEssenceLoss();
  }
  getASDF() {
    return this.wrapper.getASDF();
  }
  getActionSkill() {
    return this.wrapper.getActionSkill();
  }
  getActionAttribute() {
    return this.wrapper.getActionAttribute();
  }
  getActionAttribute2() {
    return this.wrapper.getActionAttribute2();
  }
  getModifierList() {
    return this.wrapper.getModifierList();
  }
  getActionSpecialization() {
    return this.wrapper.getActionSpecialization();
  }
  get getDrain() {
    return this.wrapper.getDrain();
  }
  getFade() {
    return this.wrapper.getFade();
  }
  /**
   * Amount of current recoil left after recoil compensation.
   */
  get unhandledRecoil() {
    if (!this.isRangedWeapon) return 0;
    return Math.max(this.actor.recoil - this.totalRecoilCompensation, 0);
  }
  /**
   * Amount of recoil compensation configured via weapon system data.
   */
  get recoilCompensation() {
    if (!this.isRangedWeapon) return 0;
    return this.wrapper.getRecoilCompensation();
  }
  /**
   * Amount of recoil compensation totally available when using weapon
   *
   * This includes both actor and item recoil compensation.
   */
  get totalRecoilCompensation() {
    if (!this.isRangedWeapon) return 0;
    return RangedWeaponRules.recoilCompensation(this);
  }
  /**
   * Current TOTAL recoil compensation with current recoil included.
   *
   * This includes both the items and it's parent actors recoil compensation and total progressive recoil.
   *
   * @returns A positive number or zero.
   */
  get currentRecoilCompensation() {
    if (!this.actor || !this.isRangedWeapon) return 0;
    return Math.max(this.totalRecoilCompensation - this.actor.recoil, 0);
  }
  getReach() {
    if (this.isMeleeWeapon) {
      const system = this.system;
      return system.melee.reach ?? 0;
    }
    return 0;
  }
  getCondition() {
    const technology = this.getTechnologyData();
    if (technology && "condition_monitor" in technology)
      return technology.condition_monitor;
  }
  hasOpposedTest() {
    if (!this.hasOpposedRoll) return false;
    const action = this.getAction();
    if (!action) return false;
    return action.opposed.test !== "";
  }
  /**
   * A host type item can store IC actors to spawn in order, use this method to add into that.
   * @param id An IC type actor id to fetch the actor with.
   * @param pack Optional pack collection to fetch from
   */
  async addIC(id, pack = null) {
    const host = this.asHost;
    if (!host || !id) return;
    const actor = pack ? await Helpers.getEntityFromCollection(pack, id) : game.actors?.get(id);
    if (!actor || !actor.isIC()) {
      console.error(`Provided actor id ${id} doesn't exist (with pack collection '${pack}') or isn't an IC type`);
      return;
    }
    const icData = actor.asIC();
    if (!icData) return;
    const sourceEntity = DataDefaults.sourceItemData({
      id: actor.id,
      name: actor.name,
      type: "Actor",
      pack,
      // Custom fields for IC
      // @ts-expect-error foundry-vtt
      system: { icType: icData.system.icType }
    });
    host.system.ic.push(sourceEntity);
    await this.update({ "system.ic": host.system.ic });
  }
  /**
   * A host type item can contain IC in an order. Use this function remove IC at the said position
   * @param index The position in the IC order to be removed
   */
  async removeIC(index) {
    if (isNaN(index) || index < 0) return;
    const host = this.asHost;
    if (!host) return;
    if (host.system.ic.length <= index) return;
    host.system.ic.splice(index, 1);
    await this.update({ "system.ic": host.system.ic });
  }
  get _isNestedItem() {
    return this.hasOwnProperty("parent") && this.parent instanceof _SR6Item;
  }
  /**
   * Hook into the Item.update process for embedded items.
   *
   * @param data changes made to the SR5ItemData
   */
  async updateNestedItem(data) {
    if (!this.parent || this.parent instanceof SR6Actor) return this;
    data._id = this.id;
    await this.parent.updateNestedItems(data);
    await this.sheet?.render(false);
    return this;
  }
  async update(data, options) {
    if (this._isNestedItem) {
      return this.updateNestedItem(data);
    }
    return await super.update(data, options);
  }
  /**
   * Place a Matrix Mark for this Item.
   *
   * @param target The Document the marks are placed on. This can be an actor (character, technomancer, IC) OR an item (Host)
   * @param marks Amount of marks to be placed.
   * @param options Additional options that may be needed.
   * @param options.scene The scene the targeted actor lives on.
   * @param options.item
   *
   * TODO: It might be useful to create a 'MatrixDocument' class sharing matrix methods to avoid duplication between
   *       SR6Item and SR6Actor.
   */
  async setMarks(target, marks, options) {
    if (!canvas.ready) return;
    if (!this.isHost) {
      console.error("Only Host item types can place matrix marks!");
      return;
    }
    const scene = options?.scene || canvas.scene;
    const item = options?.item;
    const markId = Helpers.buildMarkId(scene.id, target.id, item?.id);
    const host = this.asHost;
    if (!host) return;
    const currentMarks = options?.overwrite ? 0 : this.getMarksById(markId);
    host.system.marks[markId] = MatrixRules.getValidMarksCount(currentMarks + marks);
    await this.update({ "system.marks": host.system.marks });
  }
  getMarksById(markId) {
    const host = this.asHost;
    return host ? host.system.marks[markId] : 0;
  }
  getAllMarks() {
    const host = this.asHost;
    if (!host) return;
    return host.system.marks;
  }
  /**
   * Receive the marks placed on either the given target as a whole or one it's owned items.
   *
   * @param target
   * @param item
   * @param options
   *
   * TODO: Check with technomancers....
   *
   * @return Will always return a number. At least zero, for no marks placed.
   */
  getMarks(target, item, options) {
    if (!canvas.ready) return 0;
    if (!this.isHost) return 0;
    const scene = options?.scene || canvas.scene;
    item = item || target.getMatrixDevice();
    const markId = Helpers.buildMarkId(scene.id, target.id, item?.id);
    const host = this.asHost;
    if (!host) return 0;
    return host.system.marks[markId] || 0;
  }
  /**
   * Remove ALL marks placed by this item.
   *
   * TODO: Allow partial deletion based on target / item
   */
  async clearMarks() {
    if (!this.isHost) return;
    const host = this.asHost;
    if (!host) return;
    const updateData = {};
    for (const markId of Object.keys(host.system.marks)) {
      updateData[`-=${markId}`] = null;
    }
    await this.update({ "system.marks": updateData });
  }
  /**
   * Remove ONE mark. If you want to delete all marks, use clearMarks instead.
   */
  async clearMark(markId) {
    if (!this.isHost) return;
    const updateData = {};
    updateData[`-=${markId}`] = null;
    await this.update({ "system.marks": updateData });
  }
  /**
   * Configure the given matrix item to be controlled by this item in a PAN/WAN.
   * @param target The matrix item to be connected.
   */
  async addNetworkDevice(target) {
    await NetworkDeviceFlow.addDeviceToNetwork(this, target);
  }
  /**
   * Alias method for addNetworkDevice, both do the same.
   * @param target
   */
  async addNetworkController(target) {
    await this.addNetworkDevice(target);
  }
  async removeNetworkDevice(index) {
    const controllerData = this.asController();
    if (!controllerData) return;
    if (controllerData.system.networkDevices[index] === void 0) return;
    const networkDeviceLink = controllerData.system.networkDevices[index];
    const controller = this;
    return await NetworkDeviceFlow.removeDeviceLinkFromNetwork(controller, networkDeviceLink);
  }
  async removeAllNetworkDevices() {
    const controllerData = this.asController();
    if (!controllerData) return;
    return await NetworkDeviceFlow.removeAllDevicesFromNetwork(this);
  }
  getAllMarkedDocuments() {
    if (!this.isHost) return [];
    const marks = this.getAllMarks();
    if (!marks) return [];
    return Object.entries(marks).filter(([markId, marks2]) => Helpers.isValidMarkId(markId)).map(([markId, marks2]) => ({
      ...Helpers.getMarkIdDocuments(markId),
      marks: marks2,
      markId
    }));
  }
  /**
   * Return the network controller item when connected to a PAN or WAN.
   */
  async networkController() {
    const technologyData = this.getTechnologyData();
    if (!technologyData) return;
    if (!technologyData.networkController) return;
    return await NetworkDeviceFlow.resolveLink(technologyData.networkController);
  }
  /**
   * Return all network device items within a possible PAN or WAN.
   */
  async networkDevices() {
    const controller = this.asDevice || this.asHost;
    if (!controller) return [];
    return NetworkDeviceFlow.getNetworkDevices(this);
  }
  /**
   * Only devices can control a network.
   */
  get canBeNetworkController() {
    return this.isDevice || this.isHost;
  }
  /**
   * Assume all items with that are technology (therefore have a rating) are active matrix devices.
   */
  get canBeNetworkDevice() {
    const technologyData = this.getTechnologyData();
    return !!technologyData;
  }
  /**
   * Disconnect any kind of item from a PAN or WAN.
   */
  async disconnectFromNetwork() {
    if (this.canBeNetworkController) await NetworkDeviceFlow.removeAllDevicesFromNetwork(this);
    if (this.canBeNetworkDevice) await NetworkDeviceFlow.removeDeviceFromController(this);
  }
  async _onCreate(changed, options, user) {
    const applyData = {};
    UpdateActionFlow.injectActionTestsIntoChangeData(this.type, changed, applyData, this);
    await super._preCreate(changed, options, user);
    if (!foundry.utils.isEmpty(applyData)) await this.update(applyData);
  }
  /**
   * Make sure all item data is in a persistent and valid status.
   *
   * This is preferred to altering data on the fly in the prepareData methods flow.
   */
  async _preUpdate(changed, options, user) {
    if (options.diff !== false && options.recursive !== false) {
      UpdateActionFlow.injectActionTestsIntoChangeData(this.type, changed, changed, this);
      UpdateActionFlow.onUpdateAlterActionData(changed, this);
    }
    await super._preUpdate(changed, options, user);
  }
};

// src/module/actor/prep/functions/InitiativePrep.ts
var InitiativePrep = class {
  static {
    __name(this, "InitiativePrep");
  }
  /**
   * Current initiative is the selected initiative to be used within FoundryVTT Combat.
   *
   */
  static prepareCurrentInitiative(system) {
    const { initiative } = system;
    if (initiative.perception === "matrix") initiative.current = initiative.matrix;
    else if (initiative.perception === "astral") initiative.current = initiative.astral;
    else {
      initiative.current = initiative.meatspace;
      initiative.perception = "meatspace";
    }
    initiative.current.base.value = Helpers.calcTotal(initiative.current.base);
    initiative.current.dice.value = Helpers.calcTotal(initiative.current.dice, { min: 0, max: 5 });
    if (initiative.edge) initiative.current.dice.value = 5;
    initiative.current.dice.value = Math.min(5, initiative.current.dice.value);
    initiative.current.dice.text = `${initiative.current.dice.value}d6`;
  }
  /**
   * Physical initiative
   */
  static prepareMeatspaceInit(system) {
    const { initiative, attributes, modifiers } = system;
    initiative.meatspace.base.base = attributes.intuition.value + attributes.reaction.value;
    initiative.meatspace.base.mod = PartsList.AddUniquePart(initiative.meatspace.base.mod, "SR6.Bonus", Number(modifiers["meat_initiative"]));
    initiative.meatspace.base.value = Helpers.calcTotal(initiative.meatspace.base);
    initiative.meatspace.dice.base = 1;
    initiative.meatspace.dice.mod = PartsList.AddUniquePart(initiative.meatspace.dice.mod, "SR6.Bonus", Number(modifiers["meat_initiative_dice"]));
    initiative.meatspace.dice.value = Helpers.calcTotal(initiative.meatspace.dice, { min: 0, max: 5 });
  }
  static prepareAstralInit(system) {
    const { initiative, attributes, modifiers } = system;
    initiative.astral.base.base = attributes.intuition.value * 2;
    initiative.astral.base.mod = PartsList.AddUniquePart(initiative.astral.base.mod, "SR6.Bonus", Number(modifiers["astral_initiative"]));
    initiative.astral.base.value = Helpers.calcTotal(initiative.astral.base);
    initiative.astral.dice.base = 2;
    initiative.astral.dice.mod = PartsList.AddUniquePart(initiative.astral.dice.mod, "SR6.Bonus", Number(modifiers["astral_initiative_dice"]));
    initiative.astral.dice.value = Helpers.calcTotal(initiative.astral.dice, { min: 0, max: 5 });
  }
  static prepareMatrixInit(system) {
    const { initiative, attributes, modifiers, matrix } = system;
    if (matrix) {
      initiative.matrix.base.base = attributes.intuition.value + system.matrix.data_processing.value;
      initiative.matrix.base.mod = PartsList.AddUniquePart(initiative.matrix.base.mod, "SR6.Bonus", Number(modifiers["matrix_initiative"]));
      initiative.matrix.base.value = Helpers.calcTotal(initiative.matrix.base);
      initiative.matrix.dice.base = matrix.hot_sim ? 4 : 3;
      initiative.matrix.dice.mod = PartsList.AddUniquePart(initiative.matrix.dice.mod, "SR6.Bonus", Number(modifiers["matrix_initiative_dice"]));
      initiative.matrix.dice.value = Helpers.calcTotal(initiative.matrix.dice, { min: 0, max: 5 });
    }
  }
};

// src/module/actor/prep/functions/ModifiersPrep.ts
var ModifiersPrep = class _ModifiersPrep {
  static {
    __name(this, "ModifiersPrep");
  }
  /**
   * Prepare the modifiers that are displayed in the Misc. tab
   *
   * NOTE: Currently these aren't controlled by the Foundry template. But ONLY here.
   *       Therefore adding a modifier to an actor DataModel happens here and during Actor#prepareData
   */
  static prepareModifiers(system) {
    let modifiers = _ModifiersPrep.commonModifiers;
    modifiers = modifiers.concat(_ModifiersPrep.matrixModifiers);
    modifiers = modifiers.concat(_ModifiersPrep.characterModifiers);
    _ModifiersPrep.setupModifiers(system, modifiers);
  }
  /**
   * Modifiers that appear on all actor types.
   */
  static get commonModifiers() {
    return [
      "defense",
      "defense_dodge",
      "defense_block",
      "defense_parry",
      "defense_melee",
      "defense_ranged",
      "soak"
    ];
  }
  /**
   * Modifiers that appear on all character actors.
   */
  static get characterModifiers() {
    return [
      "drain",
      "armor",
      "physical_limit",
      "social_limit",
      "mental_limit",
      "astral_limit",
      "stun_track",
      "physical_track",
      "physical_overflow_track",
      "meat_initiative",
      "meat_initiative_dice",
      "astral_initiative",
      "astral_initiative_dice",
      "composure",
      "lift_carry",
      "judge_intentions",
      "memory",
      "walk",
      "run",
      "wound_tolerance",
      "pain_tolerance_stun",
      "pain_tolerance_physical",
      "essence",
      "fade",
      "multi_defense",
      "reach"
    ];
  }
  /**
   * Modifiers that appear on all matrix actor types.
   */
  static get matrixModifiers() {
    return [
      "matrix_initiative",
      "matrix_initiative_dice",
      "matrix_track"
    ];
  }
  static setupModifiers(system, modifiers) {
    if (!system.modifiers) {
      system.modifiers = {};
    }
    modifiers.sort();
    modifiers.unshift("global");
    const sorted = {};
    for (const modifier of modifiers) {
      sorted[modifier] = Number(system.modifiers[modifier]) || 0;
    }
    system.modifiers = sorted;
  }
  static clearAttributeMods(system) {
    const { attributes } = system;
    for (const [name3, attribute] of Object.entries(attributes)) {
      if (!SR6.attributes.hasOwnProperty(name3) || !attribute) return;
      attribute.mod = [];
    }
  }
  static clearArmorMods(system) {
    const { armor: armor3 } = system;
    armor3.mod = [];
  }
  static clearLimitMods(system) {
    const { limits } = system;
    for (const [name3, limit] of Object.entries(limits)) {
      if (!SR6.limits.hasOwnProperty(name3) || !limit) return;
      limit.mod = [];
    }
  }
  /**
   * Clear out modifierse from all calculate values, no matter where from and what.
   *
   * This is necessary to avoid items and naive modifications doubling up shoudl they be
   * saved with update calls
   *
   */
  static clearValueMods(system) {
    for (const [name3, values] of Object.entries(system.values)) {
      values.mod = [];
    }
  }
};

// src/module/actor/prep/functions/ItemPrep.ts
var ItemPrep = class {
  static {
    __name(this, "ItemPrep");
  }
  /**
   * Prepare the armor data for the Item
   * - will only allow one "Base" armor item to be used (automatically takes the best one if multiple are equipped)
   * - all "accessories" will be added to the armor
   */
  static prepareArmor(system, items) {
    const { armor: armor3 } = system;
    armor3.base = 0;
    armor3.value = 0;
    for (const element of Object.keys(SR6.elementTypes)) {
      armor3[element] = 0;
    }
    const armorModParts = new PartsList(armor3.mod);
    const equippedArmor = items.filter((item) => item.couldHaveArmor() && item.isEquipped());
    equippedArmor?.forEach((item) => {
      if (item.hasArmor()) {
        if (item.hasArmorAccessory()) {
          armorModParts.addUniquePart(item.getName(), item.getArmorValue());
        } else {
          const armorValue = item.getArmorValue();
          if (armorValue > armor3.base) {
            armor3.base = item.getArmorValue();
            armor3.label = item.getName();
            armor3.hardened = item.getHardened();
          }
        }
      }
      for (const element of Object.keys(SR6.elementTypes)) {
        armor3[element] += item.getArmorElements()[element];
      }
    });
    if (system.modifiers["armor"]) armorModParts.addUniquePart(game.i18n.localize("SR6.Bonus"), system.modifiers["armor"]);
    armor3.value = Helpers.calcTotal(armor3);
  }
  /**
   * Apply all changes to an actor by their 'ware items.
   *
   * Modify essence by items essence loss
   */
  static prepareWareEssenceLoss(system, items) {
    const parts = new PartsList(system.attributes.essence.mod);
    items.filter((item) => item.isBodyware() && item.isEquipped()).forEach((item) => {
      if (item.getEssenceLoss()) {
        parts.addPart(item.getName(), -item.getEssenceLoss());
      }
    });
    system.attributes.essence.mod = parts.list;
  }
};

// src/module/actor/prep/functions/AttributesPrep.ts
var AttributesPrep = class _AttributesPrep {
  static {
    __name(this, "AttributesPrep");
  }
  /**
   * Prepare actor data for attributes
   */
  static prepareAttributes(system, ranges) {
    const { attributes } = system;
    attributes.magic.hidden = true;
    attributes.resonance.hidden = true;
    attributes.edge.hidden = true;
    attributes.essence.hidden = true;
    for (let [name3, attribute] of Object.entries(attributes)) {
      if (name3 === "edge" && attribute["uses"] === void 0) return;
      _AttributesPrep.prepareAttribute(name3, attribute, ranges);
    }
  }
  /**
   * Prepare one single AttributeField
   * @param name The key field (and name) of the attribute given
   * @param attribute The AttributeField to prepare
   */
  static prepareAttribute(name3, attribute, ranges) {
    if (!SR6.attributes.hasOwnProperty(name3) || !attribute) return;
    _AttributesPrep.calculateAttribute(name3, attribute, ranges);
    attribute.label = SR6.attributes[name3];
  }
  /**
   * Calculate a single attributes value with all it's ranges and rules applied.
   *
   * @param name The attributes name / id
   * @param attribute The attribute will be modified in place
   */
  static calculateAttribute(name3, attribute, ranges) {
    if (!SR6.attributes.hasOwnProperty(name3) || !attribute) return;
    const range = ranges ? ranges[name3] : SR.attributes.ranges[name3];
    Helpers.calcTotal(attribute, range);
  }
  /**
   * Calculate the Essence attribute and it's modifiers.
   *
   * @param system A system actor having an essence attribute
   * @param items The items that might cause an essence loss.
   */
  static prepareEssence(system, items) {
    system.attributes.essence.base = SR.attributes.defaults.essence;
    const parts = new PartsList(system.attributes.essence.mod);
    const essenceMod = system.modifiers["essence"];
    if (essenceMod && !Number.isNaN(essenceMod)) {
      parts.addUniquePart("SR6.Bonus", Number(essenceMod));
    }
    system.attributes.essence.mod = parts.list;
    ItemPrep.prepareWareEssenceLoss(system, items);
    system.attributes.essence.value = Helpers.calcTotal(system.attributes.essence);
  }
};

// src/module/actor/prep/functions/MatrixPrep.ts
var MatrixPrep = class _MatrixPrep {
  static {
    __name(this, "MatrixPrep");
  }
  /**
   * Prepare Matrix data on the actor
   * - if an item is equipped, it will use that data
   * - if it isn't and player is technomancer, it will use that data
   */
  static prepareMatrix(system, items) {
    const { matrix, attributes, modifiers } = system;
    const MatrixList = ["firewall", "sleaze", "data_processing", "attack"];
    MatrixList.forEach((key) => {
      const parts = new PartsList(matrix[key].mod);
      if (matrix[key].temp) parts.addUniquePart("SR6.Temporary", matrix[key].temp);
      parts.removePart("Temporary");
      matrix[key].mod = parts.list;
      matrix[key].value = parts.total;
    });
    matrix.condition_monitor.max = 0;
    matrix.rating = 0;
    matrix.name = "";
    matrix.device = "";
    matrix.condition_monitor.label = "SR6.ConditionMonitor";
    const device = items.find((item) => item.isEquipped() && item.isDevice());
    if (device) {
      matrix.device = device.getId();
      const conditionMonitor = device.getConditionMonitor();
      matrix.condition_monitor.max = conditionMonitor.max + Number(modifiers.matrix_track);
      matrix.condition_monitor.value = conditionMonitor.value;
      matrix.rating = device.getRating();
      matrix.is_cyberdeck = device.isCyberdeck();
      matrix.name = device.getName();
      matrix.item = device.getData();
      const deviceAtts = device.getASDF();
      if (deviceAtts) {
        for (const [key, value] of Object.entries(deviceAtts)) {
          if (value && matrix[key]) {
            matrix[key].base = value.value;
            matrix[key].device_att = value.device_att;
          }
        }
      }
    } else if (system.special === "resonance") {
      matrix.firewall.base = Helpers.calcTotal(attributes.willpower);
      matrix.data_processing.base = Helpers.calcTotal(attributes.logic);
      matrix.rating = Helpers.calcTotal(attributes.resonance);
      matrix.attack.base = Helpers.calcTotal(attributes.charisma);
      matrix.sleaze.base = Helpers.calcTotal(attributes.intuition);
      matrix.name = game.i18n.localize("SR6.LivingPersona");
    }
    if (matrix.condition_monitor.value > matrix.condition_monitor.max) {
      matrix.condition_monitor.value = matrix.condition_monitor.max;
    }
  }
  /**
   * Add Matrix Attributes to Limits and Attributes
   * @param system
   */
  static prepareMatrixToLimitsAndAttributes(system) {
    const { matrix, attributes, limits } = system;
    Object.keys(SR6.matrixAttributes).forEach((attributeName) => {
      if (!matrix.hasOwnProperty(attributeName)) {
        return console.error(`SR6Actor matrix preparation failed due to missing matrix attributes`);
      }
      const attribute = matrix[attributeName];
      AttributesPrep.prepareAttribute(attributeName, attribute);
      const { value, base, mod, label } = attribute;
      const hidden = true;
      limits[attributeName] = {
        value,
        base,
        mod,
        label,
        hidden
      };
      attributes[attributeName] = {
        value,
        base,
        mod,
        label,
        hidden
      };
    });
  }
  static prepareMentalAttributesForDevice(system, rating) {
    const { matrix, attributes } = system;
    rating = rating ?? matrix.rating;
    const mentalAttributes = ["intuition", "logic", "charisma", "willpower"];
    mentalAttributes.forEach((attLabel) => {
      if (attributes[attLabel] !== void 0) {
        attributes[attLabel].base = rating ?? 0;
        Helpers.calcTotal(attributes[attLabel]);
      }
    });
  }
  static prepareMatrixAttributesForDevice(system, rating) {
    const { matrix } = system;
    rating = rating ?? matrix.rating;
    const matrixAttributes = ["firewall", "data_processing"];
    matrixAttributes.forEach((attribute) => {
      matrix[attribute].base = rating;
    });
    [...matrixAttributes, "sleaze", "attack"].forEach((attId) => {
      Helpers.calcTotal(matrix[attId]);
    });
  }
  /**
   * Prepare the mental attributes for a sheet that just has a device rating
   * @param system
   */
  static prepareAttributesForDevice(system, rating = 0) {
    _MatrixPrep.prepareMentalAttributesForDevice(system, rating);
    _MatrixPrep.prepareMatrixAttributesForDevice(system, rating);
  }
};

// src/module/actor/prep/functions/SkillsPrep.ts
var SkillsPrep = class {
  static {
    __name(this, "SkillsPrep");
  }
  /**
   * Prepare missing skill data as early in during data preparation as possible.
   *
   * template.json is incomplete, so we need to fill in the missing fields.
   * This is mostly a legacy design and should be fixed in the future when DataModel's are used.
   *
   * NOTE: Foundry also calls the prepareData multiple times with incomplete source data, causing some value properties to be missing.
   * @param system
   */
  static prepareSkillData(system) {
    const { language, active: active3, knowledge } = system.skills;
    Object.values(active3).forEach((skill) => {
      _mergeWithMissingSkillFields(skill);
    });
    if (language.value) Object.values(language.value).forEach((skill) => {
      _mergeWithMissingSkillFields(skill);
    });
    Object.values(knowledge).forEach((group) => {
      if (group.value) Object.values(group.value).forEach((skill) => {
        _mergeWithMissingSkillFields(skill);
      });
    });
  }
  /**
   * Prepare actor data for skills
   */
  static prepareSkills(system) {
    const { language, active: active3, knowledge } = system.skills;
    if (language) {
      if (!language.value) {
        language.value = {};
      }
      if (Array.isArray(language.value) && language.value.length == 0) {
        language.value = {};
      }
      language.attribute = "intuition";
    }
    const prepareSkill = /* @__PURE__ */ __name((skill) => {
      if (!skill.base) skill.base = 0;
      if (skill.bonus?.length) {
        for (let bonus of skill.bonus) {
          skill.mod = PartsList.AddUniquePart(skill.mod, bonus.key, Number(bonus.value));
        }
      }
      skill.value = Helpers.calcTotal(skill);
    }, "prepareSkill");
    for (const skill of Object.values(active3)) {
      if (!skill.hidden) {
        prepareSkill(skill);
      }
    }
    const entries = Object.entries(system.skills.language.value);
    entries.forEach(([key, val]) => val._delete && delete system.skills.language.value[key]);
    for (let skill of Object.values(language.value)) {
      prepareSkill(skill);
      skill.attribute = "intuition";
    }
    for (let [, group] of Object.entries(knowledge)) {
      if (!group?.value) {
        continue;
      }
      const entries2 = Object.entries(group.value);
      group.value = entries2.filter(([, val]) => !val._delete).reduce((acc, [id, skill]) => {
        prepareSkill(skill);
        skill.attribute = group.attribute;
        acc[id] = skill;
        return acc;
      }, {});
    }
    for (let [skillKey, skillValue] of Object.entries(active3)) {
      skillValue.label = SR6.activeSkills[skillKey];
    }
  }
};
var _mergeWithMissingSkillFields = /* @__PURE__ */ __name((givenSkill) => {
  const template = {
    name: "",
    base: 0,
    value: 0,
    attribute: "",
    mod: [],
    specs: [],
    hidden: false
  };
  foundry.utils.mergeObject(givenSkill, template, { overwrite: false });
}, "_mergeWithMissingSkillFields");

// src/module/actor/prep/functions/MovementPrep.ts
var MovementPrep = class {
  static {
    __name(this, "MovementPrep");
  }
  static prepareMovement(system) {
    const { attributes, modifiers } = system;
    const movement = system.movement;
    movement.walk.value = attributes.agility.value * (2 + Number(modifiers["walk"])) + new PartsList(movement.walk.mod).total;
    movement.run.value = attributes.agility.value * (4 + Number(modifiers["run"])) + new PartsList(movement.run.mod).total;
  }
};

// src/module/rules/MonitorRules.ts
var MonitorRules = {
  /**
   * Calculate the amount of damage boxes per wound modifier
   * 
   * According to SR5#169-170 'Wound Modifiers' and SR5#82 'Low Pain Tolerance'.
   * 
   * To avoid confusion between Low Pain and High Pain Tolerance, this method uses a
   * damage tolerance concept, allowing users to define how many boxes should determine
   * a wound modifier. This allows to define both lower and higher amounts of damage taken
   * per wound modifier.
   * 
   * @param damageTolerance Apply this damage tolerance to the base damage
   * @param baseDamage The amount of damage boxes taken before applying a wound modifier.
   */
  woundModifierBoxesThreshold(damageTolerance = 0, baseDamage = 3) {
    return baseDamage + damageTolerance;
  },
  /**
   * Calculate the wounds for damage taken on a monitor.
   * 
   * This differes from wound modifier and will be positive value.
   * 
   * This is intended for stund an physical monitors and implements rules 
   * - SR5#169 'Wound Modifiers
   * - SR#74 'High Pain Tolerance'
   * 
   * @param damageTaken Amount of damage boxes filled on the damage monitor
   * @param woundBoxesThreshold Amount of damage boxes per wound modifier
   * @param painTolerance Amount of damage boxes that can be ingored before calculating wound modifiers. 
   *                      Expects a positive number when applying High Pain Tolerance Ratings
   * @returns The amount of wounds on a damage monitor.
   */
  wounds(damageTaken, woundBoxesThreshold, painTolerance = 0) {
    const relevantDamageTaken = Math.max(damageTaken - painTolerance, 0);
    return Math.floor(relevantDamageTaken / woundBoxesThreshold);
  },
  /**
   * Calculate the wound modifier based on the wounds taken.
   * 
   * @param wounds Amount of wounds (not damage) taken
   * @param modifierPerWound base modifier to apply to given wounds
   */
  woundModifier(wounds, modifierPerWound = -1) {
    return wounds * modifierPerWound;
  }
};

// src/module/actor/prep/functions/WoundsPrep.ts
var WoundsPrep = class {
  static {
    __name(this, "WoundsPrep");
  }
  static prepareWounds(system) {
    const { modifiers, track } = system;
    const damageTolerance = Number(modifiers["wound_tolerance"]);
    const woundBoxesThreshold = MonitorRules.woundModifierBoxesThreshold(damageTolerance);
    track.stun.pain_tolerance = Number(modifiers["pain_tolerance_stun"]);
    track.physical.pain_tolerance = Number(modifiers["pain_tolerance_physical"]);
    const stunWounds = track.stun.disabled ? 0 : MonitorRules.wounds(track.stun.value, woundBoxesThreshold, track.stun.pain_tolerance);
    const physicalWounds = track.physical.disabled ? 0 : MonitorRules.wounds(track.physical.value, woundBoxesThreshold, track.physical.pain_tolerance);
    track.stun.wounds = stunWounds;
    track.physical.wounds = physicalWounds;
    system.wounds = {
      value: stunWounds + physicalWounds
    };
  }
};

// src/module/actor/prep/functions/NPCPrep.ts
var NPCPrep = class _NPCPrep {
  static {
    __name(this, "NPCPrep");
  }
  static prepareNPCData(system) {
    _NPCPrep.applyMetatypeModifiers(system);
  }
  /**
   * Apply modifiers that result from an NPCs metatype.
   * This method also should still run on any none NPC to remove eventually lingering NPC metatype modifiers.
   */
  static applyMetatypeModifiers(system) {
    const { attributes, metatype } = system;
    const metatypeModifier = SR.grunt.metatype_modifiers[metatype] || {};
    for (const [name3, attribute] of Object.entries(attributes)) {
      if (!Array.isArray(attribute.mod)) {
        console.error("Actor data contains wrong data type for attribute.mod", attribute, !Array.isArray(attribute.mod));
      } else {
        const parts = new PartsList(attribute.mod);
        parts.removePart(METATYPEMODIFIER);
        const modifyBy = metatypeModifier.attributes?.[name3];
        if (system.is_npc && modifyBy) {
          parts.addPart(METATYPEMODIFIER, modifyBy);
        }
        attribute.mod = parts.list;
        AttributesPrep.calculateAttribute(name3, attribute);
      }
    }
  }
};

// src/module/actor/prep/functions/ConditionMonitorsPrep.ts
var ConditionMonitorsPrep = class _ConditionMonitorsPrep {
  static {
    __name(this, "ConditionMonitorsPrep");
  }
  static prepareStun(system) {
    const { track, attributes, modifiers } = system;
    track.stun.base = 8 + Math.ceil(attributes.willpower.value / 2);
    track.stun.max = track.stun.base + Number(modifiers.stun_track);
    track.stun.label = SR6.damageTypes.stun;
    track.stun.disabled = false;
  }
  static preparePhysical(system) {
    const { track, attributes, modifiers } = system;
    track.physical.base = 8 + Math.ceil(attributes.body.value / 2);
    track.physical.max = track.physical.base + Number(modifiers.physical_track);
    track.physical.overflow.max = attributes.body.value + Number(modifiers.physical_overflow_track);
    track.physical.label = SR6.damageTypes.physical;
    track.physical.disabled = false;
  }
  static prepareGrunt(system) {
    _ConditionMonitorsPrep.prepareStun(system);
    const { track, attributes, modifiers } = system;
    track.stun.value = 0;
    track.stun.disabled = true;
    const attribute = attributes.willpower.value > attributes.body.value ? attributes.willpower : attributes.body;
    track.physical.base = 8 + Math.ceil(attribute.value / 2);
    track.physical.max = track.physical.base + Number(modifiers.physical_track);
    track.physical.overflow.max = attributes.body.value;
    track.physical.label = "SR6.ConditionMonitor";
    track.physical.disabled = false;
  }
};

// src/module/actor/prep/functions/GruntPrep.ts
var GruntPrep = {
  /**
   * If an NPC Grunt is selected, prepare the grunt condition monitor according to SR5#378 'Grunts'.
   * @param system To be altered system data.
   */
  prepareConditionMonitors: /* @__PURE__ */ __name((system) => {
    if (system.is_npc && system.npc.is_grunt) {
      ConditionMonitorsPrep.prepareGrunt(system);
    } else {
      ConditionMonitorsPrep.preparePhysical(system);
      ConditionMonitorsPrep.prepareStun(system);
    }
  }, "prepareConditionMonitors")
};

// src/module/actor/prep/CharacterPrep.ts
var CharacterPrep = class _CharacterPrep {
  static {
    __name(this, "CharacterPrep");
  }
  static prepareBaseData(system) {
    _CharacterPrep.addSpecialAttributes(system);
    SkillsPrep.prepareSkillData(system);
    ModifiersPrep.prepareModifiers(system);
    ModifiersPrep.clearAttributeMods(system);
    ModifiersPrep.clearArmorMods(system);
    ModifiersPrep.clearLimitMods(system);
    ModifiersPrep.clearValueMods(system);
  }
  /**
   * All derived data should depend on basic values like Attributes or Skills.
   *
   * It shouldn't be modified by Active Effects, which instead should modify the global modifiers.
   *
   * @param system
   * @param items
   */
  static prepareDerivedData(system, items) {
    AttributesPrep.prepareAttributes(system);
    AttributesPrep.prepareEssence(system, items);
    NPCPrep.prepareNPCData(system);
    SkillsPrep.prepareSkills(system);
    ItemPrep.prepareArmor(system, items);
    MatrixPrep.prepareMatrix(system, items);
    MatrixPrep.prepareMatrixToLimitsAndAttributes(system);
    GruntPrep.prepareConditionMonitors(system);
    MovementPrep.prepareMovement(system);
    WoundsPrep.prepareWounds(system);
    InitiativePrep.prepareMeatspaceInit(system);
    InitiativePrep.prepareAstralInit(system);
    InitiativePrep.prepareMatrixInit(system);
    InitiativePrep.prepareCurrentInitiative(system);
    _CharacterPrep.prepareRecoil(system);
    _CharacterPrep.prepareRecoilCompensation(system);
  }
  /**
   * Prepare the current progressive recoil of an actor.
   *
   * @param system Physical humanoid system data.
   */
  static prepareRecoil(system) {
    Helpers.calcTotal(system.values.recoil, { min: 0 });
  }
  /**
   * Prepare the base actor recoil compensation without item influence.
   *
   * @param system Character system data
   */
  static prepareRecoilCompensation(system) {
    const recoilCompensation = RangedWeaponRules.humanoidRecoilCompensationValue(system.attributes.strength.value);
    const baseRc = RangedWeaponRules.humanoidBaseRecoilCompensation();
    system.values.recoil_compensation.base = baseRc;
    PartsList.AddUniquePart(system.values.recoil_compensation.mod, "SR6.RecoilCompensation", recoilCompensation);
    Helpers.calcTotal(system.values.recoil_compensation, { min: 0 });
  }
  static addSpecialAttributes(system) {
    const { attributes } = system;
    attributes.initiation = DataDefaults.attributeData({ base: system.magic.initiation, label: "SR6.Initiation", hidden: true });
    attributes.submersion = DataDefaults.attributeData({ base: system.technomancer.submersion, label: "SR6.Submersion", hidden: true });
  }
};

// src/module/actor/prep/CritterPrep.ts
var CritterPrep = class {
  static {
    __name(this, "CritterPrep");
  }
  static prepareBaseData(system) {
    ModifiersPrep.prepareModifiers(system);
    ModifiersPrep.clearAttributeMods(system);
    ModifiersPrep.clearArmorMods(system);
    ModifiersPrep.clearLimitMods(system);
    SkillsPrep.prepareSkillData(system);
  }
  static prepareDerivedData(system, items) {
    AttributesPrep.prepareAttributes(system);
    AttributesPrep.prepareEssence(system, items);
    SkillsPrep.prepareSkills(system);
    ItemPrep.prepareArmor(system, items);
    MatrixPrep.prepareMatrix(system, items);
    MatrixPrep.prepareMatrixToLimitsAndAttributes(system);
    GruntPrep.prepareConditionMonitors(system);
    MovementPrep.prepareMovement(system);
    WoundsPrep.prepareWounds(system);
    InitiativePrep.prepareMeatspaceInit(system);
    InitiativePrep.prepareAstralInit(system);
    InitiativePrep.prepareMatrixInit(system);
    InitiativePrep.prepareCurrentInitiative(system);
    CharacterPrep.prepareRecoil(system);
    CharacterPrep.prepareRecoilCompensation(system);
  }
};

// src/module/actor/prep/SpiritPrep.ts
var SpiritPrep = class _SpiritPrep {
  static {
    __name(this, "SpiritPrep");
  }
  static prepareBaseData(system) {
    _SpiritPrep.prepareSpiritSpecial(system);
    SkillsPrep.prepareSkillData(system);
    ModifiersPrep.prepareModifiers(system);
    ModifiersPrep.clearAttributeMods(system);
    ModifiersPrep.clearArmorMods(system);
    ModifiersPrep.clearLimitMods(system);
  }
  static prepareDerivedData(system, items) {
    _SpiritPrep.prepareSpiritBaseData(system);
    AttributesPrep.prepareAttributes(system, SR.attributes.rangesSpirit);
    _SpiritPrep.prepareAttributesWithForce(system);
    SkillsPrep.prepareSkills(system);
    _SpiritPrep.prepareSpiritArmor(system);
    GruntPrep.prepareConditionMonitors(system);
    MovementPrep.prepareMovement(system);
    WoundsPrep.prepareWounds(system);
    InitiativePrep.prepareCurrentInitiative(system);
    CharacterPrep.prepareRecoil(system);
    CharacterPrep.prepareRecoilCompensation(system);
  }
  static prepareSpiritSpecial(data) {
    data.special = "magic";
  }
  static prepareSpiritBaseData(data) {
    const overrides = this.getSpiritStatModifiers(data.spiritType);
    if (overrides) {
      const { attributes, skills, initiative, force, modifiers } = data;
      for (const [attId, value] of Object.entries(overrides.attributes)) {
        if (attributes[attId] !== void 0) {
          attributes[attId].base = value + force;
        }
      }
      for (const skillId of overrides.skills) {
        const skill = _SpiritPrep.prepareActiveSkill(skillId, skills.active);
        if (skill === void 0) continue;
        if (SkillFlow.isCustomSkill(skill)) continue;
        skill.base = force;
        skills.active[skillId] = skill;
      }
      initiative.meatspace.base.base = force * 2 + overrides.init + Number(modifiers["astral_initiative"]);
      initiative.meatspace.base.mod = PartsList.AddUniquePart(initiative.meatspace.base.mod, "SR6.Bonus", Number(modifiers["meat_initiative"]));
      initiative.meatspace.dice.base = 2;
      initiative.meatspace.dice.mod = PartsList.AddUniquePart(initiative.meatspace.dice.mod, "SR6.Bonus", Number(modifiers["meat_initiative_dice"]));
      initiative.astral.base.base = force * 2 + overrides.astral_init + Number(modifiers["astral_initiative_dice"]);
      initiative.astral.base.mod = PartsList.AddUniquePart(initiative.astral.base.mod, "SR6.Bonus", Number(modifiers["astral_initiative"]));
      initiative.astral.dice.base = 3;
      initiative.astral.dice.mod = PartsList.AddUniquePart(initiative.astral.dice.mod, "SR6.Bonus", Number(modifiers["astral_initiative_dice"]));
    }
  }
  /**
   * Spirits can have some none default skills. The must be created first and don't count as custom skills.
   * @param skillId Whatever skill id should be used.
   * @param skills The list of active skills of the sprite.
   * @returns A prepared SkillField without levels.
   */
  static prepareActiveSkill(skillId, skills) {
    if (skills[skillId]) return skills[skillId];
    const label = SR6.activeSkills[skillId];
    const attribute = SR6.activeSkillAttribute[skillId];
    return DataDefaults.skillData({ label, attribute, canDefault: false });
  }
  static prepareSpiritArmor(data) {
    const { armor: armor3, attributes } = data;
    armor3.base = (attributes.essence.value ?? 0) * 2;
    armor3.value = Helpers.calcTotal(armor3);
    armor3.hardened = true;
  }
  /**
   * get the attribute and initiative modifiers and skills
   */
  static getSpiritStatModifiers(spiritType) {
    if (!spiritType) return;
    const overrides = {
      // value of 0 for attribute makes it equal to the Force
      attributes: {
        body: 0,
        agility: 0,
        reaction: 0,
        strength: 0,
        willpower: 0,
        logic: 0,
        intuition: 0,
        charisma: 0,
        magic: 0,
        essence: 0
      },
      // modifiers for after the Force x 2 calculation
      init: 0,
      astral_init: 0,
      // skills are all set to Force
      skills: []
    };
    switch (spiritType) {
      case "air":
        overrides.attributes.body = -2;
        overrides.attributes.agility = 3;
        overrides.attributes.reaction = 4;
        overrides.attributes.strength = -3;
        overrides.init = 4;
        overrides.skills.push("assensing", "astral_combat", "exotic_range", "perception", "unarmed_combat");
        break;
      case "aircraft":
        overrides.attributes.body = 2;
        overrides.attributes.agility = 1;
        overrides.attributes.strength = 1;
        overrides.attributes.logic = -2;
        overrides.skills.push("free_fall", "navigation", "perception", "pilot_aircraft", "unarmed_combat");
        break;
      case "airwave":
        overrides.attributes.body = 2;
        overrides.attributes.agility = 3;
        overrides.attributes.reaction = 4;
        overrides.attributes.strength = -3;
        overrides.init = 4;
        overrides.skills.push("assensing", "astral_combat", "exotic_range", "impersonation", "perception", "running", "unarmed_combat");
        break;
      case "automotive":
        overrides.attributes.body = 1;
        overrides.attributes.agility = 2;
        overrides.attributes.reaction = 1;
        overrides.attributes.logic = -2;
        overrides.init = 1;
        overrides.skills.push("navigation", "perception", "pilot_ground_craft", "running", "unarmed_combat");
        break;
      case "beasts":
        overrides.attributes.body = 2;
        overrides.attributes.agility = 1;
        overrides.attributes.strength = 2;
        overrides.skills.push("assensing", "astral_combat", "perception", "unarmed_combat");
        break;
      case "ceramic":
        overrides.attributes.agility = 1;
        overrides.attributes.reaction = 2;
        overrides.init = 2;
        overrides.skills.push("assensing", "astral_combat", "exotic_range", "perception", "unarmed_combat");
        break;
      case "earth":
        overrides.attributes.body = 4;
        overrides.attributes.agility = -2;
        overrides.attributes.reaction = -1;
        overrides.attributes.strength = 4;
        overrides.attributes.logic = -1;
        overrides.init = -1;
        overrides.skills.push("assensing", "astral_combat", "exotic_range", "perception", "unarmed_combat");
        break;
      case "energy":
        overrides.attributes.body = 1;
        overrides.attributes.agility = 2;
        overrides.attributes.reaction = 3;
        overrides.attributes.strength = -2;
        overrides.attributes.intuition = 1;
        overrides.init = 3;
        overrides.skills.push("assensing", "astral_combat", "exotic_range", "perception", "unarmed_combat");
        break;
      case "fire":
        overrides.attributes.body = 1;
        overrides.attributes.agility = 2;
        overrides.attributes.reaction = 3;
        overrides.attributes.strength = -2;
        overrides.attributes.intuition = 1;
        overrides.init = 3;
        overrides.skills.push("assensing", "astral_combat", "exotic_range", "flight", "perception", "unarmed_combat");
        break;
      case "guardian":
        overrides.attributes.body = 1;
        overrides.attributes.agility = 2;
        overrides.attributes.reaction = 3;
        overrides.attributes.strength = 2;
        overrides.init = 1;
        overrides.skills.push("assensing", "astral_combat", "blades", "clubs", "counter_spelling", "exotic_range", "perception", "unarmed_combat");
        break;
      case "guidance":
        overrides.attributes.body = 3;
        overrides.attributes.agility = -1;
        overrides.attributes.reaction = 2;
        overrides.attributes.strength = 1;
        overrides.skills.push("arcana", "assensing", "astral_combat", "counter_spelling", "perception", "unarmed_combat");
        break;
      case "man":
        overrides.attributes.body = 1;
        overrides.attributes.reaction = 2;
        overrides.attributes.strength = -2;
        overrides.attributes.intuition = 1;
        overrides.init = 2;
        overrides.skills.push("assensing", "astral_combat", "perception", "spellcasting", "unarmed_combat");
        break;
      case "metal":
        overrides.attributes.body = 4;
        overrides.attributes.agility = -2;
        overrides.attributes.reaction = -1;
        overrides.attributes.strength = 4;
        overrides.attributes.logic = -1;
        overrides.init = -1;
        overrides.skills.push("assensing", "astral_combat", "exotic_range", "perception", "unarmed_combat");
        break;
      case "plant":
        overrides.attributes.body = 2;
        overrides.attributes.agility = -1;
        overrides.attributes.strength = 1;
        overrides.attributes.logic = -1;
        overrides.skills.push("assensing", "astral_combat", "perception", "exotic_range", "unarmed_combat");
        break;
      case "ship":
        overrides.attributes.body = 4;
        overrides.attributes.agility = -1;
        overrides.attributes.reaction = -1;
        overrides.attributes.strength = 2;
        overrides.attributes.logic = -2;
        overrides.init = -1;
        overrides.skills.push("navigation", "perception", "pilot_water_craft", "survival", "swimming", "unarmed_combat");
        break;
      case "task":
        overrides.attributes.reaction = 2;
        overrides.attributes.strength = 2;
        overrides.init = 2;
        overrides.skills.push("artisan", "assensing", "astral_combat", "perception", "unarmed_combat");
        break;
      case "train":
        overrides.attributes.body = 3;
        overrides.attributes.agility = -1;
        overrides.attributes.reaction = -1;
        overrides.attributes.strength = 2;
        overrides.attributes.willpower = 1;
        overrides.attributes.logic = -2;
        overrides.init = -1;
        overrides.skills.push("intimidation", "navigation", "perception", "pilot_ground_craft", "unarmed_combat");
        break;
      case "water":
        overrides.attributes.agility = 1;
        overrides.attributes.reaction = 2;
        overrides.init = 2;
        overrides.skills.push("assensing", "astral_combat", "exotic_range", "perception", "unarmed_combat");
        break;
      case "toxic_air":
        overrides.attributes.body = -2;
        overrides.attributes.agility = 3;
        overrides.attributes.reaction = 4;
        overrides.attributes.strength = -3;
        overrides.init = 4;
        overrides.skills.push("assensing", "astral_combat", "exotic_range", "perception", "running", "unarmed_combat");
        break;
      case "toxic_beasts":
        overrides.attributes.body = 2;
        overrides.attributes.agility = 1;
        overrides.attributes.strength = 2;
        overrides.skills.push("assensing", "astral_combat", "exotic_range", "gymnastics", "perception", "running", "unarmed_combat");
        break;
      case "toxic_earth":
        overrides.attributes.body = 4;
        overrides.attributes.agility = -2;
        overrides.attributes.reaction = -1;
        overrides.attributes.strength = 4;
        overrides.attributes.logic = -1;
        overrides.init = -1;
        overrides.skills.push("assensing", "astral_combat", "exotic_range", "perception", "unarmed_combat");
        break;
      case "toxic_fire":
        overrides.attributes.body = 1;
        overrides.attributes.agility = 2;
        overrides.attributes.reaction = 3;
        overrides.attributes.strength = -2;
        overrides.attributes.intuition = 1;
        overrides.init = 3;
        overrides.skills.push("assensing", "astral_combat", "exotic_range", "perception", "flight", "unarmed_combat");
        break;
      case "toxic_man":
        overrides.attributes.reaction = 2;
        overrides.attributes.strength = -2;
        overrides.attributes.intuition = 1;
        overrides.init = 2;
        overrides.skills.push("assensing", "astral_combat", "perception", "spell_casting", "unarmed_combat");
        break;
      case "toxic_water":
        overrides.attributes.body = 1;
        overrides.attributes.agility = 1;
        overrides.attributes.reaction = 2;
        overrides.init = 2;
        overrides.skills.push("assensing", "astral_combat", "exotic_range", "perception", "unarmed_combat");
        break;
      case "blood":
        overrides.attributes.body = 2;
        overrides.attributes.agility = 2;
        overrides.attributes.strength = 2;
        overrides.attributes.logic = -1;
        overrides.skills.push("assensing", "astral_combat", "perception", "running", "unarmed_combat");
        break;
      case "muse":
        overrides.attributes.agility = 3;
        overrides.attributes.reaction = 2;
        overrides.attributes.willpower = 1;
        overrides.init = 3;
        overrides.skills.push("assensing", "astral_combat", "con", "gymnastics", "intimidation", "perception", "unarmed_combat");
        break;
      case "nightmare":
        overrides.attributes.agility = 3;
        overrides.attributes.reaction = 2;
        overrides.attributes.willpower = 1;
        overrides.attributes.intuition = 1;
        overrides.attributes.charisma = 2;
        overrides.init = 3;
        overrides.skills.push("assensing", "astral_combat", "con", "gymnastics", "intimidation", "perception", "unarmed_combat");
        break;
      case "shade":
        overrides.attributes.agility = 3;
        overrides.attributes.reaction = 2;
        overrides.attributes.willpower = 1;
        overrides.attributes.intuition = 1;
        overrides.attributes.charisma = 2;
        overrides.init = 3;
        overrides.skills.push("assensing", "astral_combat", "con", "gymnastics", "intimidation", "perception", "unarmed_combat");
        break;
      case "succubus":
        overrides.attributes.agility = 3;
        overrides.attributes.reaction = 2;
        overrides.attributes.willpower = 1;
        overrides.attributes.intuition = 1;
        overrides.attributes.charisma = 2;
        overrides.init = 3;
        overrides.skills.push("assensing", "astral_combat", "con", "gymnastics", "intimidation", "perception", "unarmed_combat");
        break;
      case "wraith":
        overrides.attributes.agility = 3;
        overrides.attributes.reaction = 2;
        overrides.attributes.willpower = 1;
        overrides.attributes.intuition = 1;
        overrides.attributes.charisma = 2;
        overrides.init = 3;
        overrides.skills.push("assensing", "astral_combat", "con", "gymnastics", "intimidation", "perception", "unarmed_combat");
        break;
      case "shedim":
        overrides.attributes.reaction = 2;
        overrides.attributes.strength = 1;
        overrides.init = 2;
        overrides.skills.push("assensing", "astral_combat", "perception", "unarmed_combat");
        break;
      case "master_shedim":
        overrides.attributes.reaction = 2;
        overrides.attributes.strength = 1;
        overrides.attributes.logic = 1;
        overrides.attributes.intuition = 1;
        overrides.init = 3;
        overrides.skills.push("assensing", "astral_combat", "counterspelling", "perception", "spellcasting", "unarmed_combat");
        break;
      // insect
      case "caretaker":
        overrides.attributes.agility = 1;
        overrides.attributes.reaction = 1;
        overrides.init = 1;
        overrides.skills.push("assensing", "astral_combat", "leadership", "perception", "unarmed_combat");
        break;
      case "nymph":
        overrides.attributes.body = 1;
        overrides.attributes.reaction = 3;
        overrides.attributes.strength = 1;
        overrides.init = 3;
        overrides.skills.push("assensing", "astral_combat", "perception", "gymnastics", "spellcasting", "unarmed_combat");
        break;
      case "scout":
        overrides.attributes.agility = 2;
        overrides.attributes.reaction = 2;
        overrides.init = 2;
        overrides.skills.push("assensing", "astral_combat", "perception", "gymnastics", "sneaking", "unarmed_combat");
        break;
      case "soldier":
        overrides.attributes.body = 3;
        overrides.attributes.agility = 1;
        overrides.attributes.reaction = 1;
        overrides.attributes.strength = 3;
        overrides.init = 1;
        overrides.skills.push("assensing", "astral_combat", "counterspelling", "exotic_range", "gymnastics", "perception", "unarmed_combat");
        break;
      case "worker":
        overrides.attributes.strength = 1;
        overrides.skills.push("assensing", "astral_combat", "perception", "unarmed_combat");
        break;
      case "queen":
        overrides.attributes.body = 5;
        overrides.attributes.agility = 3;
        overrides.attributes.reaction = 4;
        overrides.attributes.strength = 5;
        overrides.attributes.willpower = 1;
        overrides.attributes.logic = 1;
        overrides.attributes.intuition = 1;
        overrides.init = 5;
        overrides.skills.push(
          "assensing",
          "astral_combat",
          "con",
          "counterspelling",
          "gymnastics",
          "leadership",
          "negotiation",
          "perception",
          "spellcasting",
          "unarmed_combat"
        );
        break;
      case "carcass":
        overrides.attributes.body = 3;
        overrides.attributes.strength = 2;
        overrides.attributes.charisma = -1;
        overrides.skills.push("assensing", "astral_combat", "perception", "unarmed_combat");
        break;
      case "corpse":
        overrides.attributes.body = 2;
        overrides.attributes.agility = -1;
        overrides.attributes.reaction = 2;
        overrides.attributes.strength = -2;
        overrides.attributes.intuition = 1;
        overrides.attributes.charisma = -1;
        overrides.init = 2;
        overrides.skills.push("assensing", "astral_combat", "perception", "unarmed_combat");
        break;
      case "rot":
        overrides.attributes.body = 3;
        overrides.attributes.agility = -2;
        overrides.attributes.strength = 1;
        overrides.attributes.logic = -1;
        overrides.attributes.charisma = -1;
        overrides.skills.push("assensing", "astral_combat", "counterspelling", "exotic_range", "perception", "unarmed_combat");
        break;
      case "palefile":
        overrides.attributes.body = 2;
        overrides.attributes.agility = 1;
        overrides.attributes.reaction = 3;
        overrides.attributes.strength = -2;
        overrides.attributes.intuition = 1;
        overrides.attributes.charisma = -1;
        overrides.init = 3;
        overrides.skills.push("assensing", "astral_combat", "exotic_range", "flight", "perception", "unarmed_combat");
        break;
      case "detritus":
        overrides.attributes.body = 5;
        overrides.attributes.agility = -3;
        overrides.attributes.reaction = -1;
        overrides.attributes.strength = 4;
        overrides.attributes.logic = -1;
        overrides.attributes.charisma = -1;
        overrides.init = -1;
        overrides.skills.push("assensing", "astral_combat", "exotic_range", "perception", "unarmed_combat");
        break;
      // Howling Shadow
      case "anarch":
        overrides.attributes.body = -1;
        overrides.attributes.agility = -1;
        overrides.attributes.reaction = 1;
        overrides.attributes.strength = -1;
        overrides.init = 1;
        overrides.skills.push("assensing", "automatics", "blades", "clubs", "con", "demolitions", "disguise", "forgery", "gymnastics", "impersonation", "locksmith", "palming", "perception", "pistols", "sneaking", "throwing_weapons", "unarmed_combat");
        break;
      case "arboreal":
        overrides.attributes.body = 2;
        overrides.attributes.strength = 1;
        overrides.attributes.essence = -2;
        overrides.skills.push("assensing", "astral_combat", "blade", "clubs", "unarmed_combat", "exotic_range", "perception");
        break;
      case "blackjack":
        overrides.attributes.body = 2;
        overrides.attributes.agility = 1;
        overrides.attributes.reaction = 1;
        overrides.init = 1;
        overrides.skills.push("assensing", "automatics", "blades", "clubs", "computer", "first_aid", "gymnastics", "intimidation", "locksmith", "longarms", "perception", "pilot_ground_craft", "pistols", "sneaking", "throwing_weapons", "unarmed_combat");
        break;
      case "boggle":
        overrides.attributes.body = -2;
        overrides.attributes.agility = -1;
        overrides.attributes.reaction = -1;
        overrides.attributes.strength = -2;
        overrides.attributes.willpower = 2;
        overrides.init = -1;
        overrides.skills.push("assensing", "astral_combat", "blades", "clubs", "unarmed_combat", "gymnastics", "perception");
        break;
      case "bugul":
        overrides.attributes.agility = -1;
        overrides.attributes.reaction = -1;
        overrides.attributes.strength = -2;
        overrides.attributes.willpower = 1;
        overrides.attributes.logic = 2;
        overrides.skills.push("artisan", "assensing", "astral_combat", "con", "counterspelling", "disenchanting", "gymnastics", "negotiation", "perception", "unarmed_combat");
        break;
      case "chindi":
        overrides.attributes.body = 2;
        overrides.attributes.agility = 1;
        overrides.attributes.reaction = 2;
        overrides.attributes.strength = 1;
        overrides.init = 2;
        overrides.skills.push("archery", "blades", "clubs", "first_aid", "gymnastics", "intimidation", "perception", "sneaking", "throwing_weapons", "unarmed_combat");
        break;
      // HS#119: This spirit types has fixed values that don't use general spirit rules...
      case "corpselight":
        break;
      case "croki":
        overrides.attributes.reaction = 2;
        overrides.attributes.strength = 2;
        overrides.init = 2;
        overrides.skills.push("artificing", "assensing", "astral_combat", "gymnastics", "perception", "ritual_spellcasting", "spellcasting");
        break;
      case "duende":
        overrides.attributes.reaction = 2;
        overrides.attributes.strength = 2;
        overrides.init = 2;
        overrides.skills.push("assensing", "astral_combat", "con", "gymnastics", "perception");
        break;
      case "elvar":
        overrides.attributes.reaction = 2;
        overrides.attributes.strength = 2;
        overrides.init = 2;
        overrides.skills.push("assensing", "astral_combat", "con", "counterspelling", "disenchanting", "gymnastics", "perception", "spellcasting");
        break;
      case "erinyes":
        overrides.attributes.body = -1;
        overrides.attributes.agility = 3;
        overrides.attributes.reaction = 2;
        overrides.init = 2;
        overrides.skills.push("assensing", "astral_combat", "flight", "gymnastics", "perception", "sneaking", "unarmed_combat");
        break;
      case "greenman":
        overrides.attributes.body = 3;
        overrides.attributes.agility = -1;
        overrides.attributes.reaction = 2;
        overrides.attributes.strength = 4;
        overrides.init = 2;
        overrides.skills.push("assensing", "astral_combat", "counterspelling", "gymnastics", "leadership", "perception", "unarmed_combat");
        break;
      case "imp":
        overrides.attributes.reaction = 3;
        overrides.init = 3;
        overrides.skills.push("alchemy", "assensing", "astral_combat", "con", "counterspelling", "disenchanting", "gymnastics", "intimidation", "perception", "spellcasting", "unarmed_combat");
        break;
      case "jarl":
        overrides.attributes.body = 2;
        overrides.attributes.agility = -2;
        overrides.attributes.reaction = 3;
        overrides.attributes.strength = 2;
        overrides.init = 4;
        overrides.skills.push("assensing", "astral_combat", "counterspelling", "gymnastics", "leadership", "perception", "unarmed_combat");
        break;
      case "kappa":
        overrides.attributes.body = 5;
        overrides.attributes.reaction = -1;
        overrides.attributes.strength = 1;
        overrides.attributes.essence = -2;
        overrides.init = -1;
        overrides.skills.push("assensing", "astral_combat", "exotic_range", "gymnastics", "perception", "unarmed_combat");
        break;
      case "kokopelli":
        overrides.attributes.body = -1;
        overrides.attributes.agility = 2;
        overrides.attributes.reaction = 2;
        overrides.init = 2;
        overrides.skills.push("artisan", "assensing", "astral_combat", "leadership", "perception", "unarmed_combat");
        break;
      case "morbi":
        overrides.attributes.reaction = 1;
        overrides.attributes.strength = -2;
        overrides.attributes.intuition = 1;
        overrides.attributes.charisma = 2;
        overrides.init = 2;
        overrides.skills.push("assensing", "astral_combat", "perception", "ritual_spellcasting", "sneaking", "unarmed_combat");
        break;
      case "nocnitasa":
        overrides.attributes.body = -3;
        overrides.attributes.agility = 4;
        overrides.attributes.reaction = 5;
        overrides.attributes.strength = -2;
        overrides.attributes.willpower = -1;
        overrides.init = 5;
        overrides.skills.push("assensing", "astral_combat", "perception", "sneaking", "unarmed_combat");
        break;
      case "phantom":
        overrides.attributes.body = 1;
        overrides.attributes.reaction = 2;
        overrides.attributes.strength = -2;
        overrides.init = 2;
        overrides.skills.push("assensing", "astral_combat", "gymnastics", "perception", "unarmed_combat");
        break;
      case "preta":
        overrides.attributes.body = -1;
        overrides.attributes.agility = 1;
        overrides.attributes.reaction = 2;
        overrides.attributes.strength = -1;
        overrides.init = 2;
        overrides.skills.push("assensing", "astral_combat", "intimidation", "negotiation", "perception", "sneaking", "unarmed_combat");
        break;
      case "stabber":
        overrides.attributes.body = 1;
        overrides.attributes.agility = 4;
        overrides.attributes.reaction = 2;
        overrides.attributes.strength = 4;
        overrides.init = 2;
        overrides.skills.push("assensing", "astral_combat", "gymnastics", "perception", "unarmed_combat");
        break;
      case "tungak":
        overrides.attributes.body = 1;
        overrides.attributes.reaction = 2;
        overrides.attributes.strength = -2;
        overrides.init = 2;
        overrides.skills.push("assensing", "astral_combat", "gymnastics", "perception", "unarmed_combat");
        break;
      case "vucub":
        overrides.attributes.body = 3;
        overrides.attributes.agility = 4;
        overrides.attributes.reaction = 4;
        overrides.attributes.strength = 2;
        overrides.attributes.intuition = 2;
        overrides.attributes.charisma = 4;
        overrides.init = 5;
        overrides.skills.push("assensing", "flight", "perception", "unarmed_combat");
        break;
    }
    return overrides;
  }
  /**
   * The spirits force value is used for the force attribute value.
   *
   * NOTE: This separation is mainly a legacy concern. Attributes are available as testable (and modifiable values)
   *       flat values like force aren't. For this reason the flat value is transformed to an attribute.
   *
   * @param system The spirit system data to prepare
   */
  static prepareAttributesWithForce(system) {
    const { attributes, force } = system;
    attributes.force.base = 0;
    PartsList.AddUniquePart(attributes.force.mod, "SR6.Force", force);
    AttributesPrep.calculateAttribute("force", attributes.force);
  }
};

// src/module/actor/prep/SpritePrep.ts
var SpritePrep = class _SpritePrep {
  static {
    __name(this, "SpritePrep");
  }
  static prepareBaseData(data) {
    _SpritePrep.prepareSpriteSpecial(data);
    SkillsPrep.prepareSkillData(data);
    ModifiersPrep.prepareModifiers(data);
    ModifiersPrep.clearAttributeMods(data);
    ModifiersPrep.clearLimitMods(data);
  }
  static prepareDerivedData(data, items) {
    _SpritePrep.prepareSpriteMatrixAttributes(data);
    _SpritePrep.prepareSpriteAttributes(data);
    _SpritePrep.prepareSpriteSkills(data);
    AttributesPrep.prepareAttributes(data);
    SkillsPrep.prepareSkills(data);
    MatrixPrep.prepareMatrixToLimitsAndAttributes(data);
    _SpritePrep.prepareSpriteConditionMonitor(data);
    _SpritePrep.prepareSpriteInitiative(data);
    InitiativePrep.prepareCurrentInitiative(data);
  }
  static prepareSpriteSpecial(data) {
    data.special = "resonance";
  }
  static prepareSpriteAttributes(data) {
    const { attributes, level, spriteType } = data;
    const overrides = this.getSpriteStatModifiers(spriteType);
    attributes.resonance.base = level + overrides.resonance;
    Helpers.calcTotal(attributes.resonance);
  }
  static prepareSpriteMatrixAttributes(data) {
    const { level, matrix, spriteType } = data;
    const matrixAtts = ["attack", "sleaze", "data_processing", "firewall"];
    const overrides = this.getSpriteStatModifiers(spriteType);
    matrixAtts.forEach((att) => {
      if (matrix[att] !== void 0) {
        matrix[att].base = level + overrides[att];
        matrix[att].value = Helpers.calcTotal(matrix[att]);
      }
    });
    matrix.rating = level;
  }
  static prepareSpriteSkills(data) {
    const { skills, level, spriteType } = data;
    const overrides = this.getSpriteStatModifiers(spriteType);
    for (const [skillId, skill] of Object.entries(skills.active)) {
      skill.base = overrides.skills.find((s2) => s2 === skillId) ? level : 0;
    }
  }
  static prepareSpriteConditionMonitor(data) {
    const { matrix, level, modifiers } = data;
    matrix.condition_monitor.max = 8 + Math.ceil(level / 2) + Number(modifiers.matrix_track);
  }
  static prepareSpriteInitiative(data) {
    const { initiative, level, spriteType, modifiers } = data;
    initiative.perception = "matrix";
    const overrides = this.getSpriteStatModifiers(spriteType);
    initiative.matrix.base.base = level * 2 + overrides.init;
    PartsList.AddUniquePart(initiative.matrix.base.mod, "SR6.Bonus", modifiers["matrix_initiative"]);
    Helpers.calcTotal(initiative.matrix.base, { min: 0 });
    initiative.matrix.dice.base = 4;
    PartsList.AddUniquePart(initiative.matrix.dice.mod, "SR6.Bonus", modifiers["matrix_initiative_dice"]);
    Helpers.calcTotal(initiative.matrix.dice, { min: 0 });
  }
  /**
   * Get the stat modifiers for the specified type of sprite
   * @param spriteType
   */
  static getSpriteStatModifiers(spriteType) {
    const overrides = {
      attack: 0,
      sleaze: 0,
      data_processing: 0,
      firewall: 0,
      resonance: 0,
      init: 0,
      // all sprites have computer
      skills: ["computer"]
    };
    switch (spriteType) {
      case "courier":
        overrides.sleaze = 3;
        overrides.data_processing = 1;
        overrides.firewall = 2;
        overrides.init = 1;
        overrides.skills.push("hacking");
        break;
      case "crack":
        overrides.sleaze = 3;
        overrides.data_processing = 2;
        overrides.firewall = 1;
        overrides.init = 2;
        overrides.skills.push("hacking", "electronic_warfare");
        break;
      case "data":
        overrides.attack = -1;
        overrides.data_processing = 4;
        overrides.firewall = 1;
        overrides.init = 4;
        overrides.skills.push("electronic_warfare");
        break;
      case "fault":
        overrides.attack = 3;
        overrides.data_processing = 1;
        overrides.firewall = 2;
        overrides.init = 1;
        overrides.skills.push("cybercombat", "hacking");
        break;
      case "machine":
        overrides.attack = 1;
        overrides.data_processing = 3;
        overrides.firewall = 2;
        overrides.init = 3;
        overrides.skills.push("electronic_warfare", "hardware");
        break;
      case "companion":
        overrides.attack = -1;
        overrides.sleaze = 1;
        overrides.firewall = 4;
        overrides.skills.push("electronic_warfare");
        break;
      case "generalist":
        overrides.attack = 1;
        overrides.sleaze = 1;
        overrides.data_processing = 1;
        overrides.firewall = 1;
        overrides.init = 1;
        overrides.skills.push("hacking", "electronic_warfare");
        break;
    }
    return overrides;
  }
};

// src/module/actor/prep/VehiclePrep.ts
var VehiclePrep = class _VehiclePrep {
  static {
    __name(this, "VehiclePrep");
  }
  static prepareBaseData(system) {
    SkillsPrep.prepareSkillData(system);
    ModifiersPrep.prepareModifiers(system);
    ModifiersPrep.clearAttributeMods(system);
    ModifiersPrep.clearArmorMods(system);
    ModifiersPrep.clearLimitMods(system);
  }
  static prepareDerivedData(system, items) {
    _VehiclePrep.prepareVehicleStats(system);
    _VehiclePrep.prepareDeviceAttributes(system);
    _VehiclePrep.prepareLimits(system);
    AttributesPrep.prepareAttributes(system);
    _VehiclePrep.prepareAttributesWithPilot(system);
    _VehiclePrep.prepareAttributesWithBody(system);
    _VehiclePrep.prepareAttributeRanges(system);
    SkillsPrep.prepareSkills(system);
    _VehiclePrep.prepareConditionMonitor(system);
    MatrixPrep.prepareMatrixToLimitsAndAttributes(system);
    MatrixPrep.prepareMatrixAttributesForDevice(system);
    _VehiclePrep.prepareMovement(system);
    _VehiclePrep.prepareMeatspaceInit(system);
    InitiativePrep.prepareMatrixInit(system);
    InitiativePrep.prepareCurrentInitiative(system);
    _VehiclePrep.prepareArmor(system);
    CharacterPrep.prepareRecoil(system);
    _VehiclePrep.prepareRecoilCompensation(system);
  }
  static prepareVehicleStats(system) {
    const { vehicle_stats, isOffRoad, isDrone } = system;
    for (let [key, stat] of Object.entries(vehicle_stats)) {
      if (typeof stat.mod === "object") {
        stat.mod = new PartsList(stat.mod).list;
      }
      const parts = new PartsList(stat.mod);
      if (stat.temp) parts.addUniquePart("SR6.Temporary", stat.temp);
      stat.mod = parts.list;
      Helpers.calcTotal(stat);
      stat.label = SR6.vehicle.stats[key];
    }
    if (isOffRoad) {
      vehicle_stats.off_road_speed.hidden = false;
      vehicle_stats.off_road_handling.hidden = false;
      vehicle_stats.speed.hidden = true;
      vehicle_stats.handling.hidden = true;
    } else {
      vehicle_stats.off_road_speed.hidden = true;
      vehicle_stats.off_road_handling.hidden = true;
      vehicle_stats.speed.hidden = false;
      vehicle_stats.handling.hidden = false;
    }
    vehicle_stats.seats.hidden = isDrone;
  }
  /**
   * Apply SR5#199 'Pilot' and SR5#269 'Pilot Program' rules.
   *
   * Rulings here are a bit vague and current system implementation makes it more vague.
   *
   */
  static prepareAttributesWithPilot(system) {
    const { attributes, vehicle_stats } = system;
    const attributeIds = [
      // SR5#199 - 'Pilot' => All  mental attributes and reaction.
      "reaction",
      "willpower",
      "logic",
      "intuition",
      "charisma",
      // No actual rule, a typical skill check would be 'Autosoft Rating + Pilot'
      // Setting agility to pilot, helps the current unpolished way vehicles use character skills.
      "agility",
      // The actual pilot attribute will also equal the vehicle stat pilot
      "pilot"
    ];
    attributeIds.forEach((attId) => {
      const attribute = attributes[attId];
      if (!attribute) return;
      attribute.base = 0;
      PartsList.AddUniquePart(attribute.mod, vehicle_stats.pilot.label, vehicle_stats.pilot.value);
      AttributesPrep.calculateAttribute(attId, attribute);
    });
  }
  static prepareAttributesWithBody(system) {
    const { attributes } = system;
    const attributeIds = ["strength"];
    attributeIds.forEach((attId) => {
      const attribute = attributes[attId];
      if (!attribute) return;
      attribute.base = 0;
      PartsList.AddUniquePart(attribute.mod, attributes.body.label, attributes.body.value);
      AttributesPrep.calculateAttribute(attId, attribute);
    });
  }
  static prepareLimits(system) {
    const { limits, vehicle_stats, isOffRoad } = system;
    limits.mental.base = Helpers.calcTotal(vehicle_stats.sensor);
    limits.sensor = { ...vehicle_stats.sensor, hidden: true };
    limits.handling = { ...isOffRoad ? vehicle_stats.off_road_handling : vehicle_stats.handling, hidden: true };
    limits.speed = { ...isOffRoad ? vehicle_stats.off_road_speed : vehicle_stats.speed, hidden: true };
  }
  /**
   * Apply SR5#269 'Drones in the matrix' rules.
   */
  static prepareDeviceAttributes(system) {
    const { matrix, vehicle_stats } = system;
    matrix.rating = vehicle_stats.pilot.value;
  }
  static prepareConditionMonitor(system) {
    const { track, attributes, matrix, isDrone, modifiers } = system;
    const halfBody = Math.ceil(Helpers.calcTotal(attributes.body) / 2);
    if (isDrone) {
      track.physical.base = 6 + halfBody;
      track.physical.max = track.physical.base + (Number(modifiers["physical_track"]) || 0);
    } else {
      track.physical.base = 12 + halfBody;
      track.physical.max = track.physical.base + (Number(modifiers["physical_track"]) || 0);
    }
    track.physical.label = SR6.damageTypes.physical;
    const rating = matrix.rating || 0;
    matrix.condition_monitor.max = 8 + Math.ceil(rating / 2) + Number(modifiers.matrix_track);
  }
  static prepareMovement(system) {
    const { vehicle_stats, movement, isOffRoad } = system;
    let speedTotal = Helpers.calcTotal(isOffRoad ? vehicle_stats.off_road_speed : vehicle_stats.speed);
    movement.walk.base = 5 * Math.pow(2, speedTotal - 1);
    movement.walk.value = Helpers.calcTotal(movement.walk, { min: 0 });
    movement.run.base = 10 * Math.pow(2, speedTotal - 1);
    movement.run.value = Helpers.calcTotal(movement.run, { min: 0 });
  }
  static prepareMeatspaceInit(system) {
    const { vehicle_stats, initiative, modifiers } = system;
    const pilot3 = Helpers.calcTotal(vehicle_stats.pilot);
    initiative.meatspace.base.base = pilot3 * 2;
    initiative.meatspace.base.mod = PartsList.AddUniquePart(initiative.meatspace.base.mod, "SR6.Bonus", Number(modifiers["meat_initiative"]));
    initiative.meatspace.dice.base = 4;
    initiative.meatspace.dice.mod = PartsList.AddUniquePart(initiative.meatspace.dice.mod, "SR6.Bonus", Number(modifiers["meat_initiative_dice"]));
    Helpers.calcTotal(initiative.meatspace.base);
    Helpers.calcTotal(initiative.meatspace.dice);
  }
  static prepareArmor(system) {
    const { armor: armor3, modifiers } = system;
    armor3.mod = PartsList.AddUniquePart(armor3.mod, "SR6.Temporary", Number(armor3["temp"] || 0));
    armor3.mod = PartsList.AddUniquePart(armor3.mod, "SR6.Bonus", Number(modifiers["armor"] || 0));
    Helpers.calcTotal(armor3);
  }
  /**
   * Prepare the base actor recoil compensation without item influence.
   */
  static prepareRecoilCompensation(system) {
    const { attributes } = system;
    const recoilCompensation = RangedWeaponRules.vehicleRecoilCompensationValue(attributes.body.value);
    PartsList.AddUniquePart(system.values.recoil_compensation.mod, "SR6.RecoilCompensation", recoilCompensation);
    Helpers.calcTotal(system.values.recoil_compensation, { min: 0 });
  }
  /**
   * Some attributes don't exist on vehicle actors.
   *
   * Instead of default character range, use vehicle specific ranges.
   *
   * NOTE: This is a hack around the actor type character centric preparation design still present in the system.
   *       Times is short, perfect solutions are costly.
   */
  static prepareAttributeRanges(system) {
    const ranges = SR.actorTypeAttributes["vehicle"];
    Helpers.calcTotal(system.attributes.strength, ranges.strength);
    Helpers.calcTotal(system.attributes.agility, ranges.agility);
  }
};

// src/module/rules/FireModeRules.ts
var FireModeRules = {
  /**
   * Give a defense modifier according to rounds consumed and SR5#180.
   *
   * If given and not enough ammunition is available reduced defense modifier rules
   * will be applied.
   *
   * @param fireMode The selected fireMode
   * @param ammoLeft How many rounds can be fired
   *
   * @returns a negative defense modifier value
   */
  fireModeDefenseModifier: /* @__PURE__ */ __name(function(fireMode, ammoLeft = 0) {
    const rounds = fireMode.value < 0 ? fireMode.value * -1 : fireMode.value;
    const modifier = Number(fireMode.defense);
    if (modifier === 0) return 0;
    if (ammoLeft <= 0) ammoLeft = rounds;
    if (ammoLeft >= rounds) return modifier;
    return Math.min(modifier + rounds - ammoLeft, 0);
  }, "fireModeDefenseModifier"),
  /**
   * Calculate the recoil attack modifier according to SR5#175
   *
   * NOTE: Reducing recoil compensation here is a bit unintuitive and might be easier to read
   *       with its own rule function.
   *
   * @param fireMode The chosen fire mode for the attack
   * @param compensation Actors recoil compensation
   * @param recoil Accured progressive recoil of the actor before current attack
   * @param ammoLeft Amount of ammunition available
   *
   * @return compensation Amount of compensation left.
   * @return new recoil modifier.
   */
  recoilModifierAfterAttack: /* @__PURE__ */ __name(function(fireMode, compensation, recoil = 0, ammoLeft = 0) {
    if (fireMode.value < 0) return 0;
    if (ammoLeft <= 0) ammoLeft = fireMode.value;
    const additionalRecoil = FireModeRules.additionalRecoil(fireMode, ammoLeft);
    return FireModeRules.recoilModifier(compensation, recoil, additionalRecoil);
  }, "recoilModifierAfterAttack"),
  /**
   * Calculate the amount of additional recoil possible depending on recoil of the firemode and
   * ammunition left.
   *
   * @param fireMode Choosen fire mode to attack with
   * @param ammoLeft Ammunition left in the weapon
   * @returns A positive number or zero, if no additional recoil will be caused.
   */
  additionalRecoil: /* @__PURE__ */ __name(function(fireMode, ammoLeft) {
    return fireMode.recoil ? Math.min(fireMode.value, ammoLeft) : 0;
  }, "additionalRecoil"),
  /**
   * Calculate the revoil modifier value according to SR5#175 'Recoil' and 'Progressive Recoil'
   *
   * @param compensation Amount of total recoil compensation available.
   * @param recoil Current Amount of total progressive recoil.
   * @param additionalRecoil Amount of additional fired ammunition.
   *
   * @returns a negative number or zero.
   */
  recoilModifier: /* @__PURE__ */ __name(function(compensation, recoil, additionalRecoil = 0) {
    return Math.min(compensation - (recoil + additionalRecoil), 0);
  }, "recoilModifier"),
  /**
   * Determine what firemodes are available to a ranged weapon user.
   *
   * @param rangedWeaponModes The weapon modes on the actual gun
   * @param ammoLeft The amount of rounds left. If not given, all firemodes will returned.
   *
   * @returns A list of firemodes sorted by weapon mode and rounds necessary.
   */
  availableFireModes: /* @__PURE__ */ __name(function(rangedWeaponModes, ammoLeft) {
    return SR6.fireModes.filter((fireMode) => rangedWeaponModes[fireMode.mode]).sort((modeA, modeB) => {
      if (modeA.mode === modeB.mode) {
        return modeA.value - modeB.value;
      }
      const modeAIndex = SR6.rangeWeaponMode.indexOf(modeA.mode);
      const modeBIndex = SR6.rangeWeaponMode.indexOf(modeB.mode);
      return modeAIndex > modeBIndex ? 1 : -1;
    });
  }, "availableFireModes")
};

// src/module/effect/flows/EnvironmentalChangeFlow.ts
var lowLightVision = /* @__PURE__ */ __name((modifier, test) => {
  console.debug("Shadowrun 6e | Applying Low Light Effect", modifier);
  if (!modifier.applied.active.light) return;
  if (modifier.applied.active.light >= -3) modifier.applied.active.light = 0;
  console.debug("Shadowrun 6e | Applied Low Light Effect", modifier);
}, "lowLightVision");
var imageMagnification = /* @__PURE__ */ __name((modifier, test) => {
  console.debug("Shadowrun 6e | Applying Image Magnification Effect", modifier);
  if (modifier.applied.active.range) modifier.applied.active.range = _shiftUpByOneRow(modifier.applied.active.range);
  console.debug("Shadowrun 6e | Applied Image Magnification Effect", modifier);
}, "imageMagnification");
var thermographicVision = /* @__PURE__ */ __name((modifier, test) => {
  console.debug("Shadowrun 6e | Applying Thermographic Vision Effect", modifier);
  if (modifier.applied.active.light) modifier.applied.active.light = _shiftUpByOneRow(modifier.applied.active.light);
  if (modifier.applied.active.visibility) modifier.applied.active.visibility = _shiftUpByOneRow(modifier.applied.active.visibility);
  console.debug("Shadowrun 6e | Applied Thermographic Vision Effect", modifier);
}, "thermographicVision");
var tracerRounds = /* @__PURE__ */ __name((modifier, test) => {
  console.debug("Shadowrun 6e | Applying Tracer Rounds Effect", modifier);
  if (modifier.applied.active.wind && modifier.applied.active.wind < SR.combat.environmental.levels.light) {
    modifier.applied.active.wind = _shiftUpByOneRow(modifier.applied.active.wind);
  }
  if (modifier.applied.active.range && modifier.applied.active.range < SR.combat.environmental.levels.light) {
    modifier.applied.active.range = _shiftUpByOneRow(modifier.applied.active.range);
  }
  console.debug("Shadowrun 6e | Applied Tracer Rounds Effect", modifier);
}, "tracerRounds");
var smartlink = /* @__PURE__ */ __name((modifier, test) => {
  console.debug("Shadowrun 6e | Applying Smartlink Effect", modifier);
  if (modifier.applied.active.wind) modifier.applied.active.wind = _shiftUpByOneRow(modifier.applied.active.wind);
}, "smartlink");
var ultrasound = /* @__PURE__ */ __name((modifier, test) => {
  console.debug("Shadowrun 6e | Applying Ultrasound Effect", modifier);
  if (modifier.applied.active.visibility) {
    modifier.applied.active.visibility = _shiftUpByOneRow(modifier.applied.active.visibility);
  }
  if (!test) return;
  const distance = test.data["distance"];
  if (!distance) return;
  if (Number(distance) <= 50) modifier.applied.active.light = 0;
}, "ultrasound");
var _shiftUpByOneRow = /* @__PURE__ */ __name((active3) => {
  const levels = Object.values(SR.combat.environmental.levels);
  const activeIndex = levels.findIndex((level) => level === active3);
  if (activeIndex === -1) {
    console.error("Shadowrun 6e | Could not find matching active modifier level");
    return 0;
  }
  ;
  if (active3 === 0) return 0;
  return levels[activeIndex - 1];
}, "_shiftUpByOneRow");

// src/module/effect/flows/SituationModifierEffectsFlow.ts
var SituationModifierEffectsFlow = class {
  constructor(modifier) {
    this.applyHandlers = {};
    this.modifier = modifier;
    this.applyHandlers = {
      "low_light_vision": lowLightVision,
      "image_magnification": imageMagnification,
      "tracer_rounds": tracerRounds,
      "smartlink": smartlink,
      "ultrasound": ultrasound,
      "thermographic_vision": thermographicVision
    };
  }
  static {
    __name(this, "SituationModifierEffectsFlow");
  }
  /**
   * Copied version of SR6Actor.applyActiveEffects to apply effects to situation modifiers.
   *
   * @param test The test to use during application for context.
   * @returns
   */
  applyAllEffects(test) {
    console.debug("Shadowrun 6e | Applying Situation Modifier Effects", this);
    const changes = [];
    for (const effect of this.allApplicableEffects()) {
      if (!effect.active) continue;
      if (effect.onlyForItemTest && (test === void 0 || effect.parent !== test?.item)) continue;
      changes.push(...effect.changes.map((change) => {
        const c2 = foundry.utils.deepClone(change);
        c2.effect = effect;
        return c2;
      }));
    }
    changes.sort((a2, b2) => a2.priority - b2.priority);
    console.debug("Shadowrun 6e | Applying Situation Modifier Effect changes", changes);
    for (const change of changes) {
      if (!change.key) continue;
      const changeKeySplit = change.key.split(".");
      if (changeKeySplit.length !== 2) return false;
      const [modifierType, modifierHandler] = changeKeySplit;
      if (modifierType !== this.modifier.type) continue;
      const handler = this.applyHandlers[modifierHandler];
      if (!handler) continue;
      console.debug("Shadowrun 6e | ... applying modifier handler", this.modifier, handler, test);
      handler(this.modifier, test);
    }
  }
  /**
   * Reduce all actor effects to those applicable to Situational Modifiers.
   *
   * Since Foundry Core uses a generator, keep this pattern for consistency.
   * @param test An optional SuccessTest implementation to use for context.
   */
  *allApplicableEffects() {
    if (this.modifier.sourceDocumentIsActor && this.modifier.modifiers?.document) {
      const actor = this.modifier.modifiers.document;
      for (const effect of allApplicableDocumentEffects(actor, { applyTo: ["modifier"] })) {
        yield effect;
      }
      for (const effect of allApplicableItemsEffects(actor, { applyTo: ["modifier"] })) {
        yield effect;
      }
    }
  }
};

// src/module/rules/modifiers/SituationModifier.ts
var SituationModifier = class {
  static {
    __name(this, "SituationModifier");
  }
  /**
   *
   * @param data The low level modifier data for this handler to work on.
   * @param modifiers Modifiers instances this handler is used in.
   */
  constructor(data, modifiers) {
    this.source = this._prepareSourceData(data);
    this.modifiers = modifiers;
    this.effects = new SituationModifierEffectsFlow(this);
  }
  /**
   * Prepare valid source modifier data.
   *
   * @param data A documents source modifier data
   * @returns Either a documents source modifier data or a valid fallback.
   */
  _prepareSourceData(data = {}) {
    return { ...{ active: {} }, ...data };
  }
  /**
   * Determine if any documents have been added to this instance.
   */
  get hasDocuments() {
    return this.modifiers !== void 0;
  }
  /**
   * Determine if the source document used is an actor.
   */
  get sourceDocumentIsActor() {
    return this.modifiers !== void 0 && this.modifiers.documentIsActor;
  }
  /**
   * Determine if the source document used is a scene.
   */
  get sourceDocumentIsScene() {
    return this.modifiers !== void 0 && this.modifiers.documentIsScene;
  }
  /**
   * Return the source active values for use during selection.
   */
  get active() {
    return this.source.active;
  }
  /**
   * Allow a situational modifier to NOT need any source data to apply it's modifiers.
   *
   * This can be used to implement a modifier that IS situational but doesn't need data structures for selection.
   *
   * @returns false, when a handler doesn't use any document source data.
   */
  static get hasSourceData() {
    return true;
  }
  /**
   * Determine if the source data has an active modifier set for this situational modifier.
   */
  get hasActive() {
    return !foundry.utils.isEmpty(this.source.active);
  }
  /**
   * Determine if a fixed value has been set.
   */
  get hasFixed() {
    return this.applied.hasOwnProperty("fixed");
  }
  /**
   * Determine if a fixed user selection has been made.
   */
  get hasFixedSelection() {
    return this.applied.active.hasOwnProperty("value");
  }
  /**
   * Determine if any user selection has been made.
   */
  get hasSelection() {
    return this.hasActive || this.hasFixed;
  }
  /**
   * Does the applied selection match?
   *
   * Use applied as source might not match, but applied might.
   *
   * In that case a matching applied might need to be altered in source.
   *
   * @param modifier The selection / active identifier
   * @param level The modifier level
   */
  isMatching(modifier, level) {
    return this.applied.active[modifier] === level;
  }
  /**
   * Set a active selection to a modifier level.
   *
   * @param modifier The selection / active identifier.
   * @param level The modifier level
   */
  setActive(modifier, level) {
    this.source.active[modifier] = level;
    this._updateDocumentSourceModifiers();
  }
  /**
   * Set a active selection as inactive.
   *
   * @param modifier The selection / active identivier.
   */
  setInactive(modifier) {
    delete this.source.active[modifier];
    this._updateDocumentSourceModifiers();
  }
  /**
   * Determine if the given modifier is active
   * @param modifier The possibly active modifier to check
   */
  isActive(modifier) {
    return this.source.active.hasOwnProperty(modifier);
  }
  /**
   * When using a selection this method will toggle an active modifier on and off.
   *
   * @param modifier The active modifier name
   * @param value The value the modifier uses currently.
   */
  toggleSelection(modifier, value) {
    if (this.isMatching(modifier, value)) {
      this.setInactive(modifier);
    } else {
      this.setActive(modifier, value);
    }
  }
  /**
   * Using the local documents source modifier data apply all higher-level situational modifiers
   * on top and apply to the actual modifiers.
   *
   * @params options An optional set of options.
   * @params options.reapply When set to true, should cause a full re application.
   */
  apply(options = {}) {
    if (!this.applied || options.reapply || options.source) {
      this.applied = {
        active: {},
        total: 0
      };
    }
    this.source = options.source ?? this.source;
    const applicable = options.applicable ?? null;
    const sources = [];
    if (Object.getPrototypeOf(this).constructor.hasSourceData && this.modifiers && this.sourceDocumentIsActor) {
      if (!this.type) return console.error(`Shadowrun 6e | ${this.constructor.name} can't interact with documents without a modifier category set.`);
      const actor = this.modifiers.document;
      this._addSceneSourceDataFromActor(actor, sources);
    }
    sources.push(this.source);
    sources.forEach((source3) => foundry.utils.mergeObject(this.applied, source3));
    if (applicable && applicable.length > 0) {
      Object.keys(this.applied.active).forEach((selection) => {
        if (!applicable.includes(selection)) delete this.applied.active[selection];
      });
    }
    this.effects.applyAllEffects(options.test);
    if (!this.hasFixed && this.hasFixedSelection) this.applied.fixed = this.applied.active.value || 0;
    if (this.hasFixed) this.applied.total = this.applied.fixed;
    else this.applied.total = this._calcActiveTotal(options);
    console.debug(`Shadowrun 6e | Totalled situational modifiers for ${this.modifiers?.document?.name} to be: ${this.applied.total}`, this.applied);
  }
  /**
   * Add scene modifier sources into the applicable sources, when an actor is present on scene
   *
   * @param actor The actor to check for tokens
   * @param sources The sources list, as used within #apply
   */
  _addSceneSourceDataFromActor(actor, sources) {
    const scene = actor.getToken()?.parent;
    if (!scene) return;
    const sceneSource = this._getDocumentsSourceData(scene);
    if (!sceneSource) return;
    sources.push(sceneSource);
  }
  _getDocumentsSourceData(document2) {
    if (!this.type) return;
    const modifiers = DocumentSituationModifiers.getDocumentModifiers(document2);
    return modifiers.source[this.type];
  }
  /**
   * Determine the total value of all active modifier values.
   *
   * Override this method if you want to apply different rules depending on the situational modifier category.
   *
   * By default the active modifiers will simply be sumed up.
   *
   * @param options.test The SuccessTest implementation used to access this modifier. Use if the modifier changes based on test configuration.
   *
   * @returns The total modifier value to be used for this situational modifier category.
   */
  _calcActiveTotal(options = {}) {
    return Object.values(this.applied.active).reduce((sum, current) => sum + current, 0) || 0;
  }
  /**
   * Give the total modifier value for this category.
   *
   * Should this modifier not yet been applied, this will apply it.
   *
   * NOTE: Always use this field to access resulting modifier values as some modifiers might have a total level applied vs a total modifer given.
   */
  get total() {
    if (!this.applied) {
      this.apply();
    }
    return this.applied.total;
  }
  /**
   * Clear the source modifier data to a default state.
   */
  clear() {
    this.source = this._prepareSourceData();
    this.apply({ reapply: true });
    this._updateDocumentModifiers();
  }
  _updateDocumentSourceModifiers() {
    if (!this.type || !this.modifiers) return;
    this.modifiers.source[this.type] = this.source;
  }
  _updateDocumentAppliedModifiers() {
    if (!this.type || !this.modifiers) return;
    this.modifiers.applied[this.type] = this.applied;
  }
  _updateDocumentModifiers() {
    this._updateDocumentSourceModifiers();
    this._updateDocumentAppliedModifiers();
  }
};

// src/module/rules/modifiers/RecoilModifier.ts
var RecoilModifier = class extends SituationModifier {
  static {
    __name(this, "RecoilModifier");
  }
  /**
   * Recoil modifiers don't allow for any selection.
   */
  static get hasSourceData() {
    return false;
  }
  _calcActiveTotal(options) {
    if (!this.modifiers || !this.modifiers.documentIsActor) return 0;
    if (!options.test || options.test.type !== "RangedAttackTest") return this.modifiers.document?.recoil ?? 0;
    const rangedAttack = options.test;
    const testActor = options.test.actor;
    const testItem = options.test.item;
    const fireMode = rangedAttack.data.fireMode;
    if (!testActor || !testItem) {
      console.error(`Shadowrun 6e | ${this.constructor.name} calculated the recoil modifier within context of a ${options.test.constructor.name} which lacked either an actor or item document`, this, options.test);
      return 0;
    }
    return FireModeRules.recoilModifierAfterAttack(fireMode, testItem.totalRecoilCompensation, testActor.recoil, testItem.ammoLeft);
  }
};

// src/module/rules/modifiers/BackgroundCountModifier.ts
var BackgroundCountModifier = class extends SituationModifier {
  constructor() {
    super(...arguments);
    this.type = "background_count";
  }
  static {
    __name(this, "BackgroundCountModifier");
  }
};

// src/module/rules/modifiers/NoiseModifier.ts
var NoiseModifier = class extends SituationModifier {
  constructor() {
    super(...arguments);
    this.type = "noise";
  }
  static {
    __name(this, "NoiseModifier");
  }
};

// src/module/rules/modifiers/EnvironmentalModifier.ts
var EnvironmentalModifier = class extends SituationModifier {
  constructor() {
    super(...arguments);
    this.type = "environmental";
  }
  static {
    __name(this, "EnvironmentalModifier");
  }
  get levels() {
    return SR.combat.environmental.levels;
  }
  /**
   * How many selectios / modifiers are active per level of enviornmental modifiers.
   * 
   * A level would be light and fitting modifiers would be 'Light Rain', 'Light Winds' or Medium Range.
   * 
   * @param values Active modifier values to be matched to level values
   * @returns A count per level of modifiers on that level
   */
  activeLevels(values) {
    return {
      light: values.reduce((count, value) => value === this.levels.light ? count + 1 : count, 0),
      moderate: values.reduce((count, value) => value === this.levels.moderate ? count + 1 : count, 0),
      heavy: values.reduce((count, value) => value === this.levels.heavy ? count + 1 : count, 0),
      extreme: values.reduce((count, value) => value === this.levels.extreme ? count + 1 : count, 0)
    };
  }
  /**
   * Apply rules for environmental modifier selection to calculate a total modifier value.
   * 
   * SR5#173 'Environmental Modifiers'
   */
  _calcActiveTotal() {
    if (this.applied.active.value)
      return this.applied.active.value;
    const activeCategories = Object.entries(this.applied.active);
    const activeValues = activeCategories.map(([category3, level]) => level ? level : 0);
    const count = this.activeLevels(activeValues);
    if (count.extreme > 0 || count.heavy >= 2) {
      return this.levels.extreme;
    } else if (count.heavy === 1 || count.moderate >= 2) {
      return this.levels.heavy;
    } else if (count.moderate === 1 || count.light >= 2) {
      return this.levels.moderate;
    } else if (count.light === 1) {
      return this.levels.light;
    }
    return this.levels.good;
  }
  setInactive(modifier) {
    if (this.source.active[modifier] !== this.applied.active[modifier]) this.setActive(modifier, 0);
    else delete this.source.active[modifier];
  }
};

// src/module/rules/modifiers/DefenseModifier.ts
var DefenseModifier = class extends SituationModifier {
  static {
    __name(this, "DefenseModifier");
  }
  /**
   * Defense modifier is a legacy modifier but can differ based set actor modifiers
   */
  static get hasSourceData() {
    return false;
  }
  /**
   * Depending on the test context additional defense modifiers might apply
   *
   */
  _calcActiveTotal(options) {
    if (!this.modifiers || !this.modifiers.documentIsActor) return 0;
    const actor = this.modifiers.document;
    if (!options.test || options.test.type !== "PhysicalDefenseTest") return Number(actor.system.modifiers.defense);
    const test = options.test;
    let defense = Number(actor.system.modifiers.defense);
    switch (test.data.activeDefense) {
      case "dodge":
        defense += actor.modifiers.totalFor("defense_dodge");
        break;
      case "block":
        defense += actor.modifiers.totalFor("defense_block");
        break;
      case "parry":
        defense += actor.modifiers.totalFor("defense_parry");
        break;
    }
    if (test.against.item?.isRangedWeapon) defense += actor.modifiers.totalFor("defense_ranged");
    if (test.against.item?.isMeleeWeapon) defense += actor.modifiers.totalFor("defense_melee");
    return defense;
  }
};

// src/module/rules/DocumentSituationModifiers.ts
var DocumentSituationModifiers = class _DocumentSituationModifiers {
  static {
    __name(this, "DocumentSituationModifiers");
  }
  /**
   * Prepare a Modifiers instance for a and allow handling of the resulting modifiers.
   *
   * @param data situational modifiers taken from a Document.
   * @param document The source document used to retrieve data.
   */
  constructor(data, document2) {
    if (!data || foundry.utils.getType(data) !== "Object") {
      data = _DocumentSituationModifiers._defaultModifiers;
    }
    this.source = this._completeSourceData(data);
    this.document = document2;
    this._prepareModifiers();
  }
  /**
   * Prepare modifier handlers and their source data.
   */
  _prepareModifiers() {
    this._modifiers = {
      noise: new NoiseModifier(this.source.noise, this),
      background_count: new BackgroundCountModifier(this.source.background_count, this),
      environmental: new EnvironmentalModifier(this.source.environmental, this),
      recoil: new RecoilModifier({}, this),
      defense: new DefenseModifier({}, this)
    };
  }
  /**
   * Does this document have a handle a situation modifier category
   *
   * @param category A category found within the handler registry
   * @returns true, when a total modifier can be calculated by a handler.
   */
  handlesTotalFor(category3) {
    return this._modifiers.hasOwnProperty(category3);
  }
  /**
   * Access helper for the noise modifier handler.
   */
  get noise() {
    return this._modifiers.noise;
  }
  /**
   * Access helper for the background modifier handler.
   */
  get background_count() {
    return this._modifiers.background_count;
  }
  /**
   * Access helper for the environmental modifier handler.
   */
  get environmental() {
    return this._modifiers.environmental;
  }
  /**
   * Access helper for the recoilModifier handler.
   */
  get recoil() {
    return this._modifiers.recoil;
  }
  /**
   * Access helper for the defense modifier handler
   */
  get defense() {
    return this._modifiers.defense;
  }
  /**
   * Complete a partial modifier data object, making sure all modifier category fields are set.
   *
   * @param data An incomplete modifier data object.
   * @returns A completed modifier data object.
   */
  _completeSourceData(data) {
    data = foundry.utils.duplicate(data);
    for (const [category3, modifiers] of Object.entries(_DocumentSituationModifiers._defaultModifiers)) {
      if (!data.hasOwnProperty(category3)) data[category3] = modifiers;
    }
    return data;
  }
  /**
   * Return this total value for a modifiers category selection.
   *
   * @param category A string matching a situation modifiers category.
   * @param options
   */
  getTotalFor(category3, options = {}) {
    const modifier = this._modifiers[category3];
    if (options.reapply || options.applicable) {
      modifier.apply({ applicable: options.applicable, test: options.test });
    }
    return modifier.total;
  }
  /**
   * Re-apply all situational modifiers totals based on their active selections made.
   *
   * This will turn the source data per modifier category over to their matching handler
   * and apply that categories total according to the rules for that category.
   *
   * The result will be stored in the applied modifiers, where a total and the applied
   * selections can be found.
   *
   * @params options What options to pass onto the SituationModifier.apply method.
   *                 The source property will be overriden.
   */
  applyAll(options = {}) {
    this.applied = {};
    Object.entries(this._modifiers).forEach(([category3, handler]) => {
      if (Object.getPrototypeOf(handler).constructor.hasSourceData) {
        Object.entries(this.source[category3].active).forEach(([modifier, value]) => {
          switch (value) {
            case null:
            case void 0:
              delete this.source[category3].active[modifier];
          }
        });
      }
      options.reapply = options.reapply ?? true;
      options.source = this.source[category3];
      handler.apply(options);
      this.applied[category3] = handler.applied;
    });
  }
  /**
   * Clear a given document from all situation modifiers selection.
   *
   * @param document The document to clear.
   * @returns A new instance with the resulting modifiers structure
   */
  static async clearAllOn(document2) {
    if (document2 instanceof SR6Actor) {
      await document2.update({ "system.-=situation_modifiers": null }, { render: false });
      await document2.update({ "system.situation_modifiers": _DocumentSituationModifiers._defaultModifiers });
    } else {
      await document2.unsetFlag(SYSTEM_NAME, FLAGS.Modifier);
      await document2.setFlag(SYSTEM_NAME, FLAGS.Modifier, _DocumentSituationModifiers._defaultModifiers);
    }
  }
  /**
   * Clear a given modifiers categories selection from a document.
   *
   * @param document The document to clear.
   * @param category Modifiers category to clear
   * @returns A new instance with the resulting modifiers structure
   */
  static async clearTypeOn(document2, category3) {
    const modifiers = _DocumentSituationModifiers.getDocumentModifiers(document2);
    if (!modifiers.source.hasOwnProperty(category3)) return modifiers;
    modifiers.source[category3] = _DocumentSituationModifiers._defaultModifier;
    await _DocumentSituationModifiers.setDocumentModifiers(document2, modifiers.source);
    return modifiers;
  }
  /**
   * Prepare complete default modifier structure for a single modifier category.
   */
  static get _defaultModifier() {
    return {
      active: {}
    };
  }
  /**
   * Prepare complete default modifier data structure for a single document.
   */
  static get _defaultModifiers() {
    return {
      environmental: _DocumentSituationModifiers._defaultModifier,
      noise: _DocumentSituationModifiers._defaultModifier,
      background_count: _DocumentSituationModifiers._defaultModifier
    };
  }
  /**
   * Determine if the current document is a scene.
   */
  get documentIsScene() {
    return this.document instanceof CONFIG.Scene.documentClass;
  }
  /**
   * Determine if the current document is an actor.
   */
  get documentIsActor() {
    return this.document instanceof CONFIG.Actor.documentClass;
  }
  /**
   * Retrieve the situational modifiers data.
   *
   * @param document Any document with flags support.
   * @returns The raw modifier data of a document
   */
  static getDocumentModifiersData(document2) {
    if (document2 instanceof SR6Actor) {
      return document2.system.situation_modifiers;
    } else {
      return document2.getFlag(SYSTEM_NAME, FLAGS.Modifier);
    }
  }
  /**
   * For a modifiable document return all situational modifiers.
   *
   * @param document The document containing modifiers or implementing a custom modifier retrieval system.
   */
  static fromDocument(document2) {
    if (document2 instanceof SR6Actor) {
      return document2.getSituationModifiers();
    }
    return _DocumentSituationModifiers.getDocumentModifiers(document2);
  }
  /**
   * Build a full set of situational modifiers for a document.
   *
   * @param document Any document that may contain situational modifiers.
   * @returns A full set of situational modifiers.
   */
  static getDocumentModifiers(document2) {
    const data = _DocumentSituationModifiers.getDocumentModifiersData(document2);
    return new _DocumentSituationModifiers(data, document2);
  }
  /**
   * Set the situation modifiers data on the given document.
   *
   * @param document Any document with flags support.
   * @param modifiers Source data of all situation modifiers for this document.
   */
  static async setDocumentModifiers(document2, modifiers) {
    if (document2 instanceof SR6Actor) {
      await document2.update({ "system.situation_modifiers": modifiers }, { diff: false });
    } else {
      await document2.unsetFlag(SYSTEM_NAME, FLAGS.Modifier);
      await document2.setFlag(SYSTEM_NAME, FLAGS.Modifier, modifiers);
    }
  }
  /**
   * Helper for instances to update modifiers on a document
   */
  async updateDocument() {
    if (!this.document) return console.error(`'Shadowrun 6e | ${this.constructor.name} can't update without connected document'`);
    await _DocumentSituationModifiers.setDocumentModifiers(this.document, this.source);
  }
  /**
   * Helper for instances to clear all modifiers on a document
   */
  async clearAll() {
    if (!this.document) return console.error(`'Shadowrun 6e | ${this.constructor.name} can't clear without connected document'`);
    await _DocumentSituationModifiers.clearAllOn(this.document);
    this.source = _DocumentSituationModifiers.getDocumentModifiersData(this.document);
  }
  /**
   * Helper for scene modifier instances to clear all modifiers for all placed tokens
   */
  async clearAllTokensOnScene() {
    if (!canvas.ready || !canvas.scene) return;
    if (!this.documentIsScene) return;
    const scene = this.document;
    if (canvas.scene.id !== scene.id) return;
    canvas.scene.tokens.forEach((token) => token.actor?.getSituationModifiers().clearAll());
  }
};

// src/module/actor/prep/ICPrep.ts
var ICPrep = class _ICPrep {
  static {
    __name(this, "ICPrep");
  }
  static prepareBaseData(system) {
    ModifiersPrep.clearAttributeMods(system);
    ModifiersPrep.clearLimitMods(system);
    SkillsPrep.prepareSkillData(system);
    _ICPrep.addMissingTracks(system);
    _ICPrep.prepareModifiers(system);
    _ICPrep.hideMeatAttributes(system);
    _ICPrep.addHostAttributes(system);
  }
  static prepareDerivedData(system, items) {
    _ICPrep.prepareMatrixAttributes(system);
    SkillsPrep.prepareSkills(system);
    _ICPrep.prepareHostAttributes(system);
    _ICPrep.prepareMeatAttributes(system);
    MatrixPrep.prepareMatrixToLimitsAndAttributes(system);
    _ICPrep.prepareMatrix(system);
    _ICPrep.prepareMatrixTrack(system);
    _ICPrep.prepareMatrixInit(system);
    InitiativePrep.prepareCurrentInitiative(system);
  }
  /**
   * On initial actor creation the matrix track will be missing.
   *
   * This is intentional as not to pollute template.json with actor type specific data.
   *
   */
  static addMissingTracks(system) {
    const track = system.track || {};
    if (!track.matrix) track.matrix = DataDefaults.trackData();
    system.track = track;
  }
  /**
   * Add IC modifiers only to the misc tab.
   * @param system
   */
  static prepareModifiers(system) {
    let modifiers = ModifiersPrep.commonModifiers;
    modifiers = modifiers.concat(ModifiersPrep.matrixModifiers);
    ModifiersPrep.setupModifiers(system, modifiers);
  }
  static prepareMatrix(system) {
    system.matrix.rating = MatrixRules.getICDeviceRating(system.host.rating);
  }
  static prepareMatrixTrack(system) {
    const { modifiers, track, matrix } = system;
    matrix.condition_monitor.max = Number(modifiers["matrix_track"]) + MatrixRules.getConditionMonitor(matrix.rating);
    track.matrix.base = MatrixRules.getConditionMonitor(matrix.rating);
    track.matrix.mod = PartsList.AddUniquePart(track.matrix.mod, "SR6.Bonus", Number(modifiers["matrix_track"]));
    track.matrix.max = matrix.condition_monitor.max;
    track.matrix.label = SR6.damageTypes.matrix;
  }
  static prepareMatrixInit(system) {
    const { initiative, modifiers, host } = system;
    initiative.perception = "matrix";
    initiative.matrix.base.base = MatrixRules.getICInitiativeBase(host.rating);
    initiative.matrix.base.mod = PartsList.AddUniquePart(initiative.matrix.base.mod, "SR6.Bonus", Number(modifiers["matrix_initiative"]));
    initiative.matrix.dice.base = MatrixRules.getICInitiativeDice();
    initiative.matrix.dice.mod = PartsList.AddUniquePart(initiative.matrix.dice.mod, "SR6.Bonus", Number(modifiers["matrix_initiative_dice"]));
  }
  /**
   * For connected hosts overwrite matrix attributes with the hosts attributes, otherwise leave as is.
   */
  static prepareHostAttributes(system) {
    if (!system.host.id || !system.host.atts) return;
    Object.keys(system.host.atts).forEach((deviceAttribute) => {
      const attribute = system.host.atts[deviceAttribute];
      system.matrix[attribute.att].base = attribute.value;
      system.matrix[attribute.att].device_att = deviceAttribute;
    });
  }
  /**
   * Hide all meat attributes from display
   */
  static hideMeatAttributes(system) {
    const { attributes } = system;
    for (const attribute of Object.values(attributes)) {
      attribute.hidden = true;
    }
  }
  /**
   * Add derived attributes based on host values.
   *
   * As the rating attribute is only derived, it's not included in base data or template.json.
   */
  static addHostAttributes(system) {
    system.attributes["rating"] = DataDefaults.attributeData({ label: "SR6.Rating" });
  }
  static prepareMeatAttributes(system) {
    const { attributes, host } = system;
    for (const id of Object.keys(SR6.attributes)) {
      if (!attributes.hasOwnProperty(id)) continue;
      if (["magic", "edge", "essence", "resonance"].includes(id)) continue;
      const attribute = attributes[id];
      attribute.base = 0;
      const parts = new PartsList(attribute.mod);
      parts.addPart("SR6.Host.Rating", MatrixRules.getICMeatAttributeBase(host.rating));
      attribute.mod = parts.list;
      AttributesPrep.prepareAttribute(id, attribute);
    }
  }
  /**
   * Calculate all matrix attributes without the meat attributes
   */
  static prepareMatrixAttributes(system) {
    const { matrix } = system;
    for (const id of Object.keys(SR6.matrixAttributes)) {
      if (!matrix.hasOwnProperty(id)) continue;
      const attribute = matrix[id];
      AttributesPrep.prepareAttribute(id, attribute);
    }
  }
};

// src/module/actor/flows/InventoryFlow.ts
var InventoryFlow = class _InventoryFlow {
  static {
    __name(this, "InventoryFlow");
  }
  constructor(actor) {
    if (actor.type.includes(".") || !game.model.Actor.hasOwnProperty(actor.type)) {
      console.debug(`Shadowrun 6e | InventoryFlow ignored actor ${actor.name} as it has a non-system DataModel`);
      return;
    }
    if (actor.system.inventories === void 0) {
      actor.system.inventories = foundry.utils.duplicate(game.model.Actor[actor.type].inventories);
    }
    this.actor = actor;
  }
  /**
   * Create an inventory place for gear organization.
   *
   * @param name How to name the inventory, will also be its label for custom inventories.
   * @returns Created inventories name
   */
  async create(name3) {
    console.debug(`Shadowrun 6e | Creating inventory ${name3}`);
    name3 = _InventoryFlow._sanitzeName(name3);
    if (name3.length === 0) return console.error("Shadowrun 6e | The given name has been reduced to a zero length, please try another name");
    if (this.exists(name3)) return ui.notifications?.warn(game.i18n.localize("SR6.Errors.InventoryAlreadyExists"));
    if (this.actor.defaultInventory.name === name3) return;
    const updateData = {
      "system.inventories": {
        [name3]: {
          name: name3,
          label: name3,
          itemIds: []
        }
      }
    };
    console.debug(`Shadowrun 6e | Executing update to create inventory`, updateData);
    await this.actor.update(updateData, { render: false });
    return name3;
  }
  /**
   * Remove an actors inventory and maybe move the containing items over to another one.
   *
   * @param name The inventory name to be removed.
   * @param moveTo The inventory name items need to moved over to, otherwise the default inventory.
   */
  async remove(name3, moveTo = this.actor.defaultInventory.name) {
    console.debug(`Shadowrun 6e | Removing inventory ${name3}. Moving items over to ${moveTo}`);
    if (this.disallowRemove(name3))
      return ui.notifications?.error(game.i18n.localize("SR6.Errors.DefaultInventoryCantBeRemoved"));
    if (!this.exists(name3))
      return console.error(`Shadowrun 6e | Can't remove inventory ${name3} or move its items over to inventory ${moveTo}`);
    if (!this.exists(moveTo))
      moveTo = this.actor.defaultInventory.name;
    const updateData = Helpers.getDeleteKeyUpdateData("system.inventories", name3);
    if (this.actor.defaultInventory.name !== moveTo) {
      updateData[`system.inventories.${moveTo}.itemIds`] = [
        ...this.actor.system.inventories[name3].itemIds,
        ...this.actor.system.inventories[moveTo].itemIds
      ];
    }
    console.debug(`Shadowrun 6e | Executing update to remove inventory`, updateData);
    await this.actor.update(updateData, { render: false });
  }
  /**
  * Does this actor have the given inventory already?
  *
  * Note: Comparisons will only be against lower case.
  *
  * @param name The inventory name.
  */
  exists(name3) {
    return name3 === Object.keys(this.actor.system.inventories).find((inventory) => inventory.toLowerCase() === name3.toLowerCase());
  }
  /**
   * Helper to get a specifics inventory's data
   *
   * @param name The inventory name to return.
   */
  getOne(name3) {
    return this.actor.system.inventories[name3];
  }
  /**
   * Helper to get all inventories.
   */
  getAll() {
    return this.actor.system.inventories;
  }
  /**
   * Rename an existing inventory to a new name.
   *
   * @param current The old name of the inventory.
   * @param newName The new name of the inventory.
   */
  async rename(current, newName) {
    console.debug(`Shadowrun 6e | Renaming the inventory ${current} to ${newName}`);
    if (this.disallowRename(current))
      return ui.notifications?.warn(game.i18n.localize("SR6.Warnings.CantEditDefaultInventory"));
    newName = _InventoryFlow._sanitzeName(newName);
    if (newName.length === 0) return console.error("Shadowrun 6e | The given name has been reduced to a zero length, please try another name");
    if (this.actor.defaultInventory.name === current) return;
    if (current === newName) return;
    const inventory = this.getOne(current);
    if (!inventory) return;
    inventory.name = newName;
    inventory.label = newName;
    const updateData = {
      "system.inventories": {
        [`-=${current}`]: null,
        [newName]: inventory
      }
    };
    console.debug(`Shadowrun 6e | Executing update to rename inventory`, updateData);
    await this.actor.update(updateData, { render: false });
    return newName;
  }
  /**
   * Add an array of items to the given inventory.
   *
   * @param inventoryName The inventory to add the items to.
   * @param items The items in question. A single item can be given.
   * @param removeFromCurrent By default the item added will be removed from another inventory it might be in.
   */
  async addItems(inventoryName, items, removeFromCurrent = true) {
    console.debug(`Shadowrun 6e | Adding items to to inventory ${inventoryName}`, items);
    if (this.actor.defaultInventory.name !== inventoryName && !this.exists(inventoryName)) return;
    if (items instanceof SR6Item) items = [items];
    if (items.length === 0) return;
    if (removeFromCurrent) {
      for (const item of items) await this.removeItem(item);
    }
    if (this.actor.defaultInventory.name === inventoryName) return;
    for (const item of items) {
      if (item.id) this.actor.system.inventories[inventoryName].itemIds.push(item.id);
    }
    const updateData = { [`system.inventories.${inventoryName}.itemIds`]: this.actor.system.inventories[inventoryName].itemIds };
    console.debug(`Shadowrun 6e | Executing adding items to inventory`, updateData);
    await this.actor.update(updateData);
  }
  /**
  * Remove the given item from one or any inventory it might be in.
  *
  * @param item The item to be removed.
  * @param name The one inventory to remove it from. If empty, will search for inventory the item is in.
  */
  async removeItem(item, name3) {
    console.debug(`Shadowrun 6e | Removing item from inventory (${name3 || this.actor.defaultInventory.name})`, item);
    if (this.actor.defaultInventory.name === name3) return;
    const inventories = name3 ? [this.actor.system.inventories[name3]] : Object.values(this.actor.system.inventories).filter(({ itemIds }) => itemIds.includes(item.id));
    if (inventories.length === 0) return;
    const updateData = {};
    for (const inventory of inventories) {
      const itemIds = inventory.itemIds.filter((id) => id !== item.id);
      updateData[`system.inventories.${inventory.name}.itemIds`] = itemIds;
    }
    console.debug(`Shadowrun 6e | Executing update to remove item`, updateData);
    if (updateData) await this.actor.update(updateData);
  }
  /**
   * Sanitize inventory name to not use characters used within FoundryVTT Document#update and expandObject methods.
   *
   * @param name The inventory name, maybe containing prohibited characters
   */
  static _sanitzeName(name3) {
    return Helpers.sanitizeDataKey(name3);
  }
  /**
   * Check if a rename would be allowed
   * @param name The current name of the to be renamed invenotry
   * @returns true, when it's not and false when it is.
   */
  disallowRename(name3) {
    if (!name3) return true;
    return [this.actor.defaultInventory.name, this.actor.allInventories.name].includes(name3);
  }
  /**
   * Check if a remove would be allowed.
   *
   * @param name The current name of the to be removed invenotry
   * @returns true, when it's not and false when it is.
   */
  disallowRemove(name3) {
    if (!name3) return true;
    return [this.actor.defaultInventory.name, this.actor.allInventories.name].includes(name3);
  }
  /**
   * Check if the given item is within the given inventory.
   *
   * @param name Inventory name to check for item in
   * @param item Item to check for in inventory
   * @returns
   */
  isItemInInventory(name3, item) {
    const inventory = this.actor.inventory.getOne(name3);
    if (!inventory) return false;
    return inventory.itemIds.includes(item.id);
  }
};

// src/module/actor/flows/ModifierFlow.ts
var ModifierFlow = class {
  static {
    __name(this, "ModifierFlow");
  }
  constructor(actor) {
    this.actor = actor;
  }
  /**
   * Retrieve a total modifier value for a specific modifier
   *
   * @param name The internal modifiers name. This can either be a situation modifier or an actor modifier
   * @param options
   * @returns Total value requested or zero, should the requested modifier not exist.
   */
  totalFor(name3, options = {}) {
    if (this[name3] !== void 0) return this[name3];
    const modifiers = this.actor.getSituationModifiers();
    if (modifiers.handlesTotalFor(name3)) return modifiers.getTotalFor(name3, options);
    return Number(this.actor.system.modifiers[name3] ?? 0);
  }
  /**
   * Translate simple modifier type string to the differently named actor / document method.
   */
  get wounds() {
    return this.actor.getWoundModifier();
  }
};

// src/module/tests/AttributeOnlyTest.ts
var AttributeOnlyTest = class extends SuccessTest {
  static {
    __name(this, "AttributeOnlyTest");
  }
  get _dialogTemplate() {
    return "systems/shadowrun6-elysium/dist/templates/apps/dialogs/attribute-only-test-dialog.html";
  }
  _prepareData(data, options) {
    data = super._prepareData(data, options);
    data.attribute1 = data.action.attribute;
    data.attribute2 = data.action.attribute2;
    return data;
  }
  prepareBaseValues() {
    this.prepareAttributeSelection();
    super.prepareBaseValues();
  }
  prepareAttributeSelection() {
    if (!this.actor) return;
    this.data.pool.mod = [];
    const pool = new PartsList(this.pool.mod);
    const attribute1 = this.actor.getAttribute(this.data.attribute1);
    const attribute2 = this.actor.getAttribute(this.data.attribute2);
    if (attribute1) pool.addPart(attribute1.label, attribute1.value);
    if (attribute2) pool.addPart(attribute2.label, attribute2.value);
    if (attribute1 && this.actor._isMatrixAttribute(this.data.attribute1)) this.actor._addMatrixParts(pool, true);
    if (attribute2 && this.actor._isMatrixAttribute(this.data.attribute2)) this.actor._addMatrixParts(pool, true);
  }
};

// src/module/rules/RecoveryRules.ts
var RecoveryRules = {
  /**
   * Can an actor heal physical damage depends on its stun track according to SR5#207 section 'Glitches&Healing'
   *
   * @param stunBoxes
   */
  canHealPhysicalDamage: /* @__PURE__ */ __name((stunBoxes) => {
    return stunBoxes === 0;
  }, "canHealPhysicalDamage")
};

// src/module/rules/ConditionRules.ts
var ConditionRules = {
  /**
   * Determine the current defeated status of an actor
   *
   * @param actor The actor to check out
   */
  determineDefeatedStatus: /* @__PURE__ */ __name((actor) => {
    const stun = actor.getStunTrack();
    const phyiscal = actor.getPhysicalTrack();
    const matrix = actor.getMatrixTrack();
    let unconscious = false;
    let dying = false;
    let dead = false;
    if (actor.isIC() || actor.isSprite()) {
      dead = matrix?.value === matrix?.max;
    } else if (actor.isVehicle() || actor.isGrunt()) {
      dead = phyiscal?.value === phyiscal?.max;
    } else {
      unconscious = stun?.value === stun?.max;
      dying = phyiscal?.value === phyiscal?.max;
      dead = phyiscal?.overflow.value === phyiscal?.overflow.max;
    }
    return {
      unconscious,
      dying,
      dead
    };
  }, "determineDefeatedStatus")
};

// src/module/actor/SR6Actor.ts
var SR6Actor = class _SR6Actor extends Actor {
  // TODO: foundry-vtt-types v10. Allows for {system: ...} to be given without type error
  constructor(data, context) {
    super(data, context);
    // This is the default inventory name and label for when no other inventory has been created.
    this.defaultInventory = {
      name: "Carried",
      label: "SR6.Labels.Inventory.Carried",
      itemIds: []
    };
    // This is a dummy inventory
    this.allInventories = {
      name: "All",
      label: "SR6.Labels.Inventory.All",
      itemIds: [],
      showAll: true
    };
    // Allow users to access to tests creation.
    this.tests = TestCreator;
    this.inventory = new InventoryFlow(this);
    this.modifiers = new ModifierFlow(this);
  }
  static {
    __name(this, "SR6Actor");
  }
  getOverwatchScore() {
    const os = this.getFlag(SYSTEM_NAME, "overwatchScore");
    return os !== void 0 ? os : 0;
  }
  async setOverwatchScore(value) {
    const num = parseInt(value);
    if (!isNaN(num)) {
      return this.setFlag(SYSTEM_NAME, "overwatchScore", num);
    }
  }
  /**
   * General data preparation order.
   * Check base, embeddedEntities and derived methods (see super.prepareData implementation for order)
   * Only implement data preparation here that doesn't fall into the other three categories.
   */
  prepareData() {
    super.prepareData();
  }
  /**
   *  Prepare base data. Be careful that this ONLY included data not in need for item access.
   *  Check Actor and ClientDocumentMixin.prepareData for order of data prep.
   *
   *  Shadowrun data preparation is separate from the actor entity see the different <>Prep classes like
   *  CharacterPrep
   */
  prepareBaseData() {
    super.prepareBaseData();
    switch (this.type) {
      case "character":
        CharacterPrep.prepareBaseData(this.system);
        break;
      case "critter":
        CritterPrep.prepareBaseData(this.system);
        break;
      case "spirit":
        SpiritPrep.prepareBaseData(this.system);
        break;
      case "sprite":
        SpritePrep.prepareBaseData(this.system);
        break;
      case "vehicle":
        VehiclePrep.prepareBaseData(this.system);
        break;
      case "ic":
        ICPrep.prepareBaseData(this.system);
        break;
    }
  }
  /**
   * prepare embedded entities. Check ClientDocumentMixin.prepareData for order of data prep.
   */
  prepareEmbeddedDocuments() {
    super.prepareEmbeddedDocuments();
  }
  /**
   * Should some ActiveEffects need to be excluded from the general application, do so here.
   * @override
   */
  applyActiveEffects() {
    try {
      super.applyActiveEffects();
    } catch (error) {
      console.error(`SR6: Elysium | Some effect changes could not be applied and might cause issues. Check effects of actor (${this.name}) / id (${this.id})`);
      console.error(error);
      ui.notifications?.error(`See browser console (F12): Some effect changes could not be applied and might cause issues. Check effects of actor (${this.name}) / id (${this.id})`);
    }
  }
  /**
   * Get all ActiveEffects applicable to this actor.
   *
   * The system uses a custom method of determining what ActiveEffect is applicable that doesn't
   * use default FoundryVTT allApplicableEffect.
   *
   * The system has additional support for:
   * - taking actor effects from items (apply-To actor)
   * - having effects apply that are part of a targeted action against this actor (apply-To targeted_actor)
   *
   * NOTE: FoundryVTT applyActiveEffects will check for disabled effects.
   */
  //@ts-expect-error TODO: foundry-vtt-types v10
  *allApplicableEffects() {
    for (const effect of allApplicableDocumentEffects(this, { applyTo: ["actor", "targeted_actor"] })) {
      yield effect;
    }
    for (const effect of allApplicableItemsEffects(this, { applyTo: ["actor"] })) {
      yield effect;
    }
  }
  /**
   * All temporary ActiveEffects that should display on the Token
   *
   * The shadowrun6-elysium system uses a custom application method with different effect application targets. Some of
   * these effects exist on the actor or one of it's items, however still shouldn't show in their token.
   *
   * While default Foundry relies on allApplicableEffects, as it only knows apply-to actor effects, we have to
   * return all effects that are temporary instead, to include none-actor apply-to effects.
   *
   * NOTE: Foundry also shows disabled effects by default. We behave the same.
   */
  // @ts-expect-error NOTE: I don't fully understand the typing here.
  get temporaryEffects() {
    const showEffectIcon = /* @__PURE__ */ __name((effect) => !effect.disabled && !effect.isSuppressed && effect.isTemporary && effect.appliesToLocalActor, "showEffectIcon");
    let effects = this.effects.filter(showEffectIcon);
    for (const item of this.items) {
      effects = effects.concat(item.effects.filter(showEffectIcon));
      for (const nestedItem of item.items) {
        effects = effects.concat(nestedItem.effects.filter(showEffectIcon));
      }
    }
    return effects;
  }
  /**
   * prepare embedded entities. Check ClientDocumentMixin.prepareData for order of data prep.
   *
   * At the moment general actor data preparation has been moved to derived data preparation, due it's dependence
   * on prepareEmbeddedEntities and prepareEmbeddedItems for items modifying attribute values and more.
   */
  prepareDerivedData() {
    super.prepareDerivedData();
    const itemDataWrappers = this.items.map((item) => new SR6ItemDataWrapper(item));
    switch (this.type) {
      case "character":
        CharacterPrep.prepareDerivedData(this.system, itemDataWrappers);
        break;
      case "critter":
        CritterPrep.prepareDerivedData(this.system, itemDataWrappers);
        break;
      case "spirit":
        SpiritPrep.prepareDerivedData(this.system, itemDataWrappers);
        break;
      case "sprite":
        SpritePrep.prepareDerivedData(this.system, itemDataWrappers);
        break;
      case "vehicle":
        VehiclePrep.prepareDerivedData(this.system, itemDataWrappers);
        break;
      case "ic":
        ICPrep.prepareDerivedData(this.system, itemDataWrappers);
        break;
    }
  }
  /**
   * NOTE: This method is unused at the moment, keep it for future inspiration.
   */
  applyOverrideActiveEffects() {
    const changes = this.effects.reduce((changes2, effect) => {
      if (effect.data.disabled) return changes2;
      return changes2.concat(effect.data.changes.filter((change) => change.mode === CONST.ACTIVE_EFFECT_MODES.OVERRIDE).map((change) => {
        change = foundry.utils.duplicate(change);
        change.effect = effect;
        change.priority = change.priority ?? change.mode * 10;
        return change;
      }));
    }, []);
    changes.sort((a2, b2) => a2.priority - b2.priority);
    for (const change of changes) {
      change.effect.apply(this, change);
    }
  }
  /**
   * A helper method to only apply a subset of keys instead of all.
   * @param partialKeys Can either be complete keys or partial keys
   */
  _applySomeActiveEffects(partialKeys) {
    const changes = this._reduceEffectChangesByKeys(partialKeys);
    this._applyActiveEffectChanges(changes);
  }
  /**
   * A helper method to apply a active effect changes collection (which might come from multiple active effects)
   * @param changes
   */
  _applyActiveEffectChanges(changes) {
    const overrides = {};
    for (const change of changes) {
      const result = change.effect.apply(this, change);
      if (result !== null) overrides[change.key] = result;
    }
    this.overrides = { ...this.overrides, ...foundry.utils.expandObject(overrides) };
  }
  /**
   * Reduce all changes across multiple active effects that match the given set of partial keys
   * @param partialKeys Can either be complete keys or partial keys
   */
  _reduceEffectChangesByKeys(partialKeys) {
    const changes = this.effects.reduce((changes2, effect) => {
      if (effect.data.disabled) return changes2;
      return changes2.concat(effect.data.changes.filter((change) => partialKeys.some((partialKey) => change.key.includes(partialKey))).map((change) => {
        change = foundry.utils.duplicate(change);
        change.effect = effect;
        change.priority = change.priority ?? change.mode * 10;
        return change;
      }));
    }, []);
    changes.sort((a2, b2) => a2.priority - b2.priority);
    return changes;
  }
  /**
   * Some actors have skills, some don't. While others don't have skills but derive skill values from their ratings.
   */
  findActiveSkill(skillName) {
    if (!skillName) return;
    const skills = this.getActiveSkills();
    const skill = skills[skillName];
    if (skill) return skill;
    return Object.values(skills).find((skill2) => skill2.name === skillName);
  }
  findAttribute(id) {
    if (id === void 0) return;
    const attributes = this.getAttributes();
    if (!attributes) return;
    return attributes[id];
  }
  findVehicleStat(statName) {
    if (statName === void 0) return;
    const vehicleStats = this.getVehicleStats();
    if (vehicleStats)
      return vehicleStats[statName];
  }
  getWoundModifier() {
    if (!("wounds" in this.system)) return 0;
    return -1 * this.system.wounds.value || 0;
  }
  /** Use edge on actors that have an edge attribute.
   *
   * NOTE: This doesn't only include characters but spirits, critters and more.
   */
  async useEdge(by = -1) {
    const edge = this.getEdge();
    if (edge && edge.value === 0) return;
    const usesLeft = edge.uses > 0 ? edge.uses : by * -1;
    const uses = Math.min(edge.value, usesLeft + by);
    await this.update({ "system.attributes.edge.uses": uses });
  }
  getEdge() {
    return this.system.attributes.edge;
  }
  hasArmor() {
    return "armor" in this.system;
  }
  /**
   * Return armor worn by this actor.
   *
   * @param damage If given will be applied to the armor to get modified armor.
   * @returns Armor or modified armor.
   */
  getArmor(damage) {
    const armor3 = "armor" in this.system ? foundry.utils.duplicate(this.system.armor) : DataDefaults.actorArmor();
    damage = damage || DataDefaults.damageData();
    Helpers.calcTotal(damage);
    Helpers.calcTotal(damage.ap);
    if (damage.ap.value !== 0)
      PartsList.AddUniquePart(armor3.mod, "SR6.AP", damage.ap.value);
    if (damage.element.value !== "") {
      const armorForDamageElement = armor3[damage.element.value] || 0;
      if (armorForDamageElement > 0)
        PartsList.AddUniquePart(armor3.mod, "SR6.Element", armorForDamageElement);
    }
    Helpers.calcTotal(armor3, { min: 0 });
    return armor3;
  }
  getMatrixDevice() {
    if (!("matrix" in this.system)) return;
    const matrix = this.system.matrix;
    if (matrix.device) return this.items.get(matrix.device);
  }
  getFullDefenseAttribute() {
    if (this.isVehicle()) {
      return this.findVehicleStat("pilot");
    } else if (this.isCharacter()) {
      const character = this.asCharacter();
      if (character) {
        let att = character.system.full_defense_attribute;
        if (!att) att = "willpower";
        return this.findAttribute(att);
      }
    }
  }
  getEquippedWeapons() {
    return this.items.filter((item) => item.isEquipped() && item.isWeapon);
  }
  /**
   * Amount of recoil compensation this actor has available (without the weapon used).
   */
  get recoilCompensation() {
    if (!this.system.values.hasOwnProperty("recoil_compensation")) return 0;
    return this.system.values.recoil_compensation.value;
  }
  /**
   * Current recoil compensation with current recoil included.
   *
   * @returns A positive number or zero.
  */
  get currentRecoilCompensation() {
    return Math.max(this.recoilCompensation - this.recoil, 0);
  }
  /**
   * Amount of progressive recoil this actor has accrued.
   */
  get recoil() {
    if (!this.system.values.hasOwnProperty("recoil")) return 0;
    return this.system.values.recoil.value;
  }
  getDeviceRating() {
    if (!("matrix" in this.system)) return 0;
    return parseInt(this.system.matrix.rating);
  }
  getAttributes() {
    return this.system.attributes;
  }
  /**
       * Return the given attribute, no matter its source.
       *
       * For characters and similar this will only return their attributes.
       * For vehicles this will also return their vehicle stats.
  
       * @param name An attribute or other stats name.
       * @returns Note, this can return undefined. It is not typed that way, as it broke many things. :)
       */
  getAttribute(name3) {
    const stats = this.getVehicleStats();
    if (stats && stats[name3]) return stats[name3];
    const attributes = this.getAttributes();
    return attributes[name3];
  }
  /** Return actor type, which can be different kind of actors from 'character' to 'vehicle'.
   *  Please check SR5ActorType for reference.
   */
  getType() {
    return this.type;
  }
  isCharacter() {
    return this.getType() === "character";
  }
  isSpirit() {
    return this.getType() === "spirit";
  }
  isSprite() {
    return this.getType() === "sprite";
  }
  isVehicle() {
    return this.getType() === "vehicle";
  }
  isGrunt() {
    if (!("is_npc" in this.system) || !("npc" in this.system)) return false;
    return this.system.is_npc && this.system.npc.is_grunt;
  }
  isCritter() {
    return this.getType() === "critter";
  }
  isIC() {
    return this.getType() === "ic";
  }
  /**
   * Determine if this actor is able to have natural damage recovery.
   * @returns true in case of possible natural recovery.
   */
  get hasNaturalRecovery() {
    return this.isCharacter() || this.isCritter();
  }
  getVehicleTypeSkillName() {
    if (!("vehicleType" in this.system)) return;
    switch (this.system.vehicleType) {
      case "air":
        return "pilot_aircraft";
      case "ground":
        return "pilot_ground_craft";
      case "water":
        return "pilot_water_craft";
      case "aerospace":
        return "pilot_aerospace";
      case "walker":
        return "pilot_walker";
      case "exotic":
        return "pilot_exotic_vehicle";
      default:
        return;
    }
  }
  getVehicleTypeSkill() {
    if (!this.isVehicle()) return;
    const name3 = this.getVehicleTypeSkillName();
    return this.findActiveSkill(name3);
  }
  get hasSkills() {
    return this.getSkills() !== void 0;
  }
  getSkills() {
    return this.system.skills;
  }
  getActiveSkills() {
    return this.system.skills.active;
  }
  getNetworkController() {
    if (!this.isVehicle()) return;
    return this.asVehicle()?.system?.networkController;
  }
  async setNetworkController(networkController) {
    if (!this.isVehicle()) return;
    await this.update({ "system.networkController": networkController });
  }
  get canBeNetworkDevice() {
    return this.isVehicle();
  }
  /**
   * Determine if an actor can choose a special trait using the special field.
   */
  get hasSpecial() {
    return ["character", "sprite", "spirit", "critter"].includes(this.type);
  }
  /**
   * Determine if an actor can alter the special trait
   */
  get canAlterSpecial() {
    return this.hasSpecial && ["character", "critter"].includes(this.type);
  }
  /**
   * Determine if an actor can choose a full defense attribute
   */
  get hasFullDefense() {
    return ["character", "vehicle", "sprite", "spirit", "critter"].includes(this.type);
  }
  /**
   * Determine if an actor is awakened / magical in some kind.
   */
  get isAwakened() {
    return this.system.special === "magic";
  }
  /**
   * This actor is emerged as a matrix native actor (Technomancers, Sprites)
   *
   */
  get isEmerged() {
    if (this.isSprite()) return true;
    if (this.isCharacter() && this.system.special === "resonance") return true;
    return false;
  }
  /**
   * Return the full pool of a skill including attribute and possible specialization bonus.
   * @param skillId The ID of the skill. Note that this can differ from what is shown in the skill list. If you're
   *                unsure about the id and want to search
   * @param options An object to change the behavior.
   *                The property specialization will trigger the pool value to be raised by a specialization modifier
   *                The property byLabel will cause the param skillId to be interpreted as the shown i18n label.
   */
  getPool(skillId, options = { specialization: false, byLabel: false }) {
    const skill = options.byLabel ? this.getSkillByLabel(skillId) : this.getSkill(skillId);
    if (!skill || !skill.attribute) return 0;
    if (!SkillFlow.allowRoll(skill)) return 0;
    const attribute = this.getAttribute(skill.attribute);
    const attributeValue = typeof attribute.value === "number" ? attribute.value : 0;
    const skillValue = typeof skill.value === "number" ? skill.value : 0;
    if (SkillRules.mustDefaultToRoll(skill) && SkillRules.allowDefaultingRoll(skill)) {
      return SkillRules.defaultingModifier + attributeValue;
    }
    const specializationBonus = options.specialization ? SR.skill.SPECIALIZATION_MODIFIER : 0;
    return skillValue + attributeValue + specializationBonus;
  }
  /**
   * Find a skill either by id or label.
   *
   * Skills are mapped by an id, which can be a either a lower case name (legacy skills) or a short uid (custom, language, knowledge).
   * Legacy skills use their name as the id, while not having a name set on the SkillField.
   * Custom skills use an id and have their name set, however no label. This goes for active, language and knowledge.
   *
   * NOTE: Normalizing skill mapping from active, language and knowledge to a single skills with a type property would
   *       clear this function up.
   *
   * @param id Either the searched id, name or translated label of a skill
   * @param options .byLabel when true search will try to match given skillId with the translated label
   */
  getSkill(id, options = { byLabel: false }) {
    if (options.byLabel)
      return this.getSkillByLabel(id);
    const { skills } = this.system;
    if (skills.active.hasOwnProperty(id)) {
      return skills.active[id];
    }
    if (skills.language.value.hasOwnProperty(id)) {
      return skills.language.value[id];
    }
    for (const categoryKey in skills.knowledge) {
      if (skills.knowledge.hasOwnProperty(categoryKey)) {
        const category3 = skills.knowledge[categoryKey];
        if (category3.value.hasOwnProperty(id)) {
          return category3.value[id];
        }
      }
    }
    return this.getSkillByLabel(id);
  }
  /**
   * Search all skills for a matching i18n translation label.
   * NOTE: You should use getSkill if you have the skillId ready. Only use this for ease of use!
   *
   * @param searchedFor The translated output of either the skill label (after localize) or name of the skill in question.
   * @return The first skill found with a matching translation or name.
   */
  getSkillByLabel(searchedFor) {
    if (!searchedFor) return;
    const possibleMatch = /* @__PURE__ */ __name((skill) => skill.label ? game.i18n.localize(skill.label) : skill.name, "possibleMatch");
    const skills = this.getSkills();
    for (const [id, skill] of Object.entries(skills.language.value)) {
      if (searchedFor === possibleMatch(skill))
        return { ...skill, id };
    }
    for (const categoryKey in skills.knowledge) {
      if (!skills.knowledge.hasOwnProperty(categoryKey)) continue;
      const categorySkills = skills.knowledge[categoryKey].value;
      for (const [id, skill] of Object.entries(categorySkills)) {
        if (searchedFor === possibleMatch(skill))
          return { ...skill, id };
      }
    }
    for (const [id, skill] of Object.entries(skills.active)) {
      if (searchedFor === possibleMatch(skill))
        return { ...skill, id };
    }
  }
  /**
   * For the given skillId as it be would in the skill data structure for either
   * active, knowledge or language skill.
   *
   * @param skillId Legacy / default skills have human-readable ids, while custom one have machine-readable.
   * @returns The label (not yet translated) OR set custom name.
   */
  getSkillLabel(skillId) {
    const skill = this.getSkill(skillId);
    if (!skill) {
      return "";
    }
    return skill.label ?? skill.name ?? "";
  }
  /**
   * Add a new knowledge skill for a specific category.
   *
   * Knowledge skills are stored separately from active and language skills and have
   * some values pre-defined by their category (street, professional, ...)
   *
   * @param category Define the knowledge skill category
   * @param skill  Partially define the SkillField properties needed. Omitted properties will be default.
   * @returns The id of the created knowledge skill.
   */
  async addKnowledgeSkill(category3, skill = { name: SKILL_DEFAULT_NAME }) {
    if (!this.system.skills.knowledge.hasOwnProperty(category3)) {
      console.error(`SR6: Elysium | Tried creating knowledge skill with unknown category ${category3}`);
      return;
    }
    skill = DataDefaults.skillData(skill);
    const id = randomID(16);
    const value = {};
    value[id] = skill;
    const fieldName = `system.skills.knowledge.${category3}.value`;
    const updateData = {};
    updateData[fieldName] = value;
    await this.update(updateData);
    return id;
  }
  /**
   * Add a new active skill.
   *
   * @param skillData Partially define the SkillField properties needed. Omitted properties will be default.
   * @returns The new active skill id.
   */
  async addActiveSkill(skillData = { name: SKILL_DEFAULT_NAME }) {
    const skill = DataDefaults.skillData(skillData);
    const activeSkillsPath = "system.skills.active";
    const updateSkillDataResult = Helpers.getRandomIdSkillFieldDataEntry(activeSkillsPath, skill);
    if (!updateSkillDataResult) return;
    const { updateSkillData, id } = updateSkillDataResult;
    await this.update(updateSkillData);
    return id;
  }
  /**
   * Remove a language skill by it's id.
   * @param skillId What skill id to delete.
   */
  async removeLanguageSkill(skillId) {
    const updateData = Helpers.getDeleteKeyUpdateData("system.skills.language.value", skillId);
    await this.update(updateData);
  }
  /**
   * Add a language skill.
   *
   * @param skill Partially define the SkillField properties needed. Omitted properties will be default.
   * @returns The new language skill id.
   */
  async addLanguageSkill(skill) {
    const defaultSkill = {
      name: "",
      specs: [],
      base: 0,
      value: 0,
      // TODO: BUG ModifiableValue is ModList<number>[] and not number
      mod: 0
    };
    skill = {
      ...defaultSkill,
      ...skill
    };
    const id = randomID(16);
    const value = {};
    value[id] = skill;
    const fieldName = `system.skills.language.value`;
    const updateData = {};
    updateData[fieldName] = value;
    await this.update(updateData);
    return id;
  }
  /**
   * Remove a knowledge skill
   * @param skillId What skill id to delete.
   * @param category The matching knowledge skill category for skillId
   */
  async removeKnowledgeSkill(skillId, category3) {
    const updateData = Helpers.getDeleteKeyUpdateData(`system.skills.knowledge.${category3}.value`, skillId);
    await this.update(updateData);
  }
  /**
   * Delete the given active skill by it's id. It doesn't
   *
   * @param skillId Either a random id for custom skills or the skills name used as an id.
   */
  async removeActiveSkill(skillId) {
    const activeSkills = this.getActiveSkills();
    if (!activeSkills.hasOwnProperty(skillId)) return;
    const skill = this.getSkill(skillId);
    if (!skill) return;
    if (skill.name === "" && skill.label !== void 0 && skill.label !== "") {
      await this.hideSkill(skillId);
      if (!this.prototypeToken.actorLink)
        await this.sheet?.render();
      return;
    }
    const updateData = Helpers.getDeleteKeyUpdateData("system.skills.active", skillId);
    await this.update(updateData);
  }
  /**
   * Mark the given skill as hidden.
   *
   * NOTE: Hiding skills has
   *
   * @param skillId The id of any type of skill.
   */
  async hideSkill(skillId) {
    if (!skillId) return;
    const skill = this.getSkill(skillId);
    if (!skill) return;
    skill.hidden = true;
    const updateData = Helpers.getUpdateDataEntry(`system.skills.active.${skillId}`, skill);
    await this.update(updateData);
  }
  /**
   * mark the given skill as visible.
   *
   * @param skillId The id of any type of skill.
   */
  async showSkill(skillId) {
    if (!skillId) return;
    const skill = this.getSkill(skillId);
    if (!skill) return;
    skill.hidden = false;
    const updateData = Helpers.getUpdateDataEntry(`system.skills.active.${skillId}`, skill);
    await this.update(updateData);
  }
  /**
   * Show all hidden skills.
   *
   * For hiding/showing skill see SR6Actor#showSkill and SR6Actor#hideSkill.
   */
  async showHiddenSkills() {
    const updateData = {};
    const skills = this.getActiveSkills();
    for (const [id, skill] of Object.entries(skills)) {
      if (skill.hidden === true) {
        skill.hidden = false;
        updateData[`system.skills.active.${id}`] = skill;
      }
    }
    if (!updateData) return;
    await this.update(updateData);
    if (!this.prototypeToken.actorLink)
      await this.sheet?.render();
  }
  /**
   * Prompt the current user for a generic roll.
   */
  async promptRoll() {
    await this.tests.promptSuccessTest();
  }
  /**
   * The general action process has currently no good way of injecting device ratings into the mix.
   * So, let's trick a bit.
   *
   * @param options
   */
  async rollDeviceRating(options) {
    const rating = this.getDeviceRating();
    const showDialog = this.tests.shouldShowDialog(options?.event);
    const testCls = this.tests._getTestClass("SuccessTest");
    const test = new testCls({}, { actor: this }, { showDialog });
    const pool = new PartsList(test.pool.mod);
    pool.addPart("SR6.Labels.ActorSheet.DeviceRating", rating);
    pool.addPart("SR6.Labels.ActorSheet.DeviceRating", rating);
    const mods3 = new PartsList(test.data.modifiers.mod);
    mods3.addUniquePart("SR6.ModifierTypes.Global", this.modifiers.totalFor("global"));
    return await test.execute();
  }
  /**
   * Get an action from any pack with the given name, configured for this actor and let the caller handle it..
   *
   * @param packName The name of the item pack to search.
   * @param actionName The name within that pack.
   * @param options Success Test options
   * @returns the test instance after configuration and before it's execution.
   */
  async packActionTest(packName, actionName, options) {
    const showDialog = this.tests.shouldShowDialog(options?.event);
    return await this.tests.fromPackAction(packName, actionName, this, { showDialog });
  }
  /**
   * Roll an action from any pack with the given name.
   *
   * @param packName The name of the item pack to search.
   * @param actionName The name within that pack.
   * @param options Success Test options
   * @returns the test instance after it's been executed
   */
  async rollPackAction(packName, actionName, options) {
    const test = await this.packActionTest(packName, actionName, options);
    if (!test) return console.error("Shadowrun 6e | Rolling pack action failed");
    return await test.execute();
  }
  /**
   * Get an action as defined within the systems general action pack.
   *
   * @param actionName The action with in the general pack.
   * @param options Success Test options
   */
  async generalActionTest(actionName, options) {
    return await this.packActionTest(SR6.packNames.generalActions, actionName, options);
  }
  /**
   * Roll an action as defined within the systems general action pack.
   *
   * @param actionName The action with in the general pack.
   * @param options Success Test options
   */
  async rollGeneralAction(actionName, options) {
    return await this.rollPackAction(SR6.packNames.generalActions, actionName, options);
  }
  /**
   * Roll a skill test for a specific skill
   * @param skillId The id or label for the skill. When using a label, the appropriate option must be set.
   * @param options Optional options to configure the roll.
   * @param options.byLabel true to search the skill by label as displayed on the sheet.
   * @param options.specialization true to configure the skill test to use a specialization.
   */
  async rollSkill(skillId, options = {}) {
    console.info(`SR6: Elysium | Rolling skill test for ${skillId}`);
    const action = this.skillActionData(skillId, options);
    if (!action) return;
    if (options.threshold) {
      action.threshold = options.threshold;
    }
    const showDialog = this.tests.shouldShowDialog(options.event);
    const test = await this.tests.fromAction(action, this, { showDialog });
    if (!test) return;
    return await test.execute();
  }
  /**
   * Roll a general attribute test with one or two attributes.
   *
   * @param name The attributes name as defined within data
   * @param options Change general roll options.
   */
  async rollAttribute(name3, options = {}) {
    console.info(`SR6: Elysium | Rolling attribute ${name3} test from ${this.constructor.name}`);
    const action = DataDefaults.actionRollData({ attribute: name3, test: AttributeOnlyTest.name });
    const showDialog = this.tests.shouldShowDialog(options.event);
    const test = await this.tests.fromAction(action, this, { showDialog });
    if (!test) return;
    return await test.execute();
  }
  /**
   * Roll a skill test for a specific skill
   * @param skillId The id or label for the skill. When using a label, the appropriate option must be set.
   * @param options Optional options to configure the roll.
   * @param options.byLabel true to search the skill by label as displayed on the sheet.
   * @param options.specialization true to configure the skill test to use a specialization.
   */
  async startTeamworkTest(skillId, options = {}) {
    console.info(`SR6: Elysium | Starting teamwork test for ${skillId}`);
    const templateData = {
      title: "Teamwork " + Helpers.getSkillTranslation(skillId),
      // Note: While ChatData uses ids, this uses full documents.
      speaker: {
        actor: this,
        token: this.token
      },
      participants: []
    };
    const content = await renderTemplate("systems/shadowrun6-elysium/dist/templates/rolls/teamwork-test-message.html", templateData);
    const messageData = {
      user: game.user?.id,
      // Use type roll, for Foundry built in content visibility.
      type: CONST.CHAT_MESSAGE_TYPES.ROLL,
      speaker: {
        actor: this.id,
        alias: game.user?.name,
        token: this.token
      },
      content,
      // Manually build flag data to give renderChatMessage hook flag access.
      // This test data is needed for all subsequent testing based on this chat messages.
      flags: {
        // Add test data to message to allow ChatMessage hooks to access it.
        [SYSTEM_NAME]: { [FLAGS.Test]: { skill: skillId } },
        "core.canPopout": true
      },
      sound: CONFIG.sounds.dice
    };
    const message = await ChatMessage.create(messageData, options);
    if (!message) return;
    return message;
  }
  /**
  * Roll a skill test for a specific skill
  * @param skillId The id or label for the skill. When using a label, the appropriate option must be set.
  * @param options Optional options to configure the roll.
  * @param options.byLabel true to search the skill by label as displayed on the sheet.
  * @param options.specialization true to configure the skill test to use a specialization.
  */
  async rollTeamworkTest(skillId, teamworkData, options = {}) {
    console.info(`SR6: Elysium | Rolling teamwork test for ${skillId}`);
    const action = this.skillActionData(skillId, options);
    if (!action) return;
    if (teamworkData.criticalGlitch != true) {
      action.limit.mod.push({ name: "Teamwork", value: teamworkData.additionalLimit });
    }
    action.dice_pool_mod.push({ name: "Teamwork", value: teamworkData.additionalDice });
    const showDialog = this.tests.shouldShowDialog(options.event);
    const test = await this.tests.fromAction(action, this, { showDialog });
    if (!test) return;
    return await test.execute();
  }
  /**
   * Is the given attribute id a matrix attribute
   * @param attribute
   */
  _isMatrixAttribute(attribute) {
    return SR6.matrixAttributes.hasOwnProperty(attribute);
  }
  /**
   * Add matrix modifier values to the given modifier parts from whatever Value as part of
   * matrix success test.
   *
   * @param parts The Value.mod field as a PartsList
   * @param atts The attributes used for the success test.
   */
  _addMatrixParts(parts, atts) {
    if (Helpers.isMatrix(atts)) {
      if (!("matrix" in this.system)) return;
      const matrix = this.system.matrix;
      if (matrix.hot_sim) parts.addUniquePart("SR6.HotSim", 2);
      if (matrix.running_silent) parts.addUniquePart("SR6.RunningSilent", -2);
    }
  }
  /**
   * Remove matrix modifier values to the given modifier part
   *
   * @param parts A Value.mod field as a PartsList
   */
  _removeMatrixParts(parts) {
    ["SR6.HotSim", "SR6.RunningSilent"].forEach((part) => parts.removePart(part));
  }
  /**
   * Build an action for the given skill id based on it's configured values.
   *
   * @param skillId Any skill, no matter if active, knowledge or language
   * @param options
   */
  skillActionData(skillId, options = {}) {
    const byLabel = options.byLabel || false;
    const skill = this.getSkill(skillId, { byLabel });
    if (!skill) {
      console.error(`Shadowrun 6e | Skill ${skillId} is not registered of actor ${this.id}`);
      return;
    }
    skillId = skill.id || skillId;
    const attribute = this.getAttribute(skill.attribute);
    const limit = "";
    const spec = options.specialization || false;
    return DataDefaults.actionRollData({
      skill: skillId,
      spec,
      attribute: skill.attribute,
      limit: {
        base: 0,
        value: 0,
        mod: [],
        attribute: limit,
        base_formula_operator: "add"
      },
      test: "SkillTest"
    });
  }
  /**
   * Override setFlag to remove the 'SR6.' from keys in modlists, otherwise it handles them as embedded keys
   * @param scope
   * @param key
   * @param value
   */
  //@ts-expect-error // TODO: foundry-vtt-types v10
  setFlag(scope, key, value) {
    const newValue = Helpers.onSetFlag(value);
    return super.setFlag(scope, key, newValue);
  }
  /**
   * Override getFlag to add back the 'SR6.' keys correctly to be handled
   * @param scope
   * @param key
   */
  //@ts-expect-error // TODO: foundry-vtt-types v10
  getFlag(scope, key) {
    const data = super.getFlag(scope, key);
    return Helpers.onGetFlag(data);
  }
  /** Return either the linked token or the token of the synthetic actor.
   *
   * @return Will return null should no token have been placed on scene.
   */
  getToken() {
    if (this._isLinkedToToken() && this.hasToken()) {
      const linked = true;
      const tokens = this.getActiveTokens(linked);
      return tokens[0].document;
    }
    return this.token;
  }
  /**
   * There is no need for a token to placed. The prototype token is enough.
   */
  _isLinkedToToken() {
    return this.prototypeToken.actorLink && !this.token;
  }
  hasToken() {
    return this.getActiveTokens().length > 0;
  }
  hasActivePlayerOwner() {
    const players = this.getActivePlayerOwners();
    return players.length > 0;
  }
  getActivePlayer() {
    if (!game.users) return null;
    if (!this.hasPlayerOwner) return null;
    for (const user of game.users.contents) {
      if (!user.active || user.isGM) {
        continue;
      }
      if (this.id === user.character?.id) {
        return user;
      }
    }
    return null;
  }
  getActivePlayerOwners() {
    return Helpers.getPlayersWithPermission(this, "OWNER", true);
  }
  __addDamageToTrackValue(damage, track) {
    if (damage.value === 0) return track;
    if (track.value === track.max) return track;
    track = foundry.utils.duplicate(track);
    track.value += damage.value;
    if (track.value > track.max) {
      console.error("Damage did overflow the track, which shouldn't happen at this stage. Damage has been set to max. Please use applyDamage.");
      track.value = track.max;
    }
    return track;
  }
  async _addDamageToDeviceTrack(damage, device) {
    if (!device) return;
    let condition = device.getCondition();
    if (!condition) return damage;
    if (damage.value === 0) return;
    if (condition.value === condition.max) return;
    condition = this.__addDamageToTrackValue(damage, condition);
    const updateData = { ["system.technology.condition_monitor"]: condition };
    await device.update(updateData);
  }
  /**
   * Apply damage to an actors main damage monitor / track.
   *
   * This includes physical and stun for meaty actors and matrix for matrix actors.
   *
   * Applying damage will also reduce the initiative score of an active combatant.
   *
   * Handles rule 'Changing Initiative' on SR5#160.
   *
   * @param damage The damage to be taken.
   * @param track The track to apply that damage to.
   */
  async _addDamageToTrack(damage, track) {
    if (damage.value === 0) return;
    if (track.value === track.max) return;
    const woundsBefore = this.getWoundModifier();
    track = this.__addDamageToTrackValue(damage, track);
    const updateData = { [`system.track.${damage.type.value}`]: track };
    await this.update(updateData);
    const woundsAfter = this.getWoundModifier();
    const iniAdjustment = CombatRules.initiativeScoreWoundAdjustment(woundsBefore, woundsAfter);
    if (iniAdjustment < 0 && game.combat) game.combat.adjustActorInitiative(this, iniAdjustment);
  }
  /**
   * Apply damage to an actors physical overflow damage monitor / track.
   *
   * @param damage The damage to overflow.
   * @param track The track to overflow the damage into.
   * @returns
   */
  async _addDamageToOverflow(damage, track) {
    if (damage.value === 0) return;
    if (track.overflow.value === track.overflow.max) return;
    const overflow = foundry.utils.duplicate(track.overflow);
    overflow.value += damage.value;
    overflow.value = Math.min(overflow.value, overflow.max);
    const updateData = { [`system.track.${damage.type.value}.overflow`]: overflow };
    await this.update(updateData);
  }
  /**
   * Heal damage on a given damage track. Be aware that healing damage doesn't equate to recovering damage
   * and will not adhere to the recovery rules.
   *
   * @param track What track should be healed?
   * @param healing How many boxes of healing should be done?
   */
  async healDamage(track, healing) {
    console.log(`SR6: Elysium | Healing ${track} damage of ${healing} for actor`, this);
    if (!this.system?.track.hasOwnProperty(track)) return;
    const current = Math.max(this.system.track[track].value - healing, 0);
    await this.update({ [`system.track.${track}.value`]: current });
  }
  async healStunDamage(healing) {
    await this.healDamage("stun", healing);
  }
  async healPhysicalDamage(healing) {
    await this.healDamage("physical", healing);
  }
  get canRecoverPhysicalDamage() {
    const stun = this.getStunTrack();
    if (!stun) return false;
    return RecoveryRules.canHealPhysicalDamage(stun.value);
  }
  /**
   * Apply damage to the stun track and get overflow damage for the physical track.
   *
   * @param damage The to be applied damage.
   * @returns overflow damage after stun damage is full.
   */
  async addStunDamage(damage) {
    if (damage.type.value !== "stun") return damage;
    const track = this.getStunTrack();
    if (!track)
      return damage;
    const { overflow, rest } = this._calcDamageOverflow(damage, track);
    if (overflow.value > 0) {
      overflow.value = Math.floor(overflow.value / 2);
      overflow.type.value = "physical";
    }
    await this._addDamageToTrack(rest, track);
    return overflow;
  }
  /**
   * Apply damage to the physical track and get overflow damage for the physical overflow track.
   *
   * @param damage The to be applied damage.
   */
  async addPhysicalDamage(damage) {
    if (damage.type.value !== "physical") {
      return damage;
    }
    const track = this.getPhysicalTrack();
    if (!track) {
      return damage;
    }
    const { overflow, rest } = this._calcDamageOverflow(damage, track);
    await this._addDamageToTrack(rest, track);
    await this._addDamageToOverflow(overflow, track);
  }
  /**
   * Matrix damage can be added onto different tracks:
   * - IC has a local matrix.condition_monitor
   * - Characters have matrix devices (items) with their local track
   */
  async addMatrixDamage(damage) {
    if (damage.type.value !== "matrix") return;
    const device = this.getMatrixDevice();
    const track = this.getMatrixTrack();
    if (!track) return damage;
    const { overflow, rest } = this._calcDamageOverflow(damage, track);
    if (device) {
      await this._addDamageToDeviceTrack(rest, device);
    }
    if (this.isIC() || this.isSprite()) {
      await this._addDamageToTrack(rest, track);
    }
  }
  /**
   * Apply damage of any type to this actor. This should be the main entry method to applying damage.
   *
   * @param damage Damage to be applied
   * @returns overflow damage.
   */
  async addDamage(damage) {
    switch (damage.type.value) {
      case "matrix":
        await this.addMatrixDamage(damage);
        break;
      case "stun":
        const overflow = await this.addStunDamage(damage);
        await this.addPhysicalDamage(overflow);
        break;
      case "physical":
        await this.addPhysicalDamage(damage);
        break;
    }
    await this.applyDefeatedStatus();
  }
  /**
   * Directly set the matrix damage track of this actor to a set amount.
   *
   * This is mainly used for manual user input on an actor sheet.
   *
   * This is done by resetting all tracked damage and applying one manual damage set.
   *
   * @param value The matrix damage to be applied.
   */
  async setMatrixDamage(value) {
    value = Math.max(value, 0);
    const damage = DataDefaults.damageData({
      type: { base: "matrix", value: "matrix" },
      base: value,
      value
    });
    let track = this.getMatrixTrack();
    if (!track) return;
    track.value = 0;
    if (value > 0)
      track = this.__addDamageToTrackValue(damage, track);
    const device = this.getMatrixDevice();
    if (device) {
      return await device.update({ "system.technology.condition_monitor": track });
    }
    if (this.isIC()) {
      return await this.update({ "system.track.matrix": track });
    }
    if (this.isMatrixActor) {
      return await this.update({ "system.matrix.condition_monitor": track });
    }
  }
  /** Calculate damage overflow only based on max and current track values.
   */
  _calcDamageOverflow(damage, track) {
    const freeTrackDamage = track.max - track.value;
    const overflowDamage = damage.value > freeTrackDamage ? damage.value - freeTrackDamage : 0;
    const restDamage = damage.value - overflowDamage;
    const overflow = foundry.utils.duplicate(damage);
    const rest = foundry.utils.duplicate(damage);
    overflow.value = overflowDamage;
    rest.value = restDamage;
    return { overflow, rest };
  }
  getStunTrack() {
    if ("track" in this.system && "stun" in this.system.track)
      return this.system.track.stun;
  }
  getPhysicalTrack() {
    if ("track" in this.system && "physical" in this.system.track)
      return this.system.track.physical;
  }
  /**
   * The matrix depends on actor type and possibly equipped matrix device.
   *
   * Use this method for whenever you need to access this actors matrix damage track as it's source might differ.
   */
  getMatrixTrack() {
    if ("track" in this.system && "matrix" in this.system.track) {
      return this.system.track.matrix;
    }
    if (this.isMatrixActor) {
      return this.system.matrix.condition_monitor;
    }
    const device = this.getMatrixDevice();
    if (!device) return void 0;
    return device.getCondition();
  }
  /**
   * Depending on this actors defeated status, apply the correct effect and status.
   *
   * This will only work when the actor is connected to a token.
   *
   * @param defeated Optional defeated status to be used. Will be determined if not given.
   */
  async applyDefeatedStatus(defeated) {
    const token = this.getToken();
    if (!token || !game.settings.get(SYSTEM_NAME, FLAGS.UseDamageCondition)) return;
    defeated = defeated ?? ConditionRules.determineDefeatedStatus(this);
    await this.removeDefeatedStatus(defeated);
    if (defeated.unconscious || defeated.dying || defeated.dead) {
      await this.combatant?.update({ defeated: true });
    } else {
      return await this.combatant?.update({ defeated: false });
    }
    let newStatus = "unconscious";
    if (defeated.dying) newStatus = "unconscious";
    if (defeated.dead) newStatus = "dead";
    const status = CONFIG.statusEffects.find((e2) => e2.id === newStatus);
    const effect = status || CONFIG.controlIcons.defeated;
    const existing = this.effects.reduce((arr, e2) => {
      if (e2.statuses.size === 1 && e2.statuses.has(effect.id)) {
        arr.push(e2.id);
      }
      return arr;
    }, []);
    if (existing.length) return;
    await token.object.toggleEffect(effect, { overlay: true, active: true });
  }
  /**
   * Remove defeated status effects from this actor, depending on current status.
   *
   * @param defeated Optional defeated status to be used. Will be determined if not given.
   */
  async removeDefeatedStatus(defeated) {
    defeated = defeated ?? ConditionRules.determineDefeatedStatus(this);
    const removeStatus = [];
    if (!defeated.unconscious && !defeated.dying || defeated.dead) removeStatus.push("unconscious");
    if (!defeated.dead) removeStatus.push("dead");
    if (removeStatus.length) {
      const existing = this.effects.reduce((arr, e2) => {
        if (e2.statuses.size === 1 && e2.statuses.some((status) => removeStatus.includes(status))) arr.push(e2.id);
        return arr;
      }, []);
      if (existing.length) await this.deleteEmbeddedDocuments("ActiveEffect", existing);
    }
  }
  getModifiedArmor(damage) {
    if (!damage.ap?.value) {
      return this.getArmor();
    }
    const modified = foundry.utils.duplicate(this.getArmor());
    if (modified) {
      modified.mod = PartsList.AddUniquePart(modified.mod, "SR6.DV", damage.ap.value);
      modified.value = Helpers.calcTotal(modified, { min: 0 });
    }
    return modified;
  }
  /** Reduce the initiative of the actor in the currently open / selected combat.
   * Should a tokens actor be in multiple combats it will also only affect the currently open combat,
   * since that is what's set in game.combat
   *
   * TODO: There is an issue with linked actors that have multiple tokens placed, with each in different combats.
   *       The defense test needs to be done using the correct token, not just by the actor (from the sidebar).
   *       One could argue this to be correct behavior, just confusing with normal linked actor / token usage.
   */
  async changeCombatInitiative(modifier) {
    if (modifier === 0) return;
    const combat = game.combat;
    const combatant = combat.getActorCombatant(this);
    if (!combatant) return;
    if (!combatant.initiative) return;
    if (combatant.initiative + modifier < 0) {
      ui.notifications?.warn("SR6.MissingRessource.Initiative", { localize: true });
    }
    await combat.adjustInitiative(combatant, modifier);
  }
  /**
   * Determine if this actor is an active combatant.
   *
   * @returns true, when active. false, when not in combat.
   */
  get combatActive() {
    if (!game.combat) return false;
    const combatant = game.combat.getActorCombatant(this);
    if (!combatant) return false;
    if (!combatant.initiative) return false;
    return true;
  }
  get combatant() {
    if (!this.combatActive) return;
    return game.combat.getActorCombatant(this);
  }
  /**
   * Return the initiative score for a currently active combat
   *
   * @returns The score or zero.
   */
  get combatInitiativeScore() {
    if (!game.combat) return 0;
    const combatant = game.combat.getActorCombatant(this);
    if (!combatant || !combatant.initiative) return 0;
    return combatant.initiative;
  }
  hasDamageTracks() {
    return "track" in this.system;
  }
  asVehicle() {
    if (this.isVehicle())
      return this;
  }
  asCharacter() {
    if (this.isCharacter())
      return this;
  }
  asSpirit() {
    if (this.isSpirit()) {
      return this;
    }
  }
  asSprite() {
    if (this.isSprite()) {
      return this;
    }
  }
  asCritter() {
    if (this.isCritter()) {
      return this;
    }
  }
  asIC() {
    if (this.isIC()) {
      return this;
    }
  }
  getVehicleStats() {
    if (this.isVehicle() && "vehicle_stats" in this.system) {
      return this.system.vehicle_stats;
    }
  }
  /** Add another actor as the driver of a vehicle to allow for their values to be used in testing.
   *
   * @param uuid An actors id. Should be a character able to drive a vehicle
   */
  async addVehicleDriver(uuid) {
    if (!this.isVehicle()) return;
    const driver = await fromUuid(uuid);
    if (!driver) return;
    await this.update({ "system.driver": driver.id });
  }
  async removeVehicleDriver() {
    if (!this.hasDriver()) return;
    await this.update({ "system.driver": "" });
  }
  hasDriver() {
    const vehicle = this.asVehicle();
    if (!vehicle) return false;
    return this.system.driver.length > 0;
  }
  getVehicleDriver() {
    if (!this.hasDriver()) return;
    const vehicle = this.asVehicle();
    if (!vehicle) return;
    const driver = game.actors?.get(this.system.driver);
    if (!driver) return;
    return driver;
  }
  /**
   * Add a host to this IC type actor.
   *
   * Currently compendium hosts aren't supported.
   * Any other actor type has no use for this method.
   *
   * @param item The host item
   */
  async addICHost(item) {
    if (!this.isIC()) return;
    if (!item.isHost) return;
    const host = item.asHost;
    if (!host) return;
    await this._updateICHostData(host);
  }
  async _updateICHostData(hostData) {
    const updateData = {
      // @ts-expect-error _id is missing on internal typing...
      id: hostData._id,
      rating: hostData.system.rating,
      atts: foundry.utils.duplicate(hostData.system.atts)
    };
    await this.update({ "system.host": updateData }, { render: false });
    await this.sheet?.render();
  }
  /**
   * Remove a connect Host item from an ic type actor.
   */
  async removeICHost() {
    if (!this.isIC()) return;
    const updateData = {
      id: null,
      rating: 0,
      atts: null
    };
    await this.update({ "system.host": updateData });
  }
  /**
   * Will return true if this ic type actor has been connected to a host.
   */
  hasHost() {
    const ic = this.asIC();
    if (!ic) return false;
    return ic && !!ic.system.host.id;
  }
  /**
   * Get the host item connect to this ic type actor.
   */
  getICHost() {
    const ic = this.asIC();
    if (!ic) return;
    return game.items?.get(ic?.system?.host.id);
  }
  /**
   * Add an actor as this spirit actor's summoner.
   * @param actor A character actor to be used as summoner
   */
  async addSummoner(actor) {
    if (!this.isSpirit() || !actor.isCharacter()) return;
    await this.update({ "system.summonerUuid": actor.uuid });
  }
  /**
   * Remove a summoner from this spirit actor.
   */
  async removeSummoner() {
    if (!this.isSpirit()) return;
    await this.update({ "system.summonerUuid": null });
  }
  /**
   * Add an actor as this sprites technomancers.
   * @param actor A character actor to be used as technomancer
   */
  async addTechnomancer(actor) {
    if (!this.isSprite() || !actor.isCharacter()) return;
    await this.update({ "system.technomancerUuid": actor.uuid });
  }
  /**
   * Remove a technomancer from this sprite actor.
   */
  async removeTechnomancer() {
    if (!this.isSprite()) return;
    await this.update({ "system.technomancerUuid": "" });
  }
  /** Check if this actor is of one or multiple given actor types
   *
   * @param types A list of actor types to check.
   */
  matchesActorTypes(types) {
    return types.includes(this.type);
  }
  /**
   * Get all situational modifiers from this actor.
   * NOTE: These will return selections only without higher level selections applied.
   *       You'll have to manually trigger .applyAll or apply what's needed.
   */
  getSituationModifiers() {
    return DocumentSituationModifiers.getDocumentModifiers(this);
  }
  /**
   * Set all situational modifiers for this actor
   *
   * @param modifiers The DocumentSituationModifiers instance to save source modifiers from.
   *                  The actor will not be checked, so be careful.
   */
  async setSituationModifiers(modifiers) {
    await DocumentSituationModifiers.setDocumentModifiers(this, modifiers.source);
  }
  /**
   * Check if the current actor has matrix capabilities.
   */
  get isMatrixActor() {
    return "matrix" in this.system;
  }
  get matrixData() {
    if (!this.isMatrixActor) return;
    return this.system.matrix;
  }
  /**
   * Change the amount of marks on the target by the amount of marks given, while adhering to min/max values.
   *
   *
   * @param target The Document the marks are placed on. This can be an actor (character, technomancer, IC) OR an item (Host)
   * @param marks The amount of marks to be placed
   * @param options Additional options that may be needed
   * @param options.scene The scene the actor lives on. If empty, will be current active scene
   * @param options.item The item that the mark is to be placed on
   * @param options.overwrite Replace the current marks amount instead of changing it
   */
  async setMarks(target, marks, options) {
    if (!canvas.ready) return;
    if (this.isIC() && this.hasHost()) {
      return await this.getICHost()?.setMarks(target, marks, options);
    }
    if (!this.isMatrixActor) {
      ui.notifications?.error(game.i18n.localize("SR6.Errors.MarksCantBePlacedBy"));
      return console.error(`The actor type ${this.type} can't receive matrix marks!`);
    }
    if (target.actor && !target.actor.isMatrixActor) {
      ui.notifications?.error(game.i18n.localize("SR6.Errors.MarksCantBePlacedOn"));
      return console.error(`The actor type ${target.actor.type} can't receive matrix marks!`);
    }
    if (!target.actor) {
      return console.error(`The token ${target.name} is missing it's actor`);
    }
    if (this.id === target.actor.id) {
      return;
    }
    const scene = options?.scene || canvas.scene;
    const item = options?.item;
    const markId = Helpers.buildMarkId(scene.id, target.id, item?.id);
    const matrixData = this.matrixData;
    if (!matrixData) return;
    const currentMarks = options?.overwrite ? 0 : this.getMarksById(markId);
    matrixData.marks[markId] = MatrixRules.getValidMarksCount(currentMarks + marks);
    await this.update({ "system.matrix.marks": matrixData.marks });
  }
  /**
   * Remove ALL marks placed by this actor
   */
  async clearMarks() {
    const matrixData = this.matrixData;
    if (!matrixData) return;
    const updateData = {};
    for (const markId of Object.keys(matrixData.marks)) {
      updateData[`-=${markId}`] = null;
    }
    await this.update({ "system.matrix.marks": updateData });
  }
  /**
   * Remove ONE mark. If you want to delete all marks, use clearMarks instead.
   */
  async clearMark(markId) {
    if (!this.isMatrixActor) return;
    const updateData = {};
    updateData[`-=${markId}`] = null;
    await this.update({ "system.matrix.marks": updateData });
  }
  getAllMarks() {
    const matrixData = this.matrixData;
    if (!matrixData) return;
    return matrixData.marks;
  }
  /**
   * Return the amount of marks this actor has on another actor or one of their items.
   *
   * TODO: It's unclear what this method will be used for
   *       What does the caller want?
   *
   * TODO: Check with technomancers....
   *
   * @param target
   * @param item
   * @param options
   */
  getMarks(target, item, options) {
    if (!canvas.ready) return 0;
    if (target instanceof SR6Item) {
      console.error("Not yet supported");
      return 0;
    }
    if (!target.actor || !target.actor.isMatrixActor) return 0;
    const scene = options?.scene || canvas.scene;
    item = item || target instanceof _SR6Actor ? target.actor.getMatrixDevice() : void 0;
    const markId = Helpers.buildMarkId(scene.id, target.id, item?.id);
    return this.getMarksById(markId);
  }
  getMarksById(markId) {
    return this.matrixData?.marks[markId] || 0;
  }
  /**
   * Return the actor or item that is the network controller of this actor.
   * These cases are possible:
   * - IC with a host connected will provide the host item
   * - IC without a host will provide itself
   * - A matrix actor within a PAN will provide the controlling actor
   * - A matrix actor without a PAN will provide itself
   */
  get matrixController() {
    if (this.isIC() && this.hasHost()) return this.getICHost() || this;
    return this;
  }
  getAllMarkedDocuments() {
    const marks = this.matrixController.getAllMarks();
    if (!marks) return [];
    return Object.entries(marks).filter(([markId, marks2]) => Helpers.isValidMarkId(markId)).map(([markId, marks2]) => ({
      ...Helpers.getMarkIdDocuments(markId),
      marks: marks2,
      markId
    }));
  }
  /**
   * How many previous attacks has this actor been subjected to?
   *
   * @returns A positive number or zero.
   */
  get previousAttacks() {
    return Math.max(this.system.modifiers.multi_defense * -1, 0);
  }
  /**
   * Apply a new consecutive defense multiplier based on the amount of attacks given
   *
   * @param previousAttacks Attacks within a combat turn. If left out, will guess based on current modifier.
   */
  async calculateNextDefenseMultiModifier(previousAttacks = this.previousAttacks) {
    console.debug("Shadowrun 6e | Applying consecutive defense modifier for. Last amount of attacks: ", previousAttacks);
    const automateDefenseMod = game.settings.get(SYSTEM_NAME, FLAGS.AutomateMultiDefenseModifier);
    if (!automateDefenseMod || !this.combatActive) return;
    const multiDefenseModi = CombatRules.defenseModifierForPreviousAttacks(previousAttacks + 1);
    await this.update({ "system.modifiers.multi_defense": multiDefenseModi });
  }
  /**
   * Remove the consecutive defense per turn modifier.
   */
  async removeDefenseMultiModifier() {
    const automateDefenseMod = game.settings.get(SYSTEM_NAME, FLAGS.AutomateMultiDefenseModifier);
    if (!automateDefenseMod || !this.combatActive) return;
    if (this.system.modifiers.multi_defense === 0) return;
    console.debug("Shadowrun 6e | Removing consecutive defense modifier.", this);
    await this.update({ "system.modifiers.multi_defense": 0 });
  }
  /**
   * Add a firemode recoil to the progressive recoil.
   *
   * @param fireMode Ranged Weapon firemode used to attack with.
   */
  async addProgressiveRecoil(fireMode) {
    const automateProgressiveRecoil = game.settings.get(SYSTEM_NAME, FLAGS.AutomateProgressiveRecoil);
    if (!automateProgressiveRecoil) return;
    if (!this.hasPhysicalBody) return;
    if (!fireMode.recoil) return;
    await this.addRecoil(fireMode.value);
  }
  /**
   * Add a flat value on top of existing progressive recoil
   * @param additional New recoil to be added
   */
  async addRecoil(additional) {
    const base = this.recoil + additional;
    await this.update({ "system.values.recoil.base": base });
  }
  /**
   * Clear whatever progressive recoil this actor holds.
   */
  async clearProgressiveRecoil() {
    if (!this.hasPhysicalBody) return;
    if (this.recoil === 0) return;
    await this.update({ "system.values.recoil.base": 0 });
  }
  /**
   * Determine if the actor has a physical body
   *
   * @returns true, if the actor can interact with the physical plane
   */
  get hasPhysicalBody() {
    return this.isCharacter() || this.isCritter() || this.isSpirit() || this.isVehicle();
  }
  /**
   * Reset damage, edge, etc. and prepare this actor for a new run.
   */
  async resetRunData() {
    console.log(`Shadowrun 6e | Resetting actor ${this.name} (${this.id}) for a new run`);
    const updateData = {};
    if (this.isCharacter() || this.isCritter() || this.isSpirit() || this.isVehicle()) {
      updateData["system.track.physical.value"] = 0;
      updateData["system.track.physical.overflow.value"] = 0;
    }
    if (this.isCharacter() || this.isCritter() || this.isSpirit()) {
      updateData["system.track.stun.value"] = 0;
    }
    if (this.isCharacter() || this.isCritter()) {
      updateData["system.attributes.edge.uses"] = this.getEdge().value;
    }
    if (this.isMatrixActor) await this.setMatrixDamage(0);
    if (updateData) await this.update(updateData);
  }
  /**
   * Will unequip all other items of the same type as the given item.
   *
   * It's not necessary for the given item to be equipped.
   *
   * @param unequipItem Input item that will be equipped while unequipping all others of the same type.
   */
  async equipOnlyOneItemOfType(unequipItem) {
    const sameTypeItems = this.items.filter((item) => item.type === unequipItem.type);
    if (sameTypeItems.length === 1 && sameTypeItems[0].id === unequipItem.id) {
      await unequipItem.update({ "system.technology.equipped": !unequipItem.isEquipped() });
      return;
    }
    const updateData = sameTypeItems.map((item) => ({
      _id: item.id,
      "system.technology.equipped": item.id === unequipItem.id
    }));
    await this.updateEmbeddedDocuments("Item", updateData);
  }
};

// src/module/apps/dialogs/DeleteConfirmationDialog.ts
var DeleteConfirmationDialog = class _DeleteConfirmationDialog extends FormDialog {
  static {
    __name(this, "DeleteConfirmationDialog");
  }
  constructor(options) {
    const dialogData = _DeleteConfirmationDialog.getDialogData();
    super(dialogData, options);
  }
  static getDialogData() {
    return {
      title: game.i18n.localize("SR6.DeleteConfirmationApplication.Title"),
      buttons: {
        delete: {
          label: game.i18n.localize("SR6.DeleteConfirmationApplication.Delete")
        },
        cancel: {
          label: game.i18n.localize("SR6.DeleteConfirmationApplication.Cancel")
        }
      },
      default: "cancel",
      templateData: {},
      templatePath: "systems/shadowrun6-elysium/dist/templates/apps/dialogs/delete-confirmation-dialog.html"
    };
  }
  static get defaultOptions() {
    const options = super.defaultOptions;
    options.id = "delete-confirmation-application";
    options.classes = ["sr6", "form-dialog"];
    options.resizable = true;
    options.height = "auto";
    return options;
  }
};

// src/module/helpers.ts
var Helpers = class _Helpers {
  static {
    __name(this, "Helpers");
  }
  /**
   * Calculate the total value for a data object
   * - stores the total value and returns it
   * @param value
   * @param options min will a apply a minimum value, max will apply a maximum value.
   */
  static calcTotal(value, options) {
    if (value.mod === void 0) value.mod = [];
    const parts = new PartsList(value.mod);
    if (!isNaN(value.temp) && Number(value.temp) !== 0) {
      parts.addUniquePart("SR6.Temporary", value["temp"]);
    }
    value.base = value.base !== void 0 ? Number(value.base) : 0;
    if (value.override) {
      value.value = _Helpers.applyValueRange(value.override.value, options);
      return value.value;
    }
    switch (foundry.utils.getType(value.base)) {
      case "number":
        value.value = _Helpers.roundTo(parts.total + value.base, options?.roundDecimals);
        value.value = _Helpers.applyValueRange(value.value, options);
        break;
      // boolean / string values should be applied
      default:
        value.value = parts.last === void 0 ? value.base : parts.last;
        break;
    }
    value.mod = parts.list;
    return value.value;
  }
  static calcValue(value) {
    if (value.mod === void 0) value.mod = [];
    if (value.override) {
      value.value = value.override.value;
      return value.value;
    }
    value.value = value.base;
    return value.value;
  }
  /** Round a number to a given degree.
   *
   * @param value Number to round with.
   * @param decimals Amount of decimals after the decimal point.
   */
  static roundTo(value, decimals = 3) {
    const multiplier = Math.pow(10, decimals);
    return Math.round(value * multiplier) / multiplier;
  }
  /** Make sure a given value is in between a range.
   *
   * @param value
   * @param options Define the range the given value must be in (or none)
   */
  static applyValueRange(value, options) {
    if (typeof options?.min === "number") {
      value = Math.max(options.min, value);
    }
    if (typeof options?.max === "number") {
      value = Math.min(options.max, value);
    }
    return value;
  }
  static listItemId(event) {
    return event.currentTarget.closest(".list-item").dataset.itemId;
  }
  static listHeaderId(event) {
    return event.currentTarget.closest(".list-header").dataset.itemId;
  }
  // replace 'SR6.'s on keys with 'SR5_DOT_'
  static onSetFlag(data) {
    if (typeof data !== "object") return data;
    if (data === void 0 || data === null) return data;
    const newData = {};
    for (const [key, value] of Object.entries(data)) {
      const newKey = key.replace("SR6.", "SR6_DOT_");
      newData[newKey] = this.onSetFlag(value);
    }
    return newData;
  }
  // replace 'SR6_DOT_' with 'SR6.' on keys
  static onGetFlag(data) {
    if (typeof data !== "object") return data;
    if (data === void 0 || data === null) return data;
    const newData = {};
    for (const [key, value] of Object.entries(data)) {
      const newKey = key.replace("SR6_DOT_", "SR6.");
      newData[newKey] = this.onGetFlag(value);
    }
    return newData;
  }
  static isMatrix(atts) {
    if (!atts) return false;
    if (typeof atts === "boolean") return atts;
    const matrixLabels = [
      "SR6.MatrixAttrFirewall",
      "SR6.MatrixAttrDataProcessing",
      "SR6.MatrixAttrSleaze",
      "SR6.MatrixAttrAttack",
      "SR6.Skill.Computer",
      "SR6.Skill.Hacking",
      "SR6.Skill.Cybercombat",
      "SR6.Skill.ElectronicWarfare",
      "SR6.Software"
    ];
    if (!Array.isArray(atts)) atts = [atts];
    atts = atts.filter((att) => att);
    for (const att of atts) {
      if (typeof att === "string") {
        if (matrixLabels.indexOf(att) >= 0) {
          return true;
        }
      } else if (typeof att === "object" && att.label !== void 0) {
        if (matrixLabels.indexOf(att.label ?? "") >= 0) {
          return true;
        }
      }
    }
    return false;
  }
  static parseInputToString(val) {
    if (val === void 0) return "";
    if (typeof val === "number") return val.toString();
    if (typeof val === "string") return val;
    if (Array.isArray(val)) {
      return val.join(",");
    }
    return "";
  }
  static parseInputToNumber(val) {
    if (typeof val === "number") return val;
    if (typeof val === "string") {
      const ret = +val;
      if (!isNaN(ret)) return ret;
      return 0;
    }
    if (Array.isArray(val)) {
      const str = val.join("");
      const ret = +str;
      if (!isNaN(ret)) return ret;
      return 0;
    }
    return 0;
  }
  static setupCustomCheckbox(app, html) {
    const setContent = /* @__PURE__ */ __name((el) => {
      const checkbox = $(el).children("input[type=checkbox]");
      const checkmark = $(el).children(".checkmark");
      if ($(checkbox).prop("checked")) {
        $(checkmark).addClass("fa-check-circle");
        $(checkmark).removeClass("fa-circle");
      } else {
        $(checkmark).addClass("fa-circle");
        $(checkmark).removeClass("fa-check-circle");
      }
    }, "setContent");
    html.find("label.checkbox").each(function() {
      setContent(this);
    });
    html.find("label.checkbox").click((event) => setContent(event.currentTarget));
    html.find(".submit-checkbox").change((event) => app._onSubmit(event));
  }
  static mapRoundsToDefenseDesc(rounds) {
    if (rounds === 1) return "";
    if (rounds === 3) return "-2";
    if (rounds === 6) return "-5";
    if (rounds === 10) return "-9";
    if (rounds === 20) return "SR6.DuckOrCover";
    return "";
  }
  static label(str) {
    if (!str) return "";
    const frags = str.split("_");
    for (let i2 = 0; i2 < frags.length; i2++) {
      frags[i2] = frags[i2].charAt(0).toUpperCase() + frags[i2].slice(1);
    }
    frags.forEach((frag, idx) => {
      if (frag === "Processing") frags[idx] = "Proc.";
      if (frag === "Mechanic") frags[idx] = "Mech.";
    });
    return frags.join(" ");
  }
  static orderKeys(obj) {
    const keys = Object.keys(obj).sort(/* @__PURE__ */ __name(function keyOrder(k1, k2) {
      if (k1 < k2) return -1;
      if (k1 > k2) return 1;
      return 0;
    }, "keyOrder"));
    let i2;
    const after = {};
    for (i2 = 0; i2 < keys.length; i2++) {
      after[keys[i2]] = obj[keys[i2]];
      delete obj[keys[i2]];
    }
    for (i2 = 0; i2 < keys.length; i2++) {
      obj[keys[i2]] = after[keys[i2]];
    }
    return obj;
  }
  static hasModifiers(event) {
    return event && (event.shiftKey || event.altKey || event.ctrlKey || event.metaKey);
  }
  static filter(obj, comp) {
    const retObj = {};
    if (typeof obj === "object" && obj !== null) {
      Object.entries(obj).forEach(([key, value]) => {
        if (comp([key, value])) retObj[key] = value;
      });
    }
    return retObj;
  }
  static addLabels(obj, label) {
    if (typeof obj === "object" && obj !== null) {
      if (!obj.hasOwnProperty("label") && obj.hasOwnProperty("value") && label !== "") {
        obj.label = label;
      }
      Object.entries(obj).filter(([, value]) => typeof value === "object").forEach(([key, value]) => _Helpers.addLabels(value, key));
    }
  }
  /* Handle Shadowrun style shortened attribute names with typical three letter shortening. */
  static shortenAttributeLocalization(label, length = 3) {
    const name3 = game.i18n.localize(label);
    if (length <= 0) {
      return name3;
    }
    if (name3.length < length) {
      length = name3.length;
    }
    return name3.slice(0, length).toUpperCase();
  }
  // TODO: Foundry 0.9 Should TokenDocument be used instead of Token?
  // TODO: Check canvas.scene.tokens
  static getToken(id) {
    if (!canvas || !canvas.ready || !canvas.tokens) return;
    for (const token of canvas.tokens.placeables) {
      if (token.id === id) {
        return token;
      }
    }
  }
  /**
   * Use this helper to get a tokens actor from any given scene id.
   * @param sceneTokenId A mixed id with the format '<sceneId>.<tokenid>
   */
  static getSceneTokenActor(sceneTokenId) {
    const [sceneId, tokenId] = _Helpers.deconstructSceneTokenId(sceneTokenId);
    const token = _Helpers.getSceneTokenDocument(sceneId, tokenId);
    if (!token) return null;
    return token.getActor();
  }
  static deconstructSceneTokenId(sceneTokenId) {
    return sceneTokenId.split(".");
  }
  static getSceneTokenDocument(sceneId, tokenId) {
    const scene = game.scenes?.get(sceneId);
    if (!scene) return;
    const token = scene.tokens.get(tokenId);
    if (!token) return;
    return token;
  }
  static getUserTargets(user) {
    user = user ? user : game.user;
    if (!user) return [];
    return Array.from(user.targets);
  }
  static userHasTargets(user) {
    user = user ? user : game.user;
    if (!user) return false;
    return user.targets.size > 0;
  }
  /**
   * Measure the distance between two tokens on the canvas in length units,
   * factoring in both 2D distance and 3D elevation difference.
   *
   * Depending on the scene distance unit the result will be converted.
   *
   * If wall-height is installed and using tokenHeight, it will be used for elevation.
   *
   * @param tokenOrigin
   * @param tokenDest
   * @returns Distance in scene distance unit
   */
  static measureTokenDistance(tokenOrigin, tokenDest) {
    if (!canvas || !canvas.ready || !canvas.scene || !canvas.grid) return 0;
    if (!tokenOrigin || !tokenDest) return 0;
    const origin2D = new PIXI.Point(...canvas.grid.getCenter(tokenOrigin.x, tokenOrigin.y));
    const dest2D = new PIXI.Point(...canvas.grid.getCenter(tokenDest.x, tokenDest.y));
    const distanceInGridUnits2D = canvas.grid.measureDistance(origin2D, dest2D);
    const originLOSHeight = _Helpers.getTokenLOSHeight(tokenOrigin);
    const destLOSHeight = _Helpers.getTokenLOSHeight(tokenDest);
    const elevationDifference = tokenOrigin.elevation + originLOSHeight - (tokenDest.elevation + destLOSHeight);
    const origin3D = new PIXI.Point(0, 0);
    const dest3D = new PIXI.Point(distanceInGridUnits2D, elevationDifference);
    const distanceInGridUnits3D = Math.round(_Helpers.measurePointDistance(origin3D, dest3D));
    const sceneUnit = canvas.scene.grid.units;
    return _Helpers.convertLengthUnit(distanceInGridUnits3D, sceneUnit);
  }
  /**
   * Measure distance between two points on a grid in length units.
   *
   * @param origin
   * @param destination
   * @returns Distance without a unit.
   */
  static measurePointDistance(origin, destination) {
    const sideA = origin.x + destination.x;
    const sideB = origin.y + destination.y;
    return Math.sqrt(Math.pow(sideA, 2) + Math.pow(sideB, 2));
  }
  /**
   * Determine a tokens line of sight height.
   *
   * Default Foundry will use 0, while wall-height might have defined another value on the token.
   *
   * The auto height generation of wall-height isn't supported.
   *
   * @param token
   * @returns
   */
  static getTokenLOSHeight(token) {
    return token.flags["wall-height"]?.tokenHeight ?? 0;
  }
  static convertLengthUnit(length, fromUnit) {
    fromUnit = fromUnit.toLowerCase();
    if (!LENGTH_UNIT_TO_METERS_MULTIPLIERS.hasOwnProperty(fromUnit)) {
      console.error(`Distance can't be converted from ${fromUnit} to ${LENGTH_UNIT}`);
      return 0;
    }
    return Math.round(length * LENGTH_UNIT_TO_METERS_MULTIPLIERS[fromUnit]);
  }
  static getControlledTokens() {
    if (!canvas || !canvas.ready || !canvas.tokens) return [];
    return canvas.tokens.controlled;
  }
  /**
   * Determine if the current user has any tokens selected.
   * @returns true if one or more tokens have been selected.
   */
  static userHasControlledTokens() {
    if (!canvas || !canvas.ready || !canvas.tokens) return false;
    return canvas.tokens.controlled.length > 0;
  }
  /**
   * Return all actors connected to all user controlled tokens.
   * @returns An array token actors.
   */
  static getControlledTokenActors() {
    if (!canvas || !canvas.ready) return [];
    const tokens = _Helpers.getControlledTokens();
    return tokens.map((token) => token.actor);
  }
  /**
   * return all tokens a user has targeted at the moment.
   * @returns An array tokens.
   */
  static getTargetedTokens() {
    if (!canvas.ready || !game.user) return [];
    return Array.from(game.user.targets);
  }
  /**
   * Return either all user selected token actors or the users game character actor.
   * @returns An array of actors.
   */
  static getSelectedActorsOrCharacter() {
    if (!game.user) return [];
    const actors = _Helpers.getControlledTokenActors();
    if (actors.length === 0 && game.user.character) {
      actors.push(game.user.character);
    }
    return actors;
  }
  /**
   * Given a SuccessTestData subset fetch all target actors.
   *
   * BEWARE: A target will always be token based BUT linked actors provide an actor uuid instead of
   * pointing to their token actors.
   *
   * @param testData The test data containing target uuids.
   */
  static async getTestTargetActors(testData) {
    const actors = [];
    for (const uuid of testData.targetActorsUuid) {
      const tokenOrActor = await fromUuid(uuid);
      let actor = tokenOrActor;
      if (tokenOrActor instanceof TokenDocument) {
        if (!tokenOrActor.actor) continue;
        actor = tokenOrActor.actor;
      }
      if (!(actor instanceof SR6Actor)) {
        console.error(`SR6: Elysium | testData with targets containt UUID ${uuid} which doesn't provide an actor or syntheic actor`, tokenOrActor);
        continue;
      }
      actors.push(actor);
    }
    return actors;
  }
  /**
   * Check given test for actors to use for opposed tests.
   *
   * @param testData The test to use for actor selection
   * @returns A list of actors that should be used for an opposed test.
   */
  static async getOpposedTestActors(testData) {
    const overwriteSelectionWithTarget = game.settings.get(SYSTEM_NAME, FLAGS.DefaultOpposedTestActorSelection);
    if (overwriteSelectionWithTarget && testData.targetActorsUuid.length > 0) {
      return await _Helpers.getTestTargetActors(testData);
    }
    return _Helpers.getSelectedActorsOrCharacter();
  }
  static createRangeDescription(label, distance, modifier) {
    const localizedLabel = game.i18n.localize(label);
    return { label: localizedLabel, distance, modifier };
  }
  static convertIndexedObjectToArray(indexedObject) {
    return Object.keys(indexedObject).map((index) => {
      if (Number.isNaN(index)) {
        console.warn("An object with no numerical index was given, which is likely a bug.", indexedObject);
      }
      return indexedObject[index];
    });
  }
  /**
   * Depending on the system setting allow GMs to define if they want to always display the name within the actor
   * or within the token.
   *
   * This can be relevant for when GMs either manually or by module change the tokens name, while the actors name
   * is untouched and might even be detrimental to share with players.
   *
   * @param actor
   */
  static getChatSpeakerName(actor) {
    if (!actor) return "";
    const useTokenNameForChatOutput = game.settings.get(SYSTEM_NAME, FLAGS.ShowTokenNameForChatOutput);
    const token = actor.getToken();
    if (useTokenNameForChatOutput && token) return token.name;
    return actor.name;
  }
  static getDefenseRating(targets) {
    return 0;
  }
  static getAttackRating(actor) {
    return 0;
  }
  /**
   * Given an actor this will display either the actor or token name, when there is any.
   *
   * The use token name setting is also respected.
   *
   * @param actor Either an actual or a virtual actor, taken from a token.
   * @returns A path pointing to an image.
   */
  static getChatSpeakerImg(actor) {
    if (!actor) return "";
    const useTokenForChatOutput = game.settings.get(SYSTEM_NAME, FLAGS.ShowTokenNameForChatOutput);
    const token = actor.getToken();
    if (useTokenForChatOutput && token) return token.texture.src || "";
    return actor.img || "";
  }
  static createDamageData(value, type, ap = 0, element = "", sourceItem) {
    const damage = DataDefaults.damageData({ type: { base: "", value: "" } });
    damage.base = value;
    damage.value = value;
    damage.type.base = type;
    damage.type.value = type;
    damage.ap.base = ap;
    damage.ap.value = ap;
    damage.element.base = element;
    damage.element.value = element;
    if (sourceItem && sourceItem.actor) {
      damage.source = {
        actorId: sourceItem.actor.id,
        itemType: sourceItem.type,
        itemId: sourceItem.id,
        itemName: sourceItem.name
      };
    }
    return damage;
  }
  /**
   * Retrieves the item causing the damage, if there is any.
   * This only works for embedded items at the moment
   */
  static findDamageSource(damageData) {
    if (!game.actors) return;
    if (!damageData.source) {
      return;
    }
    const actorId = damageData.source.actorId;
    const actorSource = game.actors.get(actorId);
    if (!actorSource) {
      return;
    }
    const itemId = damageData.source.itemId;
    const actorItem = actorSource.items.get(itemId);
    if (actorItem) {
      return actorItem;
    }
    const tokens = actorSource.getActiveTokens();
    let tokenItem;
    tokens.forEach((token) => {
      if (!token.actor) return;
      const foundItem = token.actor.items.get(itemId);
      if (foundItem) {
        tokenItem = foundItem;
      }
    });
    return tokenItem;
  }
  /** Modifies given damage value and returns both original and modified damage
   *
   * For better readability reduceDamageByHits wraps this method to avoid negative params in the call signature.
   * so instead of
   * > modifyDamageByHits(incoming, -hits, label)
   * do this instead
   * > reduceDamageByHits(incoming, hits, label)
   *
   * @param incoming A DamageData value to be modified from
   * @param hits Positive or negative hits to change the damage value with.
   * @param modificationLabel The translatable label for the modification
   */
  static modifyDamageByHits(incoming, hits, modificationLabel) {
    const modified = foundry.utils.duplicate(incoming);
    modified.mod = PartsList.AddUniquePart(modified.mod, modificationLabel, hits);
    modified.value = _Helpers.calcTotal(modified, { min: 0 });
    return { incoming, modified };
  }
  /** Reduces given damage value and returns both original and modified damage.
   *
   * Should you want RAISE the damage value, use modifyDamageByHits directly.
   *
   * @param incoming A DamageData value to be modified from
   * @param hits Positive hits to reduce the damage value with! Should the hits amount be negative, use modifyDamageByHits.
   * @param modificationLabel The translatable label for the modification
   */
  static reduceDamageByHits(incoming, hits, modificationLabel) {
    if (hits < 0) hits = 0;
    return _Helpers.modifyDamageByHits(incoming, -hits, modificationLabel);
  }
  static async confirmDeletion() {
    const dialog = new DeleteConfirmationDialog();
    await dialog.select();
    return !dialog.canceled && dialog.selectedButton === "delete";
  }
  /**
   * This can be used to create an SkillField into the Skills data path during the Skill creation process.
   *
   * @param skillDataPath Could be 'data.skills.active' or 'data.skill.language.value' or more
   * @param skillField A SkillField with whatever values. You could use DataDefaults.skillData to create one.
   * @param idLength How long should the id (GUID) be?
   */
  static getRandomIdSkillFieldDataEntry(skillDataPath, skillField, idLength = DEFAULT_ID_LENGTH) {
    if (!skillDataPath || skillDataPath.length === 0) return;
    const id = randomID(idLength);
    const updateSkillData = {
      [skillDataPath]: { [id]: skillField }
    };
    return {
      id,
      updateSkillData
    };
  }
  /**
   * A simple helper to get an data entry for updating with Entity.update
   *
   * @param path The main data path as a doted string relative from the type data (not document data).
   * @param value Whatever needs to be stored.
   *
   */
  static getUpdateDataEntry(path, value) {
    return { [path]: value };
  }
  /**
   * A simple helper to delete existing document data keys with Entity.update
   *
   * @param path The main data path as doted string relative from the item type data (not document data). data.skills.active
   * @param key The single sub property within the path that's meant to be deleted. 'test'
   *
   * @return An expected return object could look like this: {'data.skills.active': {'-=Pistols': null}} and would
   *         remove the Pistols key from the 'data.skills.active' path within Entity.system.skills.active.
   */
  static getDeleteKeyUpdateData(path, key) {
    return { [path]: { [`-=${key}`]: null } };
  }
  static localizeSkill(skill) {
    return skill.label ? game.i18n.localize(skill.label) : skill.name;
  }
  /**
   * Alphabetically sort skills either by their translated label. Should a skill not have one, use the name as a
   * fallback.
   *
   * Sorting should be aware of UTF-8, however please blame JavaScript if it's not. :)
   *
   * @param skills
   * @param asc Set to true for ascending sorting order and to false for descending order.
   * @return Sorted Skills given by the skills parameter
   */
  static sortSkills(skills, asc = true) {
    const sortedEntries = Object.entries(skills).sort(([aId, a2], [bId, b2]) => {
      const comparatorA = _Helpers.localizeSkill(a2) || aId;
      const comparatorB = _Helpers.localizeSkill(b2) || bId;
      if (asc)
        return comparatorA.localeCompare(comparatorB) === 1 ? 1 : -1;
      else
        return comparatorA.localeCompare(comparatorB) === 1 ? -1 : 1;
    });
    const sortedAsObject = {};
    for (const [id, skill] of sortedEntries) {
      sortedAsObject[id] = skill;
    }
    return sortedAsObject;
  }
  /**
   * Alphabetically sort any SR5 config object with a key to label structure.
   *
   * Sorting should be aware of UTF-8, however please blame JavaScript if it's not. :)
   *
   * @param configValues The config value to be sorted
   * @param asc Set to true for ascending sorting order and to false for descending order.
   * @return Sorted config values given by the configValues parameter
   */
  static sortConfigValuesByTranslation(configValues, asc = true) {
    const sortedEntries = Object.entries(configValues).sort(([aId, a2], [bId, b2]) => {
      const comparatorA = game.i18n.localize(a2);
      const comparatorB = game.i18n.localize(b2);
      if (asc)
        return comparatorA.localeCompare(comparatorB) === 1 ? 1 : -1;
      else
        return comparatorA.localeCompare(comparatorB) === 1 ? -1 : 1;
    });
    const sortedAsObject = {};
    for (const [key, translated] of sortedEntries) {
      sortedAsObject[key] = translated;
    }
    return sortedAsObject;
  }
  /**
   * Return a list of users with the given permission for the given document.
   *
   * @param document A foundry Document implementation.
   * @param permission A foundry access permission
   * @param active If true, will only return users that are also currently active.
   */
  static getPlayersWithPermission(document2, permission, active3 = true) {
    if (!game.users) return [];
    return game.users.filter((user) => {
      if (user.isGM) return false;
      if (!document2.testUserPermission(user, permission)) return false;
      if (active3 && !user.active) return false;
      return true;
    });
  }
  /**
   * Handle the special skill cases with id equals name and possible i18n
   *
   * @param skill
   * @returns Either a translation or a name.
   */
  static getSkillLabelOrName(skill) {
    return skill.label ? game.i18n.localize(skill.label) : skill.name || "";
  }
  /**
   * Fetch entities from global or pack collections using data acquired by Foundry Drag&Drop process
   * @param data Foundry Drop Data
   */
  static async getEntityFromDropData(data) {
    if (!game.actors || !game.items) return;
    if (data.pack && data.type === "Actor")
      return await _Helpers.getEntityFromCollection(data.pack, data.id);
    if (data.pack && data.type === "Item")
      return await _Helpers.getEntityFromCollection(data.pack, data.id);
    if (data.type === "Actor")
      return game.actors.get(data.id);
    if (data.type === "Item")
      return game.items.get(data.id);
  }
  /**
   * Fetch entities from a pack collection
   * @param collection The pack name as stored in the collection property
   * @param id The entity id in that collection
   */
  static async getEntityFromCollection(collection, id) {
    const pack = game.packs.find((p2) => p2.collection === collection);
    return await pack.getDocument(id);
  }
  /**
   * A markId is valid if:
   * - It's scene still exists
   * - The token still exists on that scene
   * - And a possible owned item still exists on that documents actor.
   */
  static isValidMarkId(markId) {
    if (!game.scenes) return false;
    const [sceneId, targetId, itemId] = _Helpers.deconstructMarkId(markId);
    const scene = game.scenes.get(sceneId);
    if (!scene) return false;
    const tokenDocument = scene.tokens.get(targetId);
    if (!tokenDocument) return false;
    const actor = tokenDocument.actor;
    if (itemId && !actor?.items.get(itemId)) return false;
    return true;
  }
  /**
   * Build a markId string. See Helpers.deconstructMarkId for usage.
   *
   * @param sceneId Optional id in a markId
   * @param targetId Mandatory id in a markId
   * @param itemId Optional id in a markId
   * @param separator Should you want to change the default separator used. Make sure not to use a . since Foundry will split the key into objects.
   */
  static buildMarkId(sceneId, targetId, itemId, separator = "/") {
    return [sceneId, targetId, itemId || ""].join(separator);
  }
  /**
   * Deconstruct the given markId string.
   *
   * @param markId 'sceneId.targetId.itemId' with itemId being optional
   * @param separator Should you want to change the default separator used
   */
  static deconstructMarkId(markId, separator = "/") {
    const ids = markId.split(separator);
    if (ids.length !== 3) {
      console.error("A mark id must always be of length 3");
    }
    return ids;
  }
  static getMarkIdDocuments(markId) {
    if (!game.scenes || !game.items) return;
    const [sceneId, targetId, itemId] = _Helpers.deconstructMarkId(markId);
    const scene = game.scenes.get(sceneId);
    if (!scene) return;
    const target = scene.tokens.get(targetId) || game.items.get(targetId);
    const item = target?.actor?.items?.get(itemId);
    return {
      scene,
      target,
      item
    };
  }
  /**
   * Return true if all given keys are present in the given object.
   * Values don't matter for this comparison.
   *
   * @param obj
   * @param keys
   */
  static objectHasKeys(obj, keys) {
    for (const key of keys) {
      if (!obj.hasOwnProperty(key)) return false;
    }
    return true;
  }
  /**
   * Check packs for a given action.
   *
   * TODO: Use pack and action ids to avoid polluted user namespaces
   * TODO: Allow for i18n to fetch a label from an action? Or predefine the title?
   *
   * @param packName The metadata name of the pack
   * @param actionName The name of the action within that pack
   */
  static async getPackAction(packName, actionName) {
    console.debug(`Shadowrun 6e | Trying to fetch action ${actionName} from pack ${packName}`);
    const pack = game.packs.find((pack2) => pack2.metadata.system === SYSTEM_NAME && pack2.metadata.name === packName);
    if (!pack) return;
    const packEntry = pack.index.find((data) => data.name?.toLowerCase().replace(new RegExp(" ", "g"), "_") === actionName.toLowerCase());
    if (!packEntry) return;
    const item = await pack.getDocument(packEntry._id);
    if (!item || item.type !== "action") return;
    console.debug(`SR6: Elysium | Fetched action ${actionName} from pack ${packName}`, item);
    return item;
  }
  /**
   * Show the DocumentSheet of whatever entity link uuid.
   *
   * This function is designed to work in cojunction with the content-link CSS-class used by Foundry opening
   * the given id. Because of this only entity-links with uuid dataset entries should trigger.
   *
   * @param event A PointerEvent by user interaction.
   */
  static async renderEntityLinkSheet(event) {
    const element = $(event.currentTarget);
    const uuid = element.data("uuid");
    await _Helpers.renderDocumentSheet(uuid);
  }
  /**
   * Fetch a Document using the FoundryVTT UUID and render it's connected sheet.
   *
   * @param uuid Generated by Document.uuid property.
   * @param resolveTokenToActor Should the uuid resolve to a TokenDocument, rather render it's actor.
   */
  static async renderDocumentSheet(uuid, resolveTokenToActor = true) {
    if (!uuid) return;
    let document2 = await fromUuid(uuid);
    if (!document2) return;
    if (document2 instanceof TokenDocument && resolveTokenToActor && document2.actor)
      document2 = document2.actor;
    await document2.sheet.render(true);
  }
  /**
   * Sanitize keys to not use characters used within FoundryVTT Document#update and expandObject methods.
   *
   * @param key The key, maybe containing prohibited characters
   * @param replace The characters to replaces prohibited characters with
   * @returns key without
   */
  static sanitizeDataKey(key, replace = "") {
    const spicyCharacters = [".", "-="];
    spicyCharacters.forEach((character) => key = key.replace(character, replace));
    return key;
  }
  /**
   * This method tries to get an owned actor of the user.
   * If none are found it will return null
   * If exactly one is found, it will automatically return the found actor
   * If several are found it prompts the user to choose on of the available actors
   * @returns an actor
   */
  static async chooseFromAvailableActors() {
    let availableActors = game.actors?.filter((e2) => e2.isOwner && e2.hasPlayerOwner) ?? [];
    if (availableActors.length == 0) {
      return;
    }
    if (availableActors.length == 1) {
      return availableActors[0];
    } else {
      let allActors = "";
      game.actors?.filter((e2) => e2.isOwner && e2.hasPlayerOwner).forEach((t2) => {
        allActors = allActors.concat(`
                            <option value="${t2.id}">${t2.name}</option>`);
      });
      const dialog_content = `  
                <select name ="actor">
                ${allActors}
                </select>`;
      let choosenActor = await Dialog.prompt({
        title: game.i18n.localize("SR6.Skill.Teamwork.ParticipantActor"),
        content: dialog_content,
        callback: /* @__PURE__ */ __name((html) => html.find("select").val(), "callback")
      });
      return game.actors?.get(choosenActor);
    }
  }
  /**
   * A method to capitalize the first letter of a given string.
   * This allows to transform skill and attribute ids to the corresponding translation sub-keys
   * See @see getSkillTranslation @see getAttributeTranslaton
   * @param string
   * @returns the string with a capitalized first letter
   */
  static capitalizeFirstLetter(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
  }
  /**
   * Translates a skillId
   * @param skill
   * @returns translation
   */
  static getSkillTranslation(skill) {
    return game.i18n.localize(`SR6.Skill.${this.capitalizeFirstLetter(skill)}`);
  }
  /**
   * Translate an attribute
   * @param attribute
   * @returns translation
   */
  static getAttributeTranslation(attribute) {
    return game.i18n.localize(`SR6.Attr${this.capitalizeFirstLetter(attribute)}`);
  }
};

// src/module/handlebars/RollAndLabelHelpers.ts
var registerRollAndLabelHelpers = /* @__PURE__ */ __name(() => {
  Handlebars.registerHelper("damageAbbreviation", function(damage) {
    if (damage === "physical") return "P";
    if (damage === "stun") return "S";
    if (damage === "matrix") return "M";
    return "";
  });
  Handlebars.registerHelper("damageCode", function(damage) {
    const typeCode = Handlebars.helpers.damageAbbreviation(damage.type.value);
    let code = `${damage.value}${typeCode}`;
    return new Handlebars.SafeString(code);
  });
  Handlebars.registerHelper("diceIcon", function(side) {
    if (side) {
      switch (side) {
        case 1:
          return "red";
        case 2:
          return "grey";
        case 3:
          return "grey";
        case 4:
          return "grey";
        case 5:
          return "green";
        case 6:
          return "green";
      }
    }
  });
  Handlebars.registerHelper("elementIcon", function(element) {
    let icon = "";
    if (element === "electricity") {
      icon = "fas fa-bolt";
    } else if (element === "radiation") {
      icon = "fas fa-radiation-alt";
    } else if (element === "fire") {
      icon = "fas fa-fire";
    } else if (element === "acid") {
      icon = "fas fa-vials";
    } else if (element === "cold") {
      icon = "fas fa-snowflake";
    }
    return icon;
  });
  Handlebars.registerHelper("partsTotal", function(partsList) {
    const parts = new PartsList(partsList);
    return parts.total;
  });
  Handlebars.registerHelper("signedValue", function(value) {
    return value > 0 ? `+${value}` : `${value}`;
  });
  Handlebars.registerHelper("speakerName", Helpers.getChatSpeakerName);
  Handlebars.registerHelper("speakerImg", Helpers.getChatSpeakerImg);
  Handlebars.registerHelper("defenseRating", Helpers.getDefenseRating);
  Handlebars.registerHelper("attackRating", Helpers.getAttackRating);
}, "registerRollAndLabelHelpers");

// src/module/utils/strings.ts
function formatStrict(stringId, data) {
  return game.i18n.format(
    stringId,
    Object.fromEntries(
      Object.entries(data).map(([key, value]) => [key, game.i18n.localize(value)])
    )
  );
}
__name(formatStrict, "formatStrict");

// src/module/handlebars/ItemLineHelpers.ts
var registerItemLineHelpers = /* @__PURE__ */ __name(() => {
  Handlebars.registerHelper("InventoryHeaderIcons", function(section) {
    var icons = Handlebars.helpers["ItemHeaderIcons"](section.type);
    icons.push(
      section.isOpen ? {
        icon: "fas fa-square-chevron-up",
        title: game.i18n.localize("SR6.Collapse"),
        cssClass: "item-toggle",
        // Add HTML data attributes using a key<string>:value<string> structure
        data: {}
      } : {
        icon: "fas fa-square-chevron-down",
        title: game.i18n.localize("SR6.Expand"),
        cssClass: "item-toggle",
        // Add HTML data attributes using a key<string>:value<string> structure
        data: {}
      }
    );
    return icons;
  });
  Handlebars.registerHelper("ItemHeaderIcons", function(type) {
    const PlusIcon = "fas fa-plus";
    const AddText = game.i18n.localize("SR6.Add");
    const addIcon = {
      icon: PlusIcon,
      text: AddText,
      title: formatStrict("SR6.Create", { type: "SR6.Item" }),
      cssClass: "item-create",
      // Add HTML data attributes using a key<string>:value<string> structure
      data: {}
    };
    switch (type) {
      case "lifestyle":
        addIcon.title = formatStrict("SR6.Create", { type: "SR6.Lifestyle" });
        return [addIcon];
      case "contact":
        addIcon.title = formatStrict("SR6.Create", { type: "SR6.ItemTypes.Contact" });
        return [addIcon];
      case "sin":
        addIcon.title = formatStrict("SR6.Create", { type: "SR6.SIN" });
        return [addIcon];
      case "license":
        addIcon.title = formatStrict("SR6.Create", { type: "SR6.License" });
        return [addIcon];
      case "quality":
        addIcon.title = formatStrict("SR6.Create", { type: "SR6.Quality" });
        return [addIcon];
      case "adept_power":
        addIcon.title = formatStrict("SR6.Create", { type: "SR6.ItemTypes.AdeptPower" });
        return [addIcon];
      case "action":
        addIcon.title = formatStrict("SR6.Create", { type: "SR6.Action" });
        return [addIcon];
      case "spell":
        addIcon.title = formatStrict("SR6.Create", { type: "SR6.ItemTypes.Spell" });
        return [addIcon];
      case "ritual":
        addIcon.title = formatStrict("SR6.Create", { type: "SR6.ItemTypes.Ritual" });
        return [addIcon];
      case "gear":
        addIcon.title = formatStrict("SR6.Create", { type: "SR6.Gear" });
        return [addIcon];
      case "complex_form":
        addIcon.title = formatStrict("SR6.Create", { type: "SR6.ComplexForm" });
        return [addIcon];
      case "program":
        addIcon.title = formatStrict("SR6.Create", { type: "SR6.Program" });
        return [addIcon];
      case "weapon":
        addIcon.title = formatStrict("SR6.Create", { type: "SR6.ItemTypes.Weapon" });
        return [addIcon];
      case "armor":
        addIcon.title = formatStrict("SR6.Create", { type: "SR6.Armor" });
        return [addIcon];
      case "ammo":
        addIcon.title = formatStrict("SR6.Create", { type: "SR6.Ammo" });
        return [addIcon];
      case "modification":
        addIcon.title = formatStrict("SR6.Create", { type: "SR6.Modification" });
        return [addIcon];
      case "device":
        addIcon.title = formatStrict("SR6.Create", { type: "SR6.Device" });
        return [addIcon];
      case "equipment":
        addIcon.title = formatStrict("SR6.Create", { type: "SR6.Equipment" });
        return [addIcon];
      case "cyberware":
        addIcon.title = formatStrict("SR6.Create", { type: "SR6.Cyberware" });
        return [addIcon];
      case "bioware":
        addIcon.title = formatStrict("SR6.Create", { type: "SR6.ItemTypes.Bioware" });
        return [addIcon];
      case "critter_power":
        addIcon.title = formatStrict("SR6.Create", { type: "SR6.ItemTypes.CritterPower" });
        return [addIcon];
      case "sprite_power":
        addIcon.title = formatStrict("SR6.Create", { type: "SR6.ItemTypes.SpritePower" });
        return [addIcon];
      case "echo":
        addIcon.title = formatStrict("SR6.Create", { type: "SR6.Echo" });
        return [addIcon];
      case "metamagic":
        addIcon.title = formatStrict("SR6.Create", { type: "SR6.Metamagic" });
        return [addIcon];
      case "summoning":
        addIcon.title = game.i18n.localize("SR6.CallInAction.CreateSummoning");
        return [addIcon];
      case "compilation":
        addIcon.title = game.i18n.localize("SR6.CallInAction.CreateCompilation");
        return [addIcon];
      case "effect":
        addIcon.title = formatStrict("SR6.Create", { type: "SR6.Effect" });
        addIcon.cssClass = "effect-control";
        addIcon.data = { action: "create" };
        return [addIcon];
      default:
        return [];
    }
  });
  Handlebars.registerHelper("InventoryIcons", function(name3) {
    const addItemIcon = {
      icon: "fas fa-plus",
      text: game.i18n.localize("SR6.Add"),
      title: formatStrict("SR6.Create", { type: "SR6.Item" }),
      cssClass: "inventory-item-create",
      // Add HTML data attributes using a key<string>:value<string> structure
      data: { inventory: name3 }
    };
    return [addItemIcon];
  });
  Handlebars.registerHelper("ItemHeaderRightSide", function(id) {
    switch (id) {
      case "action":
        return [
          {
            text: {
              text: game.i18n.localize("SR6.ActionType"),
              cssClass: "six"
            }
          },
          {
            text: {
              text: game.i18n.localize("SR6.Skill.Skill"),
              cssClass: "six"
            }
          },
          {
            text: {
              text: game.i18n.localize("SR6.Attribute"),
              cssClass: "six"
            }
          },
          {
            text: {
              text: game.i18n.localize("SR6.Attribute"),
              cssClass: "six"
            }
          },
          {
            text: {
              text: game.i18n.localize("SR6.Limit"),
              cssClass: "six"
            }
          },
          {
            text: {
              text: game.i18n.localize("SR6.Modifier"),
              cssClass: "six"
            }
          }
        ];
      case "weapon":
      case "armor":
      case "device":
      case "equipment":
      case "cyberware":
      case "bioware":
      case "modification":
      case "ammo":
        return [
          {
            text: {
              text: game.i18n.localize("SR6.Qty")
            }
          }
        ];
      case "complex_form":
        return [
          {
            text: {
              text: game.i18n.localize("SR6.Target")
            }
          },
          {
            text: {
              text: game.i18n.localize("SR6.Duration")
            }
          },
          {
            text: {
              text: game.i18n.localize("SR6.Fade")
            }
          }
        ];
      case "adept_power":
        return [
          {
            text: {
              text: game.i18n.localize("SR6.PowerType")
            }
          }
        ];
      case "spell":
        return [
          {
            text: {
              text: game.i18n.localize("SR6.Spell.Type")
            }
          },
          {
            text: {
              text: game.i18n.localize("SR6.Spell.Range")
            }
          },
          {
            text: {
              text: game.i18n.localize("SR6.Duration")
            }
          },
          {
            text: {
              text: game.i18n.localize("SR6.Drain")
            }
          }
        ];
      case "critter_power":
        return [
          {
            text: {
              text: game.i18n.localize("SR6.CritterPower.Type")
            }
          },
          {
            text: {
              text: game.i18n.localize("SR6.CritterPower.Range")
            }
          },
          {
            text: {
              text: game.i18n.localize("SR6.CritterPower.Duration")
            }
          },
          {
            text: {
              text: game.i18n.localize("SR6.Rating")
            }
          }
        ];
      case "quality":
        return [
          {
            text: {
              text: game.i18n.localize("SR6.QualityType")
            }
          },
          {
            text: {
              text: game.i18n.localize("SR6.Rating")
            }
          }
        ];
      case "echo":
      case "metamagic":
        return [{}];
      case "summoning":
        return [
          {
            text: {
              text: game.i18n.localize("SR6.Summoning.SpiritType")
            }
          },
          {
            text: {
              text: game.i18n.localize("SR6.Force")
            }
          }
        ];
      case "compilation":
        return [
          {
            text: {
              text: game.i18n.localize("SR6.Compilation.SpriteType")
            }
          },
          {
            text: {
              text: game.i18n.localize("SR6.Level")
            }
          }
        ];
      // General use case item lines
      case "modifiers":
        return [
          {
            text: {
              text: game.i18n.localize("SR6.Value")
            }
          }
        ];
      case "itemEffects":
        return [
          {
            text: {
              text: game.i18n.localize("SR6.ActiveEffect.ApplyTo")
            }
          },
          {
            text: {
              text: game.i18n.localize("SR6.Duration")
            }
          },
          {
            text: {
              // Used as a placeholder for effect line icons.
              // This way the header column is empty (as no +Add makes sense)
              // However the line column contains the normal interaction icons.
              text: ""
            }
          }
        ];
      case "effects":
        return [
          {
            text: {
              text: game.i18n.localize("SR6.ActiveEffect.ApplyTo")
            }
          },
          {
            text: {
              text: game.i18n.localize("SR6.Duration")
            }
          }
        ];
      default:
        return [];
    }
  });
  Handlebars.registerHelper("ItemRightSide", function(item) {
    const wrapper = new SR6ItemDataWrapper(item);
    const qtyInput = {
      input: {
        type: "number",
        value: wrapper.getQuantity(),
        cssClass: "item-qty"
      }
    };
    switch (item.type) {
      case "action":
        const limitAttribute = item.system.action.limit.attribute;
        const limitBase = Number(item.system.action.limit.base);
        const textLimitParts = [];
        if (!isNaN(limitBase) && limitBase > 0) {
          textLimitParts.push(limitBase.toString());
        }
        if (limitAttribute) {
          textLimitParts.push(game.i18n.localize(SR6.limits[limitAttribute ?? ""]));
        }
        const textLimit = textLimitParts.join(" + ");
        return [
          {
            text: {
              // Instead of 'complex' only show C. This might break in some languages. At that point, you can call me lazy.
              text: item.system.action.type ? game.i18n.localize(SR6.actionTypes[item.system.action.type] ?? "")[0] : ""
            }
          },
          {
            text: {
              // Either use the legacy skill localization OR just the skill name/id instead.
              text: game.i18n.localize(SR6.activeSkills[wrapper.getActionSkill() ?? ""] ?? wrapper.getActionSkill()),
              cssClass: "six"
            }
          },
          {
            text: {
              text: game.i18n.localize(SR6.attributes[wrapper.getActionAttribute() ?? ""]),
              cssClass: "six"
            }
          },
          {
            text: {
              // Legacy actions could have both skill and attribute2 set, which would show both information, when it shouldn't.
              text: wrapper.getActionSkill() ? "" : game.i18n.localize(SR6.attributes[wrapper.getActionAttribute2() ?? ""]),
              cssClass: "six"
            }
          },
          {
            text: {
              text: textLimit,
              cssClass: "six"
            }
          },
          {
            text: {
              text: wrapper.getActionDicePoolMod(),
              cssClass: "six"
            }
          }
        ];
      case "armor":
      case "ammo":
      case "modification":
        if (wrapper.isVehicleModification()) {
          return [
            {
              text: {
                text: game.i18n.localize(SR6.modificationCategories[wrapper.getModificationCategory() ?? ""])
              }
            },
            {
              text: {
                text: wrapper.getModificationCategorySlots() ?? ""
              }
            },
            qtyInput
          ];
        }
        ;
        if (wrapper.isDroneModification()) {
          return [
            {
              text: {
                text: wrapper.getModificationCategorySlots() ?? ""
              }
            },
            qtyInput
          ];
        }
      case "device":
      case "equipment":
      case "cyberware":
      case "bioware":
        return [qtyInput];
      case "weapon":
        if (wrapper.isRangedWeapon() || wrapper.isMeleeWeapon() && item.system.ammo?.current.max > 0) {
          const count = wrapper.getAmmo()?.current.value ?? 0;
          const max = wrapper.getAmmo()?.current.max ?? 0;
          const partialReloadRounds = wrapper.getAmmo()?.partial_reload_value ?? -1;
          const reloadLinks = [];
          const textReload = count < max ? `${game.i18n.localize("SR6.Weapon.Reload")} ` : `${game.i18n.localize("SR6.AmmoFull")}`;
          const cssClassReload = "no-break";
          reloadLinks.push({
            text: {
              title: `${game.i18n.localize("SR6.Weapon.AmmoCount")}: `,
              text: textReload,
              cssClass: cssClassReload
            }
          });
          if (count < max) {
            const textFullReload = `${game.i18n.localize("SR6.Weapon.FullReload")} (${count}/${max})`;
            const cssClassFullReload = "no-break reload-ammo roll";
            reloadLinks.push({
              button: {
                short: true,
                text: textFullReload,
                cssClass: cssClassFullReload
              }
            });
          }
          if (count < max && partialReloadRounds > 0) {
            const textPartialReload = `${game.i18n.localize("SR6.Weapon.PartialReload")} (+${partialReloadRounds})`;
            const cssClassPartialReload = "no-break partial-reload-ammo roll";
            reloadLinks.push({
              button: {
                short: true,
                text: textPartialReload,
                cssClass: cssClassPartialReload
              }
            });
          }
          reloadLinks.push(qtyInput);
          return reloadLinks;
        } else {
          return [qtyInput];
        }
      case "quality":
        return [
          {
            text: {
              text: game.i18n.localize(SR6.qualityTypes[item.system.type ?? ""])
            }
          },
          {
            text: {
              text: item.system.rating || ""
            }
          }
        ];
      case "adept_power":
        return [
          {
            text: {
              text: game.i18n.localize(SR6.adeptPower.types[item.system.type ?? ""])
            }
          }
        ];
      case "spell":
        return [
          {
            text: {
              text: game.i18n.localize(SR6.spellTypes[item.system.type ?? ""])
            }
          },
          {
            text: {
              text: game.i18n.localize(SR6.spellRanges[item.system.range ?? ""])
            }
          },
          {
            text: {
              text: game.i18n.localize(SR6.durations[item.system.duration ?? ""])
            }
          },
          {
            text: {
              text: wrapper.getDrain()
            }
          }
        ];
      case "critter_power":
        return [
          {
            text: {
              text: game.i18n.localize(SR6.critterPower.types[item.system.powerType ?? ""])
            }
          },
          {
            text: {
              text: game.i18n.localize(SR6.critterPower.ranges[item.system.range ?? ""])
            }
          },
          {
            text: {
              text: game.i18n.localize(SR6.critterPower.durations[item.system.duration ?? ""])
            }
          },
          {
            text: {
              text: item.system.rating ?? ""
            }
          }
        ];
      case "complex_form":
        return [
          {
            text: {
              text: game.i18n.localize(SR6.matrixTargets[item.system.target ?? ""])
            }
          },
          {
            text: {
              text: game.i18n.localize(SR6.durations[item.system.duration ?? ""])
            }
          },
          {
            text: {
              text: String(item.system.fade)
            }
          }
        ];
      case "program":
        return [
          {
            button: {
              cssClass: `item-equip-toggle ${wrapper.isEquipped() ? "light" : ""}`,
              short: true,
              text: wrapper.isEquipped() ? game.i18n.localize("SR6.Loaded") : game.i18n.localize("SR6.Load") + " >>"
            }
          }
        ];
      case "echo":
      case "metamagic":
        return [{}];
      /**
       * Call In Actions differ depending on called in actor type.
       */
      case "call_in_action":
        if (item.system.actor_type === "spirit") {
          const summoningData = item.system;
          const spiritTypeLabel = SR6.spiritTypes[summoningData.spirit.type] ?? "";
          return [
            {
              text: {
                text: game.i18n.localize(spiritTypeLabel)
              }
            },
            {
              text: {
                text: summoningData.spirit.force
              }
            }
          ];
        }
        if (item.system.actor_type === "sprite") {
          const compilationData = item.system;
          const spriteTypeLabel = SR6.spriteTypes[compilationData.sprite.type] ?? "";
          return [
            {
              text: {
                text: game.i18n.localize(spriteTypeLabel)
              }
            },
            {
              text: {
                text: compilationData.sprite.level
              }
            }
          ];
        }
      default:
        return [];
    }
  });
  Handlebars.registerHelper("ItemIcons", function(item) {
    const wrapper = new SR6ItemDataWrapper(item);
    const editIcon = {
      icon: "fas fa-edit item-edit",
      title: game.i18n.localize("SR6.EditItem")
    };
    const removeIcon = {
      icon: "fas fa-trash item-delete",
      title: game.i18n.localize("SR6.DeleteItem")
    };
    const equipIcon = {
      icon: `${wrapper.isEquipped() ? "fas fa-check-circle" : "far fa-circle"} item-equip-toggle`,
      title: game.i18n.localize("SR6.ToggleEquip")
    };
    const pdfIcon = {
      icon: "fas fa-file open-source",
      title: game.i18n.localize("SR6.OpenSource")
    };
    const icons = [pdfIcon, editIcon, removeIcon];
    switch (wrapper.getType()) {
      case "program":
      case "armor":
      case "device":
      case "equipment":
      case "cyberware":
      case "bioware":
      case "weapon":
        icons.unshift(equipIcon);
    }
    return icons;
  });
  Handlebars.registerHelper("EffectRightSide", function(effect) {
    const getDurationLabel = /* @__PURE__ */ __name(() => {
      if (effect.duration.seconds) return `${effect.duration.seconds}s`;
      if (effect.duration.rounds && effect.duration.turns) return `${effect.duration.rounds}r, ${effect.duration.turns}t`;
      if (effect.duration.rounds) return `${effect.duration.rounds}r`;
      if (effect.duration.turns) return `${effect.duration.turns}t`;
      return "";
    }, "getDurationLabel");
    return [
      {
        // Apply To Column
        text: {
          text: game.i18n.localize(SR6.effectApplyTo[effect.applyTo]),
          cssClass: "six"
        }
      },
      {
        // Duration Column
        text: {
          text: getDurationLabel(),
          cssClass: "six"
        }
      }
    ];
  });
  Handlebars.registerHelper("InventoryItemIcons", function(item) {
    const wrapper = new SR6ItemDataWrapper(item);
    const moveIcon = {
      icon: "fas fa-exchange-alt inventory-item-move",
      title: game.i18n.localize("SR6.MoveItemInventory")
    };
    const editIcon = {
      icon: "fas fa-edit item-edit",
      title: game.i18n.localize("SR6.EditItem")
    };
    const removeIcon = {
      icon: "fas fa-trash item-delete",
      title: game.i18n.localize("SR6.DeleteItem")
    };
    const equipIcon = {
      icon: `${wrapper.isEquipped() ? "fas fa-check-circle" : "far fa-circle"} item-equip-toggle`,
      title: game.i18n.localize("SR6.ToggleEquip")
    };
    const pdfIcon = {
      icon: "fas fa-file open-source",
      title: game.i18n.localize("SR6.OpenSource")
    };
    const icons = [pdfIcon, moveIcon, editIcon, removeIcon];
    switch (wrapper.getType()) {
      case "program":
      case "armor":
      case "device":
      case "equipment":
      case "cyberware":
      case "bioware":
      case "weapon":
        icons.unshift(equipIcon);
    }
    return icons;
  });
  Handlebars.registerHelper("EffectIcons", function(effect) {
    const editIcon = {
      icon: "fas fa-edit effect-control",
      title: game.i18n.localize("SR6.EditItem"),
      data: { action: "edit" }
    };
    const removeIcon = {
      icon: "fas fa-trash effect-control",
      title: game.i18n.localize("SR6.DeleteItem"),
      data: { action: "delete" }
    };
    const disableIcon = {
      icon: `${effect.disabled ? "far fa-circle" : "fas fa-check-circle"} effect-control`,
      title: game.i18n.localize("SR6.ToggleActive"),
      data: { action: "toggle" }
    };
    const openOriginIcon = {
      icon: "fas fa-file effect-control",
      title: game.i18n.localize("SR6.OpenOrigin"),
      data: { action: "open-origin" }
    };
    let icons = [disableIcon, editIcon, removeIcon];
    if (effect.isOriginOwned) icons = [openOriginIcon, ...icons];
    return icons;
  });
  Handlebars.registerHelper("ItemEffectIcons", function(effect) {
    const openOriginIcon = {
      icon: "fas fa-file item-effect-control",
      title: game.i18n.localize("SR6.OpenOrigin"),
      data: { action: "open-origin" }
    };
    const disableIcon = {
      icon: `${effect.disabled ? "far fa-circle" : "fas fa-check-circle"} item-effect-control`,
      title: game.i18n.localize("SR6.ToggleActive"),
      data: { action: "toggle" }
    };
    const editIcon = {
      icon: "fas fa-edit item-effect-control",
      title: game.i18n.localize("SR6.EditItem"),
      data: { action: "edit" }
    };
    return [openOriginIcon, disableIcon, editIcon];
  });
  Handlebars.registerHelper("MarksRightSide", (marked) => {
    const quantityInput = {
      input: {
        type: "number",
        value: marked.marks,
        cssClass: "marks-qty"
      }
    };
    return [quantityInput];
  });
  Handlebars.registerHelper("MarksIcons", (marked) => {
    const incrementIcon = {
      icon: "fas fa-plus marks-add-one",
      title: game.i18n.localize("SR6.Labels.Sheet.AddOne"),
      data: { action: "add-one" }
    };
    const decrementIcon = {
      icon: "fas fa-minus marks-remove-one",
      title: game.i18n.localize("SR6.Labels.Sheet.SubtractOne"),
      data: { action: "remove-one" }
    };
    return [incrementIcon, decrementIcon];
  });
  Handlebars.registerHelper("MarkListHeaderRightSide", () => {
    return [
      {
        text: {
          text: game.i18n.localize("SR6.FOUNDRY.Scene")
        }
      },
      {
        text: {
          text: game.i18n.localize("SR6.FOUNDRY.Item")
        }
      },
      {
        text: {
          text: game.i18n.localize("SR6.Qty")
        }
      }
    ];
  });
  Handlebars.registerHelper("MarkListHeaderIcons", () => {
    return [{
      icon: "fas fa-trash",
      title: game.i18n.localize("SR6.ClearMarks"),
      text: game.i18n.localize("SR6.Del"),
      cssClass: "marks-clear-all"
    }];
  });
  Handlebars.registerHelper("NetworkDevicesListRightSide", () => {
    return [
      {
        text: {
          text: game.i18n.localize("SR6.FOUNDRY.Actor")
        }
      },
      {
        text: {
          text: game.i18n.localize("SR6.FOUNDRY.Item")
        }
      }
    ];
  });
  Handlebars.registerHelper("NetworkDevicesListHeaderIcons", () => {
    return [{
      icon: "fas fa-trash",
      title: game.i18n.localize("SR6.Labels.Sheet.ClearNetwork"),
      text: game.i18n.localize("SR6.Del"),
      cssClass: "network-clear"
    }];
  });
}, "registerItemLineHelpers");

// src/module/handlebars/SkillLineHelpers.ts
var registerSkillLineHelpers = /* @__PURE__ */ __name(() => {
  Handlebars.registerHelper("SkillHeaderIcons", function(category3) {
    const addIcon = {
      icon: "fas fa-plus",
      title: game.i18n.localize("SR6.AddSkill"),
      text: game.i18n.localize("SR6.Add"),
      cssClass: ""
    };
    switch (category3) {
      case "active":
        addIcon.cssClass = "add-active";
        return [addIcon];
      case "language":
        addIcon.cssClass = "add-language";
        return [addIcon];
      case "knowledge":
        addIcon.cssClass = "add-knowledge";
        return [addIcon];
      default:
        return [];
    }
  });
  Handlebars.registerHelper("SkillHeaderRightSide", function(id, filters) {
    const specs = {
      text: {
        text: game.i18n.localize("SR6.Specialization"),
        cssClass: "skill-spec-item"
      }
    };
    const activeSkillFilter = id === "active" && filters && filters.hasOwnProperty("showUntrainedSkills") && !filters.showUntrainedSkills;
    const rtg = {
      text: {
        text: activeSkillFilter ? game.i18n.localize("SR6.RtgAboveZero") : game.i18n.localize("SR6.Rtg"),
        cssClass: "rtg"
      }
    };
    switch (id) {
      case "active":
      case "knowledge":
      case "language":
        return [specs, rtg];
      default:
        return [];
    }
  });
  Handlebars.registerHelper("SkillRightSide", function(skillType, skill) {
    const specs = Array.isArray(skill.specs) ? skill.specs : [skill.specs];
    return [
      {
        html: {
          text: specs.map((spec) => `<span class="roll skill-spec-roll">${spec}</span>`).join(", "),
          cssClass: "skill-spec-item"
        }
      },
      {
        text: {
          text: Helpers.calcTotal(skill),
          cssClass: "rtg"
        }
      }
    ];
  });
  Handlebars.registerHelper("SkillAdditionCssClass", function(skill) {
    const classes = [];
    if (game.settings.get(SYSTEM_NAME, FLAGS.ShowSkillsWithDetails) && !SkillRules.allowDefaultingRoll(skill)) {
      classes.push("skill-roll-not-defaultable");
    }
    return classes;
  });
  Handlebars.registerHelper("SkillIcons", function(skillType, skill) {
    const editIcon = {
      icon: "fas fa-edit",
      title: game.i18n.localize("SR6.EditSkill"),
      cssClass: ""
    };
    const openSourceIcon = {
      icon: "fas fa-file",
      title: game.i18n.localize("SR6.OpenSource"),
      cssClass: ""
    };
    const removeIcon = {
      icon: "fas fa-trash",
      title: game.i18n.localize("SR6.DeleteSkill"),
      cssClass: ""
    };
    switch (skillType) {
      case "active":
        editIcon.cssClass = "skill-edit";
        removeIcon.cssClass = "remove-active";
        openSourceIcon.cssClass = "skill-opensource";
        return [openSourceIcon, editIcon, removeIcon];
      case "language":
        editIcon.cssClass = "language-skill-edit";
        removeIcon.cssClass = "remove-language";
        openSourceIcon.cssClass = "language-skill-opensource";
        return [openSourceIcon, editIcon, removeIcon];
      case "knowledge":
        editIcon.cssClass = "knowledge-skill-edit";
        removeIcon.cssClass = "remove-knowledge";
        openSourceIcon.cssClass = "knowledge-skill-opensource";
        return [openSourceIcon, editIcon, removeIcon];
      default:
        return [editIcon];
    }
  });
}, "registerSkillLineHelpers");

// src/module/handlebars/AppHelpers.ts
var registerAppHelpers = /* @__PURE__ */ __name(() => {
  Handlebars.registerHelper("IsEnvModifierActive", (active3, category3, modifier) => {
    return active3[category3] === modifier;
  });
}, "registerAppHelpers");

// src/module/handlebars/BasicHelpers.ts
var registerBasicHelpers = /* @__PURE__ */ __name(() => {
  Handlebars.registerHelper("localizeOb", function(strId, obj) {
    if (obj) strId = obj[strId];
    return game.i18n.localize(strId);
  });
  Handlebars.registerHelper("localizeDocumentType", function(document2) {
    if (document2.type.length < 1) return "";
    const documentClass = document2 instanceof SR6Actor ? "Actor" : "Item";
    const i18nTypeLabel = `TYPES.${documentClass}.${document2.type}`;
    return game.i18n.localize(i18nTypeLabel);
  });
  Handlebars.registerHelper("localizeSkill", function(skill) {
    return skill.label ? game.i18n.localize(skill.label) : skill.name;
  });
  Handlebars.registerHelper("toHeaderCase", function(str) {
    if (str) return Helpers.label(str);
    return "";
  });
  Handlebars.registerHelper("concatStrings", function(...args) {
    return args.filter((a2) => typeof a2 === "string").join("");
  });
  Handlebars.registerHelper("concat", function(strs, c2 = ",") {
    if (Array.isArray(strs)) {
      return strs.join(c2);
    }
    return strs;
  });
  Handlebars.registerHelper("for", function(from, to, options) {
    let accum = "";
    for (let i2 = from; i2 < to; i2 += 1) {
      accum += options.fn(i2);
    }
    return accum;
  });
  Handlebars.registerHelper("modulo", function(v1, v2) {
    return v1 % v2;
  });
  Handlebars.registerHelper("divide", function(v1, v2) {
    if (v2 === 0) return 0;
    return v1 / v2;
  });
  Handlebars.registerHelper("hasprop", function(obj, prop, options) {
    if (obj.hasOwnProperty(prop)) {
      return options.fn(this);
    } else return options.inverse(this);
  });
  Handlebars.registerHelper("ifin", function(val, arr, options) {
    if (arr.includes(val)) return options.fn(this);
    else return options.inverse(this);
  });
  Handlebars.registerHelper("ifgt", function(v1, v2, options) {
    if (v1 > v2) return options.fn(this);
    else return options.inverse(this);
  });
  Handlebars.registerHelper("iflt", function(v1, v2, options) {
    if (v1 < v2) return options.fn(this);
    else return options.inverse(this);
  });
  Handlebars.registerHelper("iflte", function(v1, v2, options) {
    if (v1 <= v2) return options.fn(this);
    else return options.inverse(this);
  });
  Handlebars.registerHelper("ifne", function(v1, v2, options) {
    if (v1 !== v2) return options.fn(this);
    else return options.inverse(this);
  });
  Handlebars.registerHelper("ife", function(v1, v2, options) {
    if (v1 === v2) return options.fn(this);
    else return options.inverse(this);
  });
  Handlebars.registerHelper("ift", function(v1, v2) {
    if (v1) return v2;
  });
  Handlebars.registerHelper("empty", function(value) {
    if (foundry.utils.getType(value) === "Array") return value.length === 0;
    if (foundry.utils.getType(value) === "Object") return Object.keys(value).length === 0;
    if (foundry.utils.getType(value) === "String") return value.length === 0;
  });
  Handlebars.registerHelper("not", function(v1) {
    return !v1;
  });
  Handlebars.registerHelper("sum", function(v1, v2) {
    return v1 + v2;
  });
  Handlebars.registerHelper("isDefined", function(value) {
    return value !== void 0 && value !== null;
  });
  Handlebars.registerHelper("fallbackValue", function(value, defaultValue) {
    return new Handlebars.SafeString(value ?? defaultValue);
  });
  Handlebars.registerHelper("log", function(value) {
    console.log(value);
  });
  Handlebars.registerHelper("buildName", function(options) {
    const hash = Helpers.orderKeys(options.hash);
    const name3 = Object.values(hash).reduce((retVal, current, index) => {
      if (index > 0) retVal += ".";
      return retVal + current;
    }, "");
    return new Handlebars.SafeString(name3);
  });
  Handlebars.registerHelper("disabledHelper", function(value) {
    const val = Boolean(value);
    return val ? val : void 0;
  });
  Handlebars.registerHelper("localizeShortened", function(label, length, options) {
    return new Handlebars.SafeString(Helpers.shortenAttributeLocalization(label, length));
  });
  Handlebars.registerHelper("objValue", function(obj, key) {
    return obj[key] || "";
  });
  Handlebars.registerHelper("toArray", function(...vals) {
    const copy = [...vals];
    copy.splice(-1);
    return copy;
  });
  Handlebars.registerHelper("itemMarking", function(element) {
    const mark = game.settings.get(SYSTEM_NAME, "MarkImports");
    if (element == "ANY" && mark != "NONE") {
      return true;
    }
    if (mark == element || mark == "BOTH") {
      return true;
    }
    return false;
  });
  Handlebars.registerHelper("hasAnyFreshImports", function(actor) {
    if (game.settings.get(SYSTEM_NAME, "MarkImports") != "NONE") {
      const allItems = actor.items;
      for (const item of allItems) {
        if (item.system.importFlags) {
          if (item.system.importFlags.isFreshImport) {
            return true;
          }
        }
      }
    }
    return false;
  });
  Handlebars.registerHelper("or", function(a2, b2) {
    return a2 || b2;
  });
  Handlebars.registerHelper("firstDefined", function(...values) {
    for (const value of values) {
      if (value !== void 0) return value;
    }
    return void 0;
  });
}, "registerBasicHelpers");

// src/module/handlebars/ActorHelpers.ts
var registerActorHelpers = /* @__PURE__ */ __name(() => {
  Handlebars.registerHelper("showWoundModifier", (box, painTolerance, woundBoxesThreshold) => {
    if (box <= painTolerance) return false;
    return (box - painTolerance) % woundBoxesThreshold === 0;
  });
  Handlebars.registerHelper("woundModifier", (box, painTolerance, woundBoxesThreshold) => {
    const wounds = MonitorRules.wounds(box, woundBoxesThreshold, painTolerance);
    return MonitorRules.woundModifier(wounds);
  });
  Handlebars.registerHelper("calcModificationCategorySlots", (items, modificationCategory) => {
    if (!Array.isArray(items) || !items.length) {
      return 0;
    }
    const slotSum = items.reduce((arr, item) => {
      if (item.system.modification_category == modificationCategory) {
        return arr += item.system.slots ? item.system.slots : 0;
      } else {
        return arr;
      }
      ;
    }, 0);
    return slotSum;
  });
  Handlebars.registerHelper("calcModPointSlots", (items) => {
    if (!Array.isArray(items) || !items.length) {
      return 0;
    }
    var dronestring = "drone";
    const slotSum = items.reduce((arr, item) => {
      if (item.system.type == dronestring) {
        return arr += item.system.slots ? item.system.slots : 0;
      } else {
        return arr;
      }
      ;
    }, 0);
    return slotSum;
  });
}, "registerActorHelpers");

// src/module/handlebars/HandlebarManager.ts
var HandlebarManager = class {
  static {
    __name(this, "HandlebarManager");
  }
  static async loadTemplates() {
    await preloadHandlebarsTemplates();
  }
  static registerHelpers() {
    registerBasicHelpers();
    registerRollAndLabelHelpers();
    registerItemLineHelpers();
    registerSkillLineHelpers();
    registerAppHelpers();
    registerActorHelpers();
  }
};

// src/module/rules/CompilationRules.ts
var CompilationRules = {
  /**
   * Determine the amount of fade value a technomancer has to resist against.
   * 
   * See SR5#254 'Compiling a sprite'
   * 
   * @param hitsSprite Amount of hits by the opposing sprite.
   * @returns The numerical drain value without damage type.
   */
  compilationFadeValue: /* @__PURE__ */ __name((hitsSprite) => {
    return Math.max(hitsSprite * 2, 2);
  }, "compilationFadeValue"),
  /**
   * Determine fade damage type according to SR5#254 'Compiling a sprite'.
   * @param level Sprite sprite level value.
   * @param resonance Resonance attribute value.
   * @returns damage type
   */
  calcFadeDamageType: /* @__PURE__ */ __name((level, resonance) => {
    if (level < 0) level = 0;
    if (resonance < 0) resonance = 1;
    return level > resonance ? "physical" : "stun";
  }, "calcFadeDamageType"),
  /**
   * Determine the fade damage a technomancer has to resist against.
   * @param spriteHits Amount of hits by the opposing sprite.
   * @param level Sprite level used.
   * @param resonance Resonance attribute value.
   * @returns Configured fade damage
   */
  calcFadeDamage: /* @__PURE__ */ __name((spriteHits, level, resonance) => {
    if (spriteHits < 1) spriteHits = 0;
    if (resonance < 0) resonance = 1;
    const damage = DataDefaults.damageData();
    damage.base = CompilationRules.compilationFadeValue(spriteHits);
    damage.type.base = damage.type.value = CompilationRules.calcFadeDamageType(level, resonance);
    Helpers.calcTotal(damage, { min: 0 });
    return damage;
  }, "calcFadeDamage"),
  /**
   * Determine if the chosen level is valid for the given resonance attribute.
   * 
   * See SR5#254 'Compiling a sprite'
   * 
   * @param level The level value.
   * @param resonance The resonance attribute value.
   */
  validLevel: /* @__PURE__ */ __name((level, resonance) => {
    if (level < 1) return false;
    return level <= resonance * 2;
  }, "validLevel")
};

// src/module/tests/CompileSpriteTest.ts
var CompileSpriteTest = class extends SuccessTest {
  static {
    __name(this, "CompileSpriteTest");
  }
  _prepareData(data, options) {
    data = super._prepareData(data, options);
    this._prepareCompilationData(data);
    data.fade = data.fade || 0;
    data.fadeDamage = data.fadeDamage || DataDefaults.damageData();
    return data;
  }
  _prepareCompilationData(data) {
    if (!this.item) return;
    const compilation = this.item.asCallInAction;
    if (!compilation || !this.item.isCompilation) return;
    data.level = Math.max(data.level || compilation.system.sprite.level || 1, 1);
    data.spriteTypes = this._prepareSpriteTypes();
    data.spriteTypeSelected = data.spriteTypeSelected || compilation.system.sprite.type;
    data.preparedSpriteUuid = data.preparedSpriteUuid || compilation.system.sprite.uuid;
  }
  _prepareSpriteTypes() {
    return SR6.spriteTypes;
  }
  get _dialogTemplate() {
    return "systems/shadowrun6-elysium/dist/templates/apps/dialogs/compilation-test-dialog.html";
  }
  get canBeExtended() {
    return false;
  }
  /**
   * Fade test is configured here but will be executed only manually after the opposed test finished.
   */
  get autoExecuteFollowupTest() {
    return false;
  }
  get testCategories() {
    return ["compiling"];
  }
  /**
   * Skill + Attribute [Limit] as defined in SR5#254 'Compiling a Sprite'
   *
   * Limit 'level' is a dynamic test value, so it's missing here as it can't be taken from actor values
   * but will be injected during test dialog preparations.
   */
  static _getDefaultTestAction() {
    return {
      skill: "compiling",
      attribute: "resonance"
    };
  }
  /**
   * Inject level as limit value into test.
   */
  prepareBaseValues() {
    super.prepareBaseValues();
    this.prepareLimitValue();
  }
  /**
   * Level value only depends on user selection and doesn't deviate according to SR5#254.
   */
  prepareLimitValue() {
    const level = Number(this.data.level);
    const label = "SR6.Level";
    const limitParts = new PartsList(this.data.limit.mod);
    limitParts.addUniquePart(label, level);
  }
  /**
   * Inject into user dialog level value selection changes.
   */
  validateBaseValues() {
    this.warnAboutInvalidLevel();
  }
  /**
   * Notify mancers about incomplete compilation. To avoid pre mature fade tests.
   */
  async executeFollowUpTest() {
    if (!this.data.fadeReady) ui.notifications?.warn("SR6.Warnings.CompilationNotConcluded", { localize: true });
    await super.executeFollowUpTest();
  }
  /**
   * Let user know about invalid level selection.
   */
  warnAboutInvalidLevel() {
    const level = Number(this.data.level);
    const resonance = this.actor?.getAttribute("resonance")?.value ?? 0;
    if (CompilationRules.validLevel(level, resonance)) return;
    ui.notifications?.warn("SR6.Warnings.InvalidCompilationLevel", { localize: true });
  }
  /**
   * Derive the actual fade damage from compilation values.
   * NOTE: This will be called by the opposing test via a follow up test action.
   *
   * @param opposingHits Amount of hits from the opposing test (sprite).
   */
  calcFade(opposingHits) {
    this.data.fadeReady = true;
    this.data.fade = CompilationRules.compilationFadeValue(opposingHits);
    this.data.fadeDamage = this.calcFadeDamage(opposingHits);
  }
  calcFadeDamage(opposingHits) {
    if (!this.actor) return DataDefaults.damageData();
    const resonance = this.actor.getAttribute("resonance").value;
    const level = this.data.level;
    return CompilationRules.calcFadeDamage(opposingHits, level, resonance);
  }
  /**
   * Indicate the use of a prepared actor.
   */
  get preparedActorUsed() {
    return this.data.preparedSpriteUuid !== "";
  }
};

// src/module/rules/DrainRules.ts
var DrainRules = class _DrainRules {
  static {
    __name(this, "DrainRules");
  }
  /**
   * Calculate spell casting drain damage according to SR5#281-282
   *
   * @param drain The drain value
   * @param force The force value used to cast
   * @param magic The magic attribute level of the caster
   * @param hits Spellcasting test hits
   */
  static calcDrainDamage(drain, force, magic, hits) {
    if (force < 0) force = 1;
    if (magic < 0) magic = 1;
    if (hits < 0) hits = 0;
    const damage = DataDefaults.damageData();
    damage.base = drain;
    Helpers.calcTotal(damage, { min: 0 });
    damage.type.base = damage.type.value = _DrainRules.calcDrainDamageType(hits, magic);
    return damage;
  }
  /**
   * Get the drain damage type according to SR5#281 'Step 3'
   * @param hits The spell casting test hits AFTER limit
   * @param magic The magic attribute level of the caster
   */
  static calcDrainDamageType(hits, magic) {
    if (hits < 0) hits = 0;
    if (magic < 0) magic = 1;
    return hits > magic ? "physical" : "stun";
  }
  /**
   * Modify the drain damage after the spell casting test has been completed.
   *
   * @param drainDamage The base drain damage after force / drain has been chosen.
   * @param hits The spell casting test hits
   */
  static modifyDrainDamage(drainDamage, hits) {
    if (hits < 0) hits = 0;
    drainDamage = foundry.utils.duplicate(drainDamage);
    PartsList.AddUniquePart(drainDamage.mod, "SR6.Hits", -hits);
    Helpers.calcTotal(drainDamage, { min: 0 });
    return drainDamage;
  }
};

// src/module/rules/ConjuringRules.ts
var ConjuringRules = {
  /**
   * Determine the amount of services a spirit will provide the it's summoner
   * 
   * @param hitsSummoner Hits of the summoning test.
   * @param hitsSpirit Hits of the spirits opposing test.
   */
  spiritServices: /* @__PURE__ */ __name((hitsSummoner, hitsSpirit) => {
    return Math.max(hitsSummoner - hitsSpirit, 0);
  }, "spiritServices"),
  /**
   * Determine the amount of drain value a summoner has to drain against.
   * 
   * See SR5#300 'Resist Drain'
   * 
   * @param hitsSpirit The amount of hits of the opposing spirit
   */
  summoningDrainValue: /* @__PURE__ */ __name((hitsSpirit) => {
    return Math.max(hitsSpirit * 2, 2);
  }, "summoningDrainValue"),
  /**
   * Determine the drain damage a summoner has to drain against.
   * 
   * See SR5#300 and general Drain Rules.
   * 
   * @param hitsSpirit The amount of hits of the opposing spirit
   * @param force The force level chosen for summoning
   * @param magic The magic attribute level of the summoner
   */
  calcDrainDamage: /* @__PURE__ */ __name((hitsSpirit, force, magic) => {
    if (hitsSpirit < 0) hitsSpirit = 0;
    if (magic < 0) magic = 1;
    const damage = DataDefaults.damageData();
    damage.base = ConjuringRules.summoningDrainValue(hitsSpirit);
    damage.type.base = damage.type.value = DrainRules.calcDrainDamageType(force, magic);
    Helpers.calcTotal(damage, { min: 0 });
    return damage;
  }, "calcDrainDamage"),
  /**
   * Determine if the chosen force is valid for the given magic attribute.
   * 
   * See SR5#300 'Summoning' Step 1.
   * 
   * @param force The force value.
   * @param magic The magic attribute value.
   */
  validForce: /* @__PURE__ */ __name((force, magic) => {
    if (force < 1) return false;
    return force <= magic * 2;
  }, "validForce")
};

// src/module/tests/OpposedSummonSpiritTest.ts
var OpposedSummonSpiritTest = class extends OpposedTest {
  static {
    __name(this, "OpposedSummonSpiritTest");
  }
  constructor(data, documents, options) {
    delete documents?.actor;
    delete data.sourceActorUuid;
    super(data, documents, options);
    this._assertCorrectAgainst();
  }
  /**
   * Prohibit opposing any other test than SummonSpiritTest
   */
  _assertCorrectAgainst() {
    if (this.against.type !== "SummonSpiritTest") throw new Error(`${this.constructor.name} can only oppose SummonSpiritTest but is opposing a ${this.against.type}`);
  }
  _prepareData(data, options) {
    data = super._prepareData(data, options);
    data.summonedSpiritUuid = data.summonedSpiritUuid || "";
    return data;
  }
  get _chatMessageTemplate() {
    return "systems/shadowrun6-elysium/dist/templates/rolls/opposed-actor-creator-message.html";
  }
  /**
   * When summoning the opposing spirit test triggers the DrainTest from summoning.
   * Since we can expect this test to be within GM context, we can't auto cast DrainTest.
   */
  get autoExecuteFollowupTest() {
    return false;
  }
  /**
   * To have an opposing actor, that's not on the map already, create the spirit actor.
   */
  async populateDocuments() {
    await this.createSummonedSpirit();
    this.data.sourceActorUuid = this.data.summonedSpiritUuid || this.against.data.preparedSpiritUuid;
    await super.populateDocuments();
  }
  /**
   * Other than force there shouldn't be any other pool parts.
   */
  applyPoolModifiers() {
    PartsList.AddUniquePart(this.data.pool.mod, "SR6.Force", this.against.data.force);
  }
  /**
   * A failure for the spirit is a success for the summoner.
   */
  async processFailure() {
    await this.updateSummonTestForFollowup();
    await this.finalizeSummonedSpirit();
  }
  /**
   * A success of the spirit is a failure for the summoner.
   */
  async processSuccess() {
    await this.updateSummonTestForFollowup();
    await this.cleanupAfterExecutionCancel();
  }
  get successLabel() {
    return "SR6.TestResults.SpiritSummonFailure";
  }
  get failureLabel() {
    return "SR6.TestResults.SpiritSummonSuccess";
  }
  async updateSummonTestForFollowup() {
    this.against.calcDrain(this.hits.value);
    await this.against.saveToMessage();
  }
  /**
   * Derive the amount of services the created actor spirit will have.
   *
   * Should be called after a successful summoning.
   */
  deriveSpiritServices() {
    return ConjuringRules.spiritServices(this.against.hits.value, this.hits.value);
  }
  /**
   * Finalize the existing spirit actor with context around it's summoning.
   *
   * This should be called as the last step in summoning.
   */
  async finalizeSummonedSpirit() {
    if (!this.actor) return;
    const summoner = this.against.actor;
    const updateData = {
      "system.services": this.deriveSpiritServices(),
      "system.summonerUuid": summoner.uuid
    };
    this._addOwnershipToUpdateData(updateData);
    await this.actor.update(updateData);
  }
  /**
   * Give all users with the summoning actor permissions of the created spirit actor.
   *
   * @param updateData The update data to add the permission to, that's applied to the spirit actor.
   */
  _addOwnershipToUpdateData(updateData) {
    const summoner = this.against.actor;
    const users = game.users?.filter((user) => user.character?.uuid === summoner.uuid);
    if (!users) return;
    const ownership = {};
    users.forEach((user) => {
      if (user.isGM) return;
      ownership[user.id] = CONST.DOCUMENT_OWNERSHIP_LEVELS.OWNER;
    });
    updateData["ownership"] = ownership;
  }
  /**
   * Based on this tests selection, create a spirit actor
   */
  async createSummonedSpirit() {
    if (!this.against) return;
    if (!this.against.actor) return;
    const summoner = this.against.actor;
    if (this.against.data.preparedSpiritUuid) {
      const preparedActor = await this.getPreparedSpiritActor();
      if (!preparedActor) return console.error("Shadowrun 6e | Could not find prepared spirit actor");
      await preparedActor.update({ "system.summonerUuid": summoner.uuid });
    } else {
      const spiritType = this.against.data.spiritTypeSelected;
      const spiritTypeLabel = game.i18n.localize(SR6.spiritTypes[spiritType]);
      const name3 = `${summoner.name} ${spiritTypeLabel} ${game.i18n.localize("TYPES.Actor.spirit")}`;
      const force = this.against.data.force;
      const system = { force, spiritType };
      const actor = await Actor.create({ name: name3, type: "spirit", system, prototypeToken: { actorLink: true } });
      if (!actor) return console.error("Shadowrun 6e | Could not create the summoned spirit actor");
      this.data.summonedSpiritUuid = actor.uuid;
    }
  }
  /**
   * Try getting a prepared spirit actor to reuse.
   *
   * @returns
   */
  async getPreparedSpiritActor() {
    return await fromUuid(this.against.data.preparedSpiritUuid);
  }
  /**
   * Cleanup created actors that aren't needed anymore.
   *
   * When user cancels the dialog, the spirits has been created. Remove it.
   */
  async cleanupAfterExecutionCancel() {
    if (!this.data.summonedSpiritUuid) return;
    const actor = await fromUuid(this.data.summonedSpiritUuid);
    await actor?.delete();
    delete this.actor;
  }
};

// src/module/tests/OpposedRitualTest.ts
var OpposedRitualTest = class extends OpposedTest {
  static {
    __name(this, "OpposedRitualTest");
  }
  constructor(data, documents, options) {
    super(data, documents, options);
    this._assertCorrectAgainst();
  }
  /**
   * Prohibit opposing any other test than SpellCastingTest
   */
  _assertCorrectAgainst() {
    if (this.against.type !== "RitualSpellcastingTest") throw new Error(`${this.constructor.name} can only oppose RitualSpellcastingTest but is opposing a ${this.against.type}`);
  }
  get _chatMessageTemplate() {
    return "systems/shadowrun6-elysium/dist/templates/rolls/success-test-message.html";
  }
  /**
   * When ritual casting the opposing ritual test triggers the DrainTest.
   * Since we can expect this test to be within GM context, we can't auto cast DrainTest.
   */
  get autoExecuteFollowupTest() {
    return false;
  }
  /**
   * Other than force there shouldn't be any other pool parts.
   */
  applyPoolModifiers() {
    PartsList.AddUniquePart(this.data.pool.mod, "SR6.Force", this.against.data.force);
    PartsList.AddPart(this.data.pool.mod, "SR6.Force", this.against.data.force);
  }
  /**
   * A failure for the ritual is a success for the summoner.
   */
  async processFailure() {
    await this.updateRitualTestForFollowup();
  }
  /**
   * A success of the ritual is a failure for the summoner.
   */
  async processSuccess() {
    await this.updateRitualTestForFollowup();
    await this.cleanupAfterExecutionCancel();
  }
  get successLabel() {
    return "SR6.TestResults.RitualFailure";
  }
  get failureLabel() {
    return "SR6.TestResults.RitualSuccess";
  }
  async updateRitualTestForFollowup() {
    let opposingHits = this.hits.value;
    this.against.calcDrain(opposingHits);
    await this.against.saveToMessage();
  }
};

// src/module/rules/RitualRules.ts
var RitualRules = {
  /**
   * Determine the amount of hits
   * 
   * @param hitsCaster Hits of the ritual test.
   * @param hitsRitual Hits of the ritual opposing test.
   */
  ritualHits: /* @__PURE__ */ __name((hitsCaster, hitsRitual) => {
    return Math.max(hitsCaster - hitsRitual, 0);
  }, "ritualHits"),
  /**
   * Determine the amount of drain value all ritual participants have to drain against.
   * 
   * See SR5#296 'Seal the ritual'
   * 
   * @param hits The amount of hits of the opposing ritual
   */
  drainValue: /* @__PURE__ */ __name((hits, reagents, force) => {
    let reduction = Math.max(Math.floor(reagents / force) - 1, 0);
    return Math.max(hits * 2 - reduction, 2);
  }, "drainValue"),
  /**
   * Determine the drain damage a ritual participant has to drain against.
   * 
   * See SR5#296 and general Drain Rules.
   * 
   * @param hits The amount of hits of the opposing ritual
   * @param drain The drain for the ritual
   * @param magic The magic attribute level of the ritual leader
   */
  calcDrainDamage: /* @__PURE__ */ __name((hits, drain, magic) => {
    if (hits < 0) hits = 0;
    if (magic < 0) magic = 1;
    const damage = DataDefaults.damageData();
    damage.base = drain;
    damage.type.base = damage.type.value = DrainRules.calcDrainDamageType(hits, magic);
    Helpers.calcTotal(damage, { min: 0 });
    return damage;
  }, "calcDrainDamage"),
  /**
   * Determine if the chosen force is valid for the given lodge rating.
   * 
   * See SR5#300 'Ritual Spellcasting' Step 4.
   * 
   * @param force The force value.
   * @param lodgeRating The lodge rating value.
   */
  validForce: /* @__PURE__ */ __name((force, lodgeRating) => {
    if (force < 1) {
      return false;
    }
    return force <= lodgeRating;
  }, "validForce"),
  validReagent: /* @__PURE__ */ __name((reagents, force) => {
    if (force < 1) {
      return false;
    }
    return force <= reagents;
  }, "validReagent"),
  /**
   * Reagents used must either match force exactly or be a multiple of force.
   * 
   * See SR5#296 'Give the offering'
   * @param force 
   */
  deriveReagents: /* @__PURE__ */ __name((force, reagents) => {
    if (reagents <= force) return force;
    const remainder = reagents % force;
    if (remainder > 0) return reagents - remainder + force;
    else return reagents;
  }, "deriveReagents")
};

// src/module/tests/RitualSpellcastingTest.ts
var RitualSpellcastingTest = class extends SuccessTest {
  static {
    __name(this, "RitualSpellcastingTest");
  }
  _prepareData(data, options) {
    data = super._prepareData(data, options);
    this._prepareRitualData(data);
    data.drain = data.drain || 0;
    data.drainDamage = data.drainDamage || DataDefaults.damageData();
    return data;
  }
  get _dialogTemplate() {
    return "systems/shadowrun6-elysium/dist/templates/apps/dialogs/ritualspellcasting-test-dialog.html";
  }
  get testCategories() {
    return ["spell_ritual"];
  }
  /**
   * A ritual test can't be extended.
   */
  get canBeExtended() {
    return false;
  }
  /**
   * Drain test is configured here but will be executed within the opposing tests context.
   */
  get autoExecuteFollowupTest() {
    return false;
  }
  /**
   *
   */
  static _getDefaultTestAction() {
    return {
      skill: "ritual_spellcasting",
      attribute: "magic"
    };
  }
  async prepareDocumentData() {
    this.prepareInitialForceValue();
    await super.prepareDocumentData();
  }
  /**
   * Set a default force value based on the force last used for this ritual.
   *
   * If ritual hasn't been cast before, fallback to a useable value.
   */
  prepareInitialForceValue() {
    if (!this.item) return;
    const lastUsedForce = this.item.getLastSpellForce();
    this.data.force = lastUsedForce.value || 1;
  }
  /**
   * Rituals uses Force as limit, which needs to be injected into the normal test flow.
   */
  prepareBaseValues() {
    super.prepareBaseValues();
    this.prepareLimitValue();
    this.prepareReagents();
  }
  /**
   * Validate user input during dialog or creation and inform user about invalid values.
   */
  validateBaseValues() {
    this.warnAboutInvalidForce();
    this.warnAboutInvalidReagents();
  }
  /**
   * Notify caster about incomplete ritual. To avoid pre mature drain tests.
   */
  async executeFollowUpTest() {
    if (!this.data.drainReady) {
      ui.notifications?.warn("SR6.Warnings.RitualNotConcluded", { localize: true });
    }
    await super.executeFollowUpTest();
  }
  /**
   * Don't abort execution as there might be some reason users would want to allow 'invalid' values.
   */
  warnAboutInvalidForce() {
    const force = Number(this.data.force);
    if (!RitualRules.validForce(force, force)) {
      ui.notifications?.warn("SR6.Warnings.RitualInvalidForce", { localize: true });
    }
  }
  warnAboutInvalidReagents() {
    const reagents = Number(this.data.reagents);
    const force = Number(this.data.force);
    if (!RitualRules.validReagent(reagents, force)) {
      ui.notifications?.warn("SR6.Warnings.RitualNotEnoughReagents", { localize: true });
    }
  }
  /**
   * Calculate limit based on force selected by user.
   *
   */
  prepareLimitValue() {
    this.data.limit.mod = PartsList.AddUniquePart(
      this.data.limit.mod,
      "SR6.Force",
      this.data.force
    );
  }
  /**
   * For rituals reagents must match the force of the ritual at a minimum.
   */
  prepareReagents() {
    this.data.reagents = RitualRules.deriveReagents(this.data.force, this.data.reagents);
  }
  /**
   *
   * @param data Test data to be extended
   */
  _prepareRitualData(data) {
    data.force = Math.max(data.force || 1, 1);
    data.reagents = data.reagents || data.force;
  }
  /**
   * Derive the actual drain damage from spellcasting values.
   *
   * NOTE: This will be called by the opposing test via a follow up test action.
   */
  calcDrain(opposingHits) {
    if (!this.actor) return DataDefaults.damageData();
    this.data.drain = RitualRules.drainValue(opposingHits, this.data.reagents, this.data.force);
    this.data.drainDamage = RitualRules.calcDrainDamage(opposingHits, this.data.drain, this.actor.getAttribute("magic").value);
    this.data.drainReady = true;
  }
  /**
   * Allow the currently used force value of this ritual to be reused next time it is cast.
   */
  async saveUserSelectionAfterDialog() {
    if (!this.item) return;
    await this.item.setLastSpellForce({ value: this.data.force });
  }
};

// src/module/migrator/VersionMigration.ts
var VersionMigration = class _VersionMigration {
  constructor() {
    this.m_Abort = false;
  }
  static {
    __name(this, "VersionMigration");
  }
  static {
    this.MODULE_NAME = "shadowrun6-elysium";
  }
  static {
    this.KEY_DATA_VERSION = "systemMigrationVersion";
  }
  static {
    this.NO_VERSION = "0";
  }
  get SourceVersionFriendlyName() {
    return `v${this.SourceVersion}`;
  }
  get TargetVersionFriendlyName() {
    return `v${this.TargetVersion}`;
  }
  /**
   * Flag the migration to be aborted.
   * @param reason The reason that the migration must be aborted, to be displayed
   *  to the user and returned from the migration call.
   */
  abort(reason) {
    this.m_Abort = true;
    this.m_AbortReason = reason;
    ui.notifications?.error(`Data migration has been aborted: ${reason}`, { permanent: true });
  }
  /**
   * Show a version specific dialog to the user to inform or confirm about certain migration aspects.
   */
  async AskForUserConsentAndConfiguration() {
    return true;
  }
  /**
   * Begin migration for the specified game.
   * @param game The world that should be migrated.
   */
  async Migrate(game2) {
    ui.notifications?.info(`${game2.i18n.localize("SR6.MIGRATION.BeginNotification")} ${this.SourceVersionFriendlyName} -> ${this.TargetVersionFriendlyName}.`);
    ui.notifications?.warn(game2.i18n.localize("SR6.MIGRATION.DoNotCloseNotification"), {
      permanent: true
    });
    const entityUpdates = /* @__PURE__ */ new Map();
    await this.PreMigrateItemData(game2, entityUpdates);
    if (this.m_Abort) {
      return Promise.reject(this.m_AbortReason);
    }
    await this.IterateItems(game2, entityUpdates);
    await this.PostMigrateItemData(game2, entityUpdates);
    if (this.m_Abort) {
      return Promise.reject(this.m_AbortReason);
    }
    await this.PreMigrateActorData(game2, entityUpdates);
    if (this.m_Abort) {
      return Promise.reject(this.m_AbortReason);
    }
    await this.IterateActors(game2, entityUpdates);
    await this.PostMigrateActorData(game2, entityUpdates);
    if (this.m_Abort) {
      return Promise.reject(this.m_AbortReason);
    }
    await this.PreMigrateSceneData(game2, entityUpdates);
    if (this.m_Abort) {
      return Promise.reject(this.m_AbortReason);
    }
    await this.IterateScenes(game2, entityUpdates);
    await this.PostMigrateSceneData(game2, entityUpdates);
    if (this.m_Abort) {
      return Promise.reject(this.m_AbortReason);
    }
    await this.Apply(entityUpdates);
    await game2.settings.set(_VersionMigration.MODULE_NAME, _VersionMigration.KEY_DATA_VERSION, this.TargetVersion);
    ui.notifications?.info(`${game2.i18n.localize("SR6.MIGRATION.SuccessNotification")} ${this.TargetVersion}.`, { permanent: true });
  }
  /**
   * Applies the specified mapping of entities, iteratively updating each.
   * @param documentUpdates A mapping of document updateData pairs.
   */
  async Apply(documentUpdates) {
    for (const [entity, { updateData, embeddedItems }] of documentUpdates) {
      const updateSystem = updateData?.data ? { system: updateData.data } : updateData;
      if (embeddedItems !== null) {
        const actor = entity;
        await actor.updateEmbeddedDocuments("Item", embeddedItems);
      }
      if (updateData !== null) {
        await entity.update(updateSystem, { enforceTypes: false });
      }
    }
  }
  /**
   * Iterate through all scenes and migrate each if needed.
   * @param game
   * @param entityUpdates
   */
  async IterateScenes(game2, entityUpdates) {
    for (const scene of game2.scenes.contents) {
      try {
        if (!await this.ShouldMigrateSceneData(scene)) {
          continue;
        }
        console.log(`Migrating Scene entity ${scene.name}`);
        const updateData = await this.MigrateSceneData(scene);
        expandObject(updateData);
        entityUpdates.set(scene, {
          updateData,
          embeddedItems: null,
          embeddedEffects: null
        });
        for (const token of scene.data.tokens) {
          if (!token.actor || token.data.actorLink) continue;
          if (foundry.utils.isEmpty(token.actor)) continue;
          const updateData2 = await this.MigrateActorData(token.actor);
          expandObject(updateData2);
          entityUpdates.set(token.actor, {
            updateData: updateData2.data || null,
            embeddedItems: updateData2.items || null,
            embeddedEffects: updateData2.effects || null
          });
        }
        if (foundry.utils.isEmpty(updateData)) {
          continue;
        }
        expandObject(updateData);
        entityUpdates.set(scene, {
          updateData,
          embeddedItems: null,
          embeddedEffects: null
        });
      } catch (error) {
        console.error(error);
        return Promise.reject(error);
      }
    }
  }
  /**
   * Iterate through all items and migrate each if needed.
   * @param game The game to be updated.
   * @param entityUpdates The current map of document updates.
   */
  async IterateItems(game2, entityUpdates) {
    for (const item of game2.items.contents) {
      try {
        if (!await this.ShouldMigrateItemData(item)) {
          continue;
        }
        console.log(`Migrating Item: ${item.name}`);
        const updateData = await this.MigrateItemData(item);
        if (foundry.utils.isEmpty(updateData)) {
          continue;
        }
        expandObject(updateData);
        entityUpdates.set(item, {
          updateData,
          embeddedItems: null,
          embeddedEffects: updateData.effects || null
        });
      } catch (error) {
        console.error(error);
        return Promise.reject(error);
      }
    }
  }
  /**
   * Iterate through all actors and migrate each if needed.
   * @param game The game to be updated.
   * @param entityUpdates The current map of document updates.
   */
  async IterateActors(game2, entityUpdates) {
    for (const actor of game2.actors.contents) {
      try {
        if (!await this.ShouldMigrateActorData(actor)) {
          continue;
        }
        console.log(`Migrating Actor ${actor.name}`);
        console.log(actor);
        const updateData = await this.MigrateActorData(actor);
        console.log(updateData);
        let items = [];
        if (updateData.items) {
          items = updateData.items;
          delete updateData.items;
        }
        expandObject(updateData);
        entityUpdates.set(actor, {
          updateData,
          embeddedItems: items,
          embeddedEffects: updateData.effects || null
        });
      } catch (error) {
        console.error(error);
        return Promise.reject(error);
      }
    }
  }
  /**
   * Iterate over an actor's items, updating those that need updating.
   * @param actor The actor to iterate over
   * @param updateData The existing update data to merge into
   */
  async IterateActorItems(actor, updateData) {
    let hasItemUpdates = false;
    if (actor.items !== void 0) {
      const items = await Promise.all(
        actor.items.map(async (item) => {
          if (item instanceof SR6Item) console.error("Shadowrun 6e | Migration encountered an Item when it should have encountered ItemData / Object");
          if (!await this.ShouldMigrateItemData(item)) return item;
          const itemUpdate = await this.MigrateItemData(item);
          hasItemUpdates = true;
          itemUpdate["_id"] = item.id;
          return foundry.utils.mergeObject(item, itemUpdate.data, {
            enforceTypes: false,
            inplace: false
          });
        })
      );
      if (hasItemUpdates) {
        updateData.items = items;
      }
    }
    return updateData;
  }
  /**
   * Check if a scene requires updates.
   * @param scene The scene to check.
   * @return A promise that resolves true or false.
   */
  async ShouldMigrateSceneData(scene) {
    return false;
  }
  /**
   * Migrate the specified scene's data.
   * @param scene The scene to migrate.
   * @return A promise that resolves with the update data.
   */
  async MigrateSceneData(scene) {
    return {};
  }
  /**
   * Do something right before scene data is migrated.
   * @param game The game to be updated.
   * @param entityUpdates The current map of document updates.
   */
  async PreMigrateSceneData(game2, entityUpdates) {
  }
  /**
   * Do something right before scene data is migrated.
   * @param game The game to be updated.
   * @param entityUpdates The current map of document updates.
   */
  async PostMigrateSceneData(game2, entityUpdates) {
  }
  /**
   * Check if an item requires updates.
   * @param item The item to check.
   * @return A promise that resolves true or false.
   */
  async ShouldMigrateItemData(item) {
    return false;
  }
  /**
   * Migrate the specified item's data.
   * @param item The item to migrate.
   * @return A promise that resolves with the update data.
   */
  async MigrateItemData(item) {
    return {};
  }
  /**
   * Do something right before item data is migrated.
   * @param game The game to be updated.
   * @param entityUpdates The current map of document updates.
   */
  async PreMigrateItemData(game2, entityUpdates) {
  }
  /**
   * Do something right before item data is migrated.
   * @param game The game to be updated.
   * @param entityUpdates The current map of document updates.
   */
  async PostMigrateItemData(game2, entityUpdates) {
  }
  /**
   * Check if an actor requires updates.
   * @param actor The actor to check.
   * @return A promise that resolves true or false.
   */
  async ShouldMigrateActorData(actor) {
    return false;
  }
  /**
   * Migrate the specified actor's data.
   * @param actor The actor to migrate.
   * @return A promise that resolves with the update data.
   */
  async MigrateActorData(actor) {
    return {};
  }
  /**
   * Do something right before actor data is migrated.
   * @param game The game to be updated.
   * @param entityUpdates The current map of document updates.
   */
  async PreMigrateActorData(game2, entityUpdates) {
  }
  /**
   * Do something right after actor data is migrated.
   * @param game The game to be updated.
   * @param entityUpdates The current map of document updates.
   */
  async PostMigrateActorData(game2, entityUpdates) {
  }
  /**
   * Migrate a compendium pack
   * @param pack
   */
  async MigrateCompendiumPack(pack) {
    if (!["Actor", "Item", "Scene"].includes(pack.metadata.type)) return;
    await pack.migrate({});
    const documents = await pack.getDocuments();
    for (let document2 of documents) {
      try {
        let updateData = null;
        if (pack.metadata.type === "Item") {
          updateData = await this.MigrateItemData(document2);
          if (foundry.utils.isEmpty(updateData)) {
            continue;
          }
          if (updateData.data) {
            expandObject(updateData.data);
            document2.update({ system: updateData.data });
          }
        } else if (pack.metadata.type === "Actor") {
          updateData = await this.MigrateActorData(document2);
          if (foundry.utils.isEmpty(updateData)) {
            continue;
          }
          if (updateData.items) {
            await document2.updateEmbeddedDocuments("Item", updateData.items);
          }
          if (updateData.effects) {
            await document2.updateEmbeddedDocuments("Effect", updateData.effects);
          }
          if (updateData.data) {
            expandObject(updateData.data);
            await document2.update({ system: updateData.data });
          }
        } else if (pack.metadata.type === "Scene") {
          updateData = await this.MigrateSceneData(document2);
          if (foundry.utils.isEmpty(updateData)) {
            continue;
          }
          if (updateData.data) {
            expandObject(updateData.data);
            await document2.update(updateData.data);
          }
        }
      } catch (err) {
        console.error(err);
      }
    }
    console.log(`Migrated all ${pack.metadata.type} entities from Compendium ${pack.collection}`);
  }
};

// src/module/migrator/versions/Version0_8_0.ts
var Version0_8_0 = class _Version0_8_0 extends VersionMigration {
  static {
    __name(this, "Version0_8_0");
  }
  get SourceVersion() {
    return "0.7.6";
  }
  get TargetVersion() {
    return _Version0_8_0.TargetVersion;
  }
  static get TargetVersion() {
    return "0.8.0";
  }
  async ShouldMigrateItemData(item) {
    return this._ShouldMigrateItemData(item);
  }
  _ShouldMigrateItemData(item) {
    return ["weapon", "spell"].includes(item.type);
  }
  async ShouldMigrateSceneData(scene) {
    return scene.tokens.size > 0;
  }
  async ShouldMigrateActorData(actor) {
    return actor.items.contents.filter((item) => this._ShouldMigrateItemData(item)).length > 0;
  }
  async MigrateItemData(item) {
    const updateData = {};
    UpdateActionFlow.injectActionTestsIntoChangeData(item.type, item.toObject(), item.toObject());
    return updateData;
  }
  async MigrateActorData(actor) {
    let updateData = {
      items: []
    };
    updateData = await this.IterateActorItems(actor, updateData);
    if (updateData.data && foundry.utils.isEmpty(updateData.data)) delete updateData.data;
    if (updateData.items?.length === 0) delete updateData.items;
    return updateData;
  }
};

// src/module/migrator/versions/Version0_18_0.ts
var Version0_18_0 = class _Version0_18_0 extends VersionMigration {
  constructor() {
    super(...arguments);
    // By default item effects will be deleted. should users want to keep them, they can
    // only have them disabled and manually review / remove each.
    this.onlyDisableEffects = false;
  }
  static {
    __name(this, "Version0_18_0");
  }
  // TODO: is this the last version with a migration?
  get SourceVersion() {
    return "0.17.0";
  }
  get TargetVersion() {
    return _Version0_18_0.TargetVersion;
  }
  static get TargetVersion() {
    return "0.18.1";
  }
  /**
   * Version 12 is introducing a breaking change with deleting effects.
   *
   * Inform users about this and provide a less destructive option.
   */
  async AskForUserConsentAndConfiguration() {
    const dialog = new ConfigurationDialog({ onlyDisableEffects: this.onlyDisableEffects });
    await dialog.select();
    if (dialog.canceled) return false;
    this.onlyDisableEffects = dialog.data.templateData.onlyDisableEffects;
    return true;
  }
  async ShouldMigrateActorData(actor) {
    return !!actor.effects.find((effect) => !!effect.origin);
  }
  /**
   * There is two ways of migrating...
   *
   * 1. Delete effects with origin. Maybe check before if a similar effect exists on the origin.
   * 2. Disable effects with origin. let users delete.
   *
   * @param data
   */
  async MigrateActorData(actor) {
    if (!this.onlyDisableEffects) {
      await _Version0_18_0.DeleteLocalItemOwnedEffects(actor);
      return {};
    }
    return _Version0_18_0.DisableLocalItemOwnedEffects(actor);
  }
  async ShouldMigrateSceneData(scene) {
    return true;
  }
  /**
   * Check if an effect originates from an owned item.
   *
   * NOTE: Since foundry copies the original items uuid as origin, this original origin
   * will be preserved for copies of that actor via tokens or packs. For these actors the
   * origin points to the original actor owned item, not the copied actors local item.
   *
   * NOTE: As the system only ever used FoundryVTT core functionality in regards of how
   * effects where applied, we delete ALL item origin effects.
   *
   * @param actor
   */
  static async DeleteLocalItemOwnedEffects(actor) {
    const itemOriginEffects = migrateEffects(actor);
    if (itemOriginEffects.length === 0) return;
    console.log(`Actor (${actor.uuid}). Delete these effects:`, itemOriginEffects);
    const toDelete = itemOriginEffects.map((effect) => effect.id);
    await actor.deleteEmbeddedDocuments("ActiveEffect", toDelete);
  }
  /**
   * Check if an effect originates from an owned item.
   *
   * For more documentation check DeleteLocalItemOwnedEffects.
   *
   * This method will only disable the effects instead of deleting them outright.
   * @param actor
   * @returns updateData{effects}
   */
  static async DisableLocalItemOwnedEffects(actor) {
    const itemOriginEffects = migrateEffects(actor);
    if (itemOriginEffects.length === 0) return {};
    console.log(`Actor (${actor.uuid}). Disable these effects:`, itemOriginEffects);
    const updateData = { effects: itemOriginEffects.map((effect) => {
      return { _id: effect.id, disabled: true, name: `DISABLED: ${effect.name?.replace("DISABLED: ", "")}` };
    }) };
    return updateData;
  }
};
var ConfigurationDialog = class extends FormDialog {
  static {
    __name(this, "ConfigurationDialog");
  }
  constructor(data = {}) {
    data.templateData = { onlyDisableEffects: data.onlyDisableEffects };
    data.templatePath = `systems/shadowrun6-elysium/dist/templates/apps/migrator/Version0.18.0.hbs`;
    data.title = Version0_18_0.TargetVersion;
    super(data, { applyFormChangesOnSubmit: true });
  }
  get buttons() {
    return {
      migrate: {
        label: game.i18n.localize("SR6.MIGRATION.BeginMigration"),
        icon: '<i class="fas fa-check"></i>'
      },
      cancel: {
        label: game.i18n.localize("SR6.Dialogs.Common.Cancel")
      }
    };
  }
};
var migrateEffects = /* @__PURE__ */ __name((actor) => {
  return actor.effects.filter((effect) => !!effect.origin && effect.origin.includes(".Item."));
}, "migrateEffects");

// src/module/migrator/versions/Version0_16_0.ts
var Version0_16_0 = class _Version0_16_0 extends VersionMigration {
  static {
    __name(this, "Version0_16_0");
  }
  get SourceVersion() {
    return "0.15.0";
  }
  get TargetVersion() {
    return _Version0_16_0.TargetVersion;
  }
  static get TargetVersion() {
    return "0.16.0";
  }
  async ShouldMigrateItemData(item) {
    return false;
  }
  async ShouldMigrateSceneData(scene) {
    return false;
  }
  async ShouldMigrateActorData(actor) {
    return true;
  }
  async MigrateActorData(actor) {
    const updateData = { data: {} };
    if (actor.type !== "character" && actor.type !== "critter" && actor.type !== "vehicle") {
      updateData.data["visibilityChecks.meat.hasHeat"] = false;
    }
    if (actor.system.magic && actor.system.magic.hasOwnProperty("initiation") && isNaN(actor.system.magic.initiation)) {
      updateData.data["magic.initiation"] = 0;
    }
    return updateData;
  }
};

// src/module/migrator/Migrator.ts
var Migrator = class _Migrator {
  static {
    __name(this, "Migrator");
  }
  static {
    // Map of all version migrations to their target version numbers.
    this.s_Versions = [
      { versionNumber: Version0_8_0.TargetVersion, migration: new Version0_8_0() },
      { versionNumber: Version0_18_0.TargetVersion, migration: new Version0_18_0() },
      { versionNumber: Version0_16_0.TargetVersion, migration: new Version0_16_0() }
    ];
  }
  /**
   * Check if the current world is empty of any migrate documents.
   *
   */
  static get isEmptyWorld() {
    return game.actors?.contents.length === 0 && game.items?.contents.length === 0 && game.scenes?.contents.length === 0 && _Migrator.onlySystemPacks;
  }
  static get onlySystemPacks() {
    return game.packs.contents.filter((pack) => pack.metadata.packageType !== "system" && pack.metadata.packageName !== "shadowrun6-elysium").length === 0;
  }
  static async InitWorldForMigration() {
    console.log("Shadowrun 6e | Initializing an empty world for future migrations");
    await game.settings.set(VersionMigration.MODULE_NAME, VersionMigration.KEY_DATA_VERSION, game.system.version);
  }
  static async BeginMigration() {
    let currentVersion = game.settings.get(VersionMigration.MODULE_NAME, VersionMigration.KEY_DATA_VERSION);
    if (currentVersion === void 0 || currentVersion === null) {
      currentVersion = VersionMigration.NO_VERSION;
    }
    const migrations = _Migrator.s_Versions.filter(({ versionNumber }) => {
      return this.compareVersion(versionNumber, currentVersion) === 1;
    });
    if (migrations.length === 0) {
      return;
    }
    const localizedWarningTitle = game.i18n.localize("SR6.MIGRATION.WarningTitle");
    const localizedWarningHeader = game.i18n.localize("SR6.MIGRATION.WarningHeader");
    const localizedWarningRequired = game.i18n.localize("SR6.MIGRATION.WarningRequired");
    const localizedWarningDescription = game.i18n.localize("SR6.MIGRATION.WarningDescription");
    const localizedWarningBackup = game.i18n.localize("SR6.MIGRATION.WarningBackup");
    const localizedWarningBegin = game.i18n.localize("SR6.MIGRATION.BeginMigration");
    const d2 = new Dialog({
      title: localizedWarningTitle,
      content: `<h2 style="color: red; text-align: center">${localizedWarningHeader}</h2><p style="text-align: center"><i>${localizedWarningRequired}</i></p><p>${localizedWarningDescription}</p><h3 style="color: red">${localizedWarningBackup}</h3>`,
      buttons: {
        ok: {
          label: localizedWarningBegin,
          callback: /* @__PURE__ */ __name(() => this.migrate(migrations), "callback")
        }
      },
      default: "ok"
    });
    d2.render(true);
  }
  static async migrate(migrations) {
    migrations.sort((a2, b2) => {
      return this.compareVersion(a2.versionNumber, b2.versionNumber);
    });
    for (const { migration } of migrations) {
      const consent = await migration.AskForUserConsentAndConfiguration();
      if (!consent) return;
    }
    await this.migrateWorld(game, migrations);
    await this.migrateCompendium(game, migrations);
    const localizedWarningTitle = game.i18n.localize("SR6.MIGRATION.SuccessTitle");
    const localizedWarningHeader = game.i18n.localize("SR6.MIGRATION.SuccessHeader");
    const localizedSuccessDescription = game.i18n.localize("SR6.MIGRATION.SuccessDescription");
    const localizedSuccessPacksInfo = game.i18n.localize("SR6.MIGRATION.SuccessPacksInfo");
    const localizedSuccessConfirm = game.i18n.localize("SR6.MIGRATION.SuccessConfirm");
    const packsDialog = new Dialog({
      title: localizedWarningTitle,
      content: `<h2 style="text-align: center; color: green">${localizedWarningHeader}</h2><p>${localizedSuccessDescription}</p><p style="text-align: center"><i>${localizedSuccessPacksInfo}</i></p>`,
      buttons: {
        ok: {
          icon: '<i class="fas fa-check"></i>',
          label: localizedSuccessConfirm
        }
      },
      default: "ok"
    });
    packsDialog.render(true);
  }
  /**
   * Migrate all world objects
   * @param game
   * @param migrations
   */
  static async migrateWorld(game2, migrations) {
    for (const { migration } of migrations) {
      await migration.Migrate(game2);
    }
  }
  /**
   * Iterate over all world compendium packs
   * @param game Game that will be migrated
   * @param migrations Instances of the version migration
   */
  static async migrateCompendium(game2, migrations) {
    const packs = game2.packs?.filter((pack) => pack.metadata.packageType === "world" && ["Actor", "Item", "Scene"].includes(pack.metadata.type));
    if (!packs) return;
    for (const pack of packs) {
      for (const { migration } of migrations) {
        await migration.MigrateCompendiumPack(pack);
      }
    }
  }
  // found at: https://helloacm.com/the-javascript-function-to-compare-version-number-strings/
  // updated for typescript
  /**
   * compare two version numbers, returns 1 if v1 > v2, -1 if v1 < v2, 0 if equal
   * @param v1
   * @param v2
   */
  static compareVersion(v1, v2) {
    const s1 = v1.split(".").map((s3) => parseInt(s3, 10));
    const s2 = v2.split(".").map((s3) => parseInt(s3, 10));
    const k2 = Math.min(v1.length, v2.length);
    for (let i2 = 0; i2 < k2; ++i2) {
      if (s1[i2] > s2[i2]) return 1;
      if (s1[i2] < s2[i2]) return -1;
    }
    return v1.length === v2.length ? 0 : v1.length < v2.length ? -1 : 1;
  }
};

// src/module/settings.ts
var registerSystemSettings = /* @__PURE__ */ __name(() => {
  game.settings.register(SYSTEM_NAME, FLAGS.GlobalDataStorage, {
    name: "SETTINGS.GlobalDataStorageName",
    hint: "SETTINGS.GlobalDataStorageDescription",
    scope: "world",
    config: false,
    type: Object,
    default: {}
  });
  game.settings.register(SYSTEM_NAME, FLAGS.DiagonalMovement, {
    name: "SETTINGS.DiagonalMovementName",
    hint: "SETTINGS.DiagonalMovementDescription",
    scope: "world",
    config: true,
    type: String,
    default: "EUCL",
    // @ts-expect-error TODO: foundry-vtt-types v10
    choices: {
      "1-1-1": "SETTINGS.IgnoreDiagonal",
      "1-2-1": "SETTINGS.EstimateDiagonal",
      "EUCL": "SETTINGS.Euclidean"
    },
    onChange: /* @__PURE__ */ __name((rule) => {
      canvas.grid.diagonalRule = rule;
    }, "onChange")
  });
  game.settings.register(SYSTEM_NAME, "applyLimits", {
    name: "SETTINGS.ApplyLimitsName",
    hint: "SETTINGS.ApplyLimitsDescription",
    scope: "world",
    config: true,
    type: Boolean,
    default: true
  });
  game.settings.register(SYSTEM_NAME, VersionMigration.KEY_DATA_VERSION, {
    name: "System Data Version.",
    scope: "world",
    config: false,
    type: String,
    default: "0"
  });
  game.settings.register(SYSTEM_NAME, FLAGS.ShowGlitchAnimation, {
    name: "SETTINGS.ShowGlitchAnimationName",
    hint: "SETTINGS.ShowGlitchAnimationDescription",
    scope: "client",
    config: true,
    type: Boolean,
    default: true
  });
  game.settings.register(SYSTEM_NAME, FLAGS.ShowTokenNameForChatOutput, {
    name: "SETTINGS.ShowTokenNameForChatOutputName",
    hint: "SETTINGS.ShowTokenNameForChatOutputDescription",
    scope: "world",
    config: true,
    type: Boolean,
    default: true
  });
  game.settings.register(SYSTEM_NAME, FLAGS.OnlyAllowRollOnDefaultableSkills, {
    name: "SETTINGS.OnlyAllowRollOnDefaultableSkills",
    hint: "SETTINGS.OnlyAllowRollOnDefaultableSkillsDescription",
    scope: "world",
    config: true,
    type: Boolean,
    default: true
  });
  game.settings.register(SYSTEM_NAME, FLAGS.ShowSkillsWithDetails, {
    name: "SETTINGS.ShowSkillsWithDetails",
    hint: "SETTINGS.ShowSkillsWithDetailsDescription",
    scope: "client",
    config: true,
    type: Boolean,
    default: true
  });
  game.settings.register(SYSTEM_NAME, FLAGS.OnlyAutoRollNPCInCombat, {
    name: "SETTINGS.OnlyAutoRollNPCInCombat",
    hint: "SETTINGS.OnlyAutoRollNPCInCombatDescription",
    scope: "world",
    config: true,
    type: Boolean,
    default: true
  });
  game.settings.register(SYSTEM_NAME, FLAGS.TokenHealthBars, {
    name: "SETTINGS.TokenHealthBars",
    hint: "SETTINGS.TokenHealthBarsDescription",
    scope: "world",
    config: true,
    type: Boolean,
    default: false
  });
  game.settings.register(SYSTEM_NAME, FLAGS.HideGMOnlyChatContent, {
    name: "SETTINGS.HideGMOnlyChatContent",
    hint: "SETTINGS.HideGMOnlyChatContentDescription",
    scope: "world",
    config: true,
    type: Boolean,
    default: false
  });
  game.settings.register(SYSTEM_NAME, FLAGS.MustHaveRessourcesOnTest, {
    name: "SETTINGS.MustHaveRessourcesOnTest",
    hint: "SETTINGS.MustHaveRessourcesOnTestDescription",
    scope: "world",
    config: true,
    type: Boolean,
    default: false
  });
  game.settings.register(SYSTEM_NAME, FLAGS.UseDamageCondition, {
    name: "SETTINGS.UseDamageConditionName",
    hint: "SETTINGS.UseDamageConditionDescription",
    scope: "world",
    config: true,
    type: Boolean,
    default: true
  });
  game.settings.register(SYSTEM_NAME, FLAGS.AutomateMultiDefenseModifier, {
    name: "SETTINGS.AutomateMultiDefenseModifier",
    hint: "SETTINGS.AutomateMultiDefenseModifierDescription",
    scope: "world",
    config: true,
    type: Boolean,
    default: true
  });
  game.settings.register(SYSTEM_NAME, FLAGS.AutomateProgressiveRecoil, {
    name: "SETTINGS.AutomateProgressiveRecoil",
    hint: "SETTINGS.AutomateProgressiveRecoilDescription",
    scope: "world",
    config: true,
    type: Boolean,
    default: true
  });
  game.settings.register(SYSTEM_NAME, FLAGS.ManualRollOnSuccessTest, {
    name: "SETTINGS.ManualRollOnSuccessTest",
    hint: "SETTINGS.ManualRollOnSuccessTestDescription",
    scope: "client",
    config: true,
    type: Boolean,
    default: false
  });
  game.settings.register(SYSTEM_NAME, FLAGS.DefaultOpposedTestActorSelection, {
    name: "SETTINGS.DefaultOpposedTestActorSelection",
    hint: "SETTINGS.DefaultOpposedTestActorSelectionDescription",
    scope: "client",
    config: true,
    type: Boolean,
    default: false
  });
  game.settings.register(SYSTEM_NAME, FLAGS.MarkImports, {
    name: "SETTINGS.MarkImportsName",
    hint: "SETTINGS.MarkImportsDescription",
    scope: "client",
    config: true,
    type: String,
    default: "BOTH",
    // @ts-expect-error TODO: foundry-vtt-types v10
    choices: {
      "BOTH": "SETTINGS.FreshColorAndIcon",
      "COLOR": "SETTINGS.FreshColor",
      "ICON": "SETTINGS.FreshIcon",
      "NONE": "SETTINGS.NoMarking"
    }
  });
  game.settings.register(SYSTEM_NAME, FLAGS.ImportIconFolder, {
    name: "SETTINGS.ImportIconFolderName",
    hint: "SETTINGS.ImportIconFolderDescription",
    scope: "world",
    config: true,
    type: String,
    default: "systems/shadowrun6-elysium/dist/icons/importer/"
  });
  game.settings.register(SYSTEM_NAME, FLAGS.UseImportIconOverrides, {
    name: "SETTINGS.UseImportIconOverridesName",
    hint: "SETTINGS.UseImportIconOverridesDescription",
    scope: "world",
    config: true,
    type: Boolean,
    default: true
  });
}, "registerSystemSettings");

// src/module/item/SR6ItemSheet.ts
var SR6ItemSheet = class extends ItemSheet {
  constructor() {
    super(...arguments);
    this._shownDesc = [];
  }
  static {
    __name(this, "SR6ItemSheet");
  }
  /**
   * Extend and override the default options used by the Simple Item Sheet
   * @returns {Object}
   */
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      classes: ["sr6", "sheet", "item"],
      width: 735,
      height: 450,
      tabs: [{ navSelector: ".tabs", contentSelector: ".sheetbody" }]
    });
  }
  get template() {
    return `systems/shadowrun6-elysium/dist/templates/item/${this.item.type}.html`;
  }
  /* -------------------------------------------- */
  /**
   * Prepare data for rendering the Item sheet
   * The prepared data object contains both the actor data as well as additional sheet options
   */
  async getData(options) {
    const data = super.getData(options);
    data.type = data.data.type;
    data.system = data.item.system;
    data.data = data.item.system;
    const itemData = this.item.system;
    const linkedActor = await this.item.getLinkedActor();
    if (itemData.action) {
      try {
        const action = itemData.action;
        if (itemData.action.mod === 0) delete action.mod;
        if (action.limit === 0) delete action.limit;
        if (action.damage) {
          if (action.damage.mod === 0) delete action.damage.mod;
          if (action.damage.ap.mod === 0) delete action.damage.ap.mod;
        }
        if (action.limit) {
          if (action.limit.mod === 0) delete action.limit.mod;
        }
      } catch (e2) {
        console.error(e2);
      }
    }
    if (itemData.technology) {
      try {
        const technology = itemData.technology;
        if (technology.rating === 0) delete technology.rating;
        if (technology.quantity === 0) delete technology.quantity;
        if (technology.cost === 0) delete technology.cost;
      } catch (e2) {
        console.log(e2);
      }
    }
    data["config"] = SR6;
    const itemTypes = this.item.items.reduce(
      (sheetItemData, nestedItem) => {
        const itemData2 = nestedItem.toObject();
        if (nestedItem.type === "ammo") sheetItemData[0].push(itemData2);
        if (nestedItem.type === "modification" && "type" in nestedItem.system && nestedItem.system.type === "weapon") sheetItemData[1].push(itemData2);
        if (nestedItem.type === "modification" && "type" in nestedItem.system && nestedItem.system.type === "armor") sheetItemData[2].push(itemData2);
        if (nestedItem.type === "modification" && "type" in nestedItem.system && nestedItem.system.type === "vehicle") sheetItemData[3].push(itemData2);
        if (nestedItem.type === "modification" && "type" in nestedItem.system && nestedItem.system.type === "drone") sheetItemData[4].push(itemData2);
        return sheetItemData;
      },
      [[], [], [], [], []]
    );
    for (const itemType of itemTypes) {
      for (const item of itemType) {
        item.descriptionHTML = await TextEditor.enrichHTML(item.system.description.value);
      }
    }
    const [ammunition, weaponMods, armorMods, vehicleMods, droneMods] = itemTypes;
    data["ammunition"] = ammunition;
    data["weaponMods"] = weaponMods;
    data["armorMods"] = armorMods;
    data["vehicleMods"] = vehicleMods;
    data["droneMods"] = droneMods;
    data["activeSkills"] = this._getSortedActiveSkillsForSelect();
    data["attributes"] = this._getSortedAttributesForSelect();
    data["limits"] = this._getSortedLimitsForSelect();
    data["effects"] = prepareSortedEffects(this.item.effects.contents);
    data["itemEffects"] = prepareSortedItemEffects(this.object);
    if (this.item.isHost) {
      data["markedDocuments"] = this.item.getAllMarkedDocuments();
    }
    if (this.item.canBeNetworkController) {
      data["networkDevices"] = await this.item.networkDevices();
    }
    if (this.item.canBeNetworkDevice) {
      data["networkController"] = await this.item.networkController();
    }
    if (this.item.isContact) {
      data["linkedActor"] = await this.item.getLinkedActor();
    }
    data.tests = game["shadowrun6-elysium"].tests;
    data.opposedTests = game["shadowrun6-elysium"].opposedTests;
    data.activeTests = game["shadowrun6-elysium"].activeTests;
    data.resistTests = game["shadowrun6-elysium"].resistTests;
    data.descriptionHTML = await this.enrichEditorFieldToHTML(this.item.system.description.value);
    data.sourceIsURL = this.item.sourceIsUrl;
    data.sourceIsPDF = this.item.sourceIsPDF;
    data.sourceIsUuid = this.item.sourceIsUuid;
    data.isUsingRangeCategory = this.item.isUsingRangeCategory;
    data.rollModes = CONFIG.Dice.rollModes;
    return {
      ...data,
      linkedActor
    };
  }
  /**
   * Help enriching editor field values to HTML used to display editor values as read-only HTML in sheets.
   *
   * @param editorValue A editor field value like Item.system.description.value
   * @param options TextEditor, enrichHTML.options passed through
   * @returns Enriched HTML result
   */
  async enrichEditorFieldToHTML(editorValue, options = { async: false }) {
    return await TextEditor.enrichHTML(editorValue, options);
  }
  /**
   * Action limits currently contain limits for all action types. Be it matrix, magic or physical.
   */
  _getSortedLimitsForSelect() {
    return Helpers.sortConfigValuesByTranslation(SR6.limits);
  }
  /**
   * Sorted (by translation) actor attributes.
   */
  _getSortedAttributesForSelect() {
    return Helpers.sortConfigValuesByTranslation(SR6.attributes);
  }
  /**
   * Sorted (by translation) active skills either from the owning actor or general configuration.
   */
  _getSortedActiveSkillsForSelect() {
    return ActionFlow.sortedActiveSkills(this.item.actorOwner, this.document.system.action?.skill);
  }
  _getNetworkDevices() {
    return [];
  }
  /* -------------------------------------------- */
  /**
   * Activate event listeners using the prepared sheet HTML
   * @param html -  The prepared HTML object ready to be rendered into the DOM
   */
  activateListeners(html) {
    super.activateListeners(html);
    Helpers.setupCustomCheckbox(this, html);
    this.form.ondragover = (event) => {
      this._onDragOver(event);
    };
    this.form.ondrop = (event) => this._onDrop(event);
    html.find(".effect-control").click((event) => onManageActiveEffect(event, this.item));
    html.find(".edit-item").click(this._onEditItem.bind(this));
    html.find(".open-source").on("click", this._onOpenSource.bind(this));
    html.find(".has-desc").click(this._onListItemToggleDescriptionVisibility.bind(this));
    html.find(".hidden").hide();
    html.find(".entity-remove").on("click", this._onEntityRemove.bind(this));
    html.find(".actor-remove").click(this.handleLinkedActorRemove.bind(this));
    html.find(".add-new-ammo").click(this._onAddNewAmmo.bind(this));
    html.find(".ammo-equip").click(this._onAmmoEquip.bind(this));
    html.find('select[name="change-ammo"]').on("change", async (event) => this._onAmmoEquip(event.target.value));
    html.find(".ammo-delete").click(this._onAmmoRemove.bind(this));
    html.find(".ammo-reload").on("click", async (event) => this._onAmmoReload(event, false));
    html.find('select[name="change-clip-type"]').on("change", async (event) => this._onClipEquip(event.target.value));
    html.find(".add-new-mod").click(this._onAddWeaponMod.bind(this));
    html.find(".mod-equip").click(this._onWeaponModEquip.bind(this));
    html.find(".mod-delete").click(this._onWeaponModRemove.bind(this));
    html.find(".add-new-license").click(this._onAddLicense.bind(this));
    html.find(".license-delete").on("click", this._onRemoveLicense.bind(this));
    html.find(".network-clear").on("click", this._onRemoveAllNetworkDevices.bind(this));
    html.find(".network-device-remove").on("click", this._onRemoveNetworkDevice.bind(this));
    html.find(".marks-qty").on("change", this._onMarksQuantityChange.bind(this));
    html.find(".marks-add-one").on("click", async (event) => this._onMarksQuantityChangeBy(event, 1));
    html.find(".marks-remove-one").on("click", async (event) => this._onMarksQuantityChangeBy(event, -1));
    html.find(".marks-delete").on("click", this._onMarksDelete.bind(this));
    html.find(".marks-clear-all").on("click", this._onMarksClearAll.bind(this));
    html.find(".origin-link").on("click", this._onOpenOriginLink.bind(this));
    html.find(".controller-remove").on("click", this._onControllerRemove.bind(this));
    html.find(".matrix-att-selector").on("change", this._onMatrixAttributeSelected.bind(this));
    html.find(".toggle-fresh-import-off").on("click", async (event) => this._toggleFreshImportFlag(event, false));
    html.find(".select-ranged-range-category").on("change", this._onSelectRangedRangeCategory.bind(this));
    html.find(".select-thrown-range-category").on("change", this._onSelectThrownRangeCategory.bind(this));
    html.find('input[name="system.technology.equipped"').on("change", this._onToggleEquippedDisableOtherDevices.bind(this));
    html.find(".list-item").each(this._addDragSupportToListItemTemplatePartial.bind(this));
    this._activateTagifyListeners(html);
  }
  /**
   * User requested removal of the linked actor.
   */
  async handleLinkedActorRemove(event) {
    await this.item.update({ "system.linkedActor": "" });
  }
  /**
   * Updating the contacts linked actor.
   *
   * @param actor The prepared actor
   */
  async updateLinkedActor(actor) {
    await this.item.update({ "system.linkedActor": actor.uuid });
  }
  _addDragSupportToListItemTemplatePartial(i2, item) {
    if (item.dataset && item.dataset.itemId) {
      item.setAttribute("draggable", true);
      item.addEventListener("dragstart", this._onDragStart.bind(this), false);
    }
  }
  async _onDragStart(event) {
    const element = event.currentTarget;
    if (element) {
      const dragData = {
        actor: this.item.actor,
        actorId: this.item.actor?.id,
        itemId: this.item.id,
        type: "",
        data: {}
      };
      switch (element.dataset.itemType) {
        // if we are dragging an active effect, get the effect from our list of effects and set it in the data transfer
        case "ActiveEffect": {
          const effectId = element.dataset.itemId;
          const effect = this.item.effects.get(effectId);
          if (effect) {
            dragData.type = "ActiveEffect";
            dragData.data = effect;
            event.dataTransfer.setData("text/plain", JSON.stringify(dragData));
            return;
          }
        }
      }
    }
    return super._onDragStart(event);
  }
  async _onDrop(event) {
    if (!game.items || !game.actors || !game.scenes) return;
    event.preventDefault();
    event.stopPropagation();
    const data = parseDropData(event);
    if (!data) return;
    const targetElement = event.toElement || event.target;
    if (targetElement?.name === "system.description.source") {
      this.item.setSource(data.uuid);
      return;
    }
    if (data.type === "ActiveEffect") {
      if (data.itemId === this.item.id) {
        return;
      }
      const effect = data.data;
      delete effect._id;
      await this.item.createEmbeddedDocuments("ActiveEffect", [effect]);
      return;
    }
    if (this.item.isWeapon && data.type === "Item") {
      let item;
      if (data.data) {
        if (this.item.isOwned && data.actorId === this.item.actor?.id && data.data._id === this.item.id) {
          return console.warn("Shadowrun 6e | Cant drop items onto themselves");
        }
        item = data;
      } else if (data.pack) {
        item = await Helpers.getEntityFromCollection(data.pack, data.id);
      } else {
        item = await fromUuid(data.uuid);
      }
      if (!item) return console.error("Shadowrun 6e | Item could not be created from DropData", data);
      return await this.item.createNestedItem(item._source);
    }
    if (this.item.isHost && data.type === "Actor") {
      const actor = await fromUuid(data.uuid);
      if (!actor || !actor.id) return console.error("Shadowrun 6e | Actor could not be retrieved from DropData", data);
      return await this.item.addIC(actor.id, data.pack);
    }
    if (this.item.canBeNetworkController && data.type === "Item") {
      const item = await fromUuid(data.uuid);
      if (!item || !item.id) return console.error("Shadowrun 6e | Item could not be retrieved from DropData", data);
      return await this.item.addNetworkDevice(item);
    }
    if (this.item.canBeNetworkController && data.type === "Actor") {
      const actor = await fromUuid(data.uuid);
      if (!actor || !actor.id) return console.error("Shadowrun 6e | Actor could not be retrieved from DropData", data);
      if (!actor.isVehicle()) {
        return ui.notifications?.error(game.i18n.localize("SR6.Errors.CanOnlyAddTechnologyItemsToANetwork"));
      }
      return await this.item.addNetworkDevice(actor);
    }
    if (this.item.isContact && data.type === "Actor") {
      const actor = await fromUuid(data.uuid);
      if (!actor || !actor.id) return console.error("Shadowrun 6e | Actor could not be retrieved from DropData", data);
      return this.updateLinkedActor(actor);
    }
  }
  _eventId(event) {
    event.preventDefault();
    return event.currentTarget.closest(".list-item").dataset.itemId;
  }
  async _onOpenSource(event) {
    event.preventDefault();
    await this.item.openSource();
  }
  async _onSelectRangedRangeCategory(event) {
    await this._onSelectRangeCategory("system.range.ranges", event);
  }
  async _onSelectThrownRangeCategory(event) {
    await this._onSelectRangeCategory("system.thrown.ranges", event);
  }
  async _onSelectRangeCategory(key, event) {
    event.stopPropagation();
    const selectedRangeCategory = event.currentTarget.value;
    if (selectedRangeCategory === "manual") {
      await this.item.update({
        [key]: {
          category: selectedRangeCategory
        }
      });
    } else {
      const ranges = SR6.weaponRangeCategories[selectedRangeCategory].ranges;
      await this.item.update({
        [key]: {
          ...ranges,
          attribute: ranges.attribute || null,
          //Clear attribute if necessary
          category: selectedRangeCategory
        }
      });
    }
  }
  //Swap slots (att1, att2, etc.) for ASDF matrix attributes
  async _onMatrixAttributeSelected(event) {
    if (!this.item.system.atts) return;
    const selectedAtt = event.currentTarget.value;
    const changedSlot = event.currentTarget.dataset.att;
    const oldValue = this.item.system.atts[changedSlot].att;
    let data = {};
    Object.entries(this.item.system.atts).forEach(([slot, { att }]) => {
      if (slot === changedSlot) {
        data[`system.atts.${slot}.att`] = selectedAtt;
      } else if (att === selectedAtt) {
        data[`system.atts.${slot}.att`] = oldValue;
      }
    });
    await this.item.update(data);
  }
  async _onEditItem(event) {
    const item = this.item.getOwnedItem(this._eventId(event));
    if (item) {
      item.sheet?.render(true);
    }
  }
  async _onEntityRemove(event) {
    event.preventDefault();
    const entityRemove = $(event.currentTarget).closest(".entity-remove");
    const list = entityRemove.data("list");
    const position = entityRemove.data("position");
    if (!list) return;
    switch (list) {
      // Handle Host item lists...
      case "ic":
        await this.item.removeIC(position);
        break;
    }
  }
  async _onAddLicense(event) {
    event.preventDefault();
    await this.item.addNewLicense();
  }
  async _onRemoveLicense(event) {
    event.preventDefault();
    const index = event.currentTarget.dataset.index;
    if (index >= 0) await this.item.removeLicense(index);
  }
  async _onWeaponModRemove(event) {
    await this._onOwnedItemRemove(event);
  }
  async _onWeaponModEquip(event) {
    await this.item.equipWeaponMod(this._eventId(event));
  }
  async _onAddWeaponMod(event) {
    event.preventDefault();
    const type = "modification";
    const itemData = {
      name: `${game.i18n.localize("SR6.New")} ${Helpers.label(game.i18n.localize(SR6.itemTypes[type]))}`,
      type,
      system: { type: "weapon" }
    };
    const item = new SR6Item(itemData, { parent: this.item });
    await this.item.createNestedItem(item._source);
  }
  async _onAmmoReload(event, partialReload) {
    event.preventDefault();
    await this.item.reloadAmmo(partialReload);
  }
  async _onAmmoRemove(event) {
    await this._onOwnedItemRemove(event);
  }
  async _onAmmoEquip(input) {
    let id;
    if (input.currentTarget) {
      id = this._eventId(input);
    } else {
      id = input;
    }
    await this.item.equipAmmo(id);
  }
  async _onAddNewAmmo(event) {
    event.preventDefault();
    const type = "ammo";
    const itemData = {
      name: `${game.i18n.localize("SR6.New")} ${Helpers.label(game.i18n.localize(SR6.itemTypes[type]))}`,
      type
    };
    const item = new SR6Item(itemData, { parent: this.item });
    await this.item.createNestedItem(item._source);
  }
  async _onClipEquip(clipType) {
    if (!clipType || !Object.keys(SR6.weaponCliptypes).includes(clipType)) return;
    const agilityValue = this.item.actor ? this.item.actor.getAttribute("agility").value : 0;
    await this.item.update({
      "system.ammo.clip_type": clipType,
      "system.ammo.partial_reload_value": RangedWeaponRules.partialReload(clipType, agilityValue)
    }, { render: true });
  }
  async _onOwnedItemRemove(event) {
    event.preventDefault();
    const userConsented = await Helpers.confirmDeletion();
    if (!userConsented) return;
    await this.item.deleteOwnedItem(this._eventId(event));
  }
  async _onRemoveAllNetworkDevices(event) {
    event.preventDefault();
    const userConsented = await Helpers.confirmDeletion();
    if (!userConsented) return;
    await this.item.removeAllNetworkDevices();
  }
  async _onRemoveNetworkDevice(event) {
    event.preventDefault();
    const userConsented = await Helpers.confirmDeletion();
    if (!userConsented) return;
    const networkDeviceIndex = Helpers.parseInputToNumber(event.currentTarget.closest(".list-item").dataset.listItemIndex);
    await this.item.removeNetworkDevice(networkDeviceIndex);
  }
  /**
   * @private
   */
  _findActiveList() {
    return $(this.element).find(".tab.active .scroll-area");
  }
  /**
   * Add a tagify element for an action-modifier dom element.
   *
   * Usage: Call method after render with a singular item's html sub-dom-tree.
   *
   * Only action items will trigger the creation of a tagify element.
   *
   * @param html see DocumentSheet.activateListeners#html param for documentation.
   */
  _createActionModifierTagify(html) {
    const inputElement = html.find("input#action-modifier").get(0);
    if (!inputElement) {
      console.error("Shadowrun 6e | Action item sheet does not contain an action-modifier input element");
      return;
    }
    const whitelist = Object.keys(SR6.modifierTypes).map((modifier) => ({
      value: game.i18n.localize(SR6.modifierTypes[modifier]),
      id: modifier
    }));
    const maxItems = Object.keys(SR6.modifierTypes).length;
    const modifiers = this.item.system.action?.modifiers ?? [];
    const tags = modifiers.map((modifier) => ({
      value: game.i18n.localize(SR6.modifierTypes[modifier]),
      id: modifier
    }));
    const tagify = createTagify(inputElement, { whitelist, maxItems, tags });
    html.find("input#action-modifier").on("change", async (event) => {
      const modifiers2 = tagify.value.map((tag) => tag.id);
      await this.item.update({ "system.action.modifiers": modifiers2 }, { render: false });
    });
  }
  /**
   * Add a tagify element for an action-categories dom element.
   *
   * Usage: Call method after render with a singular item's html sub-dom-tree.
   *
   * Only action items will trigger the creation of a tagify element.
   * @param html
   */
  _createActionCategoriesTagify(html) {
    const inputElement = html.find("input#action-categories").get(0);
    if (!inputElement) {
      console.error("Shadowrun 6e | Action item sheet does not contain an action-categories input element");
      return;
    }
    const whitelist = Object.keys(SR6.actionCategories).map((category3) => ({
      value: game.i18n.localize(SR6.actionCategories[category3]),
      id: category3
    }));
    const maxItems = Object.keys(SR6.actionCategories).length;
    const categories = this.item.system.action?.categories ?? [];
    const tags = categories.map((category3) => ({
      value: game.i18n.localize(SR6.actionCategories[category3]) ?? category3,
      id: category3
    }));
    const tagify = createTagify(inputElement, { whitelist, maxItems, tags });
    html.find("input#action-categories").on("change", async (event) => {
      const categories2 = tagify.value.map((tag) => tag.id ?? tag.value);
      await this.item.update({ "system.action.categories": categories2 }, { render: false });
    });
  }
  /**
   * @private
   */
  async _render(force = false, options = {}) {
    this._saveScrollPositions();
    await super._render(force, options);
    this._restoreScrollPositions();
  }
  /**
   * @private
   */
  _restoreScrollPositions() {
    const activeList = this._findActiveList();
    if (activeList.length && this._scroll != null) {
      activeList.prop("scrollTop", this._scroll);
    }
  }
  /**
   * @private
   */
  _saveScrollPositions() {
    const activeList = this._findActiveList();
    if (activeList.length) {
      this._scroll = activeList.prop("scrollTop");
    }
  }
  async _onMarksQuantityChange(event) {
    event.stopPropagation();
    if (!this.item.isHost) return;
    const markId = event.currentTarget.dataset.markId;
    if (!markId) return;
    const markedIdDocuments = Helpers.getMarkIdDocuments(markId);
    if (!markedIdDocuments) return;
    const { scene, target, item } = markedIdDocuments;
    if (!scene || !target) return;
    const marks = parseInt(event.currentTarget.value);
    await this.item.setMarks(target, marks, { scene, item, overwrite: true });
  }
  async _onMarksQuantityChangeBy(event, by) {
    event.stopPropagation();
    if (!this.item.isHost) return;
    const markId = event.currentTarget.dataset.markId;
    if (!markId) return;
    const markedIdDocuments = Helpers.getMarkIdDocuments(markId);
    if (!markedIdDocuments) return;
    const { scene, target, item } = markedIdDocuments;
    if (!scene || !target) return;
    await this.item.setMarks(target, by, { scene, item });
  }
  async _onMarksDelete(event) {
    event.stopPropagation();
    if (!this.item.isHost) return;
    const markId = event.currentTarget.dataset.markId;
    if (!markId) return;
    const userConsented = await Helpers.confirmDeletion();
    if (!userConsented) return;
    await this.item.clearMark(markId);
  }
  async _onMarksClearAll(event) {
    event.stopPropagation();
    if (!this.item.isHost) return;
    const userConsented = await Helpers.confirmDeletion();
    if (!userConsented) return;
    await this.item.clearMarks();
  }
  async _onOpenOriginLink(event) {
    event.preventDefault();
    console.log("Shadowrun 6e | Opening PAN/WAN network controller");
    const originLink = event.currentTarget.dataset.originLink;
    const device = await fromUuid(originLink);
    if (!device) return;
    device.sheet.render(true);
  }
  async _onControllerRemove(event) {
    event.preventDefault();
    await this.item.disconnectFromNetwork();
  }
  /**
   * Activate listeners for tagify elements for item types that allow changing action
   * modifiers.
   *
   * @param html The JQuery HTML as given by the activateListeners method.
   */
  _activateTagifyListeners(html) {
    if (!["action", "metamagic", "bioware", "cyberware", "equipment", "quality", "ritual", "call_in_action", "sprite_power", "critter_power", "adept_power"].includes(this.document.type)) return;
    this._createActionModifierTagify(html);
    this._createActionCategoriesTagify(html);
  }
  /**
   * Show / hide the items description within a sheet item l ist.
   */
  async _onListItemToggleDescriptionVisibility(event) {
    event.preventDefault();
    const item = $(event.currentTarget).parents(".list-item");
    const iid = $(item).data().item;
    const field = item.find(".list-item-description");
    field.toggle();
    if (iid) {
      if (field.is(":visible")) this._shownDesc.push(iid);
      else this._shownDesc = this._shownDesc.filter((val) => val !== iid);
    }
  }
  /**
   * Toggle to isFreshImport property of importFlags for an item
   *
   * @param event
   */
  async _toggleFreshImportFlag(event, onOff) {
    console.debug("Toggling isFreshImport on item to ->", onOff, event);
    const item = this.item;
    if (item.system.importFlags) {
      await item.update({ "system.importFlags.isFreshImport": onOff });
    }
  }
  /**
   * Clicking on equipped status should trigger unequipping all other devices of the same type.
   * @param event Click event on the equipped checkbox.
   */
  async _onToggleEquippedDisableOtherDevices(event) {
    event.preventDefault();
    if (!(this.document.parent instanceof SR6Actor)) return;
    if (!this.document.isDevice) return;
    if (!this.document.isEquipped()) return;
    await this.document.parent.equipOnlyOneItemOfType(this.document);
  }
};

// src/module/token/SR6Token.ts
var SR6Token = class extends Token {
  static {
    __name(this, "SR6Token");
  }
  // @ts-expect-error Ignore getBarAttribute from Token
  _drawBar(number, bar, data) {
    const tokenHealthBars = game.settings.get(SYSTEM_NAME, FLAGS.TokenHealthBars);
    if (tokenHealthBars && data && data.attribute.startsWith("track")) {
      const track = data;
      track.value = track.max - track.value;
    }
    super._drawBar(number, bar, data);
  }
};

// src/module/combat/SR6Combat.ts
var SR6Combat = class _SR6Combat extends Combat {
  static {
    __name(this, "SR6Combat");
  }
  // Overwrite foundry-vtt-types v9 combatTrackerSettings type definitions.
  get settings() {
    return super.settings;
  }
  get initiativePass() {
    return this.getFlag(SYSTEM_NAME, FLAGS.CombatInitiativePass) || SR.combat.INITIAL_INI_PASS;
  }
  static async setInitiativePass(combat, pass) {
    await combat.unsetFlag(SYSTEM_NAME, FLAGS.CombatInitiativePass);
    await combat.setFlag(SYSTEM_NAME, FLAGS.CombatInitiativePass, pass);
  }
  /**
   * Use the given actors token to get the combatant.
   * NOTE: The token must be used, instead of just the actor, as unlinked tokens will all use the same actor id.
   */
  getActorCombatant(actor) {
    const token = actor.getToken();
    if (!token) return;
    return this.getCombatantByToken(token.id);
  }
  /**
   * Add ContextMenu options to CombatTracker Entries -- adds the basic Initiative Subtractions
   * @param html
   * @param options
   */
  static addCombatTrackerContextOptions(html, options) {
    options.push(
      {
        name: game.i18n.localize("SR6.COMBAT.ReduceInitByOne"),
        icon: '<i class="fas fa-caret-down"></i>',
        callback: /* @__PURE__ */ __name(async (li) => {
          const combatant = await game.combat?.combatants.get(li.data("combatant-id"));
          if (combatant) {
            const combat = game.combat;
            await combat.adjustInitiative(combatant, -1);
          }
        }, "callback")
      },
      {
        name: game.i18n.localize("SR6.COMBAT.ReduceInitByFive"),
        icon: '<i class="fas fa-angle-down"></i>',
        callback: /* @__PURE__ */ __name(async (li) => {
          const combatant = await game.combat?.combatants.get(li.data("combatant-id"));
          if (combatant) {
            const combat = game.combat;
            await combat.adjustInitiative(combatant, -5);
          }
        }, "callback")
      },
      {
        name: game.i18n.localize("SR6.COMBAT.ReduceInitByTen"),
        icon: '<i class="fas fa-angle-double-down"></i>',
        callback: /* @__PURE__ */ __name(async (li) => {
          const combatant = await game.combat?.combatants.get(li.data("combatant-id"));
          if (combatant) {
            const combat = game.combat;
            await combat.adjustInitiative(combatant, -10);
          }
        }, "callback")
      }
    );
    return options;
  }
  /**
   * Helper method to adjust an actors combatants initiative.
   *
   * @param actor The actor that should have their ini score adjusted.
   * @param adjustment The delta to adjust the ini score with.
   */
  async adjustActorInitiative(actor, adjustment) {
    const combatant = this.getActorCombatant(actor);
    if (!combatant) return;
    await this.adjustInitiative(combatant, adjustment);
  }
  /**
   * Adjust a combatants initiative score in combat.
   *
   * @param combatant Combatant to adjust
   * @param adjustment The adjustment that's to be added onto the current ini score.
   */
  async adjustInitiative(combatant, adjustment) {
    combatant = typeof combatant === "string" ? this.combatants.find((c2) => c2.id === combatant) : combatant;
    if (!combatant || typeof combatant === "string") {
      console.error("Could not find combatant with id ", combatant);
      return;
    }
    await combatant.update({
      initiative: Number(combatant.initiative) + adjustment
    });
  }
  /**
   * Handle the change of an initiative pass. This needs owner permissions on the combat document.
   * @param combatId
   */
  static async handleIniPass(combatId) {
    const combat = game.combats?.get(combatId);
    if (!combat) return;
    const initiativePass = combat.initiativePass + 1;
    const turn = 0;
    const combatants = [];
    for (const combatant of combat.combatants) {
      const initiative = CombatRules.reduceIniResultAfterPass(Number(combatant.initiative));
      combatants.push({
        _id: combatant.id,
        initiative
      });
    }
    await combat.update({
      turn,
      combatants,
      [`flags.${SYSTEM_NAME}.${FLAGS.CombatInitiativePass}`]: initiativePass
    });
    await combat.handleActionPhase();
  }
  /**
   * Handle the change of a initiative round. This needs owner permission on the combat document.
   * @param combatId
   */
  static async handleNextRound(combatId) {
    const combat = game.combats?.get(combatId);
    if (!combat) return;
    await combat.resetAll();
    await _SR6Combat.setInitiativePass(combat, SR.combat.INITIAL_INI_PASS);
    if (game.settings.get(SYSTEM_NAME, FLAGS.OnlyAutoRollNPCInCombat)) {
      await combat.rollNPC();
    } else {
      await combat.rollAll();
    }
    const turn = 0;
    await combat.update({ turn });
    await combat.handleActionPhase();
  }
  /**
   * New action phase might need changes on the actor that only the GM can reliable make.
   */
  async handleActionPhase() {
    if (!game.user?.isGM)
      await this._createNewActionPhaseSocketMessage();
    else
      await _SR6Combat.handleActionPhase(this.id);
  }
  /**
   * When combat enters a new combat phase, apply necessary changes.
   *
   * This action phase change can occur through phase/turn/round changes.
   *
   * @param combatId Combat with the current combatant entering it's next action phase.
   */
  static async handleActionPhase(combatId) {
    const combat = game.combats?.get(combatId);
    if (!combat) return;
    const combatant = combat.combatant;
    if (!combatant) return;
    await combatant.actor?.removeDefenseMultiModifier();
    const turnsSinceLastAttackSetting = combatant.getFlag(SYSTEM_NAME, FLAGS.TurnsSinceLastAttack);
    if (foundry.utils.getType(turnsSinceLastAttackSetting) !== "number") return await combatant.actor?.clearProgressiveRecoil();
    const turnsSinceLastAttack = Number(turnsSinceLastAttackSetting);
    if (turnsSinceLastAttack > 0) await combatant.actor?.clearProgressiveRecoil();
    else await combatant.setFlag(SYSTEM_NAME, FLAGS.TurnsSinceLastAttack, 1);
  }
  /**
   * Make sure Shadowrun initiative order is applied.
   */
  setupTurns() {
    const turns = super.setupTurns();
    return turns.sort(_SR6Combat.sortByRERIC);
  }
  /**
   * Sort combatants by shadowrun6-elysium attribute order of
   *  - initiative score
   *  - edge
   *  - reaction
   *  - intuition
   *  - coin toss
   *
   * @param left A combatant in order
   * @param right A combatant in order
   * @returns A Array.sort result determining sort order: -1, 1, 0
   */
  static sortByRERIC(left, right) {
    if (!left.actor) return 0;
    if (!right.actor) return 0;
    const leftInit = Number(left.initiative);
    const rightInit = Number(right.initiative);
    if (isNaN(leftInit)) return 1;
    if (isNaN(rightInit)) return -1;
    if (leftInit > rightInit) return -1;
    if (leftInit < rightInit) return 1;
    const genData = /* @__PURE__ */ __name((actor) => {
      if (!actor) return [0, 0, 0, 0];
      return [
        Number(actor.getEdge().value),
        Number(actor.findAttribute("reaction")?.value),
        Number(actor.findAttribute("intuition")?.value),
        new Roll("1d2").evaluate({ async: false }).total
      ];
    }, "genData");
    const leftData = genData(left.actor);
    const rightData = genData(right.actor);
    for (let index = 0; index < leftData.length; index++) {
      const diff = rightData[index] - leftData[index];
      if (diff !== 0) return diff;
    }
    return 0;
  }
  /**
   * Return the position in the current ini pass of the next undefeated combatant.
   */
  get nextUndefeatedTurnPosition() {
    for (let [turnInPass, combatant] of this.turns.entries()) {
      if (this.turn !== null && turnInPass <= this.turn) continue;
      if (!combatant.defeated && combatant.initiative > 0) {
        return turnInPass;
      }
    }
    return this.turns.length;
  }
  /**
   * Return the position in the current ini pass of the next combatant that has an action phase left.
   */
  get nextViableTurnPosition() {
    for (let [turnInPass, combatant] of this.turns.entries()) {
      if (this.turn !== null && turnInPass <= this.turn) continue;
      if (combatant.initiative > 0) {
        return turnInPass;
      }
    }
    return this.turns.length;
  }
  /**
   * Determine whether the current combat situation (current turn order) needs and can have an initiative pass applied.
   * @return true means that an initiative pass must be applied
   */
  doIniPass(nextTurn) {
    if (nextTurn < this.turns.length) return false;
    const currentScores = this.combatants.map((combatant) => Number(combatant.initiative));
    return CombatRules.iniOrderCanDoAnotherPass(currentScores);
  }
  /**
   * After all combatants have had their action phase (click on next 'turn') handle shadowrun rules for
   * initiative pass and combat turn.
   *
   * As long as a combatant still has a positive initiative score left, go to the next pass.
   *  Raise the Foundry turn and don't raise the Foundry round.
   * As soon as all combatants have no initiative score left, go to the next combat round.
   *  Reset the Foundry pass and don't raise the Foundry turn.
   *
   * Retrigger Initiative Rolls on each new Foundry round.
   *
   *
   * * @Override
   */
  async nextTurn() {
    let nextRound = this.round;
    let initiativePass = this.initiativePass;
    let nextTurn = this.settings?.skipDefeated ? this.nextUndefeatedTurnPosition : this.nextViableTurnPosition;
    if (nextRound === 0 && initiativePass === 0) {
      await this.startCombat();
      return;
    }
    if (nextTurn < this.turns.length) {
      await this.update({ turn: nextTurn });
      await this.handleActionPhase();
      return;
    }
    if (!game.user?.isGM && this.doIniPass(nextTurn)) {
      await this._createDoIniPassSocketMessage();
      return;
    }
    if (game.user?.isGM && this.doIniPass(nextTurn)) {
      await _SR6Combat.handleIniPass(this.id);
      return;
    }
    return this.nextRound();
  }
  async startCombat() {
    if (game.settings.get(SYSTEM_NAME, FLAGS.OnlyAutoRollNPCInCombat)) {
      await this.rollNPC({ updateTurn: false });
    } else {
      await this.rollAll({ updateTurn: false });
    }
    const turn = 0;
    const round = SR.combat.INITIAL_INI_ROUND;
    const initiativePass = SR.combat.INITIAL_INI_PASS;
    const updateData = {
      turn,
      round,
      [`flags.${SYSTEM_NAME}.${FLAGS.CombatInitiativePass}`]: initiativePass
    };
    await this.update(updateData);
    this._playCombatSound("startEncounter");
    Hooks.callAll("combatStart", this, updateData);
    await this.handleActionPhase();
    return this;
  }
  //@ts-expect-error TODO: foundry-vtt-types v11
  _playCombatSound(name3) {
    super._playCombatSound(name3);
  }
  async nextRound() {
    await super.nextRound();
    if (!game.user?.isGM) {
      await this._createDoNextRoundSocketMessage();
    } else {
      await _SR6Combat.handleNextRound(this.id);
    }
  }
  /**
   * This handler handles FoundryVTT hook preUpdateCombatant
   *
   * @param combatant The Combatant to update
   * @param changed The changedData (tends to a diff)
   * @param options
   * @param id
   */
  static onPreUpdateCombatant(combatant, changed, options, id) {
    console.log("SR6: Elysium | Handle preUpdateCombatant to apply system rules", combatant, changed);
    if (changed.initiative) changed.initiative = CombatRules.getValidInitiativeScore(changed.initiative);
  }
  /**
   * Alter initiative formula to include initiative pass reduction.
   *
   * NOTE: Should this here fail or be buggy, there always is SR6Combat.updateNewCombatants which can be uncommented in SR6Combat.rollInitiative
   * @deprecated since Foundry 0.8. Kept for possible Foundry 0.7 support. Might just be not needed anymore during 0.8 lifecycle.
   * @param combatant
   */
  _getInitiativeFormula(combatant) {
    if (this.initiativePass === SR.combat.INITIAL_INI_PASS) {
      return super._getInitiativeFormula(combatant);
    }
    return _SR6Combat._getSystemInitiativeFormula(this.initiativePass);
  }
  static _getSystemInitiativeBaseFormula() {
    return String(CONFIG.Combat.initiative.formula || game.system.data.initiative);
  }
  static _getSystemInitiativeFormula(initiativePass) {
    initiativePass = initiativePass > 1 ? initiativePass : 1;
    const baseFormula = _SR6Combat._getSystemInitiativeBaseFormula();
    const ongoingIniPassModified = (initiativePass - 1) * -SR.combat.INI_RESULT_MOD_AFTER_INI_PASS;
    return `max(${baseFormula} - ${ongoingIniPassModified}[Pass], 0)`;
  }
  static async _handleDoNextRoundSocketMessage(message) {
    if (!message.data.hasOwnProperty("id") && typeof message.data.id !== "string") {
      console.error(`SR5Combat Socket Message ${FLAGS.DoNextRound} data.id must be a string (combat id) but is ${typeof message.data} (${message.data})!`);
      return;
    }
    return await _SR6Combat.handleNextRound(message.data.id);
  }
  static async _handleDoInitPassSocketMessage(message) {
    if (!message.data.hasOwnProperty("id") && typeof message.data.id !== "string") {
      console.error(`SR5Combat Socket Message ${FLAGS.DoInitPass} data.id must be a string (combat id) but is ${typeof message.data} (${message.data})!`);
      return;
    }
    return await _SR6Combat.handleIniPass(message.data.id);
  }
  /**
   * Apply changes on the given combat for new action phase
   * @param message
   */
  static async _handleDoNewActionPhaseSocketMessage(message) {
    if (!message.data.hasOwnProperty("id") && typeof message.data.id !== "string") {
      console.error(`SR5Combat Socket Message ${FLAGS.DoNewActionPhase} data.id must be a string (combat id) but is ${typeof message.data} (${message.data})!`);
      return;
    }
    return await _SR6Combat.handleActionPhase(message.data.id);
  }
  async _createDoNextRoundSocketMessage() {
    await SocketMessage.emitForGM(FLAGS.DoNextRound, { id: this.id });
  }
  async _createDoIniPassSocketMessage() {
    await SocketMessage.emitForGM(FLAGS.DoInitPass, { id: this.id });
  }
  async _createNewActionPhaseSocketMessage() {
    await SocketMessage.emitForGM(FLAGS.DoNewActionPhase, { id: this.id });
  }
  delete(...args) {
    this.combatants.contents.forEach((combatant) => combatant.actor?.removeDefenseMultiModifier());
    return super.delete(...args);
  }
};
function _combatantGetInitiativeFormula() {
  const combat = this.parent;
  return SR6Combat._getSystemInitiativeFormula(combat.initiativePass);
}
__name(_combatantGetInitiativeFormula, "_combatantGetInitiativeFormula");

// src/module/apps/gmtools/OverwatchScoreTracker.js
var OverwatchScoreTracker = class _OverwatchScoreTracker extends Application {
  static {
    __name(this, "OverwatchScoreTracker");
  }
  static MatrixOverwatchDiceCount = "2d6";
  static get defaultOptions() {
    const options = super.defaultOptions;
    options.id = "overwatch-score-tracker";
    options.classes = ["sr6"];
    options.title = game.i18n.localize("SR6.OverwatchScoreTrackerTitle");
    options.template = "systems/shadowrun6-elysium/dist/templates/apps/gmtools/overwatch-score-tracker.html";
    options.width = 450;
    options.height = "auto";
    options.resizable = true;
    return options;
  }
  // Contains only non-user actors added manually by the GM.
  static addedActors = [];
  getData(options) {
    const actors = this._prepareCharacterActorsData();
    _OverwatchScoreTracker.addedActors.forEach((id) => {
      const actor = game.actors.get(id);
      if (actor) {
        actors.push(actor.toObject());
      }
    });
    this.actors = actors;
    return {
      actors
    };
  }
  _prepareCharacterActorsData() {
    return game.users.reduce((acc, user) => {
      if (!user.isGM && user.character) {
        acc.push(user.character.toObject());
      }
      return acc;
    }, []);
  }
  activateListeners(html) {
    html.find(".overwatch-score-reset").on("click", this._resetOverwatchScore.bind(this));
    html.find(".overwatch-score-add").on("click", this._addOverwatchScore.bind(this));
    html.find(".overwatch-score-input").on("change", this._setOverwatchScore.bind(this));
    html.find(".overwatch-score-roll-15-minutes").on("click", this._rollFor15Minutes.bind(this));
    html.find(".overwatch-score-add-actor").on("click", this._onAddActor.bind(this));
    html.find(".overwatch-score-delete").on("click", this._onDeleteActor.bind(this));
  }
  // returns the actor that this event is acting on
  _getActorFromEvent(event) {
    const id = $(event.currentTarget).closest(".list-item").data("actorId");
    if (id) return game.actors.get(id);
  }
  _onAddActor(event) {
    event.preventDefault();
    const tokens = Helpers.getControlledTokens();
    if (tokens.length === 0) {
      return ui.notifications?.warn(game.i18n.localize("SR6.OverwatchScoreTracker.NotifyNoSelectedTokens"));
    }
    const unlinkedActor = tokens.find((token) => !token.document.actorLink);
    if (unlinkedActor !== void 0) {
      ui.notifications.warn(game.i18n.localize("SR6.OverwatchScoreTracker.OnlyLinkedActorsSupported"));
    }
    tokens.filter((token) => token.document.actorLink).forEach((token) => {
      const actor = game.actors.get(token.document.actorId);
      if (!actor) return;
      if (this._isActorOnTracker(actor)) return;
      _OverwatchScoreTracker.addedActors.push(actor.id);
    });
    this.render();
  }
  /**
   * Check if the given actor is already added and displayed on the current tracker.
   *
   * @param actor A actors collection actor.
   * @returns {boolean} Will return true when the given actor already exists.
   */
  _isActorOnTracker(actor) {
    return this.actors.find((actorData) => actorData._id === actor.id) !== void 0;
  }
  _setOverwatchScore(event) {
    const actor = this._getActorFromEvent(event);
    const amount = event.currentTarget.value;
    if (amount && actor) {
      actor.setOverwatchScore(amount).then(() => this.render());
    }
  }
  _addOverwatchScore(event) {
    const actor = this._getActorFromEvent(event);
    const amount = parseInt(event.currentTarget.dataset.amount);
    if (amount && actor) {
      const os = actor.getOverwatchScore();
      actor.setOverwatchScore(os + amount).then(() => this.render());
    }
  }
  _resetOverwatchScore(event) {
    event.preventDefault();
    const actor = this._getActorFromEvent(event);
    if (actor) {
      actor.setOverwatchScore(0).then(() => this.render());
    }
  }
  /**
   * Remove the connected actor from the tracker.
   * @param {*} event
   */
  _onDeleteActor(event) {
    event.preventDefault();
    const actor = this._getActorFromEvent(event);
    if (!actor) return;
    const index = _OverwatchScoreTracker.addedActors.indexOf(actor.id);
    if (index === -1) {
      ui.notifications?.warn(game.i18n.localize("SR6.OverwatchScoreTracker.CantDeleteUserCharacter"), { localize: true });
      return;
    }
    _OverwatchScoreTracker.addedActors.splice(index, 1);
    this.render();
  }
  async _rollFor15Minutes(event) {
    event.preventDefault();
    const actor = this._getActorFromEvent(event);
    if (actor) {
      const roll = new Roll(_OverwatchScoreTracker.MatrixOverwatchDiceCount);
      await roll.evaluate();
      if (roll.total) {
        const os = actor.getOverwatchScore();
        actor.setOverwatchScore(os + roll.total).then(() => this.render());
      }
    }
  }
};

// src/module/apps/itemImport/importer/Constants.ts
var Constants = class {
  static {
    __name(this, "Constants");
  }
  static {
    this.MAP_CATEGORY_TO_SKILL = {
      "Assault Cannons": "heavy_weapons",
      "Assault Rifles": "automatics",
      "Blades": "blades",
      "Bows": "archery",
      "Carbines": "automatics",
      "Clubs": "clubs",
      "Crossbows": "archery",
      "Exotic Melee Weapons": "exotic_melee",
      "Exotic Ranged Weapons": "exotic_ranged",
      "Flamethrowers": "exotic_ranged",
      "Grenade Launchers": "heavy_weapons",
      "Heavy Machine Guns": "heavy_weapons",
      "Heavy Pistols": "pistols",
      "Holdouts": "pistols",
      "Laser Weapons": "exotic_ranged",
      "Light Machine Guns": "heavy_weapons",
      "Light Pistols": "pistols",
      "Machine Pistols": "automatics",
      "Medium Machine Guns": "automatics",
      "Missile Launchers": "heavy_weapons",
      "Shotguns": "longarms",
      "Sniper Rifles": "longarms",
      "Sporting Rifles": "longarms",
      "Submachine Guns": "automatics",
      "Tasers": "pistols",
      "Unarmed": "unarmed_combat"
    };
  }
  static {
    this.MAP_IMPORT_RANGE_CATEGORY_TO_SYSTEM_RANGE_CATEGORY = {
      "Tasers": "taser",
      "Holdouts": "holdOutPistol",
      "Light Pistols": "lightPistol",
      "Heavy Pistols": "heavyPistol",
      "Machine Pistols": "machinePistol",
      "Submachine Guns": "smg",
      "Assault Rifles": "assaultRifle",
      "Shotguns": "shotgunSlug",
      "Shotguns (slug)": "shotgunSlug",
      "Shotguns (flechette)": "shotgunFlechette",
      "Sniper Rifles": "sniperRifle",
      "Sporting Rifles": "sportingRifle",
      "Light Machine Guns": "lightMachinegun",
      "Medium/Heavy Machinegun": "mediumHeavyMachinegun",
      "Assault Cannons": "assaultCannon",
      "Grenade Launchers": "grenadeLauncher",
      "Missile Launchers": "missileLauncher",
      "Bows": "bow",
      "Light Crossbows": "lightCrossbow",
      "Medium Crossbows": "mediumCrossbow",
      "Heavy Crossbows": "heavyCrossbow",
      "Thrown Knife": "thrownKnife",
      "Net": "net",
      "Shuriken": "shuriken",
      "Standard Grenade": "standardThrownGrenade",
      "Aerodynamic Grenade": "aerodynamicThrownGrenade",
      "Harpoon Gun": "harpoonGun",
      "Harpoon Gun (Underwater)": "harpoonGunUnderwater",
      "Flamethrowers": "flamethrower"
    };
  }
  static {
    this.ROOT_IMPORT_FOLDER_NAME = "SR5e";
  }
  static {
    this.MAP_CHUMMER_PROGRAMM_CATEGORY = {
      "Hacking Programs": "hacking_program",
      "Common Programs": "common_program"
    };
  }
};

// src/module/apps/itemImport/helper/ImportStrategy.ts
var ImportStrategy = class {
  static {
    __name(this, "ImportStrategy");
  }
};

// src/module/apps/itemImport/helper/XMLStrategy.ts
var XMLStrategy = class extends ImportStrategy {
  static {
    __name(this, "XMLStrategy");
  }
  intValue(jsonData, key, fallback = void 0) {
    try {
      return parseInt(jsonData[key][ImportHelper.CHAR_KEY]);
    } catch (e2) {
      if (fallback !== void 0) {
        return fallback;
      } else {
        throw e2;
      }
    }
  }
  stringValue(jsonData, key, fallback = void 0) {
    try {
      return jsonData[key][ImportHelper.CHAR_KEY];
    } catch (e2) {
      if (fallback !== void 0) {
        return fallback;
      } else {
        throw e2;
      }
    }
  }
  objectValue(jsonData, key, fallback = void 0) {
    try {
      return jsonData[key];
    } catch (e2) {
      if (fallback !== void 0) {
        return fallback;
      } else {
        throw e2;
      }
    }
  }
};

// src/module/apps/itemImport/helper/JSONStrategy.ts
var JSONStrategy = class extends ImportStrategy {
  static {
    __name(this, "JSONStrategy");
  }
  intValue(jsonData, key, fallback = void 0) {
    throw new Error("Unimplemented");
  }
  stringValue(jsonData, key, fallback = void 0) {
    throw new Error("Unimplemented");
  }
  objectValue(jsonData, key, fallback = void 0) {
    throw new Error("Unimplemented");
  }
};

// src/module/apps/itemImport/helper/ImportHelper.ts
var ImportHelper = class _ImportHelper {
  static {
    __name(this, "ImportHelper");
  }
  static {
    this.CHAR_KEY = "_TEXT";
  }
  static {
    this.s_Strategy = new XMLStrategy();
  }
  static SetMode(mode) {
    switch (mode) {
      case 1 /* XML */:
        _ImportHelper.s_Strategy = new XMLStrategy();
        break;
      case 2 /* JSON */:
        _ImportHelper.s_Strategy = new JSONStrategy();
        break;
    }
  }
  constructor() {
  }
  /**
   * Helper method to create a new folder.
   * @param name The name of the folder.
   * @param folder The parent folder.
   * @returns {Promise<Folder>} A promise that resolves with the folder object when the folder is created.
   */
  static async NewFolder(name3, folder = null) {
    return await Folder.create({
      type: "Item",
      folder: folder === null ? null : folder.id,
      name: name3
    });
  }
  /**
   * Get / create a folder at a path in the items directory.
   *
   * Traverse path and match folder structure to the last and current path segments.
   *
   * @param path The absolute path of the folder.
   * @param mkdirs If true, will make all folders along the hierarchy if they do not exist.
   * @returns A promise that will resolve with the found folder.
   */
  static async GetFolderAtPath(path, mkdirs = false) {
    let currentFolder, lastFolder = null;
    const pathSegments = path.split("/");
    for (const pathSegment of pathSegments) {
      currentFolder = game.folders?.find((folder) => {
        return folder.folder === lastFolder && folder.name === pathSegment;
      });
      if (!currentFolder && !mkdirs) return Promise.reject(`Unable to find folder: ${path}`);
      if (!currentFolder) currentFolder = await _ImportHelper.NewFolder(pathSegment, lastFolder);
      lastFolder = currentFolder;
    }
    return Promise.resolve(currentFolder);
  }
  /**
   * Get a value from the the provided jsonData, optionally returning a default value if it is not found
   * or is unable to be parsed to an integer.
   * @param jsonData The data to get the keyed value in.
   * @param key The key to check for the value under.
   * @param fallback An optional default value to return if the key is not found.
   */
  static IntValue(jsonData, key, fallback = void 0) {
    return _ImportHelper.s_Strategy.intValue(jsonData, key, fallback);
  }
  /**
   * Get a value from the the provided jsonData, optionally returning a default value if it is not found.
   * @param jsonData The data to get the keyed value in.
   * @param key The key to check for the value under.
   * @param fallback An optional default value to return if the key is not found.
   */
  static StringValue(jsonData, key, fallback = void 0) {
    return _ImportHelper.s_Strategy.stringValue(jsonData, key, fallback);
  }
  /**
   * Get an object from the the provided jsonData, optionally returning a default value if it is not found.
   * @param jsonData The data to get the keyed value in.
   * @param key The key to check for the value under.
   * @param fallback An optional default value to return if the key is not found.
   */
  static ObjectValue(jsonData, key, fallback = void 0) {
    return _ImportHelper.s_Strategy.objectValue(jsonData, key, fallback);
  }
  static findItem(nameOrCmp) {
    let result;
    if (typeof nameOrCmp === "string") {
      result = game.items?.find((item) => item.name == nameOrCmp);
    } else {
      result = game.items?.find(nameOrCmp);
    }
    return result;
  }
  static TranslateCategory(name3, jsonCategoryTranslations) {
    if (jsonCategoryTranslations && jsonCategoryTranslations.hasOwnProperty(name3)) {
      return jsonCategoryTranslations[name3];
    }
    return name3;
  }
  static async MakeCategoryFolders(jsonData, path, jsonCategoryTranslations) {
    let folders = {};
    let jsonCategories = jsonData["categories"]["category"];
    for (let i2 = 0; i2 < jsonCategories.length; i2++) {
      let categoryName = jsonCategories[i2][_ImportHelper.CHAR_KEY];
      let origCategoryName = categoryName;
      categoryName = _ImportHelper.TranslateCategory(categoryName, jsonCategoryTranslations);
      folders[origCategoryName.toLowerCase()] = await _ImportHelper.GetFolderAtPath(`${Constants.ROOT_IMPORT_FOLDER_NAME}/${path}/${categoryName}`, true);
    }
    return folders;
  }
  /** Extract the correct <chummer file="${dataFileName}>[...]</chummer> element from xx-xx_data.xml translations.
   *
   * @param jsoni18n
   * @param dataFileName Expected translation target file name
   */
  static ExtractDataFileTranslation(jsoni18n, dataFileName) {
    for (let i2 = 0; i2 < jsoni18n.length; i2++) {
      const translation = jsoni18n[i2];
      if (translation.$.file === dataFileName) {
        return translation;
      }
    }
    return {};
  }
  /** Extract categories translations within xx-xx_data.xml <chummer/> translation subset.
   *
   *  Note: Not all file translations provide categories.
   *
   * @param jsonChummeri18n Translations as given by ExtractDataFileTranslations
   */
  static ExtractCategoriesTranslation(jsonChummeri18n) {
    const categoryTranslations = {};
    if (jsonChummeri18n && jsonChummeri18n.hasOwnProperty("categories")) {
      jsonChummeri18n.categories.category.forEach((category3) => {
        const name3 = category3[_ImportHelper.CHAR_KEY];
        const translate = category3.$.translate;
        categoryTranslations[name3] = translate;
      });
    }
    return categoryTranslations;
  }
  /** Extract item type translations within xx-xx_data.xml <chummer/> translation subset.
   *
   * @param jsonItemsi18n Translations as given by ExtractDataFileTranslations
   * @param typeKey The item type to translate. Tends to be plural.
   * @param listKey The item to translate. Tends to be singular.
   */
  static ExtractItemTranslation(jsonItemsi18n, typeKey, listKey) {
    const itemTranslation = {};
    if (jsonItemsi18n && jsonItemsi18n[typeKey] && jsonItemsi18n[typeKey][listKey] && jsonItemsi18n[typeKey][listKey].length > 0) {
      jsonItemsi18n[typeKey][listKey].forEach((item) => {
        const name3 = item.name[_ImportHelper.CHAR_KEY];
        const translate = item.translate[_ImportHelper.CHAR_KEY];
        const altpage = item.altpage[_ImportHelper.CHAR_KEY];
        itemTranslation[name3] = { translate, altpage };
      });
    }
    return itemTranslation;
  }
  static MapNameToTranslationKey(translationMap, name3, key, fallbackValue = "") {
    if (translationMap && translationMap.hasOwnProperty(name3) && translationMap[name3].hasOwnProperty(key)) {
      return translationMap[name3][key];
    }
    return fallbackValue;
  }
  static MapNameToTranslation(translationMap, name3) {
    return _ImportHelper.MapNameToTranslationKey(translationMap, name3, "translate", name3);
  }
  static MapNameToPageSource(translationMap, name3, fallback = "?") {
    return _ImportHelper.MapNameToTranslationKey(translationMap, name3, "altpage", fallback);
  }
};

// src/module/apps/iconAssigner/iconAssign.ts
async function getIconFiles() {
  if (!game.user?.can("FILES_BROWSE")) {
    return [];
  }
  const imgFolder = game.settings.get(SYSTEM_NAME, FLAGS.ImportIconFolder) || "systems/shadowrun6-elysium/dist/icons/importer/";
  const folderList = await FilePicker.browse("data", imgFolder).then((picker) => picker.dirs);
  let fileList = await FilePicker.browse("data", imgFolder).then((picker) => picker.files);
  for (const folder of folderList) {
    const newFiles = await FilePicker.browse("data", folder).then((picker) => picker.files);
    fileList = fileList.concat(newFiles);
  }
  return fileList;
}
__name(getIconFiles, "getIconFiles");
async function iconAssign(importFlags, system, iconList) {
  const defaultImg = "icons/svg/item-bag.svg";
  const imgFolder = game.settings.get(SYSTEM_NAME, FLAGS.ImportIconFolder) || "systems/shadowrun6-elysium/dist/icons/importer/";
  const imgExtensionOptions = [".svg", ".webp", ".png", ".jpg", ".jpeg", ".avif"];
  const imgName = importFlags.name;
  const imgType = importFlags.type;
  const imgSubType = importFlags.subType;
  const useOverrides = game.settings.get(SYSTEM_NAME, FLAGS.UseImportIconOverrides);
  let override = "";
  if (imgSubType && useOverrides) override = SR6.itemSubTypeIconOverrides[imgType][imgSubType];
  let fileNamePriority = [
    imgFolder + override,
    imgFolder + imgType + (imgSubType ? "/" : "") + imgSubType,
    imgFolder + imgType + "/" + imgType,
    imgFolder + imgSubType,
    imgFolder + imgType
  ];
  switch (imgType) {
    case "armor":
      break;
    case "weapon":
      fileNamePriority = [
        imgFolder + override,
        imgFolder + imgType + (imgSubType ? "/" : "") + imgSubType,
        imgFolder + imgType + "/" + system.category,
        imgFolder + imgType + "/" + imgType,
        imgFolder + imgSubType,
        imgFolder + imgType
      ];
      break;
    default:
      break;
  }
  for (const iconFileName of fileNamePriority) {
    for (const imgExtension of imgExtensionOptions) {
      const withExtension = iconFileName + imgExtension;
      if (iconList.includes(withExtension)) {
        return withExtension;
      }
    }
  }
  return defaultImg;
}
__name(iconAssign, "iconAssign");

// src/module/apps/itemImport/importer/DataImporter.ts
var xml2js = require_xml2js();
var DataImporter = class _DataImporter {
  constructor() {
    // Used to filter down a files entries based on category.
    // See filterObjects for use.
    // Leave on null to support all categories.
    this.unsupportedCategories = [];
  }
  static {
    __name(this, "DataImporter");
  }
  static {
    this.unsupportedBooks = ["2050"];
  }
  static {
    this.SR6 = SR6;
  }
  /**
   * Get complete item data.
   *
   * NOTE: We use temporary items to have a full set of item data instead of just
   *       system model data that game.model.Item would give us.
   */
  GetDefaultData({ type }) {
    return DataDefaults.baseItemData({ type });
  }
  /**
   *
   * @param jsonObject JSON Data with all data translations for one language.
   */
  static CanParseI18n(jsonObject) {
    return jsonObject.hasOwnProperty("chummer") && jsonObject.chummer.length > 0 && jsonObject.chummer[0].$.hasOwnProperty("file");
  }
  /**
   * Stores translations as a whole for all implementing classes to extract from without reparsing.
   * @param jsonObject JSON Data with all data translations for one language.
   */
  static ParseTranslation(jsonObject) {
    if (jsonObject && jsonObject.hasOwnProperty("chummer")) {
      _DataImporter.jsoni18n = jsonObject["chummer"];
    }
  }
  /**
   * Get the appropriate default icon
   * @param importFlags The importFlags data of an item
   * @param system The item's system data
   */
  iconAssign(importFlags, system, iconList) {
    return iconAssign(importFlags, system, iconList);
  }
  /**
   * Gets a list of icons available in the importer's folder
   */
  async getIconFiles() {
    return getIconFiles();
  }
  /**
   * Reformat the name or subtype name so it matches the categories in config.ts
   * @param name The item's name or subtype name to reformat
   */
  formatAsSlug(name3) {
    return name3.trim().toLowerCase().replace(/'|,|\[|\]|\(|\)/g, "").split(/-|\s|\//g).join("-");
  }
  /**
   * Set the subtype
   * @param name The item's English name
   * @param type The item's type
   * @param subType The item's subtype
   */
  genImportFlags(name3, type, subType) {
    const flags = {
      name: this.formatAsSlug(name3),
      // original english name
      type,
      subType: "",
      isFreshImport: true
    };
    if (subType && Object.keys(SR6.itemSubTypeIconOverrides[type]).includes(subType)) {
      flags.subType = subType;
    }
    return flags;
  }
  /**
   * Parse an XML string into a JSON object.
   * @param xmlString The string to parse as XML.
   * @returns A json object converted from the string.
   */
  static async xml2json(xmlString) {
    const parser = xml2js.Parser({
      explicitArray: false,
      explicitCharkey: true,
      charkey: ImportHelper.CHAR_KEY
    });
    return (await parser.parseStringPromise(xmlString))["chummer"];
  }
  static unsupportedBookSource(jsonObject) {
    if (!jsonObject.hasOwnProperty("source")) return false;
    const source3 = ImportHelper.StringValue(jsonObject, "source", "");
    return _DataImporter.unsupportedBooks.includes(source3);
  }
  static unsupportedEntry(jsonObject) {
    if (_DataImporter.unsupportedBookSource(jsonObject)) {
      return true;
    }
    return false;
  }
  /**
   * Filter down objects to those actaully imported.
   *
   * Sometimes a single Chummer xml file contains mulitple 'categories' that don't mix with system types
   *
   * @param objects
   * @returns A subset of objects
   */
  filterObjects(objects) {
    if (!this.unsupportedCategories) return objects;
    return objects.filter((object) => !this.unsupportedCategories.includes(ImportHelper.StringValue(object, "category", "")));
  }
};

// src/module/apps/itemImport/importer/ProgramImporter.ts
var ProgramImporter = class extends DataImporter {
  constructor() {
    super(...arguments);
    this.files = ["gear.xml"];
  }
  static {
    __name(this, "ProgramImporter");
  }
  CanParse(jsonObject) {
    return jsonObject.hasOwnProperty("gears") && jsonObject["gears"].hasOwnProperty("gear");
  }
  ExtractTranslation(fileName) {
    if (!DataImporter.jsoni18n) {
      return;
    }
    let jsonGeari18n = ImportHelper.ExtractDataFileTranslation(DataImporter.jsoni18n, this.files[0]);
    this.categoryTranslations = ImportHelper.ExtractCategoriesTranslation(jsonGeari18n);
    this.itemTranslations = ImportHelper.ExtractItemTranslation(jsonGeari18n, "gears", "gear");
  }
  filterGearToPrograms(jsonObject) {
    const categories = [
      "Hacking Programs",
      "Common Programs"
    ];
    return jsonObject["gears"]["gear"].filter((gear) => categories.includes(ImportHelper.StringValue(gear, "category", "")));
  }
  async parsePrograms(programs, setIcons) {
    const items = [];
    this.iconList = await this.getIconFiles();
    const parserType = "program";
    for (const program of programs) {
      if (DataImporter.unsupportedEntry(program)) continue;
      const item = this.GetDefaultData({ type: parserType });
      item.name = ImportHelper.StringValue(program, "name");
      item.system.type = Constants.MAP_CHUMMER_PROGRAMM_CATEGORY[ImportHelper.StringValue(program, "category")];
      const categoryEN = ImportHelper.StringValue(program, "category");
      const category3 = ImportHelper.TranslateCategory(categoryEN, this.categoryTranslations).replace("/", " ");
      let categoryFolder = await ImportHelper.GetFolderAtPath(`${Constants.ROOT_IMPORT_FOLDER_NAME}/${game.i18n.localize("SR6.Programs")}/${category3}`, true);
      item.folder = categoryFolder.id;
      item.system.importFlags = this.genImportFlags(item.name, item.type, item.system.type);
      if (setIcons) {
        item.img = await this.iconAssign(item.system.importFlags, item.system, this.iconList);
      }
      ;
      item.system.technology.rating = ImportHelper.IntValue(program, "rating", 0);
      item.system.description.source = `${ImportHelper.StringValue(program, "source")} ${ImportHelper.MapNameToPageSource(this.itemTranslations, ImportHelper.StringValue(program, "name"), ImportHelper.StringValue(program, "page"))}`;
      item.system.technology.availability = ImportHelper.StringValue(program, "avail");
      item.system.technology.cost = ImportHelper.IntValue(program, "cost", 0);
      item.name = ImportHelper.MapNameToTranslation(this.itemTranslations, item.name);
      items.push(item);
    }
    return items;
  }
  async Parse(jsonObject, setIcons) {
    const programs = this.filterGearToPrograms(jsonObject);
    const items = await this.parsePrograms(programs, setIcons);
    return await Item.create(items);
  }
};

// src/module/apps/itemImport/parser/Parser.ts
var Parser = class {
  static {
    __name(this, "Parser");
  }
};

// src/module/apps/itemImport/parser/item/ItemParserBase.ts
var ItemParserBase = class extends Parser {
  static {
    __name(this, "ItemParserBase");
  }
  Parse(jsonData, item, jsonTranslation) {
    item.name = ImportHelper.StringValue(jsonData, "name");
    item.system.description.source = `${ImportHelper.StringValue(jsonData, "source")} ${ImportHelper.StringValue(jsonData, "page")}`;
    if (jsonTranslation) {
      const origName = ImportHelper.StringValue(jsonData, "name");
      item.name = ImportHelper.MapNameToTranslation(jsonTranslation, origName);
      item.system.description.source = `${ImportHelper.StringValue(jsonData, "source")} ${ImportHelper.MapNameToPageSource(jsonTranslation, origName)}`;
    }
    return item;
  }
};

// src/module/apps/itemImport/parser/item/TechnologyItemParserBase.ts
var TechnologyItemParserBase = class extends ItemParserBase {
  static {
    __name(this, "TechnologyItemParserBase");
  }
  Parse(jsonData, item, jsonTranslation) {
    item = super.Parse(jsonData, item, jsonTranslation);
    item.system.technology.availability = ImportHelper.StringValue(jsonData, "avail", "0");
    item.system.technology.cost = ImportHelper.IntValue(jsonData, "cost", 0);
    item.system.technology.rating = ImportHelper.IntValue(jsonData, "rating", 0);
    return item;
  }
};

// src/module/apps/itemImport/parser/weapon/WeaponParserBase.ts
var WeaponParserBase = class _WeaponParserBase extends TechnologyItemParserBase {
  static {
    __name(this, "WeaponParserBase");
  }
  GetSkill(weaponJson) {
    if (weaponJson.hasOwnProperty("useskill")) {
      let jsonSkill = ImportHelper.StringValue(weaponJson, "useskill");
      if (Constants.MAP_CATEGORY_TO_SKILL.hasOwnProperty(jsonSkill)) {
        return Constants.MAP_CATEGORY_TO_SKILL[jsonSkill];
      }
      return jsonSkill.replace(/[\s\-]/g, "_").toLowerCase();
    } else {
      let category3 = ImportHelper.StringValue(weaponJson, "category");
      if (Constants.MAP_CATEGORY_TO_SKILL.hasOwnProperty(category3)) {
        return Constants.MAP_CATEGORY_TO_SKILL[category3];
      }
      let type = ImportHelper.StringValue(weaponJson, "type").toLowerCase();
      return type === "ranged" ? "exotic_range" : "exotic_melee";
    }
  }
  static GetWeaponType(weaponJson) {
    let type = ImportHelper.StringValue(weaponJson, "type");
    if (type === "Melee") {
      return "melee";
    } else {
      if (weaponJson.hasOwnProperty("useskill")) {
        let skill = ImportHelper.StringValue(weaponJson, "useskill");
        if (skill === "Throwing Weapons") return "thrown";
      }
      let category3 = ImportHelper.StringValue(weaponJson, "category");
      if (category3 === "Throwing Weapons") return "thrown";
      return "range";
    }
  }
  Parse(jsonData, item, jsonTranslation) {
    item = super.Parse(jsonData, item, jsonTranslation);
    let category3 = ImportHelper.StringValue(jsonData, "category");
    if (category3 === "Hold-outs") {
      category3 = "Holdouts";
    }
    item.system.category = _WeaponParserBase.GetWeaponType(jsonData);
    item.system.subcategory = category3.toLowerCase();
    item.system.action.skill = this.GetSkill(jsonData);
    item.system.action.damage = this.GetDamage(jsonData);
    item.system.action.limit.value = ImportHelper.IntValue(jsonData, "accuracy");
    item.system.action.limit.base = ImportHelper.IntValue(jsonData, "accuracy");
    item.system.technology.conceal.base = ImportHelper.IntValue(jsonData, "conceal");
    return item;
  }
  GetDamage(jsonData) {
    const jsonDamage = ImportHelper.StringValue(jsonData, "damage");
    const simpleDamage = /^([0-9]+)([PSM])? ?(\([a-zA-Z]+\))?/g.exec(jsonDamage);
    const strengthDamage = /^\({STR}([+-]?[0-9]*)\)([PSM])? ?(\([a-zA-Z]+\))?/g.exec(jsonDamage);
    let damageType = "";
    let damageAttribute = "";
    let damageBase = 0;
    let damageElement = "";
    if (simpleDamage !== null) {
      damageAttribute = "";
      damageBase = parseInt(simpleDamage[1], 10);
      damageType = this.parseDamageType(simpleDamage[2]);
      damageElement = this.parseDamageElement(simpleDamage[3]);
    } else if (strengthDamage !== null) {
      damageAttribute = "strength";
      damageBase = parseInt(strengthDamage[1], 10) || 0;
      damageType = this.parseDamageType(strengthDamage[2]);
      damageElement = this.parseDamageElement(strengthDamage[3]);
    }
    const damageAp = ImportHelper.IntValue(jsonData, "ap", 0);
    const partialDamageData = {
      type: {
        base: damageType || "physical",
        value: damageType || "physical"
      },
      base: damageBase,
      value: damageBase,
      ap: {
        base: damageAp,
        value: damageAp,
        mod: []
      },
      attribute: damageAttribute,
      element: {
        base: damageElement,
        value: damageElement
      }
    };
    return DataDefaults.damageData(partialDamageData);
  }
  parseDamageType(parsedType) {
    switch (parsedType) {
      case "S":
        return "stun";
      case "M":
        return "matrix";
      case "P":
        return "physical";
      default:
        return "";
    }
  }
  parseDamageElement(parsedElement) {
    switch (parsedElement?.toLowerCase()) {
      case "(e)":
        return "electricity";
      case "(fire)":
        return "fire";
      default:
        return "";
    }
  }
  GetRangeDataFromImportedCategory(category3) {
    const systemRangeCategory = Constants.MAP_IMPORT_RANGE_CATEGORY_TO_SYSTEM_RANGE_CATEGORY[category3];
    if (systemRangeCategory === void 0) {
      return void 0;
    }
    return {
      ...SR6.weaponRangeCategories[systemRangeCategory].ranges,
      category: systemRangeCategory
    };
  }
};

// src/module/apps/itemImport/parser/weapon/RangedParser.ts
var RangedParser = class extends WeaponParserBase {
  static {
    __name(this, "RangedParser");
  }
  GetAmmo(weaponJson) {
    let jsonAmmo = ImportHelper.StringValue(weaponJson, "ammo");
    let match = jsonAmmo.match(/([0-9]+)/g)?.[0];
    return match !== void 0 ? parseInt(match) : 0;
  }
  Parse(jsonData, item, jsonTranslation) {
    item = super.Parse(jsonData, item, jsonTranslation);
    if (jsonData.hasOwnProperty("rc")) {
      item.system.range.rc.base = ImportHelper.IntValue(jsonData, "rc");
      item.system.range.rc.value = ImportHelper.IntValue(jsonData, "rc");
    } else {
      item.system.range.rc.base = 0;
      item.system.range.rc.value = 0;
    }
    const rangeCategory = ImportHelper.StringValue(jsonData, jsonData.hasOwnProperty("range") ? "range" : "category");
    item.system.range.ranges = DataDefaults.weaponRangeData(this.GetRangeDataFromImportedCategory(rangeCategory));
    item.system.ammo.current.value = this.GetAmmo(jsonData);
    item.system.ammo.current.max = this.GetAmmo(jsonData);
    const modeData = ImportHelper.StringValue(jsonData, "mode");
    item.system.range.modes = {
      single_shot: modeData.includes("SS"),
      semi_auto: modeData.includes("SA"),
      burst_fire: modeData.includes("BF"),
      full_auto: modeData.includes("FA")
    };
    return item;
  }
};

// src/module/apps/itemImport/parser/weapon/MeleeParser.ts
var MeleeParser = class extends WeaponParserBase {
  static {
    __name(this, "MeleeParser");
  }
  Parse(jsonData, item, jsonTranslation) {
    item = super.Parse(jsonData, item, jsonTranslation);
    item.system.melee.reach = ImportHelper.IntValue(jsonData, "reach");
    return item;
  }
};

// src/module/apps/itemImport/parser/weapon/ThrownParser.ts
var ThrownParser = class extends WeaponParserBase {
  static {
    __name(this, "ThrownParser");
  }
  GetBlast(jsonData, item) {
    let blastData = {
      radius: 0,
      dropoff: 0
    };
    let blastCode = ImportHelper.StringValue(jsonData, "damage");
    let radiusMatch = blastCode.match(/([0-9]+m)/)?.[0];
    if (radiusMatch !== void 0) {
      radiusMatch = radiusMatch.match(/[0-9]+/)?.[0];
      if (radiusMatch !== void 0) {
        blastData.radius = parseInt(radiusMatch);
      }
    }
    let dropoffMatch = blastCode.match(/(-[0-9]+\/m)/)?.[0];
    if (dropoffMatch !== void 0) {
      dropoffMatch = dropoffMatch.match(/-[0-9]+/)?.[0];
      if (dropoffMatch !== void 0) {
        blastData.dropoff = parseInt(dropoffMatch);
      }
    }
    if (blastData.dropoff && !blastData.radius) {
      blastData.radius = -(item.system.action.damage.base / blastData.dropoff);
    }
    return blastData;
  }
  Parse(jsonData, item, jsonTranslation) {
    item = super.Parse(jsonData, item, jsonTranslation);
    const rangeCategory = ImportHelper.StringValue(jsonData, jsonData.hasOwnProperty("range") ? "range" : "category");
    item.system.thrown.ranges = DataDefaults.weaponRangeData(this.GetRangeDataFromImportedCategory(rangeCategory));
    item.system.thrown.blast = this.GetBlast(jsonData, item);
    return item;
  }
};

// src/module/apps/itemImport/parser/ParserMap.ts
var ParserMap = class extends Parser {
  static {
    __name(this, "ParserMap");
  }
  constructor(branchKey, elements) {
    super();
    this.m_BranchKey = branchKey;
    this.m_Map = /* @__PURE__ */ new Map();
    for (const { key, value } of elements) {
      this.m_Map.set(key, value);
    }
  }
  Parse(jsonData, item, jsonTranslation) {
    let key;
    if (typeof this.m_BranchKey === "function") {
      key = this.m_BranchKey(jsonData);
    } else {
      key = this.m_BranchKey;
      key = ImportHelper.StringValue(jsonData, key);
    }
    const parser = this.m_Map.get(key);
    if (parser === void 0) {
      console.warn(`Could not find mapped parser for category ${key}.`);
      return item;
    }
    return parser.Parse(jsonData, item, jsonTranslation);
  }
};

// src/module/apps/itemImport/importer/WeaponImporter.ts
var WeaponImporter = class extends DataImporter {
  constructor() {
    super(...arguments);
    this.files = ["weapons.xml"];
  }
  static {
    __name(this, "WeaponImporter");
  }
  CanParse(jsonObject) {
    return jsonObject.hasOwnProperty("weapons") && jsonObject["weapons"].hasOwnProperty("weapon");
  }
  GetDefaultData({ type }) {
    const systemData = { action: { type: "varies", attribute: "agility" } };
    return DataDefaults.baseItemData({ type }, systemData);
  }
  ExtractTranslation() {
    if (!DataImporter.jsoni18n) {
      return;
    }
    let jsonWeaponi18n = ImportHelper.ExtractDataFileTranslation(DataImporter.jsoni18n, this.files[0]);
    this.categoryTranslations = ImportHelper.ExtractCategoriesTranslation(jsonWeaponi18n);
    this.itemTranslations = ImportHelper.ExtractItemTranslation(jsonWeaponi18n, "weapons", "weapon");
  }
  async Parse(jsonObject, setIcons) {
    const folders = await ImportHelper.MakeCategoryFolders(jsonObject, "Weapons", this.categoryTranslations);
    folders["gear"] = await ImportHelper.GetFolderAtPath(`${Constants.ROOT_IMPORT_FOLDER_NAME}/Weapons/Gear`, true);
    folders["quality"] = await ImportHelper.GetFolderAtPath(`${Constants.ROOT_IMPORT_FOLDER_NAME}/Weapons/Quality`, true);
    const parser = new ParserMap(WeaponParserBase.GetWeaponType, [
      { key: "range", value: new RangedParser() },
      { key: "melee", value: new MeleeParser() },
      { key: "thrown", value: new ThrownParser() }
    ]);
    let items = [];
    let jsonDatas = jsonObject["weapons"]["weapon"];
    this.iconList = await this.getIconFiles();
    const parserType = "weapon";
    for (let i2 = 0; i2 < jsonDatas.length; i2++) {
      let jsonData = jsonDatas[i2];
      if (DataImporter.unsupportedEntry(jsonData)) {
        continue;
      }
      let item = parser.Parse(jsonData, this.GetDefaultData({ type: parserType }), this.itemTranslations);
      item.folder = folders[item.system.subcategory].id;
      let subType = "";
      if (item.system.category) {
        subType = this.formatAsSlug(item.system.category);
      }
      const weaponCategory = this.formatAsSlug(item.system.subcategory);
      if (!(subType && weaponCategory == "gear")) {
        subType = weaponCategory;
      }
      if (weaponCategory == "gear" && item.name.includes(":")) {
        subType = this.formatAsSlug(item.name.split(":")[0]);
      }
      item.system.importFlags = this.genImportFlags(item.name, item.type, subType);
      if (setIcons) {
        item.img = await this.iconAssign(item.system.importFlags, item.system, this.iconList);
      }
      ;
      UpdateActionFlow.injectActionTestsIntoChangeData(item.type, item, item);
      items.push(item);
    }
    return await Item.create(items);
  }
};

// src/module/apps/itemImport/parser/armor/ArmorParserBase.ts
var ArmorParserBase = class extends TechnologyItemParserBase {
  static {
    __name(this, "ArmorParserBase");
  }
  Parse(jsonData, item) {
    item = super.Parse(jsonData, item);
    item.system.armor.value = ImportHelper.IntValue(jsonData, "armor", 0);
    item.system.armor.mod = ImportHelper.StringValue(jsonData, "armor").includes("+");
    return item;
  }
};

// src/module/apps/itemImport/importer/ArmorImporter.ts
var ArmorImporter = class extends DataImporter {
  constructor() {
    super(...arguments);
    this.files = ["armor.xml"];
  }
  static {
    __name(this, "ArmorImporter");
  }
  CanParse(jsonObject) {
    return jsonObject.hasOwnProperty("armors") && jsonObject["armors"].hasOwnProperty("armor");
  }
  ExtractTranslation() {
    if (!DataImporter.jsoni18n) {
      return;
    }
    let jsonArmori18n = ImportHelper.ExtractDataFileTranslation(DataImporter.jsoni18n, this.files[0]);
    this.categoryTranslations = ImportHelper.ExtractCategoriesTranslation(jsonArmori18n);
    this.armorTranslations = ImportHelper.ExtractItemTranslation(jsonArmori18n, "armors", "armor");
  }
  async Parse(jsonObject, setIcons) {
    const folders = await ImportHelper.MakeCategoryFolders(jsonObject, "Armor", this.categoryTranslations);
    const parser = new ArmorParserBase();
    let datas = [];
    let jsonDatas = jsonObject["armors"]["armor"];
    this.iconList = await this.getIconFiles();
    const parserType = "armor";
    for (let i2 = 0; i2 < jsonDatas.length; i2++) {
      let jsonData = jsonDatas[i2];
      if (DataImporter.unsupportedEntry(jsonData)) {
        continue;
      }
      let item = parser.Parse(jsonData, this.GetDefaultData({ type: parserType }));
      const category3 = ImportHelper.StringValue(jsonData, "category").toLowerCase();
      item.folder = folders[category3].id;
      item.system.importFlags = this.genImportFlags(item.name, item.type, this.formatAsSlug(category3));
      if (setIcons) {
        item.img = await this.iconAssign(item.system.importFlags, item.system, this.iconList);
      }
      ;
      item.name = ImportHelper.MapNameToTranslation(this.armorTranslations, item.name);
      UpdateActionFlow.injectActionTestsIntoChangeData(item.type, item, item);
      datas.push(item);
    }
    return await Item.create(datas);
  }
};

// src/module/apps/itemImport/importer/AmmoImporter.ts
var AmmoImporter = class extends DataImporter {
  constructor() {
    super(...arguments);
    this.files = ["gear.xml"];
  }
  static {
    __name(this, "AmmoImporter");
  }
  CanParse(jsonObject) {
    return jsonObject.hasOwnProperty("gears") && jsonObject["gears"].hasOwnProperty("gear");
  }
  ExtractTranslation() {
    if (!DataImporter.jsoni18n) {
      return;
    }
    let jsonGeari18n = ImportHelper.ExtractDataFileTranslation(DataImporter.jsoni18n, this.files[0]);
    this.categoryTranslations = ImportHelper.ExtractCategoriesTranslation(jsonGeari18n);
    this.itemTranslations = ImportHelper.ExtractItemTranslation(jsonGeari18n, "gears", "gear");
  }
  async Parse(jsonObject, setIcons) {
    let ammoDatas = [];
    let jsonAmmos = jsonObject["gears"]["gear"];
    this.iconList = await this.getIconFiles();
    const parserType = "ammo";
    for (let i2 = 0; i2 < jsonAmmos.length; i2++) {
      let jsonData = jsonAmmos[i2];
      if (DataImporter.unsupportedEntry(jsonData)) {
        continue;
      }
      if (ImportHelper.StringValue(jsonData, "category", "") !== "Ammunition") {
        continue;
      }
      let item = this.GetDefaultData({ type: parserType });
      item.name = ImportHelper.StringValue(jsonData, "name");
      item.system.importFlags = this.genImportFlags(item.name, item.type, this.formatAsSlug(item.name.split(":")[0]));
      if (setIcons) {
        item.img = await this.iconAssign(item.system.importFlags, item.system, this.iconList);
      }
      ;
      item.system.description.source = `${ImportHelper.StringValue(jsonData, "source")} ${ImportHelper.StringValue(jsonData, "page")}`;
      item.system.technology.rating = 2;
      item.system.technology.availability = ImportHelper.StringValue(jsonData, "avail");
      item.system.technology.cost = ImportHelper.IntValue(jsonData, "cost", 0);
      let bonusData = ImportHelper.ObjectValue(jsonData, "weaponbonus", null);
      if (bonusData !== void 0 && bonusData !== null) {
        item.system.ap = ImportHelper.IntValue(bonusData, "ap", 0);
        item.system.damage = ImportHelper.IntValue(bonusData, "damage", 0);
        let damageType = ImportHelper.StringValue(bonusData, "damagetype", "");
        if (damageType.length > 0) {
          if (damageType.includes("P")) {
            item.system.damageType = "physical";
          } else if (damageType.includes("S")) {
            item.system.damageType = "stun";
          } else if (damageType.includes("M")) {
            item.system.damageType = "matrix";
          }
        }
      }
      let shouldLookForWeapons = false;
      let nameLower = item.name.toLowerCase();
      ["grenade", "rocket", "missile"].forEach((compare) => {
        shouldLookForWeapons = shouldLookForWeapons || nameLower.includes(compare);
      });
      if (shouldLookForWeapons) {
        let foundWeapon = ImportHelper.findItem((item2) => {
          if (!item2 || !item2.name) return false;
          return item2.type === "weapon" && item2.name.toLowerCase() === nameLower;
        });
        if (foundWeapon != null && "action" in foundWeapon.system) {
          const weaponData = foundWeapon.system;
          item.system.damage = weaponData.action.damage.value;
          item.system.ap = weaponData.action.damage.ap.value;
        }
      }
      item.system.technology.conceal.base = 0;
      item.name = ImportHelper.MapNameToTranslation(this.itemTranslations, item.name);
      UpdateActionFlow.injectActionTestsIntoChangeData(item.type, item, item);
      ammoDatas.push(item);
    }
    for (let i2 = 0; i2 < ammoDatas.length; i2++) {
      let folderName = "Misc";
      let ammo = ammoDatas[i2];
      let splitName = ammo.name.split(":");
      if (splitName.length > 1) {
        folderName = splitName[0].trim();
      }
      let folder = await ImportHelper.GetFolderAtPath(`${Constants.ROOT_IMPORT_FOLDER_NAME}/Ammo/${folderName}`, true);
      ammo.folder = folder.id;
    }
    return await Item.create(ammoDatas);
  }
};

// src/module/apps/itemImport/parser/mod/ModParserBase.ts
var ModParserBase = class extends TechnologyItemParserBase {
  static {
    __name(this, "ModParserBase");
  }
  Parse(jsonData, item) {
    item = super.Parse(jsonData, item);
    item.system.type = "weapon";
    item.system.mount_point = ImportHelper.StringValue(jsonData, "mount");
    item.system.rc = ImportHelper.IntValue(jsonData, "rc", 0);
    item.system.accuracy = ImportHelper.IntValue(jsonData, "accuracy", 0);
    item.system.technology.conceal.base = ImportHelper.IntValue(jsonData, "conceal", 0);
    return item;
  }
};

// src/module/apps/itemImport/importer/ModImporter.ts
var ModImporter = class extends DataImporter {
  constructor() {
    super(...arguments);
    this.files = ["weapons.xml"];
  }
  static {
    __name(this, "ModImporter");
  }
  CanParse(jsonObject) {
    return jsonObject.hasOwnProperty("accessories") && jsonObject["accessories"].hasOwnProperty("accessory");
  }
  ExtractTranslation() {
    if (!DataImporter.jsoni18n) {
      return;
    }
    let jsonWeaponsi18n = ImportHelper.ExtractDataFileTranslation(DataImporter.jsoni18n, this.files[0]);
    this.accessoryTranslations = ImportHelper.ExtractItemTranslation(jsonWeaponsi18n, "accessories", "accessory");
  }
  async Parse(jsonObject, setIcons) {
    const parser = new ModParserBase();
    let datas = [];
    let jsonDatas = jsonObject["accessories"]["accessory"];
    this.iconList = await this.getIconFiles();
    const parserType = "modification";
    for (let i2 = 0; i2 < jsonDatas.length; i2++) {
      let jsonData = jsonDatas[i2];
      if (DataImporter.unsupportedEntry(jsonData)) {
        continue;
      }
      let item = parser.Parse(jsonData, this.GetDefaultData({ type: parserType }));
      let folderName = item.system.mount_point !== void 0 ? item.system.mount_point : "Other";
      if (folderName.includes("/")) {
        let splitName = folderName.split("/");
        folderName = splitName[0];
      }
      let folder = await ImportHelper.GetFolderAtPath(`${Constants.ROOT_IMPORT_FOLDER_NAME}/Mods/${folderName}`, true);
      item.folder = folder.id;
      item.system.importFlags = this.genImportFlags(item.name, item.type, this.formatAsSlug(folderName));
      if (setIcons) {
        item.img = await this.iconAssign(item.system.importFlags, item.system, this.iconList);
      }
      ;
      item.name = ImportHelper.MapNameToTranslation(this.accessoryTranslations, item.name);
      UpdateActionFlow.injectActionTestsIntoChangeData(item.type, item, item);
      datas.push(item);
    }
    return await Item.create(datas);
  }
};

// src/module/apps/itemImport/parser/spell/SpellParserBase.ts
var SpellParserBase = class extends ItemParserBase {
  static {
    __name(this, "SpellParserBase");
  }
  Parse(jsonData, item, jsonTranslation) {
    item.name = ImportHelper.StringValue(jsonData, "name");
    item.system.description.source = `${ImportHelper.StringValue(jsonData, "source")} ${ImportHelper.StringValue(jsonData, "page")}`;
    item.system.category = ImportHelper.StringValue(jsonData, "category").toLowerCase();
    let damage = ImportHelper.StringValue(jsonData, "damage");
    if (damage === "P") {
      item.system.action.damage.type.base = "physical";
      item.system.action.damage.type.value = "physical";
    } else if (damage === "S") {
      item.system.action.damage.type.base = "stun";
      item.system.action.damage.type.value = "stun";
    }
    let duration = ImportHelper.StringValue(jsonData, "duration");
    if (duration === "I") {
      item.system.duration = "instant";
    } else if (duration === "S") {
      item.system.duration = "sustained";
    } else if (duration === "P") {
      item.system.duration = "permanent";
    }
    let drain = ImportHelper.StringValue(jsonData, "dv");
    if (drain.includes("+") || drain.includes("-")) {
      item.system.drain = parseInt(drain.substring(1, drain.length));
    }
    let range = ImportHelper.StringValue(jsonData, "range");
    if (range === "T") {
      item.system.range = "touch";
    } else if (range === "LOS") {
      item.system.range = "los";
    } else if (range === "LOS (A)") {
      item.system.range = "los_a";
    }
    let type = ImportHelper.StringValue(jsonData, "type");
    if (type === "P") {
      item.system.type = "physical";
    } else if (type === "M") {
      item.system.type = "mana";
    }
    if (jsonTranslation) {
      const origName = ImportHelper.StringValue(jsonData, "name");
      item.name = ImportHelper.MapNameToTranslation(jsonTranslation, origName);
      item.system.description.source = `${ImportHelper.StringValue(jsonData, "source")} ${ImportHelper.MapNameToPageSource(jsonTranslation, origName)}`;
    }
    return item;
  }
};

// src/module/apps/itemImport/parser/spell/CombatSpellParser.ts
var CombatSpellParser = class extends SpellParserBase {
  static {
    __name(this, "CombatSpellParser");
  }
  Parse(jsonData, item, jsonTranslation) {
    item = super.Parse(jsonData, item, jsonTranslation);
    let descriptor = ImportHelper.StringValue(jsonData, "descriptor");
    if (descriptor === void 0) {
      descriptor = "";
    }
    item.system.combat.type = descriptor.includes("Indirect") ? "indirect" : "direct";
    return item;
  }
};

// src/module/apps/itemImport/parser/spell/ManipulationSpellParser.ts
var ManipulationSpellParser = class extends SpellParserBase {
  static {
    __name(this, "ManipulationSpellParser");
  }
  Parse(jsonData, item, jsonTranslation) {
    item = super.Parse(jsonData, item, jsonTranslation);
    let descriptor = ImportHelper.StringValue(jsonData, "descriptor", "");
    if (descriptor === void 0) {
      descriptor = "";
    }
    item.system.manipulation.environmental = descriptor.includes("Environmental");
    item.system.manipulation.mental = descriptor.includes("Mental");
    if (item.system.manipulation.mental) {
      item.system.action.opposed.type = "custom";
      item.system.action.opposed.attribute = "logic";
      item.system.action.opposed.attribute2 = "willpower";
    }
    item.system.manipulation.physical = descriptor.includes("Physical");
    if (item.system.manipulation.physical) {
      item.system.action.opposed.type = "custom";
      item.system.action.opposed.attribute = "body";
      item.system.action.opposed.attribute2 = "strength";
    }
    item.system.manipulation.damaging = descriptor.includes("Damaging");
    if (item.system.manipulation.damaging) {
      item.system.action.opposed.type = "soak";
    }
    return item;
  }
};

// src/module/apps/itemImport/parser/spell/IllusionSpellParser.ts
var IllusionSpellParser = class extends SpellParserBase {
  static {
    __name(this, "IllusionSpellParser");
  }
  Parse(jsonData, item, jsonTranslation) {
    item = super.Parse(jsonData, item, jsonTranslation);
    let descriptor = ImportHelper.StringValue(jsonData, "descriptor");
    if (descriptor === void 0) {
      descriptor = "";
    }
    if (item.system.type === "mana") {
      item.system.action.opposed.type = "custom";
      item.system.action.opposed.attribute = "logic";
      item.system.action.opposed.attribute2 = "willpower";
    } else if (item.system.type === "physical") {
      item.system.action.opposed.type = "custom";
      item.system.action.opposed.attribute = "intuition";
      item.system.action.opposed.attribute2 = "logic";
    }
    return item;
  }
};

// src/module/apps/itemImport/parser/spell/DetectionSpellImporter.ts
var DetectionSpellImporter = class extends SpellParserBase {
  static {
    __name(this, "DetectionSpellImporter");
  }
  Parse(jsonData, item, jsonTranslation) {
    item = super.Parse(jsonData, item, jsonTranslation);
    let descriptor = ImportHelper.StringValue(jsonData, "descriptor");
    if (descriptor === void 0) {
      descriptor = "";
    }
    item.system.detection.passive = descriptor.includes("Passive");
    if (!item.system.detection.passive) {
      item.system.action.opposed.type = "custom";
      item.system.action.opposed.attribute = "willpower";
      item.system.action.opposed.attribute2 = "logic";
    }
    item.system.detection.extended = descriptor.includes("Extended");
    if (descriptor.includes("Psychic")) {
      item.system.detection.type = "psychic";
    } else if (descriptor.includes("Directional")) {
      item.system.detection.type = "directional";
    } else if (descriptor.includes("Area")) {
      item.system.detection.type = "area";
    }
    return item;
  }
};

// src/module/apps/itemImport/importer/SpellImporter.ts
var SpellImporter = class extends DataImporter {
  constructor() {
    super(...arguments);
    this.files = ["spells.xml"];
  }
  static {
    __name(this, "SpellImporter");
  }
  CanParse(jsonObject) {
    return jsonObject.hasOwnProperty("spells") && jsonObject["spells"].hasOwnProperty("spell");
  }
  GetDefaultData({ type }) {
    const systemData = { action: { type: "varies", attribute: "magic", skill: "spellcasting" } };
    return DataDefaults.baseItemData({ type }, systemData);
  }
  ExtractTranslation() {
    if (!DataImporter.jsoni18n) {
      return;
    }
    let jsonSpelli18n = ImportHelper.ExtractDataFileTranslation(DataImporter.jsoni18n, this.files[0]);
    this.categoryTranslations = ImportHelper.ExtractCategoriesTranslation(jsonSpelli18n);
    this.itemTranslations = ImportHelper.ExtractItemTranslation(jsonSpelli18n, "spells", "spell");
  }
  async Parse(jsonObject, setIcons) {
    const folders = await ImportHelper.MakeCategoryFolders(jsonObject, "Spells", this.categoryTranslations);
    const parser = new ParserMap("category", [
      { key: "Combat", value: new CombatSpellParser() },
      { key: "Manipulation", value: new ManipulationSpellParser() },
      { key: "Illusion", value: new IllusionSpellParser() },
      { key: "Detection", value: new DetectionSpellImporter() },
      { key: "Health", value: new SpellParserBase() },
      { key: "Enchantments", value: new SpellParserBase() },
      { key: "Rituals", value: new SpellParserBase() }
    ]);
    let items = [];
    let jsonDatas = jsonObject["spells"]["spell"];
    this.iconList = await this.getIconFiles();
    const parserType = "spell";
    for (let i2 = 0; i2 < jsonDatas.length; i2++) {
      let jsonData = jsonDatas[i2];
      if (DataImporter.unsupportedEntry(jsonData)) {
        continue;
      }
      let item = parser.Parse(jsonData, this.GetDefaultData({ type: parserType }), this.itemTranslations);
      item.folder = folders[item.system.category].id;
      item.system.importFlags = this.genImportFlags(item.name, item.type, item.system.category);
      if (setIcons) {
        item.img = await this.iconAssign(item.system.importFlags, item.system, this.iconList);
      }
      ;
      item.name = ImportHelper.MapNameToTranslation(this.itemTranslations, item.name);
      UpdateActionFlow.injectActionTestsIntoChangeData(item.type, item, item);
      items.push(item);
    }
    return await Item.create(items);
  }
};

// src/module/apps/itemImport/parser/quality/QualityParserBase.ts
var QualityParserBase = class extends ItemParserBase {
  static {
    __name(this, "QualityParserBase");
  }
  Parse(jsonData, item, jsonTranslation) {
    item.name = ImportHelper.StringValue(jsonData, "name");
    item.system.description.source = `${ImportHelper.StringValue(jsonData, "source")} ${ImportHelper.StringValue(jsonData, "page")}`;
    item.system.type = ImportHelper.StringValue(jsonData, "category") === "Positive" ? "positive" : "negative";
    if (jsonTranslation) {
      const origName = ImportHelper.StringValue(jsonData, "name");
      item.name = ImportHelper.MapNameToTranslation(jsonTranslation, origName);
      item.system.description.source = `${ImportHelper.StringValue(jsonData, "source")} ${ImportHelper.MapNameToPageSource(jsonTranslation, origName)}`;
    }
    return item;
  }
};

// src/module/apps/itemImport/importer/QualityImporter.ts
var QualityImporter = class extends DataImporter {
  constructor() {
    super(...arguments);
    this.files = ["qualities.xml"];
  }
  static {
    __name(this, "QualityImporter");
  }
  CanParse(jsonObject) {
    return jsonObject.hasOwnProperty("qualities") && jsonObject["qualities"].hasOwnProperty("quality");
  }
  ExtractTranslation() {
    if (!DataImporter.jsoni18n) {
      return;
    }
    let jsonQualityi18n = ImportHelper.ExtractDataFileTranslation(DataImporter.jsoni18n, this.files[0]);
    this.categoryTranslations = ImportHelper.ExtractCategoriesTranslation(jsonQualityi18n);
    this.itemTranslations = ImportHelper.ExtractItemTranslation(jsonQualityi18n, "qualities", "quality");
  }
  async Parse(jsonObject, setIcons) {
    const jsonNameTranslations = {};
    const folders = await ImportHelper.MakeCategoryFolders(jsonObject, "Qualities", this.categoryTranslations);
    const parser = new QualityParserBase();
    let items = [];
    let jsonDatas = jsonObject["qualities"]["quality"];
    this.iconList = await this.getIconFiles();
    const parserType = "quality";
    for (let i2 = 0; i2 < jsonDatas.length; i2++) {
      let jsonData = jsonDatas[i2];
      if (DataImporter.unsupportedEntry(jsonData)) {
        continue;
      }
      let item = parser.Parse(jsonData, this.GetDefaultData({ type: parserType }), this.itemTranslations);
      let category3 = ImportHelper.StringValue(jsonData, "category").toLowerCase();
      item.folder = folders[category3].id;
      item.system.importFlags = this.genImportFlags(item.name, item.type, this.formatAsSlug(category3));
      if (setIcons) {
        item.img = await this.iconAssign(item.system.importFlags, item.system, this.iconList);
      }
      ;
      item.name = ImportHelper.MapNameToTranslation(this.itemTranslations, item.name);
      UpdateActionFlow.injectActionTestsIntoChangeData(item.type, item, item);
      items.push(item);
    }
    return await Item.create(items);
  }
};

// src/module/apps/itemImport/parser/complex-form/ComplexFormParserBase.ts
var ComplexFormParserBase = class extends ItemParserBase {
  static {
    __name(this, "ComplexFormParserBase");
  }
  Parse(jsonData, item, jsonTranslation) {
    item.name = ImportHelper.StringValue(jsonData, "name");
    item.system.description.source = `${ImportHelper.StringValue(jsonData, "source")} ${ImportHelper.StringValue(jsonData, "page")}`;
    let fade = ImportHelper.StringValue(jsonData, "fv");
    if (fade.includes("+") || fade.includes("-")) {
      item.system.fade = parseInt(fade.substring(1, fade.length));
    }
    let duration = ImportHelper.StringValue(jsonData, "duration");
    if (duration === "I") {
      item.system.duration = "instant";
    } else if (duration === "S") {
      item.system.duration = "sustained";
    } else if (duration === "P") {
      item.system.duration = "permanent";
    }
    let target = ImportHelper.StringValue(jsonData, "target");
    switch (target) {
      case "Device":
      case "File":
      case "Host":
      case "Persona":
      case "Self":
      case "Sprite":
        item.system.target = target.toLowerCase();
        break;
      default:
        item.system.target = "other";
        break;
    }
    if (jsonTranslation) {
      const origName = ImportHelper.StringValue(jsonData, "name");
      item.name = ImportHelper.MapNameToTranslation(jsonTranslation, origName);
      item.system.description.source = `${ImportHelper.StringValue(jsonData, "source")} ${ImportHelper.MapNameToPageSource(jsonTranslation, origName)}`;
    }
    return item;
  }
};

// src/module/apps/itemImport/importer/ComplexFormImporter.ts
var ComplexFormImporter = class extends DataImporter {
  constructor() {
    super(...arguments);
    this.files = ["complexforms.xml"];
  }
  static {
    __name(this, "ComplexFormImporter");
  }
  CanParse(jsonObject) {
    return jsonObject.hasOwnProperty("complexforms") && jsonObject["complexforms"].hasOwnProperty("complexform");
  }
  GetDefaultData({ type }) {
    const systemData = { action: { type: "complex", attribute: "resonance", skill: "compiling" } };
    return DataDefaults.baseItemData({ type }, systemData);
  }
  ExtractTranslation() {
    if (!DataImporter.jsoni18n) {
      return;
    }
    let jsonItemi18n = ImportHelper.ExtractDataFileTranslation(DataImporter.jsoni18n, this.files[0]);
    this.nameTranslations = ImportHelper.ExtractItemTranslation(jsonItemi18n, "complexforms", "complexform");
  }
  async Parse(jsonObject, setIcons) {
    const parser = new ComplexFormParserBase();
    const folder = await ImportHelper.GetFolderAtPath(`${Constants.ROOT_IMPORT_FOLDER_NAME}/Complex Forms`, true);
    let items = [];
    let jsonDatas = jsonObject["complexforms"]["complexform"];
    this.iconList = await this.getIconFiles();
    const parserType = "complex_form";
    for (let i2 = 0; i2 < jsonDatas.length; i2++) {
      let jsonData = jsonDatas[i2];
      if (DataImporter.unsupportedEntry(jsonData)) {
        continue;
      }
      let item = parser.Parse(jsonData, this.GetDefaultData({ type: parserType }), this.nameTranslations);
      item.folder = folder.id;
      item.system.importFlags = this.genImportFlags(item.name, item.type, "");
      if (setIcons) {
        item.img = await this.iconAssign(item.system.importFlags, item.system, this.iconList);
      }
      ;
      item.name = ImportHelper.MapNameToTranslation(this.nameTranslations, item.name);
      UpdateActionFlow.injectActionTestsIntoChangeData(item.type, item, item);
      items.push(item);
    }
    return await Item.create(items);
  }
};

// src/module/apps/itemImport/parser/ware/CyberwareParser.ts
var CyberwareParser = class extends TechnologyItemParserBase {
  static {
    __name(this, "CyberwareParser");
  }
  Parse(jsonData, item, jsonTranslation) {
    item = super.Parse(jsonData, item, jsonTranslation);
    const essence = ImportHelper.StringValue(jsonData, "ess", "0").match(/[0-9]\.?[0-9]*/g);
    if (essence !== null) {
      item.system.essence = parseFloat(essence[0]);
    }
    const capacity = ImportHelper.StringValue(jsonData, "capacity", "0").match(/[0-9]+/g);
    if (capacity !== null) {
      item.system.capacity = parseInt(capacity[0]);
    }
    return item;
  }
};

// src/module/apps/itemImport/importer/WareImporter.ts
var WareImporter = class extends DataImporter {
  constructor() {
    super(...arguments);
    this.files = ["cyberware.xml", "bioware.xml"];
  }
  static {
    __name(this, "WareImporter");
  }
  CanParse(jsonObject) {
    return jsonObject.hasOwnProperty("cyberwares") && jsonObject["cyberwares"].hasOwnProperty("cyberware") || jsonObject.hasOwnProperty("biowares") && jsonObject["biowares"].hasOwnProperty("bioware");
  }
  GetDefaultCyberwareData() {
    return this.GetDefaultData({ type: "cyberware" });
  }
  GetDefaultBiowareData() {
    return this.GetDefaultData({ type: "bioware" });
  }
  ExtractTranslation(fileName) {
    if (!DataImporter.jsoni18n) {
      return;
    }
    let jsonItemi18n = ImportHelper.ExtractDataFileTranslation(DataImporter.jsoni18n, fileName);
    if (this.files.length !== 2) console.error("Lazily hacked code will fail for more or less than two files.");
    this.categoryTranslations = ImportHelper.ExtractCategoriesTranslation(jsonItemi18n);
    const { typeKey, listKey } = fileName === "cyberware.xml" ? { typeKey: "cyberwares", listKey: "cyberware" } : { typeKey: "biowares", listKey: "bioware" };
    this.itemTranslations = ImportHelper.ExtractItemTranslation(jsonItemi18n, typeKey, listKey);
  }
  async Parse(jsonObject, setIcons) {
    const cyberParser = new CyberwareParser();
    let key = jsonObject.hasOwnProperty("cyberwares") ? "Cyberware" : "Bioware";
    const folders = await ImportHelper.MakeCategoryFolders(jsonObject, key);
    key = key.toLowerCase();
    let items = [];
    let jsonDatas = jsonObject[key + "s"][key];
    this.iconList = await this.getIconFiles();
    for (let i2 = 0; i2 < jsonDatas.length; i2++) {
      let jsonData = jsonDatas[i2];
      if (DataImporter.unsupportedEntry(jsonData)) {
        continue;
      }
      const defaultData = key === "cyberware" ? this.GetDefaultCyberwareData() : this.GetDefaultBiowareData();
      let item = cyberParser.Parse(jsonData, defaultData, this.itemTranslations);
      const category3 = ImportHelper.StringValue(jsonData, "category").toLowerCase();
      item.folder = folders[category3].id;
      if (key === "bioware") {
        item.system.technology.wireless = false;
      }
      item.system.importFlags = this.genImportFlags(item.name, item.type, this.formatAsSlug(category3));
      if (setIcons) {
        item.img = await this.iconAssign(item.system.importFlags, item.system, this.iconList);
      }
      ;
      item.name = ImportHelper.MapNameToTranslation(this.itemTranslations, item.name);
      UpdateActionFlow.injectActionTestsIntoChangeData(item.type, item, item);
      items.push(item);
    }
    return await Item.create(items);
  }
};

// src/module/apps/itemImport/parser/critter-power/CritterPowerParserBase.ts
var CritterPowerParserBase = class extends ItemParserBase {
  static {
    __name(this, "CritterPowerParserBase");
  }
  Parse(jsonData, item, jsonTranslation) {
    item.name = ImportHelper.StringValue(jsonData, "name");
    item.system.description.source = `${ImportHelper.StringValue(jsonData, "source")} ${ImportHelper.StringValue(jsonData, "page")}`;
    item.system.category = ImportHelper.StringValue(jsonData, "category").toLowerCase();
    let duration = ImportHelper.StringValue(jsonData, "duration");
    if (duration === "Always") {
      item.system.duration = "always";
    } else if (duration === "Instant") {
      item.system.duration = "instant";
    } else if (duration === "Sustained") {
      item.system.duration = "sustained";
    } else if (duration === "Permanent") {
      item.system.duration = "permanent";
    } else {
      item.system.duration = "special";
    }
    let range = ImportHelper.StringValue(jsonData, "range");
    if (range === "T") {
      item.system.range = "touch";
    } else if (range === "LOS") {
      item.system.range = "los";
    } else if (range === "LOS (A)") {
      item.system.range = "los_a";
    } else if (range === "Self") {
      item.system.range = "self";
    } else {
      item.system.range = "special";
    }
    let type = ImportHelper.StringValue(jsonData, "type");
    if (type === "P") {
      item.system.powerType = "physical";
    } else if (type === "M") {
      item.system.powerType = "mana";
    }
    if (jsonTranslation) {
      const origName = ImportHelper.StringValue(jsonData, "name");
      item.name = ImportHelper.MapNameToTranslation(jsonTranslation, origName);
      item.system.description.source = `${ImportHelper.StringValue(jsonData, "source")} ${ImportHelper.MapNameToPageSource(jsonTranslation, origName)}`;
    }
    return item;
  }
};

// src/module/apps/itemImport/importer/CritterPowerImporter.ts
var CritterPowerImporter = class extends DataImporter {
  constructor() {
    super(...arguments);
    this.files = ["critterpowers.xml"];
    this.unsupportedCategories = [
      "Emergent"
    ];
  }
  static {
    __name(this, "CritterPowerImporter");
  }
  CanParse(jsonObject) {
    return jsonObject.hasOwnProperty("powers") && jsonObject["powers"].hasOwnProperty("power");
  }
  ExtractTranslation() {
    if (!DataImporter.jsoni18n) {
      return;
    }
    let jsonCritterPoweri18n = ImportHelper.ExtractDataFileTranslation(DataImporter.jsoni18n, this.files[0]);
    this.categoryTranslations = ImportHelper.ExtractCategoriesTranslation(jsonCritterPoweri18n);
    this.itemTranslations = ImportHelper.ExtractItemTranslation(jsonCritterPoweri18n, "powers", "power");
  }
  async Parse(chummerPowers, setIcons) {
    const parser = new CritterPowerParserBase();
    const folder = await ImportHelper.GetFolderAtPath(`${Constants.ROOT_IMPORT_FOLDER_NAME}/${game.i18n.localize("TYPES.Item.critter_power")}`, true);
    const items = [];
    const chummerCritterPowers = this.filterObjects(chummerPowers["powers"]["power"]);
    this.iconList = await this.getIconFiles();
    const parserType = "critter_power";
    for (const chummerCritterPower of chummerCritterPowers) {
      if (DataImporter.unsupportedEntry(chummerCritterPower)) {
        continue;
      }
      const item = parser.Parse(chummerCritterPower, this.GetDefaultData({ type: parserType }), this.itemTranslations);
      item.folder = folder.id;
      item.system.importFlags = this.genImportFlags(item.name, item.type, item.system.powerType);
      if (setIcons) {
        item.img = await this.iconAssign(item.system.importFlags, item.system, this.iconList);
      }
      ;
      item.name = ImportHelper.MapNameToTranslation(this.itemTranslations, item.name);
      UpdateActionFlow.injectActionTestsIntoChangeData(item.type, item, item);
      items.push(item);
    }
    return await Item.create(items);
  }
};

// src/module/apps/itemImport/importer/DeviceImporter.ts
var DeviceImporter = class extends DataImporter {
  constructor() {
    super(...arguments);
    this.files = ["gear.xml"];
  }
  static {
    __name(this, "DeviceImporter");
  }
  CanParse(jsonObject) {
    return jsonObject.hasOwnProperty("gears") && jsonObject["gears"].hasOwnProperty("gear");
  }
  ExtractTranslation(fileName) {
    if (!DataImporter.jsoni18n) {
      return;
    }
    let jsonGeari18n = ImportHelper.ExtractDataFileTranslation(DataImporter.jsoni18n, this.files[0]);
    this.categoryTranslations = ImportHelper.ExtractCategoriesTranslation(jsonGeari18n);
    this.itemTranslations = ImportHelper.ExtractItemTranslation(jsonGeari18n, "gears", "gear");
  }
  async ParseCommlinkDevices(commlinks, folder, setIcons) {
    const entries = [];
    this.iconList = await this.getIconFiles();
    const parserType = "device";
    for (const commlink of commlinks) {
      if (DataImporter.unsupportedEntry(commlink)) {
        continue;
      }
      const item = this.GetDefaultData({ type: parserType });
      item.name = ImportHelper.StringValue(commlink, "name");
      item.folder = folder.id;
      item.system.importFlags = this.genImportFlags(item.name, parserType, item.system.category);
      if (setIcons) {
        item.img = await this.iconAssign(item.system.importFlags, item.system, this.iconList);
      }
      ;
      item.system.description.source = `${ImportHelper.StringValue(commlink, "source")} ${ImportHelper.MapNameToPageSource(this.itemTranslations, ImportHelper.StringValue(commlink, "name"), ImportHelper.StringValue(commlink, "page"))}`;
      item.system.technology.rating = ImportHelper.IntValue(commlink, "devicerating", 0);
      item.system.technology.availability = ImportHelper.StringValue(commlink, "avail");
      item.system.technology.cost = ImportHelper.IntValue(commlink, "cost", 0);
      item.system.atts.att3.value = ImportHelper.IntValue(commlink, "dataprocessing", 0);
      item.system.atts.att4.value = ImportHelper.IntValue(commlink, "firewall", 0);
      item.name = ImportHelper.MapNameToTranslation(this.itemTranslations, item.name);
      UpdateActionFlow.injectActionTestsIntoChangeData(item.type, item, item);
      entries.push(item);
    }
    return entries;
  }
  async ParseRCCDevices(rccs, folder, setIcons) {
    const entries = [];
    this.iconList = await this.getIconFiles();
    const parserType = "device";
    for (const rcc of rccs) {
      if (DataImporter.unsupportedEntry(rcc)) {
        continue;
      }
      const item = this.GetDefaultData({ type: parserType });
      item.system.category = "rcc";
      item.name = ImportHelper.StringValue(rcc, "name");
      item.folder = folder.id;
      item.system.importFlags = this.genImportFlags(item.name, parserType, item.system.category);
      if (setIcons) {
        item.img = await this.iconAssign(item.system.importFlags, item.system, this.iconList);
      }
      ;
      item.system.description.source = `${ImportHelper.StringValue(rcc, "source")} ${ImportHelper.MapNameToPageSource(this.itemTranslations, ImportHelper.StringValue(rcc, "name"), ImportHelper.StringValue(rcc, "page"))}`;
      item.system.technology.rating = ImportHelper.IntValue(rcc, "devicerating", 0);
      item.system.technology.availability = ImportHelper.StringValue(rcc, "avail");
      item.system.technology.cost = ImportHelper.IntValue(rcc, "cost", 0);
      item.system.atts.att3.value = ImportHelper.IntValue(rcc, "dataprocessing", 0);
      item.system.atts.att4.value = ImportHelper.IntValue(rcc, "firewall", 0);
      item.name = ImportHelper.MapNameToTranslation(this.itemTranslations, item.name);
      UpdateActionFlow.injectActionTestsIntoChangeData(item.type, item, item);
      entries.push(item);
    }
    return entries;
  }
  async ParseCyberdeckDevices(cyberdecks, folder, setIcons) {
    const items = [];
    this.iconList = await this.getIconFiles();
    const parserType = "device";
    for (const cyberdeck of cyberdecks) {
      if (DataImporter.unsupportedEntry(cyberdeck)) {
        continue;
      }
      const item = this.GetDefaultData({ type: parserType });
      item.system.category = "cyberdeck";
      item.name = ImportHelper.StringValue(cyberdeck, "name");
      item.folder = folder.id;
      item.system.importFlags = this.genImportFlags(item.name, parserType, item.system.category);
      if (setIcons) {
        item.img = await this.iconAssign(item.system.importFlags, item.system, this.iconList);
      }
      ;
      item.system.description.source = `${ImportHelper.StringValue(cyberdeck, "source")} ${ImportHelper.MapNameToPageSource(this.itemTranslations, ImportHelper.StringValue(cyberdeck, "name"), ImportHelper.StringValue(cyberdeck, "page"))}`;
      item.system.technology.rating = ImportHelper.IntValue(cyberdeck, "devicerating", 0);
      item.system.technology.availability = ImportHelper.StringValue(cyberdeck, "avail");
      item.system.technology.cost = ImportHelper.IntValue(cyberdeck, "cost", 0);
      if (cyberdeck.hasOwnProperty("attributearray")) {
        const attributeOrder = ImportHelper.StringValue(cyberdeck, "attributearray").split(",");
        const att1 = Number(attributeOrder[0]);
        const att2 = Number(attributeOrder[1]);
        const att3 = Number(attributeOrder[2]);
        const att4 = Number(attributeOrder[3]);
        item.system.atts.att1.value = att1;
        item.system.atts.att2.value = att2;
        item.system.atts.att3.value = att3;
        item.system.atts.att4.value = att4;
      } else if (cyberdeck.hasOwnProperty("attack")) {
        item.system.atts.att1.value = ImportHelper.IntValue(cyberdeck, "attack", 0);
        item.system.atts.att2.value = ImportHelper.IntValue(cyberdeck, "sleaze", 0);
        item.system.atts.att3.value = ImportHelper.IntValue(cyberdeck, "dataprocessing", 0);
        item.system.atts.att4.value = ImportHelper.IntValue(cyberdeck, "firewall", 0);
      }
      item.name = ImportHelper.MapNameToTranslation(this.itemTranslations, item.name);
      UpdateActionFlow.injectActionTestsIntoChangeData(item.type, item, item);
      items.push(item);
    }
    return items;
  }
  async Parse(jsonObject, setIcons) {
    let entries = [];
    const commlinks = jsonObject["gears"]["gear"].filter((gear) => ImportHelper.StringValue(gear, "category", "") === "Commlinks");
    const cyberdecks = jsonObject["gears"]["gear"].filter((gear) => ImportHelper.StringValue(gear, "category", "") === "Cyberdecks");
    const rccs = jsonObject["gears"]["gear"].filter((gear) => ImportHelper.StringValue(gear, "category", "") === "Rigger Command Consoles");
    let commlinksFolder = await ImportHelper.GetFolderAtPath(`${Constants.ROOT_IMPORT_FOLDER_NAME}/${game.i18n.localize("SR6.DeviceCatCommlink")}`, true);
    let cyberdecksFolder = await ImportHelper.GetFolderAtPath(`${Constants.ROOT_IMPORT_FOLDER_NAME}/${game.i18n.localize("SR6.DeviceCatCyberdeck")}`, true);
    let rccsFolder = await ImportHelper.GetFolderAtPath(`${Constants.ROOT_IMPORT_FOLDER_NAME}/${game.i18n.localize("SR6.DeviceCatRCC")}`, true);
    entries = entries.concat(await this.ParseCommlinkDevices(commlinks, commlinksFolder, setIcons));
    entries = entries.concat(await this.ParseCyberdeckDevices(cyberdecks, cyberdecksFolder, setIcons));
    entries = entries.concat(await this.ParseRCCDevices(rccs, rccsFolder, setIcons));
    return await Item.create(entries);
  }
  /* List of unsupported Commlinks, due to dynamics value calculations.
   */
  static unsupportedEntry(jsonData) {
    if (DataImporter.unsupportedEntry(jsonData)) {
      return true;
    }
    const unsupportedIds = [
      "d63eb841-7b15-4539-9026-b90a4924aeeb"
      // Dynamic rating value.
    ];
    return unsupportedIds.includes(ImportHelper.StringValue(jsonData, "id"));
  }
};

// src/module/apps/itemImport/importer/EquipmentImporter.ts
var EquipmentImporter = class extends DataImporter {
  constructor() {
    super(...arguments);
    this.files = ["gear.xml"];
    this.unsupportedCategories = [
      "Ammunition",
      "Commlinks",
      "Cyberdecks",
      "Hacking Programs",
      "Common Programs",
      "Rigger Command Consoles",
      "Custom"
    ];
  }
  static {
    __name(this, "EquipmentImporter");
  }
  CanParse(jsonObject) {
    return jsonObject.hasOwnProperty("gears") && jsonObject["gears"].hasOwnProperty("gear");
  }
  ExtractTranslation(fileName) {
    if (!DataImporter.jsoni18n) {
      return;
    }
    let jsonGeari18n = ImportHelper.ExtractDataFileTranslation(DataImporter.jsoni18n, this.files[0]);
    this.categoryTranslations = ImportHelper.ExtractCategoriesTranslation(jsonGeari18n);
    this.itemTranslations = ImportHelper.ExtractItemTranslation(jsonGeari18n, "gears", "gear");
  }
  async ParseEquipment(equipments, setIcons) {
    const items = [];
    this.iconList = await this.getIconFiles();
    const parserType = "equipment";
    for (const equipment of equipments) {
      if (DataImporter.unsupportedEntry(equipment)) {
        continue;
      }
      const item = this.GetDefaultData({ type: parserType });
      item.name = ImportHelper.StringValue(equipment, "name");
      const categoryEN = ImportHelper.StringValue(equipment, "category");
      const category3 = ImportHelper.TranslateCategory(categoryEN, this.categoryTranslations).replace("/", " ");
      let categoryFolder = await ImportHelper.GetFolderAtPath(`${Constants.ROOT_IMPORT_FOLDER_NAME}/${game.i18n.localize("SR6.Gear")}/${category3}`, true);
      item.folder = categoryFolder.id;
      item.system.importFlags = this.genImportFlags(item.name, item.type, this.formatAsSlug(categoryEN));
      if (setIcons) {
        item.img = await this.iconAssign(item.system.importFlags, item.system, this.iconList);
      }
      ;
      item.system.description.source = `${ImportHelper.StringValue(equipment, "source")} ${ImportHelper.MapNameToPageSource(this.itemTranslations, ImportHelper.StringValue(equipment, "name"), ImportHelper.StringValue(equipment, "page"))}`;
      item.system.technology.rating = ImportHelper.IntValue(equipment, "rating", 0);
      item.system.technology.availability = ImportHelper.StringValue(equipment, "avail");
      item.system.technology.cost = ImportHelper.IntValue(equipment, "cost", 0);
      item.name = ImportHelper.MapNameToTranslation(this.itemTranslations, item.name);
      UpdateActionFlow.injectActionTestsIntoChangeData(item.type, item, item);
      items.push(item);
    }
    return items;
  }
  async Parse(jsonObject, setIcons) {
    const equipment = this.filterObjects(jsonObject["gears"]["gear"]);
    const items = await this.ParseEquipment(equipment, setIcons);
    return await Item.create(items);
  }
};

// src/module/apps/itemImport/parser/critter-power/SpritePowerParser.ts
var SpritePowerParser = class extends ItemParserBase {
  static {
    __name(this, "SpritePowerParser");
  }
  _parseSpritePowerActionType(chummerData) {
    const action = ImportHelper.StringValue(chummerData, "action", void 0);
    if (foundry.utils.getType(action) === "string") return action.toLowerCase();
    else return "";
  }
  Parse(chummerData, itemData, dataTranslation) {
    itemData = super.Parse(chummerData, itemData, dataTranslation);
    itemData.system.action.type = this._parseSpritePowerActionType(chummerData);
    return itemData;
  }
};

// src/module/apps/itemImport/importer/SpritePowerImporter.ts
var SpritePowerImporter = class extends DataImporter {
  constructor() {
    super(...arguments);
    this.files = ["critterpowers.xml"];
    this.unsupportedCategories = [
      "Drake",
      "Echoes",
      "Free Spirit",
      "Infected",
      "Mundane",
      "Paranormal",
      "Paranormal/Infected",
      "Toxic Critter Powers",
      "Weakness",
      "Chimeric Modification",
      "Shapeshifter"
    ];
  }
  static {
    __name(this, "SpritePowerImporter");
  }
  /**
   * Sprite translations is included in the crittwerpowers lang section.
   */
  ExtractTranslation() {
    if (!DataImporter.jsoni18n) {
      return;
    }
    let powerI18n = ImportHelper.ExtractDataFileTranslation(DataImporter.jsoni18n, this.files[0]);
    this.categoryTranslations = ImportHelper.ExtractCategoriesTranslation(powerI18n);
    this.itemTranslations = ImportHelper.ExtractItemTranslation(powerI18n, "powers", "power");
  }
  /**
   * Sprite powers are included in critterpowers.xml via the category 'Emergent'
   *
   * @param jsonObject Chummer critterpower structure
   */
  CanParse(jsonObject) {
    return jsonObject.hasOwnProperty("powers") && jsonObject["powers"].hasOwnProperty("power");
  }
  async Parse(chummerData, setIcons) {
    const parser = new SpritePowerParser();
    const folder = await ImportHelper.GetFolderAtPath(`${Constants.ROOT_IMPORT_FOLDER_NAME}/${game.i18n.localize("TYPES.Item.sprite_power")}`, true);
    const items = [];
    const chummerSpritePowers = this.filterObjects(chummerData["powers"]["power"]);
    this.iconList = await this.getIconFiles();
    const parserType = "sprite_power";
    for (const chummerSpritePower of chummerSpritePowers) {
      if (DataImporter.unsupportedEntry(chummerSpritePower)) {
        continue;
      }
      let item = parser.Parse(chummerSpritePower, this.GetDefaultData({ type: parserType }), this.itemTranslations);
      item.folder = folder.id;
      item.system.importFlags = this.genImportFlags(item.name, item.type, "");
      if (setIcons) {
        item.img = await this.iconAssign(item.system.importFlags, item.system, this.iconList);
      }
      ;
      item.name = ImportHelper.MapNameToTranslation(this.itemTranslations, item.name);
      UpdateActionFlow.injectActionTestsIntoChangeData(item.type, item, item);
      items.push(item);
    }
    return await Item.create(items);
  }
};

// src/module/apps/itemImport/apps/import-form.ts
var Import = class _Import extends Application {
  constructor() {
    super();
    this.supportedDataFiles = [];
    this.dataFiles = [];
    this.parsedFiles = [];
    this.disableImportButton = true;
    this.isDataFile = /* @__PURE__ */ __name((file) => {
      return this.supportedDataFiles.some((supported) => supported === file.name);
    }, "isDataFile");
    this.isLangDataFile = /* @__PURE__ */ __name((file) => {
      const pattern = /[a-zA-Z]{2}-[a-zA-Z]{2}_data\.xml/;
      return file.name.match(pattern) !== null;
    }, "isLangDataFile");
    this.collectDataImporterFileSupport();
  }
  static {
    __name(this, "Import");
  }
  static get defaultOptions() {
    const options = super.defaultOptions;
    options.id = "chummer-data-import";
    options.classes = ["app", "window-app", "filepicker"];
    options.title = "Chummer/Data Import";
    options.template = "systems/shadowrun6-elysium/dist/templates/apps/compendium-import.html";
    options.width = 600;
    options.height = "auto";
    return options;
  }
  getData(options) {
    const data = super.getData(options);
    data.dataFiles = {};
    this.supportedDataFiles.forEach((supportedFileName) => {
      const missing = !this.dataFiles.some((dataFile) => supportedFileName === dataFile.name);
      const parsed = this.parsedFiles.some((parsedFileName) => supportedFileName === parsedFileName);
      const parsing = supportedFileName === this.currentParsedFile;
      data.dataFiles[supportedFileName] = {
        name: supportedFileName,
        missing,
        parsed,
        parsing
      };
    });
    data.langDataFile = this.langDataFile ? this.langDataFile.name : "";
    data.finishedOverallParsing = this.supportedDataFiles.length === this.parsedFiles.length;
    data.disableImportButton = this.disableImportButton;
    return { ...data };
  }
  collectDataImporterFileSupport() {
    this.supportedDataFiles = [];
    _Import.Importers.forEach((importer) => {
      if (this.supportedDataFiles.some((supported) => importer.files.includes(supported))) {
        return;
      }
      this.supportedDataFiles = this.supportedDataFiles.concat(importer.files);
    });
  }
  clearParsingStatus() {
    this.parsedFiles = [];
  }
  static {
    //Order is important, ex. some weapons need mods to fully import
    this.Importers = [
      new ModImporter(),
      new WeaponImporter(),
      new ArmorImporter(),
      new AmmoImporter(),
      new SpellImporter(),
      new ComplexFormImporter(),
      new QualityImporter(),
      new WareImporter(),
      new CritterPowerImporter(),
      new SpritePowerImporter(),
      new DeviceImporter(),
      new EquipmentImporter(),
      new ProgramImporter()
    ];
  }
  async parseXML(xmlSource, fileName, setIcons) {
    let jsonSource = await DataImporter.xml2json(xmlSource);
    ImportHelper.SetMode(1 /* XML */);
    for (const di of _Import.Importers) {
      if (di.CanParse(jsonSource)) {
        di.ExtractTranslation(fileName);
        await di.Parse(jsonSource, setIcons);
      }
    }
  }
  async parseXmli18n(xmlSource) {
    if (!xmlSource) {
      return;
    }
    let jsonSource = await DataImporter.xml2json(xmlSource);
    if (DataImporter.CanParseI18n(jsonSource)) {
      DataImporter.ParseTranslation(jsonSource);
    }
  }
  activateListeners(html) {
    html.find("button[type='submit']").on("click", async (event) => {
      event.preventDefault();
      this.clearParsingStatus();
      this.disableImportButton = true;
      await this.render();
      if (this.langDataFile) {
        const text = await this.langDataFile.text();
        await this.parseXmli18n(text);
      }
      const setIcons = $(".setIcons").is(":checked");
      for (const supportedFile of this.supportedDataFiles) {
        const dataFile = this.dataFiles.find((dataFile2) => dataFile2.name === supportedFile);
        if (dataFile) {
          const text = await dataFile.text();
          this.currentParsedFile = dataFile.name;
          await this.render();
          await this.parseXML(text, dataFile.name, setIcons);
          if (!this.parsedFiles.some((parsedFileName) => parsedFileName === dataFile.name)) {
            this.parsedFiles.push(dataFile.name);
          }
          await this.render();
        }
      }
      this.disableImportButton = false;
      await this.render();
      ui.notifications?.warn("SR6.Warnings.BulkImportPerformanceWarning", { localize: true });
    });
    html.find("input[type='file'].langDataFileDrop").on("change", async (event) => {
      Array.from(event.target.files).forEach((file) => {
        if (this.isLangDataFile(file)) {
          this.langDataFile = file;
          this.render();
        }
      });
      return true;
    });
    html.find("input[type='file'].filedatadrop").on("change", async (event) => {
      Array.from(event.target.files).forEach((file) => {
        if (this.isDataFile(file)) {
          const existingIdx = this.dataFiles.findIndex((dataFile) => dataFile.name === file.name);
          if (existingIdx === -1) {
            this.dataFiles.push(file);
          } else {
            this.dataFiles[existingIdx] = file;
          }
        }
      });
      if (this.dataFiles.length > 0) {
        this.disableImportButton = false;
      }
      this.render();
    });
  }
};

// src/module/apps/ChangelogApplication.ts
var ChangelogApplication = class _ChangelogApplication extends Application {
  static {
    __name(this, "ChangelogApplication");
  }
  get template() {
    return "systems/shadowrun6-elysium/dist/templates/apps/changelog.html";
  }
  static get defaultOptions() {
    const options = super.defaultOptions;
    options.classes = ["shadowrun6-elysium"];
    options.title = game.i18n.localize("SR6.ChangelogApplication.Title");
    options.width = 500;
    options.height = "auto";
    return options;
  }
  render(force, options) {
    _ChangelogApplication.setRenderForCurrentVersion();
    return super.render(force, options);
  }
  // Let the async operation happen in background.
  static setRenderForCurrentVersion() {
    game.user?.setFlag(SYSTEM_NAME, FLAGS.ChangelogShownForVersion, game.system.version);
  }
  static get showApplication() {
    if (!game.user?.isGM || !game.user?.isTrusted) return false;
    const shownForVersion = game.user?.getFlag(SYSTEM_NAME, FLAGS.ChangelogShownForVersion);
    return shownForVersion !== game.system.version;
  }
};

// src/module/apps/SituationModifiersApplication.ts
var ModifiersHandler = class {
  static {
    __name(this, "ModifiersHandler");
  }
  constructor(situationModifiersApp) {
    this.app = situationModifiersApp;
  }
  /**
   * Provide template data fields necessary for the extending modifier type to be added to a
   * general template data object.
   */
  getData(options) {
    return {};
  }
  /**
   * Define what event listeners to register for the extending modifier type.
   */
  activateListeners(html) {
  }
  /**
   * Define what token hud buttons to register for the extending modifier type.
   *
   * NOTE: TypeScript doesn't support abstract static method definitions as of yet.
   */
  static addTokenHUDElements(modifierColumn, tokenId, actor, modifiers) {
    console.error(`SR6: Elysium | Class ${this.constructor.name} must implement static method onRenderTokenHUD`);
  }
};
var EnvironmentalModifiersHandler = class extends ModifiersHandler {
  static {
    __name(this, "EnvironmentalModifiersHandler");
  }
  activateListeners(html) {
    console.log(`SR6: Elysium | Registering modifier handler ${this.constructor.name} listeners`);
    $(html).find("button.env-modifier").on("click", this._handleModifierChange.bind(this));
  }
  static addTokenHUDElements(modifierColumn, tokenId, actor, modifiers) {
    console.log(`${SYSTEM_NAME} | Environmental modifier HUD on renderTokenHUD`);
    const modifier = $('<div class="modifier-row"></div>');
    const modifierValue = $(`<div class="modifier-value modifier-value-matrix">${modifiers.environmental.applied.total}</div>`);
    const modifierDescription = $(`<div class="modifier-description open-matrix-modifier">${game.i18n.localize("SR6.ModifierTypes.Environmental")}</div>`);
    modifierDescription.on("click", SituationModifiersApplication.openForTokenHUD(tokenId, "environmental"));
    modifierColumn.append(modifier);
    modifier.append(modifierValue);
    modifier.append(modifierDescription);
  }
  async _handleModifierChange(event) {
    event.preventDefault();
    const element = event.currentTarget;
    if (!element.dataset.category || !element.dataset.value) return;
    const category3 = element.dataset.category;
    const value = Number(element.dataset.value);
    this.app.modifiers.environmental.toggleSelection(category3, value);
    await this.app.modifiers.updateDocument();
    await this.app.render();
  }
  async _handleRemoveModifiersFromTarget(event) {
    event.preventDefault();
    this.app.modifiers.environmental.clear();
    await this.clearModifiersOnTarget();
    await this.app.render();
  }
  async clearModifiersOnTarget() {
    await DocumentSituationModifiers.clearTypeOn(this.app.target, "environmental");
    this.app.modifiers = this.app._getModifiers();
  }
};
var MatrixModifiersHandler = class extends ModifiersHandler {
  static {
    __name(this, "MatrixModifiersHandler");
  }
  getData(options) {
    return {};
  }
  activateListeners(html) {
  }
  static addTokenHUDElements(modifierColumn, tokenId, actor, modifiers) {
    console.log(`${SYSTEM_NAME} | Matrix modifier HUD on renderTokenHUD`);
    const modifier = $('<div class="modifier-row"></div>');
    const modifierValue = $(`<div class="modifier-value modifier-value-matrix">${modifiers.noise.applied.total}</div>`);
    const modifierDescription = $(`<div class="modifier-description open-matrix-modifier">${game.i18n.localize("SR6.ModifierTypes.Noise")}</div>`);
    modifierDescription.on("click", SituationModifiersApplication.openForTokenHUD(tokenId, "matrix"));
    modifierColumn.append(modifier);
    modifier.append(modifierValue);
    modifier.append(modifierDescription);
  }
};
var MagicModifiersHandler = class extends ModifiersHandler {
  static {
    __name(this, "MagicModifiersHandler");
  }
  getData(options) {
    return {};
  }
  activateListeners(html) {
    html.find(".remove-magical-from-target").on("click", this.handleClearMagicModifiers.bind(this));
  }
  static addTokenHUDElements(modifierColumn, tokenId, actor, modifiers) {
    console.log(`${SYSTEM_NAME} | Magic modifier HUD on renderTokenHUD`);
    if (!actor.isAwakened) return;
    const modifier = $('<div class="modifier-row"></div>');
    const modifierValue = $(`<div class="modifier-value modifier-value-magic">${modifiers.background_count.applied.total}</div>`);
    const modifierDescription = $(`<div class="modifier-description open-magic-modifier">${game.i18n.localize("SR6.ModifierTypes.BackgroundCount")}</div>`);
    modifierDescription.on("click", SituationModifiersApplication.openForTokenHUD(tokenId, "magic"));
    modifierColumn.append(modifier);
    modifier.append(modifierValue);
    modifier.append(modifierDescription);
  }
  async handleClearMagicModifiers(event) {
    event.preventDefault();
    this.app.modifiers = await DocumentSituationModifiers.clearTypeOn(this.app.target, "background_count");
    this.app.render();
  }
};
var RecoilModifiersHandler = class extends ModifiersHandler {
  static {
    __name(this, "RecoilModifiersHandler");
  }
  getData(options) {
    return {};
  }
  activateListeners(html) {
    html.find(".recoil-delta button").on("click", this.applyRecoilDelta.bind(this));
    html.find("button#modifiers-recoil-total").on("click", async (event) => {
      if (this.app.modifiers.documentIsScene) return;
      const actor = this.app.modifiers.document;
      await actor.clearProgressiveRecoil();
      ui.notifications?.info("SR6.Infos.ResetProgressiveRecoil", { localize: true });
      this.app.render();
    });
  }
  /**
   * Apply actor system recoil data back to the actor.
   *
   * A delta is a numerical difference to be applied onto the base value
   *
   * This method is related to SituationModifierApplication#applyModifierDelta
   */
  async applyRecoilDelta(event) {
    event.preventDefault();
    if (!this.app.modifiers.documentIsActor) return;
    const actor = this.app.modifiers.document;
    const triggerElement = event.target;
    if (!triggerElement || !triggerElement.dataset.hasOwnProperty("delta"))
      return console.error("SR6: Elysium | Expected a DOMElement with a different structure");
    const delta = Number(triggerElement.dataset["delta"]);
    if (delta === 0) return;
    await actor.addRecoil(delta);
    this.app.modifiers.applyAll();
    this.app.render();
  }
  static addTokenHUDElements(modifierColumn, tokenId, actor, modifiers) {
    console.log(`${SYSTEM_NAME} | Recoil modifier HUD on renderTokenHUD`);
    const modifier = $('<div class="modifier-row"></div>');
    const modifierValue = $(`<div class="modifier-value modifier-value-recoil">${modifiers.recoil.applied.total}</div>`);
    const modifierDescription = $(`<div class="modifier-description open-recoil-modifier">${game.i18n.localize("SR6.ModifierTypes.Recoil")}</div>`);
    modifierDescription.on("click", SituationModifiersApplication.openForTokenHUD(tokenId, "recoil"));
    modifierColumn.append(modifier);
    modifier.append(modifierValue);
    modifier.append(modifierDescription);
  }
};
var SituationModifiersApplication = class _SituationModifiersApplication extends FormApplication {
  static {
    __name(this, "SituationModifiersApplication");
  }
  static {
    // Static Handlers contain the class references used for both static method calls and to setup the instance handlers.
    this._staticHandlers = [
      MatrixModifiersHandler,
      MagicModifiersHandler,
      EnvironmentalModifiersHandler,
      RecoilModifiersHandler
    ];
  }
  static {
    // The default sheet tab to open.
    this._defaultTabId = "physical";
  }
  constructor(target) {
    super(target);
    this.target = target;
    this.modifiers = this._getModifiers();
    this.handlers = this._prepareHandlers();
  }
  /**
   * Prepare all handlers used for the different modifier categories.
   */
  _prepareHandlers() {
    return _SituationModifiersApplication._staticHandlers.map((staticHandler) => new staticHandler(this));
  }
  get template() {
    return "systems/shadowrun6-elysium/dist/templates/apps/situational-modifiers.hbs";
  }
  static get defaultOptions() {
    const options = super.defaultOptions;
    options.classes = ["sr6"];
    options.id = "situational-modifiers-application";
    options.title = game.i18n.localize("SR6.SituationalModifiersApplication.Title");
    options.width = "auto";
    options.height = "auto";
    options.resizable = false;
    options.tabs = [
      {
        navSelector: ".tabs",
        contentSelector: ".sheetbody",
        initial: _SituationModifiersApplication._defaultTabId
      }
    ];
    options.submitOnChange = true;
    options.closeOnSubmit = false;
    return options;
  }
  async getData(options) {
    this.modifiers.applyAll();
    return {
      ...await super.getData(options),
      targetType: this._targetTypeLabel,
      targetName: this.target.name || "Unknown target",
      modifiers: this.modifiers,
      environmentalLevels: this.modifiers.environmental.levels
    };
  }
  activateListeners(html) {
    super.activateListeners(html);
    this.handlers.forEach((handler) => handler.activateListeners(html));
    html.find(".modifier-delta button").on("click", this.applyModifierDelta.bind(this));
    html.find(".remove-modifiers-from-target").on("click", this.clearModifierData.bind(this));
    html.find(".remove-token-modifiers-from-scene").on("click", this.clearTokenModifiersData.bind(this));
  }
  /**
   * Apply a formData change based on a custom numerical input element.
   */
  async applyModifierDelta(event) {
    event.preventDefault();
    const triggerElement = event.target;
    if (!triggerElement || !triggerElement.dataset.hasOwnProperty("delta"))
      return console.error("SR6: Elysium | Expected a DOMElement with a different structure");
    const delta = Number(triggerElement.dataset["delta"]);
    if (delta === 0) return;
    const valueElement = $(triggerElement).siblings().closest("input");
    if (!valueElement || !valueElement.attr("name"))
      return console.error("SR6: Elysium | Expected a DOMElement with a name attribute");
    const sourceKey = valueElement.attr("name");
    const appliedKey = sourceKey.includes("source") ? sourceKey.replace("source", "applied") : sourceKey;
    const currentValue = foundry.utils.getProperty(this, appliedKey) ?? 0;
    if (isNaN(currentValue))
      return console.error("SR6: Elysium | Expected data property is not a number", sourceKey, currentValue);
    const value = currentValue + delta;
    const formData = {
      [sourceKey]: value
    };
    await this._updateObject(event, formData);
    this.modifiers.applyAll();
    this.render();
  }
  /**
   * Clear all modifiers from this document
   */
  async clearModifierData() {
    await this.modifiers.clearAll();
    this.render(true);
  }
  /**
   * Clear all modifiers from all tokens on this scene.
   */
  async clearTokenModifiersData() {
    await this.modifiers.clearAllTokensOnScene();
    this.render(true);
  }
  async _updateObject(event, formData) {
    if (!formData) return;
    for (const [key, value] of Object.entries(formData)) {
      foundry.utils.setProperty(this, key, value);
    }
    await DocumentSituationModifiers.setDocumentModifiers(this.target, this.modifiers.source);
  }
  /**
   * Override _onChangeInput to include a render on changing modifier values.
   */
  async _onChangeInput(event) {
    await super._onChangeInput(event);
    this.render(true);
  }
  _getModifiers() {
    return DocumentSituationModifiers.fromDocument(this.target);
  }
  get _targetTypeLabel() {
    if (this.target instanceof Scene) {
      return game.i18n.localize("SR6.FOUNDRY.Scene");
    }
    if (this.target instanceof SR6Actor) {
      return game.i18n.localize("SR6.FOUNDRY.Actor");
    }
    return "";
  }
  static getControl() {
    return {
      name: "situational-modifiers-application",
      title: "CONTROLS.SR6.SituationalModifiers",
      icon: "fas fa-list",
      onClick: _SituationModifiersApplication.openForCurrentScene,
      button: true
    };
  }
  // TODO: Implement system wide token HUD management...
  /**
   * Add buttons to both show and open global modifiers currently applied to this token when showing the
   * tokenHUD.
   */
  static onRenderTokenHUD(app, html, data) {
    if (!data._id) return;
    const token = Helpers.getToken(data._id);
    if (!token) return;
    const actor = token.actor;
    const modifiers = actor.getSituationModifiers();
    modifiers.applyAll();
    const container = $('<div class="col far-right sr-modifier-container"></div>');
    const column = $('<div class="col modifier-column"></div>');
    container.append(column);
    html.find(".col.right").after(container);
    _SituationModifiersApplication._staticHandlers.forEach((handler) => handler.addTokenHUDElements(column, data._id, actor, modifiers));
  }
  static openForCurrentScene() {
    if (!canvas || !canvas.ready || !canvas.scene) return;
    new _SituationModifiersApplication(canvas.scene).render(true);
  }
  /**
   * Part of the tokenHUD workflow makes it necessary to have the token id piped in
   * @param tokenId
   */
  static openForTokenHUD(tokenId, tab) {
    const token = Helpers.getToken(tokenId);
    return async (event) => {
      event.preventDefault();
      if (!token || !token.actor) return;
      const app = new _SituationModifiersApplication(token.actor);
      await app._render(true);
    };
  }
  /**
   * Open the application when the system registered keybinding has been pressed.
   *
   * If the user is a player => open selection or character
   * If the user is a gm => open selection or scene
   */
  static openForKeybinding() {
    console.debug(`Shadowrun 6e | Trying to open ${this.name}`);
    let document2 = null;
    const controlledActors = Helpers.getControlledTokenActors();
    if (controlledActors.length === 1) document2 = controlledActors[0];
    if (!document2 && game.user?.isGM) {
      document2 = canvas.scene;
    }
    if (!document2) {
      document2 = game.user?.character;
    }
    if (!document2) return console.debug(`Shadowrun 6e | ...aborting, as no suitable document could be found`);
    console.debug(`Shadowrun 6e | ...opening with document ${document2.uuid}`, document2);
    const app = new _SituationModifiersApplication(document2);
    app.render(true);
  }
};

// src/module/apps/skills/SkillEditSheet.ts
var SkillEditSheet = class extends DocumentSheet {
  static {
    __name(this, "SkillEditSheet");
  }
  get document() {
    return super.document;
  }
  constructor(actor, options, skillId) {
    super(actor, options);
    this.skillId = skillId;
  }
  _updateString() {
    return `system.skills.active.${this.skillId}`;
  }
  static get defaultOptions() {
    const options = super.defaultOptions;
    return foundry.utils.mergeObject(options, {
      id: "skill-editor",
      classes: ["sr6", "sheet", "skill-edit-window"],
      template: "systems/shadowrun6-elysium/dist/templates/apps/skill-edit.html",
      width: 300,
      height: "auto",
      submitOnClose: true,
      submitOnChange: true,
      closeOnSubmit: false,
      resizable: true
    });
  }
  get title() {
    const label = this.document.getSkillLabel(this.skillId);
    return `${game.i18n.localize("SR6.EditSkill")} - ${game.i18n.localize(label)}`;
  }
  _onUpdateObject(event, formData, updateData) {
    const name3 = formData["skill.name"];
    const link = formData["skill.link"];
    const attribute = formData["skill.attribute"];
    const base = formData["skill.base"];
    const canDefault = formData["skill.canDefault"];
    const specsRegex = /skill\.specs\.(\d+)/;
    const specs = Object.entries(formData).reduce((running, [key, val]) => {
      const found = key.match(specsRegex);
      if (found && found[0]) {
        running.push(val);
      }
      return running;
    }, []);
    const bonusKeyRegex = /skill\.bonus\.(\d+).key/;
    const bonusValueRegex = /skill\.bonus\.(\d+).value/;
    const bonus = Object.entries(formData).reduce((running, [key, value]) => {
      const foundKey = key.match(bonusKeyRegex);
      const foundVal = key.match(bonusValueRegex);
      if (foundKey && foundKey[0] && foundKey[1]) {
        const index = foundKey[1];
        if (running[index] === void 0) running[index] = {};
        running[index].key = value;
      } else if (foundVal && foundVal[0] && foundVal[1]) {
        const index = foundVal[1];
        if (running[index] === void 0) running[index] = {};
        running[index].value = value;
      }
      return running;
    }, []);
    updateData[this._updateString()] = {
      specs,
      bonus,
      name: name3,
      attribute,
      canDefault,
      link
    };
    if (event.currentTarget.name === "skill.base") updateData[this._updateString()].base = base;
  }
  /** @override */
  // @ts-expect-error // SkillEditSheet vs DocumentSheet typing, I don't quite get it...
  async _updateObject(event, formData) {
    if (event.currentTarget) {
      const updateData = {};
      this._onUpdateObject(event, formData, updateData);
      await this.document.update(updateData);
    }
  }
  activateListeners(html) {
    super.activateListeners(html);
    this.form.ondragover = (event) => this._onDragOver(event);
    this.form.ondrop = (event) => this._onDrop(event);
    $(html).find(".open-source").on("click", this._onOpenSource.bind(this));
    $(html).find(".add-spec").on("click", this._addNewSpec.bind(this));
    $(html).find(".remove-spec").on("click", this._removeSpec.bind(this));
    $(html).find(".add-bonus").on("click", this._addNewBonus.bind(this));
    $(html).find(".remove-bonus").on("click", this._removeBonus.bind(this));
  }
  async _addNewBonus(event) {
    event.preventDefault();
    const updateData = {};
    const skill = this.getData().skill;
    if (!skill) return;
    const { bonus = [] } = skill;
    updateData[`${this._updateString()}.bonus`] = [...bonus, { key: "", value: 0 }];
    await this.document.update(updateData);
  }
  async _onDrop(event) {
    if (!game.items || !game.actors || !game.scenes) return;
    event.preventDefault();
    event.stopPropagation();
    const data = parseDropData(event);
    if (!data) return;
    this.document.update({ [`${this._updateString()}.link`]: data.uuid });
  }
  async _removeBonus(event) {
    event.preventDefault();
    const updateData = {};
    const data = this.getData().skill;
    if (data?.bonus) {
      const { bonus } = data;
      const index = event.currentTarget.dataset.spec;
      if (index >= 0) {
        bonus.splice(index, 1);
        updateData[`${this._updateString()}.bonus`] = bonus;
        await this.document.update(updateData);
      }
    }
  }
  /**
   * Open a source document connected to this skill.
   */
  async _onOpenSource(event) {
    event.preventDefault();
    LinksHelpers.openSource(this.getData().skill.link);
  }
  async _addNewSpec(event) {
    event.preventDefault();
    const updateData = {};
    const data = this.getData().skill;
    if (data?.specs) {
      const { specs } = data;
      updateData[`${this._updateString()}.specs`] = [...specs, ""];
    }
    await this.document.update(updateData);
  }
  async _removeSpec(event) {
    event.preventDefault();
    const updateData = {};
    const data = this.getData().skill;
    if (data?.specs) {
      const { specs } = data;
      const index = event.currentTarget.dataset.spec;
      if (index >= 0) {
        specs.splice(index, 1);
        updateData[`${this._updateString()}.specs`] = specs;
        await this.document.update(updateData);
      }
    }
  }
  /** Enhance attribute selection by an empty option to allow newly created skills to have no attribute selected.
   */
  _getSkillAttributesForSelect() {
    return { ...SR6.attributes, "": "" };
  }
  _allowSkillNameEditing() {
    const skill = this.document.getSkill(this.skillId);
    return !!(!skill?.name && !skill?.label || skill?.name && !skill?.label);
  }
  // @ts-expect-error // Missing DocumentSheetData typing
  getData() {
    const data = super.getData();
    data["skill"] = foundry.utils.getProperty(data.data, this._updateString());
    data["editable_name"] = this._allowSkillNameEditing();
    data["editable_canDefault"] = true;
    data["editable_attribute"] = true;
    data["attributes"] = this._getSkillAttributesForSelect();
    return data;
  }
};

// src/module/apps/skills/LanguageSkillEditSheet.ts
var LanguageSkillEditSheet = class extends SkillEditSheet {
  static {
    __name(this, "LanguageSkillEditSheet");
  }
  _updateString() {
    return `system.skills.language.value.${this.skillId}`;
  }
  getData() {
    return foundry.utils.mergeObject(super.getData(), {
      editable_name: true,
      editable_canDefault: false,
      editable_attribute: false
    });
  }
  /** @override */
  _onUpdateObject(event, formData, updateData) {
    super._onUpdateObject(event, formData, updateData);
    const name3 = formData["skill.name"];
    const currentData = updateData[this._updateString()] || {};
    updateData[this._updateString()] = {
      ...currentData,
      name: name3
    };
  }
};

// src/module/apps/skills/KnowledgeSkillEditSheet.ts
var KnowledgeSkillEditSheet = class extends LanguageSkillEditSheet {
  static {
    __name(this, "KnowledgeSkillEditSheet");
  }
  constructor(actor, options, skillId, category3) {
    super(actor, options, skillId);
    this.category = category3;
  }
  _updateString() {
    return `system.skills.knowledge.${this.category}.value.${this.skillId}`;
  }
};

// src/module/apps/dialogs/MoveInventoryDialog.ts
var MoveInventoryDialog = class _MoveInventoryDialog extends FormDialog {
  static {
    __name(this, "MoveInventoryDialog");
  }
  /**
   * @param actor Use this actor's inventories to select from.
   * @param item The item to be moved between inventories
   * @param sourceInventory The currently selected inventory, which won't be displayed.
   * @param options
   */
  constructor(actor, item, sourceInventory, options) {
    const dialogData = _MoveInventoryDialog.getDialogData(actor, item, sourceInventory);
    super(dialogData, options);
  }
  static get defaultOptions() {
    const options = super.defaultOptions;
    options.id = "move-inventory-application";
    options.classes = ["sr6", "form-dialog"];
    options.height = "auto";
    return options;
  }
  static getDialogData(actor, item, sourceInventory) {
    const inventories = _MoveInventoryDialog.selectableInventories(actor, item, sourceInventory);
    return {
      title: game.i18n.localize("SR6.MoveInventoryDialog.Title"),
      buttons: {
        move: {
          label: game.i18n.localize("SR6.MoveInventoryDialog.Move")
        },
        cancel: {
          label: game.i18n.localize("SR6.MoveInventoryDialog.Cancel")
        }
      },
      default: "cancel",
      templateData: { inventories },
      templatePath: "systems/shadowrun6-elysium/dist/templates/apps/dialogs/move-inventory-dialog.html",
      onAfterClose: /* @__PURE__ */ __name(async (html) => {
        return html.find('input[name="inventories"]:checked').val();
      }, "onAfterClose")
    };
  }
  /**
   * Depending on actor and item different intenvories are selectable.
   *
   * @param actor Actor to check for inventories
   * @param item Item that is to be moved to a new inventory
   * @param sourceInventory Inventory that is to be moved from
   * @returns List of inventories
   */
  static selectableInventories(actor, item, sourceInventory) {
    if (sourceInventory !== actor.allInventories.name && actor.inventory.isItemInInventory(actor.allInventories.name, item)) {
      const inventories2 = Object.values(actor.inventory.getAll()).filter((inventory) => inventory.name !== actor.allInventories.name).sort();
      inventories2.unshift(actor.defaultInventory);
      return inventories2;
    }
    const inventories = Object.values(actor.inventory.getAll()).filter((inventory) => inventory.name !== sourceInventory).sort();
    if (sourceInventory !== actor.defaultInventory.name) inventories.unshift(actor.defaultInventory);
    return inventories;
  }
};

// src/module/apps/importer/actorImport/itemImporter/importHelper/BaseParserFunctions.js
var getValues = /* @__PURE__ */ __name((val) => {
  const regex = /(-?[0-9]+)(?:([0-9]+))*/g;
  const l2 = val.match(regex);
  return l2 || ["0"];
}, "getValues");
var getArray = /* @__PURE__ */ __name((value) => {
  if (value) {
    return Array.isArray(value) ? value : [value];
  }
  return [];
}, "getArray");
var parseDescription = /* @__PURE__ */ __name((chummerEntry) => {
  const parsedDescription = DataDefaults.descriptionData();
  if (chummerEntry.source && chummerEntry.page) {
    parsedDescription.source = `${chummerEntry.source} ${chummerEntry.page}`;
  }
  if (chummerEntry.description) {
    parsedDescription.value = chummerEntry.description;
  }
  if (chummerEntry.notes) {
    parsedDescription.value = chummerEntry.notes;
  }
  return parsedDescription;
}, "parseDescription");
var parseTechnology = /* @__PURE__ */ __name((chummerEntry) => {
  const parsedTechnology = DataDefaults.technologyData();
  if (chummerEntry.rating) {
    parsedTechnology.rating = chummerEntry.rating;
  }
  if (chummerEntry.avail) {
    parsedTechnology.availability = chummerEntry.avail;
  }
  if (chummerEntry.qty) {
    parsedTechnology.quantity = chummerEntry.qty;
  }
  if (chummerEntry.cost) {
    parsedTechnology.cost = parseFloat(chummerEntry.cost.replace(/[^\d\.\-]/g, ""));
  }
  if (chummerEntry.equipped?.toLowerCase() === "true") {
    parsedTechnology.equipped = true;
  }
  if (chummerEntry.conditionmonitor) {
    parsedTechnology.condition_monitor.max = Number(chummerEntry.conditionmonitor);
  }
  if (chummerEntry.conceal) {
    parsedTechnology.conceal.base = Number(chummerEntry.conceal);
  }
  return parsedTechnology;
}, "parseTechnology");
var setSubType = /* @__PURE__ */ __name((parsedItem, parserType, subType) => {
  if (Object.keys(SR6.itemSubTypeIconOverrides[parserType]).includes(subType)) {
    parsedItem.importFlags.subType = formatAsSlug(subType);
  }
}, "setSubType");
var createItemData = /* @__PURE__ */ __name((name3, type, system) => {
  return {
    name: name3,
    _id: "",
    folder: "",
    flags: {},
    type,
    system,
    permission: {
      default: 2
    }
  };
}, "createItemData");
var formatAsSlug = /* @__PURE__ */ __name((name3) => {
  return name3.trim().toLowerCase().replace(/'|,|\[|\]|\(|\)|:/g, "").split(/-|\s|\//g).join("-");
}, "formatAsSlug");
var genImportFlags = /* @__PURE__ */ __name((name3, type) => {
  const flags = {
    name: name3,
    // original english name
    type,
    subType: "",
    isFreshImport: true,
    isImported: true
  };
  return flags;
}, "genImportFlags");

// src/module/apps/importer/actorImport/itemImporter/magicImport/InitiationParser.js
var InitiationParser = class {
  static {
    __name(this, "InitiationParser");
  }
  parseInitiation(chummerChar, system) {
    const initiationgrades = getArray(chummerChar.initiationgrade.initiationgrade);
    system.magic.initiation = Math.max(...initiationgrades.filter((grade) => grade.technomancer == "False").map((grade) => grade.grade));
  }
};

// src/module/apps/importer/actorImport/itemImporter/technoImport/SubmersionParser.js
var SubmersionParser = class {
  static {
    __name(this, "SubmersionParser");
  }
  parseSubmersions(chummerChar, system) {
    const initiationgrades = getArray(chummerChar.initiationgrade.initiationgrade);
    system.technomancer.submersion = Math.max(...initiationgrades.filter((grade) => grade.technomancer == "True").map((grade) => grade.grade));
  }
};

// src/module/apps/importer/actorImport/characterImporter/CharacterInfoUpdater.js
var CharacterInfoUpdater = class {
  static {
    __name(this, "CharacterInfoUpdater");
  }
  /**
   *  Maps the chummer attribute name to our sr5-foundry attribute name
   *  @param attName name of the chummer attribute
   */
  parseAttName = /* @__PURE__ */ __name((attName) => {
    if (attName.toLowerCase() === "bod") {
      return "body";
    }
    if (attName.toLowerCase() === "agi") {
      return "agility";
    }
    if (attName.toLowerCase() === "rea") {
      return "reaction";
    }
    if (attName.toLowerCase() === "str") {
      return "strength";
    }
    if (attName.toLowerCase() === "cha") {
      return "charisma";
    }
    if (attName.toLowerCase() === "int") {
      return "intuition";
    }
    if (attName.toLowerCase() === "log") {
      return "logic";
    }
    if (attName.toLowerCase() === "wil") {
      return "willpower";
    }
    if (attName.toLowerCase() === "edg") {
      return "edge";
    }
    if (attName.toLowerCase() === "mag") {
      return "magic";
    }
    if (attName.toLowerCase() === "res") {
      return "resonance";
    }
  }, "parseAttName");
  getArray = /* @__PURE__ */ __name((value) => {
    return Array.isArray(value) ? value : [value];
  }, "getArray");
  /**
   *  Converts the chummer attribute value to our sr5-foundry attribute value
   *  @param att the chummer attribute
   */
  parseAttBaseValue = /* @__PURE__ */ __name((att) => {
    if (att.name.toLowerCase() === "edg") {
      return parseInt(att.base);
    } else {
      return parseInt(att.total);
    }
  }, "parseAttBaseValue");
  /**
   * Parses the actor data from the chummer file and returns an updated clone of the actor data.
   * @param {*} actorSource The actor data (actor not actor.system) that is used as the basis for the import. Will not be changed.
   * @param {*} chummerChar The chummer character to parse.
   */
  async update(actorSource, chummerChar) {
    const clonedActorSource = foundry.utils.duplicate(actorSource);
    if (chummerChar.alias) {
      clonedActorSource.name = chummerChar.alias;
    } else {
      clonedActorSource.name = chummerChar.name ? chummerChar.name : "[Name not found]";
    }
    clonedActorSource.prototypeToken.name = clonedActorSource.name;
    this.importBasicData(clonedActorSource.system, chummerChar);
    await this.importBio(clonedActorSource.system, chummerChar);
    this.importAttributes(clonedActorSource.system, chummerChar);
    this.importInitiative(clonedActorSource.system, chummerChar);
    this.importSkills(clonedActorSource.system, chummerChar);
    if (chummerChar.critterpowers?.critterpower) {
      clonedActorSource.system.is_critter = true;
    }
    return clonedActorSource;
  }
  importBasicData(system, chummerChar) {
    try {
      if (chummerChar.metatype) {
        system.metatype = chummerChar.metatype_english.toLowerCase();
      }
      if (chummerChar.sex) {
        system.sex = chummerChar.sex;
      }
      if (chummerChar.age) {
        system.age = chummerChar.age;
      }
      if (chummerChar.height) {
        system.height = chummerChar.height;
      }
      if (chummerChar.weight) {
        system.weight = chummerChar.weight;
      }
      if (chummerChar.calculatedstreetcred) {
        system.street_cred = chummerChar.calculatedstreetcred;
      }
      if (chummerChar.calculatednotoriety) {
        system.notoriety = chummerChar.calculatednotoriety;
      }
      if (chummerChar.calculatedpublicawareness) {
        system.public_awareness = chummerChar.calculatedpublicawareness;
      }
      if (chummerChar.karma) {
        system.karma.value = chummerChar.karma;
      }
      if (chummerChar.totalkarma) {
        system.karma.max = chummerChar.totalkarma;
      }
      if (chummerChar.technomancer?.toLowerCase() === "true") {
        system.special = "resonance";
        if (chummerChar.initiationgrade) {
          new SubmersionParser().parseSubmersions(chummerChar, system);
        }
      }
      if (chummerChar.magician?.toLowerCase() === "true" || chummerChar.adept?.toLowerCase() === "true") {
        system.special = "magic";
        let attr = [];
        if (chummerChar.tradition?.drainattribute?.attr) {
          attr = chummerChar.tradition.drainattribute.attr;
        } else if (chummerChar.tradition?.drainattributes) {
          attr = chummerChar.tradition.drainattributes.split("+").map((item) => item.trim());
        }
        attr.forEach((att) => {
          const attName = this.parseAttName(att);
          if (attName !== "willpower") {
            system.magic.attribute = attName;
          }
        });
        if (chummerChar.initiationgrade) {
          new InitiationParser().parseInitiation(chummerChar, system);
        }
      }
      if (chummerChar.totaless) {
        system.attributes.essence.value = chummerChar.totaless;
      }
      if (chummerChar.nuyen) {
        system.nuyen = parseInt(chummerChar.nuyen.replace(",", "").replace(".", ""));
      }
    } catch (e2) {
      console.error(`Error while parsing character information ${e2}`);
    }
  }
  async importBio(system, chummerChar) {
    system.description.value = "";
    if (chummerChar.description) {
      system.description.value += await TextEditor.enrichHTML(chummerChar.description + "<br/>", { async: true });
    }
    if (chummerChar.background) {
      system.description.value += await TextEditor.enrichHTML(chummerChar.background + "<br/>", { async: true });
    }
    if (chummerChar.concept) {
      system.description.value += await TextEditor.enrichHTML(chummerChar.concept + "<br/>", { async: true });
    }
    if (chummerChar.notes) {
      system.description.value += await TextEditor.enrichHTML(chummerChar.notes + "<br/>", { async: true });
    }
  }
  importAttributes(system, chummerChar) {
    if (!chummerChar.attributes) {
      return;
    }
    const atts = chummerChar.attributes[1].attribute;
    atts.forEach((att) => {
      try {
        const attName = this.parseAttName(att.name_english);
        if (attName) {
          system.attributes[attName].base = this.parseAttBaseValue(att);
        }
      } catch (e2) {
        console.error(`Error while parsing attributes ${e2}`);
      }
    });
  }
  // TODO: These modifiers are very unclear in how they're used here and where they come from.
  importInitiative(system, chummerChar) {
    try {
      system.modifiers.meat_initiative = chummerChar.initbonus;
      system.modifiers.meat_initiative_dice = chummerChar.initdice - 1;
    } catch (e2) {
      console.error(`Error while parsing initiative ${e2}`);
    }
  }
  importSkills(system, chummerChar) {
    const chummerSkills = chummerChar.skills?.skill;
    try {
      let languageSkills = chummerSkills?.filter((skill) => skill.islanguage && skill.islanguage.toLowerCase() === "true") ?? [];
      this.handleLanguageSkills(system, languageSkills);
      let knowledgeSkills = chummerSkills?.filter((skill) => skill.rating > 0 && skill.knowledge && skill.knowledge.toLowerCase() === "true") ?? [];
      this.handleKnowledgeSkills(system, knowledgeSkills);
      let activeSkills = chummerSkills?.filter((skill) => skill.rating > 0 && !languageSkills.includes(skill) && !knowledgeSkills.includes(skill)) ?? [];
      this.handleActiveSkills(system, activeSkills);
    } catch (e2) {
      console.error(e2);
    }
  }
  handleActiveSkills(system, activeSkills) {
    for (let skill of activeSkills) {
      let name3 = skill.name_english.toLowerCase().trim().replace(/\s/g, "_").replace(/-/g, "_");
      if (name3.includes("exotic") && name3.includes("_weapon")) {
        name3 = name3.replace("_weapon", "");
      }
      if (name3.includes("exotic") && name3.includes("_ranged")) {
        name3 = name3.replace("_ranged", "_range");
      }
      if (name3 === "pilot_watercraft") {
        name3 = "pilot_water_craft";
      }
      let parsedSkill = system.skills.active[name3];
      parsedSkill.base = parseInt(skill.rating);
      if (skill.skillspecializations) {
        parsedSkill.specs = this.getArray(skill.skillspecializations.skillspecialization).map((spec) => spec.name);
      }
      _mergeWithMissingSkillFields(parsedSkill);
    }
  }
  handleLanguageSkills(system, languageSkills) {
    system.skills.language.value = {};
    for (let skill of languageSkills) {
      let parsedSkill = {};
      const id = randomID(16);
      system.skills.language.value[id] = parsedSkill;
      if (skill.isnativelanguage.toLowerCase() === "true") {
        skill.rating = 6;
      }
      parsedSkill.name = skill.name;
      parsedSkill.base = parseInt(skill.rating);
      if (skill.skillspecializations) {
        parsedSkill.specs = this.getArray(skill.skillspecializations.skillspecialization).map((spec) => spec.name);
      }
      _mergeWithMissingSkillFields(parsedSkill);
    }
  }
  handleKnowledgeSkills(system, knowledgeSkills) {
    system.skills.knowledge.academic.value = {};
    system.skills.knowledge.interests.value = {};
    system.skills.knowledge.professional.value = {};
    system.skills.knowledge.street.value = {};
    for (let skill of knowledgeSkills) {
      const id = randomID(16);
      let parsedSkill = {};
      let skillCategory;
      if (skill.skillcategory_english) {
        const cat = skill.skillcategory_english.toLowerCase();
        if (cat === "street")
          skillCategory = system.skills.knowledge.street.value;
        if (cat === "academic")
          skillCategory = system.skills.knowledge.academic.value;
        if (cat === "professional")
          skillCategory = system.skills.knowledge.professional.value;
        if (cat === "interest")
          skillCategory = system.skills.knowledge.interests.value;
        if (skillCategory)
          skillCategory[id] = parsedSkill;
      } else {
        if (skill.attribute.toLowerCase() === "int") {
          system.skills.knowledge.street.value[id] = parsedSkill;
        }
        if (skill.attribute.toLowerCase() === "log") {
          system.skills.knowledge.professional.value[id] = parsedSkill;
        }
      }
      parsedSkill.name = skill.name;
      parsedSkill.base = parseInt(skill.rating);
      if (skill.skillspecializations) {
        parsedSkill.specs = this.getArray(skill.skillspecializations.skillspecialization).map((spec) => spec.name);
      }
      _mergeWithMissingSkillFields(parsedSkill);
    }
  }
};

// src/module/apps/importer/actorImport/itemImporter/importHelper/BaseGearParser.ts
var BaseGearParser = class {
  static {
    __name(this, "BaseGearParser");
  }
  parse(chummerGear) {
    const parsedGear = this.getDefaultData();
    const parserType = "equipment";
    parsedGear.name = chummerGear.name;
    if (chummerGear.extra) {
      parsedGear.name += ` (${chummerGear.extra})`;
    }
    parsedGear.system.technology = parseTechnology(chummerGear);
    parsedGear.system.description = parseDescription(chummerGear);
    parsedGear.system.importFlags = genImportFlags(formatAsSlug(chummerGear.name), parserType);
    return parsedGear;
  }
  setSubType(parsedGear, parserType, subType) {
    if (Object.keys(SR6.itemSubTypeIconOverrides[parserType]).includes(subType)) {
      parsedGear.system.importFlags.subType = formatAsSlug(subType);
    }
  }
  getDefaultData() {
    return DataDefaults.baseItemData({ type: "equipment" });
  }
};

// src/module/apps/importer/actorImport/itemImporter/bioImport/SinParser.ts
var SinParser = class extends BaseGearParser {
  static {
    __name(this, "SinParser");
  }
  parse(chummerGear) {
    const parserType = "sin";
    const parsedGear = super.parse(chummerGear);
    parsedGear.type = parserType;
    if (chummerGear.children) {
      const chummerLicenses = [];
      if (!Array.isArray(chummerGear.children.gear)) {
        chummerLicenses.push(chummerGear.children.gear);
      } else {
        chummerLicenses.push(...chummerGear.children.gear);
      }
      parsedGear.system.licenses = this.parseLicenses(chummerLicenses);
    }
    parsedGear.system.importFlags = genImportFlags(formatAsSlug(chummerGear.name_english), parserType);
    return parsedGear;
  }
  parseLicenses(chummerLicenses) {
    const parsedLicenses = [];
    chummerLicenses.forEach((chummerLicense) => {
      if (chummerLicense.category_english === "ID/Credsticks") {
        parsedLicenses.push(
          {
            name: chummerLicense.extra,
            // 'extra' holds the type of license from chummer
            rtg: chummerLicense.rating,
            description: ""
          }
        );
      }
    });
    return parsedLicenses;
  }
};

// src/module/apps/importer/actorImport/itemImporter/matrixImport/DeviceParser.ts
var DeviceParser = class extends BaseGearParser {
  static {
    __name(this, "DeviceParser");
  }
  parse(chummerGear) {
    const parserType = "device";
    const parsedGear = super.parse(chummerGear);
    parsedGear.type = parserType;
    parsedGear.system.technology.rating = chummerGear.devicerating;
    parsedGear.system.atts = {
      att1: {
        value: parseInt(chummerGear.attack),
        att: "attack"
      },
      att2: {
        value: parseInt(chummerGear.sleaze),
        att: "sleaze"
      },
      att3: {
        value: parseInt(chummerGear.dataprocessing),
        att: "data_processing"
      },
      att4: {
        value: parseInt(chummerGear.firewall),
        att: "firewall"
      }
    };
    if (chummerGear.category_english === "Cyberdecks") {
      parsedGear.system.category = "cyberdeck";
    }
    if (chummerGear.category_english === "Commlinks") {
      parsedGear.system.category = "commlink";
    }
    if (chummerGear.category_english === "Rigger Command Consoles") {
      parsedGear.system.category = "rcc";
    }
    if (chummerGear.category_english === "Entertainment") {
      parsedGear.system.category = "commlink";
    }
    parsedGear.system.importFlags = genImportFlags(formatAsSlug(chummerGear.name_english), parserType);
    this.setSubType(parsedGear, parserType, parsedGear.system.category);
    return parsedGear;
  }
};

// src/module/apps/importer/actorImport/itemImporter/matrixImport/ProgramParser.ts
var ProgramParser = class extends BaseGearParser {
  static {
    __name(this, "ProgramParser");
  }
  parse(chummerGear) {
    const parserType = "program";
    const parsedGear = super.parse(chummerGear);
    parsedGear.type = parserType;
    if (chummerGear.category_english === "Common Programs") {
      parsedGear.system.type = "common_program";
    } else if (chummerGear.category_english === "Hacking Programs") {
      parsedGear.system.type = "hacking_program";
    } else if (chummerGear.category_english === "Software") {
      parsedGear.system.type = "agent";
    }
    parsedGear.system.importFlags = genImportFlags(formatAsSlug(chummerGear.name_english), parserType);
    this.setSubType(parsedGear, parserType, parsedGear.system.type);
    return parsedGear;
  }
};

// src/module/apps/importer/actorImport/itemImporter/weaponImport/AmmoParser.ts
var AmmoParser = class extends BaseGearParser {
  static {
    __name(this, "AmmoParser");
  }
  parse(chummerGear) {
    const parserType = "ammo";
    const parsedGear = super.parse(chummerGear);
    parsedGear.type = parserType;
    if (chummerGear.weaponbonusap) {
      parsedGear.system.ap = parseInt(chummerGear.weaponbonusap);
    }
    if (chummerGear.weaponbonusdamage) {
      parsedGear.system.damage = parseInt(chummerGear.weaponbonusdamage_english);
      if (chummerGear.weaponbonusdamage.includes("S")) {
        parsedGear.system.damageType = "stun";
      } else if (chummerGear.weaponbonusdamage.includes("M")) {
        parsedGear.system.damageType = "matrix";
      } else {
        parsedGear.system.damageType = "physical";
      }
      parsedGear.system.element = chummerGear.weaponbonusdamage_english.match(/\(e\)/)?.pop() == "(e)" ? "electricity" : "";
    }
    parsedGear.system.accuracy = parseInt(chummerGear.weaponbonusacc);
    parsedGear.system.blast = {
      radius: 0,
      dropoff: 0
    };
    parsedGear.system.replaceDamage = false;
    parsedGear.system.importFlags = genImportFlags(formatAsSlug(chummerGear.name_english), parserType);
    this.setSubType(parsedGear, parserType, formatAsSlug(chummerGear.name_english.split(":")[0]));
    return parsedGear;
  }
};

// src/module/apps/importer/actorImport/itemImporter/importHelper/ParserSelector.ts
var ParserSelector = class {
  static {
    __name(this, "ParserSelector");
  }
  /**
   * Selects the correct GearParser depending on the gear.
   * @param chummerGear The gear that needs to be parsed
   * The correct GearParser for this gear entry.
   */
  select(chummerGear) {
    if (chummerGear.issin === "True") {
      return new SinParser();
    }
    if (chummerGear.iscommlink === "True") {
      return new DeviceParser();
    }
    if (chummerGear.isammo === "True") {
      return new AmmoParser();
    }
    if (chummerGear.category_english === "Common Programs" || chummerGear.category_english === "Hacking Programs" || chummerGear.category_english === "Software") {
      return new ProgramParser();
    }
    return new BaseGearParser();
  }
};

// src/module/apps/importer/actorImport/itemImporter/importHelper/GearsParser.ts
var GearsParser = class {
  static {
    __name(this, "GearsParser");
  }
  /**
   * Parses all chummer gear entries
   * @param chummerGears Array of chummer gear entries
   */
  async parseGears(chummerGears, assignIcons) {
    let items = [];
    const iconList = await getIconFiles();
    chummerGears.forEach(async (chummerGear) => {
      try {
        if (!this.gearShouldBeParsed(chummerGear)) {
          return;
        }
        const itemData = this.parseGearEntry(chummerGear);
        if (assignIcons) {
          itemData.img = await iconAssign(itemData.system.importFlags, itemData.system, iconList);
        }
        ;
        items.push(itemData);
      } catch (e2) {
        console.error(e2);
      }
    });
    return items;
  }
  parseGearEntry(chummerGear) {
    const parserSelector = new ParserSelector();
    const parser = parserSelector.select(chummerGear);
    return parser.parse(chummerGear);
  }
  gearShouldBeParsed(chummerGear) {
    const englishGearName = chummerGear.name_english.toLowerCase();
    if (englishGearName.startsWith("grenade") || englishGearName.startsWith("minigrenade") || englishGearName.startsWith("rocket")) {
      return false;
    }
    return true;
  }
};

// src/module/apps/importer/actorImport/itemImporter/armorImport/ArmorParser.js
var ArmorParser = class {
  static {
    __name(this, "ArmorParser");
  }
  async parseArmors(chummerChar, assignIcons) {
    const armors = getArray(chummerChar.armors?.armor);
    const parsedArmors = [];
    const iconList = await getIconFiles();
    armors.forEach(async (chummerArmor) => {
      try {
        const itemData = this.parseArmor(chummerArmor);
        if (assignIcons) {
          itemData.img = await iconAssign(itemData.system.importFlags, itemData.system, iconList);
        }
        ;
        parsedArmors.push(itemData);
      } catch (e2) {
        console.error(e2);
      }
    });
    const otherArmors = getArray(chummerChar.otherarmors?.otherarmor);
    otherArmors.forEach(async (chummerArmor) => {
      try {
        const itemData = this.parseOtherArmor(chummerArmor);
        if (assignIcons) {
          itemData.img = await iconAssign(itemData.system.importFlags, itemData.system, iconList);
        }
        ;
        parsedArmors.push(itemData);
      } catch (e2) {
        console.error(e2);
      }
    });
    return parsedArmors;
  }
  parseArmor(chummerArmor) {
    const parserType = "armor";
    const system = {
      armor: {}
    };
    const armor3 = system.armor;
    armor3.mod = chummerArmor.armor.includes("+");
    armor3.value = parseInt(chummerArmor.armor);
    if (chummerArmor.armormods?.armormod) {
      armor3.fire = 0;
      armor3.electricity = 0;
      armor3.cold = 0;
      armor3.acid = 0;
      armor3.radiation = 0;
      const mods3 = getArray(chummerArmor.armormods.armormod);
      mods3.forEach((mod) => {
        if (mod.name_english.toLowerCase().includes("fire resistance")) {
          armor3.fire += parseInt(mod.rating);
        } else if (mod.name_english.toLowerCase().includes("nonconductivity")) {
          armor3.electricity += parseInt(mod.rating);
        } else if (mod.name_english.toLowerCase().includes("insulation")) {
          armor3.cold += parseInt(mod.rating);
        } else if (mod.name_english.toLowerCase().includes("radiation shielding")) {
          armor3.radiation += parseInt(mod.rating);
        }
      });
    }
    system.technology = parseTechnology(chummerArmor);
    system.description = parseDescription(chummerArmor);
    system.importFlags = genImportFlags(formatAsSlug(chummerArmor.name_english), parserType);
    setSubType(system, parserType, formatAsSlug(chummerArmor.category_english));
    return createItemData(chummerArmor.name, parserType, system);
  }
  parseOtherArmor(chummerArmor) {
    const parserType = "armor";
    const system = {
      armor: {}
    };
    const armor3 = system.armor;
    armor3.mod = chummerArmor.armor.includes("+");
    armor3.value = parseInt(chummerArmor.armor);
    system.technology = parseTechnology(chummerArmor);
    system.technology.equipped = true;
    system.description = parseDescription(chummerArmor);
    system.importFlags = genImportFlags(formatAsSlug(chummerArmor.objectname_english), parserType);
    setSubType(system, parserType, formatAsSlug(chummerArmor.improvesource));
    return createItemData(chummerArmor.objectname_english, parserType, system);
  }
};

// src/module/apps/importer/actorImport/itemImporter/wareImport/WareParser.js
var WareParser = class {
  static {
    __name(this, "WareParser");
  }
  async parseWares(chummerChar, assignIcons) {
    const chummerWares = getArray(chummerChar.cyberwares.cyberware);
    const parsedWare = [];
    const iconList = await getIconFiles();
    await chummerWares.forEach(async (chummerWare) => {
      try {
        const itemData = this.parseWare(chummerWare);
        if (assignIcons) {
          itemData.img = await iconAssign(itemData.system.importFlags, itemData.system, iconList);
        }
        ;
        parsedWare.push(itemData);
      } catch (e2) {
        console.error(e2);
      }
    });
    return parsedWare;
  }
  parseWare(chummerWare) {
    let parserType = chummerWare.improvementsource.toLowerCase();
    if (!["cyberware", "bioware"].includes(parserType)) {
      parserType = "cyberware";
    }
    ;
    const system = {};
    system.description = parseDescription(chummerWare);
    system.technology = parseTechnology(chummerWare);
    system.technology.equipped = true;
    system.essence = chummerWare.ess;
    system.grade = chummerWare.grade;
    if (parserType == "bioware") {
      system.technology.wireless = false;
    }
    system.importFlags = genImportFlags(formatAsSlug(chummerWare.name_english), parserType);
    setSubType(system, parserType, formatAsSlug(chummerWare.category_english));
    return createItemData(chummerWare.name, parserType, system);
  }
};

// src/module/apps/importer/actorImport/itemImporter/bioImport/QualityParser.js
var QualityParser = class {
  static {
    __name(this, "QualityParser");
  }
  async parseQualities(chummerChar, assignIcons) {
    const qualities = getArray(chummerChar.qualities.quality);
    const parsedQualities = [];
    const iconList = await getIconFiles();
    await qualities.forEach(async (chummerQuality) => {
      try {
        const itemData = this.parseQuality(chummerQuality);
        if (assignIcons) {
          itemData.img = await iconAssign(itemData.system.importFlags, itemData.system, iconList);
        }
        ;
        parsedQualities.push(itemData);
      } catch (e2) {
        console.error(e2);
      }
    });
    return parsedQualities;
  }
  parseQuality(chummerQuality) {
    const parserType = "quality";
    const system = {};
    system.type = chummerQuality.qualitytype_english.toLowerCase();
    system.rating = parseInt(chummerQuality.extra) || 0;
    system.description = parseDescription(chummerQuality);
    system.importFlags = genImportFlags(formatAsSlug(chummerQuality.name_english), parserType);
    setSubType(system, parserType, formatAsSlug(system.type));
    let quality = createItemData(chummerQuality.name, parserType, system);
    return quality;
  }
};

// src/module/apps/importer/actorImport/itemImporter/magicImport/PowerParser.js
var PowerParser = class {
  static {
    __name(this, "PowerParser");
  }
  async parsePowers(chummerChar, assignIcons) {
    const powers = getArray(chummerChar.powers.power);
    const parsedPowers = [];
    const iconList = await getIconFiles();
    powers.forEach(async (chummerPower) => {
      try {
        const itemData = this.parsePower(chummerPower);
        if (assignIcons) {
          itemData.img = await iconAssign(itemData.system.importFlags, itemData.system, iconList);
        }
        ;
        parsedPowers.push(itemData);
      } catch (e2) {
        console.error(e2);
      }
    });
    return parsedPowers;
  }
  parsePower(chummerPower) {
    const parserType = "adept_power";
    const system = {};
    system.description = parseDescription(chummerPower);
    system.level = parseInt(chummerPower.rating);
    system.pp = parseFloat(chummerPower.totalpoints);
    system.importFlags = genImportFlags(formatAsSlug(chummerPower.fullname), parserType);
    if (chummerPower.name != chummerPower.fullname) {
      setSubType(system, parserType, formatAsSlug(chummerPower.name));
      if (system.importFlags.subType) {
        system.importFlags.name = formatAsSlug(chummerPower.extra);
      }
    }
    return createItemData(chummerPower.fullname, parserType, system);
  }
};

// src/module/apps/importer/actorImport/itemImporter/magicImport/SpellParser.js
var SpellParser = class {
  static {
    __name(this, "SpellParser");
  }
  async parseSpells(chummerChar, assignIcons) {
    const spells = getArray(chummerChar.spells.spell).filter((chummerSpell) => !chummerSpell.category_english.includes("Rituals"));
    const parsedSpells = [];
    const iconList = await getIconFiles();
    spells.forEach(async (chummerSpell) => {
      try {
        if (chummerSpell.alchemy.toLowerCase() !== "true") {
          const itemData = await this.parseSpell(chummerSpell);
          if (assignIcons) {
            itemData.img = await iconAssign(itemData.system.importFlags, itemData.system, iconList);
          }
          ;
          parsedSpells.push(itemData);
        }
      } catch (e2) {
        console.error(e2);
      }
    });
    return parsedSpells;
  }
  async parseSpell(chummerSpell) {
    const parserType = "spell";
    const system = {};
    this.prepareSystem(system, chummerSpell);
    let description = "";
    if (chummerSpell.descriptors) description = chummerSpell.descriptors;
    if (chummerSpell.description) description += `
${chummerSpell.description}`;
    system.description.value = await TextEditor.enrichHTML(description);
    this.parseDuration(chummerSpell, system);
    this.prepareAction(system);
    this.handleSpellTypeSpecifics(system, chummerSpell);
    system.importFlags = genImportFlags(formatAsSlug(chummerSpell.name_english), parserType);
    setSubType(system, parserType, formatAsSlug(chummerSpell.category_english));
    return createItemData(chummerSpell.name, parserType, system);
  }
  prepareSystem(system, chummerSpell) {
    system.category = chummerSpell.category_english.toLowerCase().replace(/\s/g, "_");
    system.name = chummerSpell.name;
    system.type = chummerSpell.type === "M" ? "mana" : "physical";
    system.range = chummerSpell.range === "T" ? "touch" : chummerSpell.range.toLowerCase().replace(/\s/g, "_").replace("(", "").replace(")", "");
    system.drain = parseInt(chummerSpell.dv.replace(/[A-Z]*/g, ""));
    system.description = parseDescription(chummerSpell);
  }
  parseDuration(chummerSpell, system) {
    if (chummerSpell.duration.toLowerCase() === "s") {
      system.duration = "sustained";
    } else if (chummerSpell.duration.toLowerCase() === "i") {
      system.duration = "instant";
    } else if (chummerSpell.duration.toLowerCase() === "p") {
      system.duration = "permanent";
    }
  }
  prepareAction(system) {
    system.action = {};
    system.action.type = "varies";
    system.action.skill = "spellcasting";
    system.action.attribute = "magic";
    system.action.damage = DataDefaults.damageData();
    system.action.damage.type.base = "";
    system.action.damage.type.value = "";
  }
  handleSpellTypeSpecifics(system, chummerSpell) {
    let category3 = chummerSpell.category_english;
    if (chummerSpell.descriptors) {
      const desc = chummerSpell.descriptors.toLowerCase();
      if (category3.toLowerCase() === "combat") {
        this.handleCombatSpellSpecifics(system, desc, chummerSpell.damage);
      }
      if (category3.toLowerCase() === "detection") {
        this.handleDetectionSpellSpecifics(system, desc);
      }
      if (category3.toLowerCase() === "illusion") {
        this.handleIllusionSpellSpecifics(system, desc);
      }
      if (category3.toLowerCase() === "manipulation") {
        this.handleManipulationSpellSpecifics(system, desc);
      }
    }
  }
  handleCombatSpellSpecifics(system, desc, damage) {
    system.combat = {};
    if (desc.includes("indire")) {
      system.combat.type = "indirect";
      system.action.opposed = {
        type: "defense"
      };
    } else {
      system.combat.type = "direct";
      if (system.type === "mana") {
        system.action.opposed = {
          type: "soak",
          attribute: "willpower"
        };
      } else if (system.type === "physical") {
        system.action.opposed = {
          type: "soak",
          attribute: "body"
        };
      }
    }
    if (damage.includes("0")) {
      system.action.damage.type.base = damage.match(/[SG]/) !== null ? "stun" : "physical";
      system.action.damage.type.value = system.action.damage.type.base;
    }
  }
  handleDetectionSpellSpecifics(system, desc) {
    system.detection = {};
    const split = desc.split(",");
    split.forEach((token) => {
      token = token || "";
      token = token.replace(" detection spell", "");
      if (!token) return;
      if (token.includes("area")) return;
      if (token.includes("passive"))
        system.detection.passive = true;
      else if (token.includes("active"))
        system.detection.passive = false;
      else if (token)
        system.detection.type = token.toLowerCase();
    });
    if (!system.detection.passive) {
      system.action.opposed = {
        type: "custom",
        attribute: "willpower",
        attribute2: "logic"
      };
    }
  }
  handleIllusionSpellSpecifics(system, desc) {
    system.illusion = {};
    const split = desc.split(",");
    split.forEach((token) => {
      token = token || "";
      token = token.replace(" illusion spell", "");
      if (!token) return;
      if (token.includes("area")) return;
      if (token.includes("sense"))
        system.illusion.sense = token.toLowerCase();
      else if (token)
        system.illusion.type = token.toLowerCase();
    });
    if (system.type === "mana") {
      system.action.opposed = {
        type: "custom",
        attribute: "willpower",
        attribute2: "logic"
      };
    } else {
      system.action.opposed = {
        type: "custom",
        attribute: "intuition",
        attribute2: "logic"
      };
    }
  }
  handleManipulationSpellSpecifics(system, desc) {
    system.manipulation = {};
    if (desc.includes("environmental"))
      system.manipulation.environmental = true;
    if (desc.includes("physical"))
      system.manipulation.physical = true;
    if (desc.includes("mental"))
      system.manipulation.mental = true;
    if (system.manipulation.mental) {
      system.action.opposed = {
        type: "custom",
        attribute: "willpower",
        attribute2: "logic"
      };
    }
    if (system.manipulation.physical) {
      system.action.opposed = {
        type: "custom",
        attribute: "body",
        attribute2: "strength"
      };
    }
  }
};

// src/module/apps/importer/actorImport/itemImporter/weaponImport/WeaponParser.js
var WeaponParser = class {
  static {
    __name(this, "WeaponParser");
  }
  parseDamage = /* @__PURE__ */ __name((val) => {
    const damage = {
      damage: 0,
      type: "",
      radius: 0,
      dropoff: 0
    };
    const split = val.split(" ");
    if (split.length > 0) {
      const l2 = split[0].match(/(\d+)(\w+)/);
      if (l2 && l2[1]) {
        damage.damage = parseInt(l2[1]);
      }
      if (l2 && l2[2]) {
        damage.type = l2[2] === "P" ? "physical" : "stun";
      }
    }
    for (let i2 = 1; i2 < split.length; i2++) {
      const l2 = split[i2].match(/(-?\d+)(.*)/);
      if (l2 && l2[2]) {
        if (l2[2].toLowerCase().includes("/m")) {
          damage.dropoff = parseInt(l2[1]);
          damage.radius = damage.damage / Math.abs(damage.dropoff);
        } else {
          damage.radius = parseInt(l2[1]);
        }
      }
    }
    return damage;
  }, "parseDamage");
  async parseWeapons(chummerChar, assignIcons) {
    return this.parseWeaponArray(getArray(chummerChar.weapons?.weapon), assignIcons);
  }
  async parseWeaponArray(weapons3, assignIcons) {
    const parsedWeapons = [];
    const iconList = await getIconFiles();
    weapons3.forEach(async (chummerWeapon) => {
      try {
        const itemData = this.parseWeapon(chummerWeapon);
        if (assignIcons) {
          itemData.img = await iconAssign(itemData.system.importFlags, itemData.system, iconList);
        }
        ;
        parsedWeapons.push(itemData);
      } catch (e2) {
        console.error(e2);
      }
    });
    return parsedWeapons;
  }
  parseWeapon(chummerWeapon) {
    const parserType = "weapon";
    const system = {
      action: {
        damage: {}
      }
    };
    const action = system.action;
    const damage = system.action.damage;
    system.description = parseDescription(chummerWeapon);
    system.technology = parseTechnology(chummerWeapon);
    damage.ap = {
      base: parseInt(getValues(chummerWeapon.rawap)[0])
    };
    action.type = "varies";
    if (chummerWeapon.skill) {
      action.skill = chummerWeapon.skill.toLowerCase().replace(/\s/g, "_");
    } else if (chummerWeapon.category && chummerWeapon.category.toLowerCase().includes("exotic")) {
      action.skill = chummerWeapon.category.toLowerCase().replace(" weapons", "").replace(/\s/g, "_");
    } else if (chummerWeapon.category && chummerWeapon.category.toLowerCase().includes("laser weapons")) {
      action.skill = "exotic_range";
    }
    if (action.skill.includes("exotic")) {
      action.skill = action.skill.replace("_weapon", "");
    }
    action.attribute = "agility";
    action.limit = {
      base: parseInt(getValues(chummerWeapon.rawaccuracy)[0])
    };
    if (chummerWeapon.type.toLowerCase() === "melee") {
      this.handleMeleeWeapon(chummerWeapon, system);
    }
    if (chummerWeapon.type.toLowerCase() === "ranged") {
      this.handledRangedWeapon(chummerWeapon, system);
    } else if (chummerWeapon.type.toLowerCase() === "thrown") {
      system.category = "thrown";
      const ranges = chummerWeapon.ranges[0];
      if (ranges && ranges.short && ranges.medium && ranges.long && ranges.extreme) {
        system.thrown = {
          ...system.thrown,
          ranges: {
            short: parseInt(ranges.short.split("-")[1]),
            medium: parseInt(ranges.medium.split("-")[1]),
            long: parseInt(ranges.long.split("-")[1]),
            extreme: parseInt(ranges.extreme.split("-")[1])
          }
        };
      }
    }
    {
      const chummerDamage = this.parseDamage(chummerWeapon.damage_noammo_english);
      damage.base = chummerDamage.damage;
      damage.type = {
        base: chummerDamage.type
      };
      if (chummerDamage.dropoff || chummerDamage.radius) {
        system.thrown = {
          ...system.thrown,
          blast: {
            radius: chummerDamage.radius,
            dropoff: chummerDamage.dropoff
          }
        };
      }
    }
    system.importFlags = genImportFlags(formatAsSlug(chummerWeapon.name_english), parserType);
    let subType = "";
    if (system.category) {
      subType = formatAsSlug(system.category);
    }
    const weaponCategory = formatAsSlug(chummerWeapon.category_english);
    if (!(subType && weaponCategory == "gear")) {
      subType = weaponCategory;
    }
    if (weaponCategory == "gear" && chummerWeapon.name_english.includes(":")) {
      subType = formatAsSlug(chummerWeapon.name_english.split(":")[0]);
    }
    setSubType(system, parserType, subType);
    const itemData = createItemData(chummerWeapon.name, "weapon", system);
    this.handleClips(itemData, chummerWeapon);
    this.handleAccessories(itemData, chummerWeapon);
    return itemData;
  }
  handleMeleeWeapon(chummerWeapon, system) {
    system.action.type = "complex";
    system.category = "melee";
    system.melee = {
      reach: parseInt(chummerWeapon.reach)
    };
  }
  handledRangedWeapon(chummerWeapon, system) {
    system.category = "range";
    if (system.action.skill.toLowerCase().includes("throw")) {
      system.category = "thrown";
    }
    const range = {};
    system.range = range;
    range.rc = { base: parseInt(getValues(chummerWeapon.rawrc)[0]) };
    if (chummerWeapon.mode) {
      const modes = chummerWeapon.mode_noammo.toLowerCase();
      range.modes = {
        single_shot: modes.includes("ss"),
        semi_auto: modes.includes("sa"),
        burst_fire: modes.includes("bf"),
        full_auto: modes.includes("fa")
      };
    }
    if (chummerWeapon.clips?.clip != null) {
      system.ammo = {};
      let ammo = system.ammo;
      const chummerClips = getArray(chummerWeapon.clips.clip);
      let clips = chummerClips.filter((clip) => !clip.name.toLowerCase().includes("inter"));
      ammo.spare_clips = {
        value: clips?.length - 1 || 0,
        max: clips?.length - 1 || 0
      };
      let loadedClip = clips.filter((clip) => clip.location === "loaded")[0];
      ammo.current = {
        max: loadedClip?.count || 0,
        value: loadedClip?.count || 0
      };
    }
    const ranges = chummerWeapon.ranges[0];
    if (ranges && ranges.short && ranges.medium && ranges.long && ranges.extreme) {
      const rangeData = {
        short: parseInt(ranges.short.split("-")[1]),
        medium: parseInt(ranges.medium.split("-")[1]),
        long: parseInt(ranges.long.split("-")[1]),
        extreme: parseInt(ranges.extreme.split("-")[1])
      };
      if (system.category === "range") {
        range.ranges = rangeData;
      }
      if (system.category === "thrown") {
        system.thrown = {
          ...system.thrown,
          ranges: rangeData
        };
      }
    }
  }
  handleClips(item, chummerWeapon) {
    if (chummerWeapon.clips?.clip != null) {
      const chummerClips = getArray(chummerWeapon.clips.clip);
      let clips = chummerClips.filter((clip) => !clip.name.toLowerCase().includes("inter"));
      let ammo = [];
      clips.forEach((clip) => {
        let ammobonus = clip.ammotype;
        let systemAmmo = {
          accuracy: parseInt(ammobonus.weaponbonusacc),
          ap: parseInt(ammobonus.weaponbonusap),
          blast: {
            radius: 0,
            dropoff: 0
          },
          damage: ammobonus.weaponbonusdamage_english.match(/(\d+)/).pop(),
          damageType: ammobonus.weaponbonusdamage_english.match(/S/)?.pop() === "S" ? "stun" : "physical",
          element: ammobonus.weaponbonusdamage_english.match(/\(e\)/)?.pop() == "(e)" ? "electricity" : "",
          importFlags: {
            isFreshImport: true
          },
          replaceDamage: false,
          technology: {
            equipped: clip.name === chummerWeapon.currentammo
          }
        };
        let currentAmmo = createItemData(clip.name, "ammo", systemAmmo);
        currentAmmo._id = randomID(16);
        ammo.push(currentAmmo);
      });
      if (!item.flags?.shadowrun6 - elysium?.embeddedItems) {
        item.flags = {
          "shadowrun6-elysium": {
            embeddedItems: ammo
          }
        };
      } else {
        item.flags.shadowrun6 - elysium.embeddedItems.push(...ammo);
      }
    }
  }
  handleAccessories(itemData, chummerWeapon) {
    if (chummerWeapon.clips?.clip != null) {
      let chummerAccessories = getArray(chummerWeapon.accessories.accessory);
      let accessories = [];
      chummerAccessories.forEach((item) => {
        let system = {
          type: "weapon",
          mount_point: item.mount.toLowerCase(),
          dice_pool: 0,
          accuracy: parseInt(item.accuracy),
          rc: parseInt(item.rc) || 0,
          conceal: parseInt(item.conceal),
          technology: {
            equipped: true
          }
        };
        let current = createItemData(item.name, "modification", system);
        current._id = randomID(16);
        accessories.push(current);
      });
      if (!itemData.flags?.shadowrun6 - elysium?.embeddedItems) {
        itemData.flags = {
          "shadowrun6-elysium": {
            embeddedItems: accessories
          }
        };
      } else {
        itemData.flags.shadowrun6 - elysium.embeddedItems.push(...accessories);
      }
    }
  }
};

// src/module/apps/importer/actorImport/itemImporter/bioImport/LifestyleParser.js
var LifestyleParser = class {
  static {
    __name(this, "LifestyleParser");
  }
  async parseLifestyles(chummerChar, assignIcons) {
    const chummerLifestyle = getArray(chummerChar.lifestyles.lifestyle);
    const parsedLifestyle = [];
    const iconList = await getIconFiles();
    chummerLifestyle.forEach(async (chummerLifestyle2) => {
      try {
        const itemData = this.parseLifestyle(chummerLifestyle2);
        if (assignIcons) {
          itemData.img = await iconAssign(itemData.system.importFlags, itemData.system, iconList);
        }
        ;
        parsedLifestyle.push(itemData);
      } catch (e2) {
        console.error(e2);
      }
    });
    return parsedLifestyle;
  }
  parseLifestyle(chummerLifestyle) {
    const parserType = "lifestyle";
    const system = {};
    const chummerLifestyleType = chummerLifestyle.baselifestyle.toLowerCase();
    if (chummerLifestyleType in SR6.lifestyleTypes) {
      system.type = chummerLifestyleType;
    } else {
      if (chummerLifestyleType === "luxury") {
        system.type = "luxory";
      } else {
        system.type = "other";
      }
    }
    system.cost = chummerLifestyle.totalmonthlycost;
    system.permanent = chummerLifestyle.purchased;
    system.description = parseDescription(chummerLifestyle);
    const itemName = chummerLifestyle.name ? chummerLifestyle.name : chummerLifestyle.baselifestyle;
    system.importFlags = genImportFlags(formatAsSlug(itemName), parserType);
    const itemData = createItemData(itemName, parserType, system);
    return itemData;
  }
};

// src/module/apps/importer/actorImport/itemImporter/bioImport/ContactParser.js
var ContactParser = class {
  static {
    __name(this, "ContactParser");
  }
  async parseContacts(chummerChar, assignIcons) {
    const chummerContacts = getArray(chummerChar.contacts.contact);
    const parsedContacts = [];
    const iconList = await getIconFiles();
    chummerContacts.forEach(async (chummerContact) => {
      try {
        const itemData = this.parseContact(chummerContact);
        if (assignIcons) {
          itemData.img = await iconAssign(itemData.system.importFlags, itemData.system, iconList);
        }
        ;
        parsedContacts.push(itemData);
      } catch (e2) {
        console.error(e2);
      }
    });
    return parsedContacts;
  }
  parseContact(chummerContact) {
    const parserType = "contact";
    const system = {};
    system.type = chummerContact.role;
    if (chummerContact.connection.toLowerCase().includes("group")) {
      system.connection = chummerContact.connection.toLowerCase().replace("group(", "").replace(")", "");
    } else {
      system.connection = chummerContact.connection;
    }
    system.loyalty = chummerContact.loyalty;
    system.family = chummerContact.family.toLowerCase() === "true";
    system.blackmail = chummerContact.blackmail.toLowerCase() === "true";
    system.description = parseDescription(chummerContact);
    const itemName = chummerContact.name ? chummerContact.name : "[Unnamed connection]";
    system.importFlags = genImportFlags(formatAsSlug(itemName), parserType);
    const itemData = createItemData(itemName, "contact", system);
    return itemData;
  }
};

// src/module/apps/importer/actorImport/itemImporter/importHelper/SimpleParser.js
var SimpleParser = class {
  static {
    __name(this, "SimpleParser");
  }
  async parseCollection(parsingCollection, parserType, assignIcons) {
    const parsed = [];
    const iconList = await getIconFiles();
    parsingCollection.forEach(async (toParse) => {
      try {
        const itemData = this.parseItem(toParse, parserType);
        if (assignIcons) {
          itemData.img = await iconAssign(itemData.system.importFlags, itemData.system, iconList);
        }
        ;
        parsed.push(itemData);
      } catch (e2) {
        console.error(e2);
      }
    });
    return parsed;
  }
  parseItem(toParse, parserType) {
    const system = {};
    system.description = parseDescription(toParse);
    system.importFlags = genImportFlags(formatAsSlug(toParse.name_english), parserType);
    return createItemData(toParse.fullname, parserType, system);
  }
};

// src/module/apps/importer/actorImport/itemImporter/magicImport/CritterPowerParser.js
var CritterPowerParser = class {
  static {
    __name(this, "CritterPowerParser");
  }
  async parseCritterPowers(chummerChar, assignIcons) {
    const powers = getArray(chummerChar.critterpowers?.critterpower);
    const parsedItems = [];
    const iconList = await getIconFiles();
    powers.forEach(async (chummerPower) => {
      try {
        const itemData = this.parseCritterPower(chummerPower);
        if (assignIcons) {
          itemData.img = await iconAssign(itemData.system.importFlags, itemData.system, iconList);
        }
        ;
        parsedItems.push(itemData);
      } catch (e2) {
        console.error(e2);
      }
    });
    return parsedItems;
  }
  parseCritterPower(chummerCritterPower) {
    const parserType = "critter_power";
    const system = {};
    system.description = parseDescription(chummerCritterPower);
    system.rating = parseFloat(chummerCritterPower.extra);
    system.powerType = chummerCritterPower.type === "P" ? "physical" : "mana";
    system.range = chummerCritterPower.range;
    system.duration = chummerCritterPower.duration;
    system.importFlags = genImportFlags(formatAsSlug(chummerCritterPower.fullname), parserType);
    if (chummerCritterPower.name_english != chummerCritterPower.fullname) {
      setSubType(system, parserType, formatAsSlug(chummerCritterPower.name_english));
      if (system.importFlags.subType) {
        system.importFlags.name = formatAsSlug(chummerCritterPower.extra);
      }
    }
    return createItemData(chummerCritterPower.fullname, parserType, system);
  }
};

// src/module/apps/importer/actorImport/itemImporter/magicImport/RitualParser.js
var RitualParser = class {
  static {
    __name(this, "RitualParser");
  }
  async parseRituals(chummerChar, assignIcons) {
    const items = getArray(chummerChar.spells.spell).filter((chummerSpell) => chummerSpell.category_english.includes("Rituals"));
    const parsedItems = [];
    const iconList = await getIconFiles();
    items.forEach(async (item) => {
      try {
        if (item.alchemy.toLowerCase() !== "true") {
          const itemData = this.parseRitual(item);
          if (assignIcons) {
            itemData.img = await iconAssign(itemData.system.importFlags, itemData.system, iconList);
          }
          ;
          parsedItems.push(itemData);
        }
      } catch (e2) {
        console.error(e2);
      }
    });
    return parsedItems;
  }
  parseRitual(chummerRitual) {
    const parserType = "ritual";
    const system = {};
    this.prepareSystem(system, chummerRitual);
    this.prepareAction(system);
    system.importFlags = genImportFlags(formatAsSlug(chummerRitual.name_english), parserType);
    setSubType(system, parserType, formatAsSlug(chummerRitual.category_english));
    return createItemData(chummerRitual.name, parserType, system);
  }
  prepareSystem(system, chummerRitual) {
    system.name = chummerRitual.name;
    system.type = chummerRitual.type === "M" ? "mana" : "physical";
    system.descriptors = chummerRitual.descriptors;
    system.description = parseDescription(chummerRitual);
  }
  prepareAction(system) {
    system.action = {};
    system.action.type = "varies";
    system.action.skill = "ritual_spellcasting";
    system.action.attribute = "magic";
  }
};

// src/module/apps/importer/actorImport/itemImporter/ItemsParser.js
var ItemsParser = class {
  static {
    __name(this, "ItemsParser");
  }
  /**
   * Parses all items from a chummer char and returns an array of the corresponding foundry items.
   * @param {*} chummerChar The chummer char holding the items
   * @param {*} importOptions Additional import option that specify what items will be imported.
   */
  async parse(chummerChar, importOptions) {
    const promises = [];
    Object.freeze(chummerChar);
    if (importOptions.qualities && chummerChar.qualities?.quality) {
      promises.push(new QualityParser().parseQualities(chummerChar, importOptions.assignIcons));
    }
    if (importOptions.weapons && chummerChar.weapons?.weapon) {
      promises.push(new WeaponParser().parseWeapons(chummerChar, importOptions.assignIcons));
    }
    if (importOptions.armor && (chummerChar.armors?.armor || chummerChar.otherarmors?.otherarmor)) {
      promises.push(new ArmorParser().parseArmors(chummerChar, importOptions.assignIcons));
    }
    if (importOptions.cyberware && chummerChar.cyberwares?.cyberware) {
      promises.push(new WareParser().parseWares(chummerChar, importOptions.assignIcons));
    }
    if (importOptions.powers && chummerChar.powers?.power) {
      promises.push(new PowerParser().parsePowers(chummerChar, importOptions.assignIcons));
    }
    if (importOptions.equipment && chummerChar.gears?.gear) {
      const gears3 = getArray(chummerChar.gears.gear);
      promises.push(new GearsParser().parseGears(gears3, importOptions.assignIcons));
    }
    if (importOptions.spells && chummerChar.spells?.spell) {
      promises.push(new SpellParser().parseSpells(chummerChar, importOptions.assignIcons));
      promises.push(new RitualParser().parseRituals(chummerChar, importOptions.assignIcons));
    }
    if (importOptions.contacts && chummerChar.contacts?.contact) {
      promises.push(new ContactParser().parseContacts(chummerChar, importOptions.assignIcons));
    }
    if (importOptions.lifestyles && chummerChar.lifestyles?.lifestyle) {
      promises.push(new LifestyleParser().parseLifestyles(chummerChar, importOptions.assignIcons));
    }
    if (chummerChar.metamagics?.metamagic) {
      let metamagics = getArray(chummerChar.metamagics.metamagic).filter((meta) => meta.improvementsource.toLowerCase().includes("metamagic"));
      promises.push(new SimpleParser().parseCollection(metamagics, "metamagic", importOptions.assignIcons));
    }
    if (chummerChar.metamagics?.metamagic) {
      let echoes = getArray(chummerChar.metamagics.metamagic).filter((meta) => meta.improvementsource.toLowerCase().includes("echo"));
      promises.push(new SimpleParser().parseCollection(echoes, "echo", importOptions.assignIcons));
    }
    promises.push(new CritterPowerParser().parseCritterPowers(chummerChar, importOptions.assignIcons));
    return (await Promise.all(promises)).flat();
  }
};

// src/module/apps/importer/actorImport/itemImporter/vehicleImport/MountedWeaponParser.js
var MountedWeaponParser = class {
  static {
    __name(this, "MountedWeaponParser");
  }
  async parseWeapons(vehicle, assignIcons) {
    const mods3 = getArray(vehicle.mods?.mod);
    const weapons3 = mods3.filter((mod) => mod.weapons != null).map((mod) => getArray(mod.weapons?.weapon)).flat();
    return new WeaponParser().parseWeaponArray(weapons3, assignIcons);
  }
};

// src/module/apps/importer/actorImport/itemImporter/vehicleImport/VehicleModsParser.js
var VehicleModsParser = class {
  static {
    __name(this, "VehicleModsParser");
  }
  async parseMods(vehicle, assignIcons) {
    const mods3 = getArray(vehicle.mods?.mod);
    let parsed = [];
    const iconList = await getIconFiles();
    mods3.forEach(async (toParse) => {
      try {
        const itemData = this.parseMod(toParse);
        if (assignIcons) {
          itemData.img = await iconAssign(itemData.system.importFlags, itemData.system, iconList);
        }
        ;
        parsed.push(itemData);
      } catch (e2) {
        console.error(e2);
      }
    });
    return parsed;
  }
  parseMod(mod) {
    const parserType = "modification";
    const system = {};
    system.description = parseDescription(mod);
    system.technology = parseTechnology(mod);
    system.importFlags = genImportFlags(formatAsSlug(mod.name_english), parserType);
    setSubType(system, parserType, formatAsSlug(mod.category_english));
    const itemData = createItemData(mod.name, parserType, system);
    return itemData;
  }
};

// src/module/apps/importer/actorImport/itemImporter/vehicleImport/VehicleParser.ts
var VehicleParser = class {
  static {
    __name(this, "VehicleParser");
  }
  async parseVehicles(actor, chummerChar, importOptions) {
    if (!importOptions.vehicles) {
      return;
    }
    if (!game.user?.can("ACTOR_CREATE")) {
      ui.notifications?.error(game.i18n.format("SR6.VehicleImport.MissingPermission"));
      return;
    }
    const vehicles = getArray(chummerChar.vehicles?.vehicle);
    return await Promise.all(vehicles.map(async (vehicle) => {
      const vehicleActor = await Actor.create({
        name: vehicle.name,
        type: "vehicle"
      });
      const promises = [];
      promises.push(new WeaponParser().parseWeapons(vehicle, importOptions.assignIcons));
      promises.push(new GearsParser().parseGears(getArray(vehicle.gears?.gear), importOptions.assignIcons));
      promises.push(new MountedWeaponParser().parseWeapons(vehicle, importOptions.assignIcons));
      promises.push(new VehicleModsParser().parseMods(vehicle, importOptions.assignIcons));
      let handling3;
      let off_road_handling;
      if (vehicle.handling.includes("/")) {
        handling3 = vehicle.handling.split("/")[0];
        off_road_handling = vehicle.handling.split("/")[1];
      } else {
        handling3 = vehicle.handling;
        off_road_handling = vehicle.handling;
      }
      let speed3;
      let off_road_speed;
      if (vehicle.speed.includes("/")) {
        speed3 = vehicle.speed.split("/")[0];
        off_road_speed = vehicle.speed.split("/")[1];
      } else {
        speed3 = vehicle.speed;
        off_road_speed = vehicle.speed;
      }
      await vehicleActor.update({
        "system.driver": actor.id,
        "system.vehicle_stats.pilot.base": vehicle.pilot,
        "system.vehicle_stats.handling.base": handling3,
        "system.vehicle_stats.off_road_handling.base": off_road_handling,
        "system.vehicle_stats.speed.base": speed3,
        "system.vehicle_stats.off_road_speed.base": off_road_speed,
        "system.vehicle_stats.acceleration.base": vehicle.accel,
        "system.vehicle_stats.sensor.base": vehicle.sensor,
        "system.vehicle_stats.seats.base": vehicle.seats,
        "system.attributes.body.base": vehicle.body,
        "system.armor.base": vehicle.armor,
        "system.isDrone": vehicle.isdrone === "True",
        "folder": actor.folder?.id
      });
      await vehicleActor.createEmbeddedDocuments("Item", (await Promise.all(promises)).flat());
      return vehicleActor;
    }));
  }
};

// src/module/apps/importer/actorImport/characterImporter/CharacterImporter.js
var CharacterImporter = class {
  static {
    __name(this, "CharacterImporter");
  }
  /**
   * Imports a chummer character into an existing actor. The actor will be updated. This might lead to duplicate items.
   * @param {*} actor The actor that will be updated with the chummer character.
   * @param {*} chummerFile The complete chummer file as json object. The first character will be selected for import.
   * @param {*} importOptions Additional import option that specify what parts of the chummer file will be imported.
   */
  async importChummerCharacter(actor, chummerFile, importOptions) {
    console.log("Importing the following character file content:");
    console.log(chummerFile);
    console.log("Using the following import options:");
    console.log(importOptions);
    if (!chummerFile.characters?.character) {
      console.log("Did not find a valid character to import  - aborting import");
      return;
    }
    await this.resetCharacter(actor);
    const chummerCharacter = chummerFile.characters.character;
    const infoUpdater = new CharacterInfoUpdater();
    const updatedActorData = infoUpdater.update(actor._source, chummerCharacter);
    const items = new ItemsParser().parse(chummerCharacter, importOptions);
    new VehicleParser().parseVehicles(actor, chummerCharacter, importOptions);
    await actor.update(await updatedActorData);
    await actor.createEmbeddedDocuments("Item", await items);
  }
  async resetCharacter(actor) {
    let toDeleteItems = actor.items?.filter((item) => item.type !== "action").filter((item) => item.system.importFlags != void 0).filter((item) => item.system.importFlags.isImported).filter((item) => item.effects.size == 0).map((item) => item.id);
    let deletedItems = actor.deleteEmbeddedDocuments("Item", toDeleteItems);
    let removed = {
      "system.skills.language.-=value": null,
      "system.skills.knowledge.academic.-=value": null,
      "system.skills.knowledge.interests.-=value": null,
      "system.skills.knowledge.professional.-=value": null,
      "system.skills.knowledge.street.-=value": null
    };
    let removeSkills = actor.update(removed);
    await deletedItems;
    await removeSkills;
  }
};

// src/module/apps/importer/actorImport/spiritImporter/SpiritInfoUpdater.js
var SpiritInfoUpdater = class {
  static {
    __name(this, "SpiritInfoUpdater");
  }
  /**
   * Parses the actor data from the chummer file and returns an updated clone of the actor data.
   * @param {*} actorSource The actor data (actor not actor.system) that is used as the basis for the import. Will not be changed.
   * @param {*} chummerChar The chummer character to parse.
   */
  async update(actorSource, chummerChar) {
    const clonedActorSource = foundry.utils.duplicate(actorSource);
    if (chummerChar.alias) {
      clonedActorSource.name = chummerChar.alias;
    } else {
      clonedActorSource.name = chummerChar.name ? chummerChar.name : "[Name not found]";
    }
    clonedActorSource.prototypeToken.name = clonedActorSource.name;
    clonedActorSource.system.special = "magic";
    const magic = Number(chummerChar.attributes[1]?.attribute.filter((att) => att.name_english.toLowerCase() == "mag")[0].total);
    clonedActorSource.system.force = magic;
    this.importSpiritType(clonedActorSource.system, chummerChar);
    return clonedActorSource;
  }
  importSpiritType(system, chummerChar) {
    let chummerType = chummerChar.metatype_english;
    let spiritTypes = [
      "air",
      "aircraft",
      "airwave",
      "automotive",
      "beasts",
      "ceramic",
      "earth",
      "energy",
      "fire",
      "guardian",
      "guidance",
      "man",
      "metal",
      "plant",
      "ship",
      "task",
      "train",
      "water",
      "toxic_air",
      "toxic_beasts",
      "toxic_earth",
      "toxic_fire",
      "toxic_man",
      "toxic_water",
      "blood",
      "muse",
      "nightmare",
      "shade",
      "succubus",
      "wraith",
      "shedim",
      "master_shedim",
      // insect
      "caretaker",
      "nymph",
      "scout",
      "soldier",
      "worker",
      "queen",
      "carcass",
      "corpse",
      "rot",
      "palefile",
      "detritus",
      // Howling Shadow
      "anarch",
      "arboreal",
      "blackjack",
      "boggle",
      "bugul",
      "chindi",
      "corpselight",
      "croki",
      "duende",
      "elvar",
      "erinyes",
      "greenman",
      "imp",
      "jarl",
      "kappa",
      "kokopelli",
      "morbi",
      "nocnitasa",
      "phantom",
      "preta",
      "stabber",
      "tungak",
      "vucub"
    ];
    let specialMapping = /* @__PURE__ */ new Map([
      ["Noxious Spirit", "toxic_air"],
      ["Abomination Spirit", "toxic_beasts"],
      ["Barren Spirit", "toxic_earth"],
      ["Nuclear Spirit", "toxic_fire"],
      ["Plague Spirit", "toxic_man"],
      ["Sludge Spirit", "toxic_water"]
    ]);
    const type = spiritTypes.find((v2) => chummerType?.toLowerCase().includes(v2)) ?? specialMapping.get(chummerType);
    if (type == void 0) {
      ui.notifications?.error(game.i18n.format("SR6.Import.Spirit.SpiritTypeNotFound"));
      return;
    }
    system.spiritType = type;
  }
};

// src/module/apps/importer/actorImport/spiritImporter/SpiritImporter.js
var SpiritImporter = class {
  static {
    __name(this, "SpiritImporter");
  }
  /**
   * Imports a chummer character into an existing actor. The actor will be updated. This might lead to duplicate items.
   * @param {*} actor The actor that will be updated with the chummer character.
   * @param {*} chummerFile The complete chummer file as json object. The first character will be selected for import.
   * @param {*} importOptions Additional import option that specify what parts of the chummer file will be imported.
   */
  async importChummerCharacter(actor, chummerFile, importOptions) {
    console.log("Importing the following character file content:");
    console.log(chummerFile);
    console.log("Using the following import options:");
    console.log(importOptions);
    if (!chummerFile.characters?.character) {
      console.log("Did not find a valid character to import  - aborting import");
      return;
    }
    if (actor.type !== "spirit") {
      return;
    }
    await this.resetCharacter(actor);
    const chummerCharacter = chummerFile.characters.character;
    const infoUpdater = new SpiritInfoUpdater();
    const updatedActorData = infoUpdater.update(actor._source, chummerCharacter);
    const items = new ItemsParser().parse(chummerCharacter, importOptions);
    await actor.update(await updatedActorData);
    await actor.createEmbeddedDocuments("Item", await items);
  }
  async resetCharacter(actor) {
    let toDeleteItems = actor.items?.filter((item) => item.type !== "action").map((item) => item.id);
    let deletedItems = actor.deleteEmbeddedDocuments("Item", toDeleteItems);
    let removed = {
      "system.skills.language.-=value": null,
      "system.skills.knowledge.academic.-=value": null,
      "system.skills.knowledge.interests.-=value": null,
      "system.skills.knowledge.professional.-=value": null,
      "system.skills.knowledge.street.-=value": null
    };
    let removeSkills = actor.update(removed);
    await deletedItems;
    await removeSkills;
  }
};

// src/module/apps/chummer-import-form.js
var ChummerImportForm = class extends FormApplication {
  static {
    __name(this, "ChummerImportForm");
  }
  static get defaultOptions() {
    const options = super.defaultOptions;
    options.id = "chummer-import";
    options.classes = ["shadowrun6-elysium"];
    options.title = "Chummer/Hero Lab Import";
    options.template = "systems/shadowrun6-elysium/dist/templates/apps/import.html";
    options.width = 600;
    options.height = "auto";
    return options;
  }
  getData() {
    return {};
  }
  activateListeners(html) {
    html.find(".submit-chummer-import").click(async (event) => {
      event.preventDefault();
      const chummerFile = JSON.parse($(".chummer-text").val());
      const importOptions = {
        weapons: $(".weapons").is(":checked"),
        armor: $(".armor").is(":checked"),
        cyberware: $(".cyberware").is(":checked"),
        equipment: $(".gear").is(":checked"),
        qualities: $(".qualities").is(":checked"),
        powers: $(".powers").is(":checked"),
        spells: $(".spells").is(":checked"),
        contacts: $(".contacts").is(":checked"),
        lifestyles: $(".lifestyles").is(":checked"),
        vehicles: $(".vehicles").is(":checked"),
        assignIcons: $(".assignIcons").is(":checked")
      };
      let importer;
      switch (this.object.type) {
        case "character":
          importer = new CharacterImporter();
          break;
        case "spirit":
          importer = new SpiritImporter();
          break;
      }
      await importer.importChummerCharacter(this.object, chummerFile, importOptions);
      ui.notifications?.info(
        "Complete! Check everything. Notably: Ranged weapon mods and ammo; Strength based weapon damage; Specializations on all spells, powers, and weapons;"
      );
      this.close();
    });
  }
};

// src/module/actor/sheets/SR6BaseActorSheet.ts
var globalSkillAppId = -1;
var sortByName = /* @__PURE__ */ __name((a2, b2) => {
  if (a2.name > b2.name) return 1;
  if (a2.name < b2.name) return -1;
  return 0;
}, "sortByName");
var sortByEquipped = /* @__PURE__ */ __name((a2, b2) => {
  const leftEquipped = a2.system?.technology?.equipped;
  const rightEquipped = b2.system?.technology?.equipped;
  if (leftEquipped && !rightEquipped) return -1;
  if (rightEquipped && !leftEquipped) return 1;
  if (a2.name > b2.name) return 1;
  if (a2.name < b2.name) return -1;
  return 0;
}, "sortByEquipped");
var sortyByQuality = /* @__PURE__ */ __name((a2, b2) => {
  if (a2.system.type === "positive" && b2.system.type === "negative") return -1;
  if (a2.system.type === "negative" && b2.system.type === "positive") return 1;
  return a2.name < b2.name ? -1 : 1;
}, "sortyByQuality");
var SR6BaseActorSheet = class extends ActorSheet {
  constructor(...args) {
    super(...args);
    // What document description is shown on sheet. Allow displaying multiple descriptions at the same time.
    this._shownDesc = [];
    // If something needs filtering, store those filters here.
    this._filters = {
      skills: "",
      // filter based on user input and skill name/label.
      showUntrainedSkills: true
      // filter based on pool size.
    };
    // Used together with _filters to delay textinput
    this._delays = {
      skills: null
    };
    this._inventoryOpenClose = {};
    this.selectedInventory = this.actor.defaultInventory.name;
    this._setInventoryVisibility(true);
  }
  static {
    __name(this, "SR6BaseActorSheet");
  }
  /**
   * All actors will handle these item types specifically.
   *
   * All others will be collected somewhere.
   *
   * @return A string of item types from the template.json Item section.
   */
  getHandledItemTypes() {
    return ["action"];
  }
  /**
   * All actors will always show these in their 'inventory'.
   * The inventory might be named differently for each actor.
   *
   * All other item types will only be shown when they've been added to that actor.
   * This allows all players/GMs to add item types to each actor that the system may not find useful
   * but the players/GMs might.
   *
   * @return An array of item types from the template.json Item section.
   */
  getInventoryItemTypes() {
    return [];
  }
  /**
   * These item types aren't allowed to be created on this actor sheet.
   *
   * This includes dropping them onto this actor.
   */
  getForbiddenItemTypes() {
    return [];
  }
  /**
   * Extend and override the default options used by the 5e Actor Sheet
   * @returns {Object}
   */
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      classes: ["sr6", "sheet", "actor"],
      width: 930,
      height: 690,
      tabs: [
        {
          navSelector: ".tabs",
          contentSelector: ".sheetbody",
          initial: "skills"
        }
      ]
    });
  }
  /**
   * Decide which template to render both for actor types and user permissions.
   *
   *
   * This could also be done within individual ActorType sheets, however, for ease of use, it's
   * centralized here.
   *
   * @override
   */
  get template() {
    const path = "systems/shadowrun6-elysium/dist/templates";
    if (!game.user?.isGM && this.actor.limited) {
      return `${path}/actor-limited/${this.actor.type}.html`;
    }
    return `${path}/actor/${this.actor.type}.html`;
  }
  /** SheetData used by _all_ actor types! */
  async getData(options) {
    let data = super.getData();
    const actorData = this.actor.toObject(false);
    data = {
      ...data,
      // @ts-expect-error TODO: foundry-vtt-types v10
      data: actorData.system,
      // @ts-expect-error TODO: foundry-vtt-types v10
      system: actorData.system
    };
    data.config = SR6;
    data.filters = this._filters;
    this._prepareActorAttributes(data);
    this._prepareActorModifiers(data);
    this._prepareActorTypeFields(data);
    this._prepareSpecialFields(data);
    this._prepareSkillsWithFilters(data);
    data.itemType = await this._prepareItemTypes(data);
    data.effects = prepareSortedEffects(this.actor.effects.contents);
    data.itemEffects = prepareSortedItemEffects(this.actor, { applyTo: this.itemEffectApplyTos });
    data.inventories = await this._prepareItemsInventory();
    data.inventory = this._prepareSelectedInventory(data.inventories);
    data.hasInventory = this._prepareHasInventory(data.inventories);
    data.selectedInventory = this.selectedInventory;
    data.situationModifiers = this._prepareSituationModifiers();
    data.biographyHTML = await TextEditor.enrichHTML(actorData.system.description.value, {
      // secrets: this.actor.isOwner,
      // rollData: this.actor.getRollData.bind(this.actor),
      // @ts-expect-error TODO: foundry-vtt-types v10
      relativeTo: this.actor
    });
    data.bindings = this._prepareKeybindings();
    return data;
  }
  /** Listeners used by _all_ actor types! */
  activateListeners(html) {
    super.activateListeners(html);
    Helpers.setupCustomCheckbox(this, html);
    html.find(".effect-control").on("click", (event) => onManageActiveEffect(event, this.actor));
    html.find(".item-effect-control").on("click", (event) => onManageItemActiveEffect(event));
    html.find(".item-toggle").on("click", this._onInventorySectionVisiblitySwitch.bind(this));
    html.find(".item-create").on("click", this._onItemCreate.bind(this));
    html.find(".item-edit").on("click", this._onItemEdit.bind(this));
    html.find(".item-delete").on("click", this._onItemDelete.bind(this));
    html.find(".item-qty").on("change", this._onListItemChangeQuantity.bind(this));
    html.find(".item-rtg").on("change", this._onListItemChangeRating.bind(this));
    html.find(".item-equip-toggle").on("click", this._onListItemToggleEquipped.bind(this));
    html.find(".hidden").hide();
    html.find(".has-desc").on("click", this._onListItemToggleDescriptionVisibility.bind(this));
    html.find(".item-roll").on("click", this._onItemRoll.bind(this));
    html.find(".Roll").on("click", this._onRoll.bind(this));
    html.find(".inventory-inline-create").on("click", this._onInventoryCreate.bind(this));
    html.find(".inventory-collapse").on("click", this._onInventorySectionVisibilityChange.bind(this, false));
    html.find(".inventory-expand").on("click", this._onInventorySectionVisibilityChange.bind(this, true));
    html.find(".inventory-remove").on("click", this._onInventoryRemove.bind(this));
    html.find(".inventory-edit").on("click", this._onInplaceInventoryEdit.bind(this));
    html.find(".inventory-input-cancel").on("click", this._onInplaceInventoryEditCancel.bind(this));
    html.find(".inventory-input-save").on("click", this._onInplaceInventoryEditSave.bind(this));
    html.find("input#input-inventory").on("keydown", this._onInplaceInventoryEditCancel.bind(this));
    html.find("input#input-inventory").on("keydown", this._onInplaceInventoryEditSave.bind(this));
    html.find("input#input-inventory").on("change", this._onInventoryChangePreventSheetSubmit.bind(this));
    html.find("#select-inventory").on("change", this._onSelectInventory.bind(this));
    html.find(".inventory-item-move").on("click", this._onItemMoveToInventory.bind(this));
    html.find(".horizontal-cell-input .cell").on("click", this._onSetConditionTrackCell.bind(this));
    html.find(".horizontal-cell-input .cell").on("contextmenu", this._onClearConditionTrack.bind(this));
    html.find(".marks-qty").on("change", this._onMarksQuantityChange.bind(this));
    html.find(".marks-add-one").on("click", async (event) => this._onMarksQuantityChangeBy(event, 1));
    html.find(".marks-remove-one").on("click", async (event) => this._onMarksQuantityChangeBy(event, -1));
    html.find(".marks-delete").on("click", this._onMarksDelete.bind(this));
    html.find(".marks-clear-all").on("click", this._onMarksClearAll.bind(this));
    html.find(".skill-header").find(".item-name").on("click", this._onFilterUntrainedSkills.bind(this));
    html.find(".skill-header").find(".skill-spec-item").on("click", this._onFilterUntrainedSkills.bind(this));
    html.find(".skill-header").find(".rtg").on("click", this._onFilterUntrainedSkills.bind(this));
    html.find("#filter-skills").on("input", this._onFilterSkills.bind(this));
    html.find(".skill-opensource").on("click", this._onOpenSourceSkill.bind(this));
    html.find(".knowledge-skill-opensource").on("click", this._onOpenSourceSkill.bind(this));
    html.find(".language-skill-opensource").on("click", this._onOpenSourceSkill.bind(this));
    html.find(".skill-edit").on("click", this._onShowEditSkill.bind(this));
    html.find(".knowledge-skill-edit").on("click", this._onShowEditKnowledgeSkill.bind(this));
    html.find(".language-skill-edit").on("click", this._onShowEditLanguageSkill.bind(this));
    html.find(".add-knowledge").on("click", this._onAddKnowledgeSkill.bind(this));
    html.find(".add-language").on("click", this._onAddLanguageSkill.bind(this));
    html.find(".add-active").on("click", this._onAddActiveSkill.bind(this));
    html.find(".remove-knowledge").on("click", this._onRemoveKnowledgeSkill.bind(this));
    html.find(".remove-language").on("click", this._onRemoveLanguageSkill.bind(this));
    html.find(".remove-active").on("click", this._onRemoveActiveSkill.bind(this));
    html.find(".attribute-roll").on("click", this._onRollAttribute.bind(this));
    html.find(".cell-input-roll").on("click", this._onRollCellInput.bind(this));
    html.find(".skill-roll").on("click", this._onRollSkill.bind(this));
    html.find(".knowledge-skill").on("click", this._onRollSkill.bind(this));
    html.find(".language-skill").on("click", this._onRollSkill.bind(this));
    html.find(".skill-spec-roll").on("click", this._onRollSkillSpec.bind(this));
    html.find(".show-hidden-skills").on("click", this._onShowHiddenSkills.bind(this));
    html.find(".open-source").on("click", this._onOpenSource.bind(this));
    html.find(".list-item").each(this._addDragSupportToListItemTemplatePartial.bind(this));
    html.find(".import-character").on("click", this._onShowImportCharacter.bind(this));
    html.find(".reload-ammo").on("click", async (event) => this._onReloadAmmo(event, false));
    html.find(".partial-reload-ammo").on("click", async (event) => this._onReloadAmmo(event, true));
    html.find(".matrix-att-selector").on("change", this._onMatrixAttributeSelected.bind(this));
    html.find(".show-situation-modifiers-application").on("click", this._onShowSituationModifiersApplication.bind(this));
    html.find(".toggle-fresh-import-all-off").on("click", async (event) => this._toggleAllFreshImportFlags(event, false));
    html.find(".toggle-fresh-import-all-on").on("click", async (event) => this._toggleAllFreshImportFlags(event, true));
    html.find(".reset-actor-run-data").on("click", this._onResetActorRunData.bind(this));
  }
  /**
   * Handle display of item types within the actors inventory section.
   *
   * Unexpected means there is no use for this type but the user added it anyway.
   * Inventory types means they should always be shown, even if there are none.
   * All other item types will be collected at some tab / place on the sheet.
   */
  _addInventoryItemTypes(inventory) {
    const inventoryTypes = this.getInventoryItemTypes();
    for (const type of Object.keys(inventory.types)) {
      if (inventoryTypes.includes(type)) continue;
      if (inventory.types[type].items.length === 0) delete inventory.types[type];
    }
    return inventory;
  }
  /**
   * Add any item type to the inventory display that's configured for this actor sheet type.
   *
   * @param inventory The inventory to check and add types to.
   */
  _addInventoryTypes(inventory) {
    for (const type of this.getInventoryItemTypes()) {
      if (inventory.types.hasOwnProperty(type)) continue;
      inventory.types[type] = {
        type,
        label: SR6.itemTypes[type],
        isOpen: this._inventoryOpenClose[type],
        items: []
      };
    }
  }
  /**
   * @override Default drag start handler to add Skill support
   * @param event
   */
  async _onDragStart(event) {
    const dragData = {
      actorId: this.actor.id,
      sceneId: this.actor.isToken ? canvas.scene?.id : null,
      tokenId: this.actor.isToken ? this.actor.token?.id : null,
      type: "",
      data: {}
    };
    const element = event.currentTarget;
    switch (element.dataset.itemType) {
      // Skill data transfer. (Active and language skills)
      case "skill":
        dragData.type = "Skill";
        dragData.data = {
          skillId: element.dataset.itemId,
          skill: this.actor.getSkill(element.dataset.itemId)
        };
        event.dataTransfer.setData("text/plain", JSON.stringify(dragData));
        return;
      // Knowlege skill data transfer
      case "knowledgeskill":
        const skillId = element.dataset.itemId.includes(".") ? element.dataset.itemId.split(".")[0] : element.dataset.itemId;
        dragData.type = "Skill";
        dragData.data = {
          skillId,
          skill: this.actor.getSkill(skillId)
        };
        event.dataTransfer.setData("text/plain", JSON.stringify(dragData));
        return;
      // if we are dragging an active effect, get the effect from our list of effects and set it in the data transfer
      case "ActiveEffect": {
        const effectId = element.dataset.itemId;
        let effect = this.actor.effects.get(effectId);
        if (!effect) {
          effect = await fromUuid(effectId);
        }
        if (effect) {
          dragData.type = "ActiveEffect";
          dragData.data = effect;
          event.dataTransfer.setData("text/plain", JSON.stringify(dragData));
        }
        return;
      }
      // All default Foundry data transfer.
      default:
        return super._onDragStart(event);
    }
  }
  /** Handle all document drops onto all actor sheet types.
   *
   * @param event
   */
  // @ts-expect-error
  async _onDrop(event) {
    event.preventDefault();
    event.stopPropagation();
    if (!event.dataTransfer) return;
    const data = parseDropData(event);
    if (data !== void 0) {
      if (data.type === "ActiveEffect" && data.actorId !== this.actor.id) {
        const effect = data.data;
        const applyTo = effect.flags["shadowrun6-elysium"].applyTo;
        if (applyTo === "test_item") {
          ui.notifications?.warn(game.i18n.localize("SR6.ActiveEffect.CannotAddTestViaItemToActor"));
          return;
        }
        delete effect._id;
        await this.actor.createEmbeddedDocuments("ActiveEffect", [effect]);
        return;
      }
      if (data.type === "Actor" && data.uuid !== this.actor.uuid) {
        const actor = await fromUuid(data.uuid);
        const itemData = {
          name: actor.name ?? `${game.i18n.localize("SR6.New")} ${game.i18n.localize(SR6.itemTypes["contact"])}`,
          type: "contact",
          "system.linkedActor": actor.uuid
        };
        await this.actor.createEmbeddedDocuments("Item", [itemData], { renderSheet: true });
      }
    }
    const documents = await super._onDrop(event);
    if (Array.isArray(documents)) {
      const items = documents.filter((document2) => document2 instanceof SR6Item);
      await this.actor.inventory.addItems(this.selectedInventory, items);
    }
    return documents;
  }
  /**
   * Enhance Foundry state restore on rerender by more user interaction state.
   * @override
   */
  async _render(...args) {
    const focus = this._saveInputCursorPosition();
    this._saveScrollPositions();
    await super._render(...args);
    this._restoreScrollPositions();
    this._restoreInputCursorPosition(focus);
  }
  /**
   * Use together with _restoreInputCursorPosition during render calls.
   * Without this the cursor will always be on the first character, causing writing in reverse.
   */
  _saveInputCursorPosition() {
    const focusList = $(this.element).find("input:focus");
    return focusList.length ? focusList[0] : null;
  }
  /**
   * Use together with _restoreInputCursorPosition during render calls.
   */
  _restoreInputCursorPosition(focus) {
    if (focus && focus.name) {
      if (!this.form) return;
      const element = this.form[focus.name];
      if (element) {
        element.focus();
        if (["checkbox", "radio"].includes(element.type)) return;
        element.setSelectionRange && element.setSelectionRange(focus.selectionStart, focus.selectionEnd);
      }
    }
  }
  /**
   * Used together with _restoreScrollPositions during render calls.
   * @private
   */
  _saveScrollPositions() {
    const activeList = this._findActiveList();
    if (activeList.length) {
      this._scroll = activeList.prop("scrollTop");
    }
  }
  /**
   * Used together with _storeScrollPositions during render calls.
   * @private
   */
  _restoreScrollPositions() {
    const activeList = this._findActiveList();
    if (activeList.length && this._scroll != null) {
      activeList.prop("scrollTop", this._scroll);
    }
  }
  /**
   * Return scroll area of the currently opened tab.
   * @private
   */
  _findActiveList() {
    return $(this.element).find(".tab.active .scroll-area");
  }
  async _onInventorySectionVisibilityChange(isOpen, event) {
    event.preventDefault();
    this._setInventoryVisibility(isOpen);
    this.render();
  }
  async _onInventorySectionVisiblitySwitch(event) {
    event.preventDefault();
    const type = Helpers.listHeaderId(event);
    this._setInventoryTypeVisibility(type, !this._inventoryOpenClose[type]);
    this.render();
  }
  _setInventoryVisibility(isOpen) {
    Object.keys(CONFIG.Item.typeLabels).forEach((type) => this._setInventoryTypeVisibility(type, isOpen));
  }
  _setInventoryTypeVisibility(type, isOpen) {
    this._inventoryOpenClose[type] = isOpen;
  }
  async _onItemCreate(event) {
    event.preventDefault();
    const type = event.currentTarget.closest(".list-header").dataset.itemId;
    this._setInventoryTypeVisibility(type, true);
    const itemData = {
      name: `${game.i18n.localize("SR6.New")} ${Helpers.label(game.i18n.localize(SR6.itemTypes[type]))}`,
      type
    };
    const items = await this.actor.createEmbeddedDocuments("Item", [itemData], { renderSheet: true });
    if (!items) return;
    if (this.selectedInventory !== this.actor.defaultInventory.name)
      await this.actor.inventory.addItems(this.selectedInventory, items);
  }
  async _onItemEdit(event) {
    event.preventDefault();
    const iid = Helpers.listItemId(event);
    const item = this.actor.items.get(iid);
    if (item) await item.sheet?.render(true);
  }
  async _onItemDelete(event) {
    event.preventDefault();
    const userConsented = await Helpers.confirmDeletion();
    if (!userConsented) return;
    const iid = Helpers.listItemId(event);
    const item = this.actor.items.get(iid);
    if (!item) return;
    await this.actor.inventory.removeItem(item);
    return await this.actor.deleteEmbeddedDocuments("Item", [iid]);
  }
  async _onItemRoll(event) {
    event.preventDefault();
    const iid = Helpers.listItemId(event);
    const item = this.actor.items.get(iid);
    if (item) {
      await item.castAction(event);
    }
  }
  /**
   * Setup all general system rolls after clicking on their roll on the sheet.
   *
   * @param event Must contain a currentTarget with a rollId dataset
   */
  async _onRoll(event) {
    event.preventDefault();
    let rollId = $(event.currentTarget).data()?.rollId;
    rollId = rollId ?? $(event.currentTarget).parent(".RollId").data().rollId;
    const split = rollId.split(".");
    const options = { event };
    switch (split[0]) {
      case "prompt-roll":
        await this.actor.promptRoll();
        break;
      case "armor":
        await this.actor.rollGeneralAction("armor", options);
        break;
      case "fade":
        await this.actor.rollGeneralAction("fade", options);
        break;
      case "drain":
        await this.actor.rollGeneralAction("drain", options);
        break;
      case "defense":
        await this.actor.rollGeneralAction("physical_defense", options);
        break;
      case "damage-resist":
        await this.actor.rollGeneralAction("physical_damage_resist", options);
        break;
      // attribute only rolls
      case "composure":
        await this.actor.rollGeneralAction("composure", options);
        break;
      case "judge-intentions":
        await this.actor.rollGeneralAction("judge_intentions", options);
        break;
      case "lift-carry":
        await this.actor.rollGeneralAction("lift_carry", options);
        break;
      case "memory":
        await this.actor.rollGeneralAction("memory", options);
        break;
      case "vehicle-stat":
        console.log("roll vehicle stat", rollId);
        break;
      case "drone":
        const droneRoll = split[1];
        switch (droneRoll) {
          case "perception":
            await this.actor.rollGeneralAction("drone_perception", options);
            break;
          case "infiltration":
            await this.actor.rollGeneralAction("drone_infiltration", options);
            break;
          case "pilot-vehicle":
            await this.actor.rollGeneralAction("drone_pilot_vehicle", options);
            break;
        }
        break;
      // end drone
      case "attribute": {
        const attribute = split[1];
        if (attribute) {
          await this.actor.rollAttribute(attribute, options);
        }
        break;
      }
      case "skill": {
        const skillId = split[2];
        await this.actor.rollSkill(skillId, options);
        break;
      }
      case "matrix":
        const matrixRoll = split[1];
        switch (matrixRoll) {
          case "attribute":
            const attr = split[2];
            await this.actor.rollAttribute(attr, options);
            break;
          case "device-rating":
            await this.actor.rollDeviceRating(options);
            break;
        }
        break;
    }
  }
  /**
   * Set any kind of condition monitor to a specific cell value.
   *
   * @event Most return a currentTarget with a value dataset
   */
  async _onSetConditionTrackCell(event) {
    event.preventDefault();
    const value = Number(event.currentTarget.dataset.value);
    const track = $(event.currentTarget).closest(".horizontal-cell-input").data().id;
    const data = {};
    if (track === "stun" || track === "physical") {
      const property = `system.track.${track}.value`;
      data[property] = value;
    } else if (track === "edge") {
      const property = `system.attributes.edge.uses`;
      data[property] = value;
    } else if (track === "overflow") {
      const property = "system.track.physical.overflow.value";
      data[property] = value;
    } else if (track === "matrix") {
      await this.actor.setMatrixDamage(value);
    }
    if (data) await this.actor.update(data);
    await this.document.applyDefeatedStatus();
  }
  /**
   * Reset all condition tracks to zero values.
   * @param event
   */
  async _onClearConditionTrack(event) {
    event.preventDefault();
    const track = $(event.currentTarget).closest(".horizontal-cell-input").data().id;
    const data = {};
    if (track === "stun") {
      data[`system.track.stun.value`] = 0;
    } else if (track === "physical") {
      data[`system.track.physical.value`] = 0;
      data["system.track.physical.overflow.value"] = 0;
    } else if (track === "edge") {
      data[`system.attributes.edge.uses`] = 0;
    } else if (track === "overflow") {
      data["system.track.physical.overflow.value"] = 0;
    } else if (track === "matrix") {
      await this.actor.setMatrixDamage(0);
    }
    if (data) await this.actor.update(data);
    await this.actor.applyDefeatedStatus();
  }
  /**
   * Special fields are shared across all actor types.
   *
   * These are used as indicators about what kind of 'special' a character might be.
   *
   * @param sheetData ActorSheetData as created within getData method
   */
  _prepareSpecialFields(sheetData) {
    sheetData.awakened = sheetData.system.special === "magic";
    sheetData.emerged = sheetData.system.special === "resonance";
  }
  /**
   * Pretty up display of zero value actor modifiers.
   *
   * @param sheetData ActorSheetData as created within getData method
   */
  _prepareActorModifiers(sheetData) {
    const { modifiers } = sheetData.system;
    for (let [key, value] of Object.entries(modifiers)) {
      if (value === 0) modifiers[key] = "";
    }
    sheetData.woundTolerance = 3 + (Number(modifiers["wound_tolerance"]) || 0);
  }
  _prepareActorAttributes(sheetData) {
    const attributes = sheetData.system.attributes;
    for (let [, attribute] of Object.entries(attributes)) {
      if (!attribute.hidden) {
        if (attribute.temp === 0) delete attribute.temp;
      }
    }
  }
  _prepareMatrixAttributes(sheetData) {
    const { matrix } = sheetData.system;
    if (matrix) {
      const cleanupAttribute = /* @__PURE__ */ __name((attribute) => {
        const att = matrix[attribute];
        if (att) {
          if (!att.mod) att.mod = [];
          if (att.temp === 0) delete att.temp;
        }
      }, "cleanupAttribute");
      ["firewall", "data_processing", "sleaze", "attack"].forEach((att) => cleanupAttribute(att));
    }
  }
  /**
   * Prepare Actor Sheet Inventory display.
   *
   * Each item can  be in one custom inventory or the default inventory.
   */
  async _prepareItemsInventory() {
    const inventoriesSheet = {};
    const itemIdInventory = {};
    inventoriesSheet[this.actor.allInventories.name] = {
      name: this.actor.allInventories.name,
      label: this.actor.allInventories.label,
      types: {}
    };
    this._addInventoryTypes(inventoriesSheet[this.actor.allInventories.name]);
    inventoriesSheet[this.actor.defaultInventory.name] = {
      name: this.actor.defaultInventory.name,
      label: this.actor.defaultInventory.label,
      types: {}
    };
    this._addInventoryTypes(inventoriesSheet[this.actor.defaultInventory.name]);
    Object.values(this.actor.system.inventories).forEach((inventory) => {
      const { name: name3, label, itemIds } = inventory;
      if (!inventoriesSheet.hasOwnProperty(name3)) {
        inventoriesSheet[name3] = {
          name: name3,
          label,
          types: {}
        };
      }
      this._addInventoryTypes(inventoriesSheet[name3]);
      itemIds.forEach((id) => {
        itemIdInventory[id] = inventory;
      });
    });
    const handledTypes = this.getHandledItemTypes();
    for (const item of this.actor.items) {
      if (!item.id) continue;
      if (handledTypes.includes(item.type)) continue;
      const sheetItem = await this._prepareSheetItem(item);
      const inventory = itemIdInventory[item.id] || this.actor.defaultInventory;
      const addTo = inventory.showAll ? Object.keys(inventoriesSheet) : [inventory.name];
      addTo.forEach((name3) => {
        const inventorySheet = inventoriesSheet[name3];
        if (!inventorySheet.types[item.type]) {
          inventorySheet.types[item.type] = {
            type: item.type,
            label: SR6.itemTypes[item.type],
            isOpen: this._inventoryOpenClose[item.type],
            items: []
          };
        }
        inventorySheet.types[item.type].items.push(sheetItem);
      });
    }
    Object.values(inventoriesSheet).forEach((inventory) => {
      this._addInventoryItemTypes(inventory);
      Object.values(inventory.types).forEach((type) => {
        type.items.sort(sortByName);
      });
    });
    return inventoriesSheet;
  }
  /**
   * Choose the selected inventory to actually display.
   *
   * @param inventories
   */
  _prepareSelectedInventory(inventories) {
    return inventories[this.selectedInventory];
  }
  /**
   * Show if any items are in the inventory or if the actor is supposed to have an inventory.
   *
   * A sheet is supposed to show an inventory if there are item types defined or an item of some
   * type exists in any of its inventories.
   *
   * @param inventories
   */
  _prepareHasInventory(inventories) {
    if (this.getInventoryItemTypes().length > 0) return true;
    for (const inventory of Object.values(inventories)) {
      if (Object.keys(inventory.types).length > 0) return true;
    }
    return false;
  }
  /**
   * Enhance SR6Item data for display on actors sheets.
   *
   * @param item: The item to transform into a 'sheet item'
   */
  async _prepareSheetItem(item) {
    const sheetItem = item.toObject(false);
    const chatData = await item.getChatData();
    sheetItem.description = chatData.description;
    sheetItem.properties = chatData.properties;
    return sheetItem;
  }
  /**
   * Prepare items for easy type by type display on actors sheets with lists per item type.
   *
   * NOTE: This method uses sheet item types, instead of item types. A sheet item type allows
   * to sub-group items of one type into separate lists as needed.
   *
   * @param data An object containing Actor Sheet data, as would be returned by ActorSheet.getData
   * @returns Sorted item lists per sheet item type.
   */
  async _prepareItemTypes(data) {
    const itemsByType = {};
    const sheetItemTypes = [
      ...Object.keys(CONFIG.Item.typeLabels),
      "summoning",
      "compilation"
    ];
    sheetItemTypes.forEach((type) => {
      itemsByType[type] = [];
    });
    for (const item of this.actor.items) {
      const sheetItem = await this._prepareSheetItem(item);
      itemsByType[sheetItem.type].push(sheetItem);
      if (item.isSummoning) itemsByType["summoning"].push(sheetItem);
      if (item.isCompilation) itemsByType["compilation"].push(sheetItem);
    }
    Object.entries(itemsByType).forEach(([type, items]) => {
      switch (type) {
        case "quality":
          items.sort(sortyByQuality);
          break;
        case "program":
          items.sort(sortByEquipped);
          break;
        default:
          items.sort(sortByName);
          break;
      }
    });
    return itemsByType;
  }
  /**
   * @param sheetData An object containing Actor Sheet data, as would be returned by ActorSheet.getData
   */
  _prepareActorTypeFields(sheetData) {
    sheetData.isCharacter = this.actor.isCharacter();
    sheetData.isSpirit = this.actor.isSpirit();
    sheetData.isCritter = this.actor.isCritter();
    sheetData.isVehicle = this.actor.isVehicle();
    sheetData.hasSkills = this.actor.hasSkills;
    sheetData.canAlterSpecial = this.actor.canAlterSpecial;
    sheetData.hasFullDefense = this.actor.hasFullDefense;
  }
  async _onMarksQuantityChange(event) {
    event.stopPropagation();
    if (this.actor.isIC() && this.actor.hasHost()) {
      return ui.notifications?.info(game.i18n.localize("SR6.Infos.CantModifyHostContent"));
    }
    const markId = event.currentTarget.dataset.markId;
    if (!markId) return;
    const markedDocuments = Helpers.getMarkIdDocuments(markId);
    if (!markedDocuments) return;
    const { scene, target, item } = markedDocuments;
    if (!scene || !target) return;
    const marks = parseInt(event.currentTarget.value);
    await this.actor.setMarks(target, marks, { scene, item, overwrite: true });
  }
  async _onMarksQuantityChangeBy(event, by) {
    event.stopPropagation();
    if (this.actor.isIC() && this.actor.hasHost()) {
      return ui.notifications?.info(game.i18n.localize("SR6.Infos.CantModifyHostContent"));
    }
    const markId = event.currentTarget.dataset.markId;
    if (!markId) return;
    const markedDocuments = Helpers.getMarkIdDocuments(markId);
    if (!markedDocuments) return;
    const { scene, target, item } = markedDocuments;
    if (!scene || !target) return;
    await this.actor.setMarks(target, by, { scene, item });
  }
  async _onMarksDelete(event) {
    event.stopPropagation();
    if (this.actor.isIC() && this.actor.hasHost()) {
      return ui.notifications?.info(game.i18n.localize("SR6.Infos.CantModifyHostContent"));
    }
    const markId = event.currentTarget.dataset.markId;
    if (!markId) return;
    const userConsented = await Helpers.confirmDeletion();
    if (!userConsented) return;
    await this.actor.clearMark(markId);
  }
  async _onMarksClearAll(event) {
    event.stopPropagation();
    if (this.actor.isIC() && this.actor.hasHost()) {
      return ui.notifications?.info(game.i18n.localize("SR6.Infos.CantModifyHostContent"));
    }
    const userConsented = await Helpers.confirmDeletion();
    if (!userConsented) return;
    await this.actor.clearMarks();
  }
  /**
   * Prepare skills with sorting and filtering given by this sheet.
   *
   * @param sheetData What is to be displayed on sheet.
   */
  _prepareSkillsWithFilters(sheetData) {
    this._filterActiveSkills(sheetData);
  }
  _filterSkills(data, skills = {}) {
    const filteredSkills = {};
    for (let [key, skill] of Object.entries(skills)) {
      if (skill.hidden) {
        continue;
      }
      if (this._showSkill(key, skill, data)) {
        filteredSkills[key] = skill;
      }
    }
    return Helpers.sortSkills(filteredSkills);
  }
  _showSkill(key, skill, data) {
    if (this._showMagicSkills(key, skill, data)) {
      return true;
    }
    if (this._showResonanceSkills(key, skill, data)) {
      return true;
    }
    return this._showGeneralSkill(key, skill);
  }
  _showGeneralSkill(skillId, skill) {
    return !this._isSkillMagic(skillId, skill) && !this._isSkillResonance(skill) && this._isSkillFiltered(skillId, skill);
  }
  _showMagicSkills(skillId, skill, sheetData) {
    return this._isSkillMagic(skillId, skill) && sheetData.system.special === "magic" && this._isSkillFiltered(skillId, skill);
  }
  _showResonanceSkills(skillId, skill, sheetData) {
    return this._isSkillResonance(skill) && sheetData.system.special === "resonance" && this._isSkillFiltered(skillId, skill);
  }
  _isSkillFiltered(skillId, skill) {
    const isFilterable = this._getSkillLabelOrName(skill).length > 0;
    const isHiddenForText = !this._doesSkillContainText(skillId, skill, this._filters.skills);
    const isHiddenForUntrained = !this._filters.showUntrainedSkills && skill.value === 0;
    return !(isFilterable && (isHiddenForUntrained || isHiddenForText));
  }
  _getSkillLabelOrName(skill) {
    return Helpers.getSkillLabelOrName(skill);
  }
  _doesSkillContainText(key, skill, text) {
    if (!text) {
      return true;
    }
    const name3 = this._getSkillLabelOrName(skill);
    const searchKey = skill.name === void 0 ? key : "";
    const specs = skill.specs !== void 0 && Array.isArray(skill.specs) ? skill.specs.join(" ") : "";
    let searchString = `${searchKey} ${name3} ${specs}`;
    return searchString.toLowerCase().search(text.toLowerCase()) > -1;
  }
  _filterActiveSkills(sheetData) {
    sheetData.system.skills.active = this._filterSkills(sheetData, sheetData.system.skills.active);
  }
  _isSkillMagic(id, skill) {
    return skill.attribute === "magic" || id === "astral_combat" || id === "assensing";
  }
  _isSkillResonance(skill) {
    return skill.attribute === "resonance";
  }
  /** Setup untrained skill filter within getData */
  async _onFilterUntrainedSkills(event) {
    event.preventDefault();
    this._filters.showUntrainedSkills = !this._filters.showUntrainedSkills;
    await this.render();
  }
  /**
   * Parameterize skill filtering within getData and implement a general delay around it.
   *
   * NOTE: Be aware of UTF-8/16 multi character input languages, using mulitple separate input symbol to form a single alphabet character.
   * NOTE: This is ONLY necessary as shadowrun6-elysium filters through the render -> getData -> template chain instead of
   *       hiding HTML elements based on their text.
   */
  async _onFilterSkills(event) {
    if (this._delays.skills)
      clearTimeout(this._delays.skills);
    this._delays.skills = setTimeout(() => {
      this._filters.skills = event.currentTarget.value;
      this.render();
    }, game["shadowrun6-elyium"].inputDelay);
  }
  async _onRollSkill(event) {
    event.preventDefault();
    const itemId = Helpers.listItemId(event);
    const skillId = itemId.includes(".") ? itemId.split(".")[0] : itemId;
    if (!skillId) return console.error(`Shadowrun 6e | Rolling skill with item id (${itemId}). But (${skillId}) doesn't seem to be an id`);
    return this.actor.rollSkill(skillId, { event });
  }
  async _onRollSkillSpec(event) {
    event.preventDefault();
    const itemId = Helpers.listItemId(event);
    const skillId = itemId.includes(".") ? itemId.split(".")[0] : itemId;
    return this.actor.rollSkill(skillId, { event, specialization: true });
  }
  async _onOpenSourceSkill(event) {
    event.preventDefault();
    const [skillId] = Helpers.listItemId(event).split(".");
    const skill = this.actor.getSkill(skillId);
    if (!skill) {
      return console.error(`Shadowrun 6e | Editing skill failed due to missing skill ${skillId}`);
    }
    LinksHelpers.openSource(skill.link);
  }
  async _onShowEditSkill(event) {
    event.preventDefault();
    const skill = Helpers.listItemId(event);
    if (!skill) {
      return console.error(`Shadowrun 6e | Editing knowledge skill failed due to missing skill ${skill} id`);
    }
    await this._showSkillEditForm(SkillEditSheet, this.actor, { event }, skill);
  }
  /** Keep track of each SkillEditSheet instance and close before opening another.
   *
   * @param skillEditFormImplementation Any extending class! of SkillEditSheet
   * @param actor
   * @param options
   * @param args Collect arguments of the different renderWithSkill implementations.
   */
  async _showSkillEditForm(skillEditFormImplementation, actor, options, ...args) {
    await this._closeOpenSkillApp();
    const skillEditForm = new skillEditFormImplementation(actor, options, ...args);
    globalSkillAppId = skillEditForm.appId;
    await skillEditForm.render(true);
  }
  _onShowEditKnowledgeSkill(event) {
    event.preventDefault();
    const [skill, category3] = Helpers.listItemId(event).split(".");
    if (!skill || !category3) {
      return console.error(`Shadowrun 6e | Editing knowledge skill failed due to missing skill ${skill} or category id ${category3}`);
    }
    this._showSkillEditForm(
      KnowledgeSkillEditSheet,
      this.actor,
      {
        event
      },
      skill,
      category3
    );
  }
  async _onShowEditLanguageSkill(event) {
    event.preventDefault();
    const skill = Helpers.listItemId(event);
    if (!skill) {
      return console.error(`Shadowrun 6e | Editing knowledge skill failed due to missing skill ${skill} id`);
    }
    await this._showSkillEditForm(LanguageSkillEditSheet, this.actor, { event }, skill);
  }
  async _closeOpenSkillApp() {
    if (globalSkillAppId !== -1) {
      if (ui.windows[globalSkillAppId]) {
        await ui.windows[globalSkillAppId].close();
      }
      globalSkillAppId = -1;
    }
  }
  async _onAddLanguageSkill(event) {
    event.preventDefault();
    const skillId = await this.actor.addLanguageSkill({ name: "" });
    if (!skillId) return;
    await this._showSkillEditForm(LanguageSkillEditSheet, this.actor, { event }, skillId);
  }
  async _onRemoveLanguageSkill(event) {
    event.preventDefault();
    const userConsented = await Helpers.confirmDeletion();
    if (!userConsented) return;
    const skillId = Helpers.listItemId(event);
    await this.actor.removeLanguageSkill(skillId);
  }
  async _onAddKnowledgeSkill(event) {
    event.preventDefault();
    const category3 = Helpers.listHeaderId(event);
    const skillId = await this.actor.addKnowledgeSkill(category3);
    if (!skillId) return;
    await this._showSkillEditForm(KnowledgeSkillEditSheet, this.actor, { event }, skillId, category3);
  }
  async _onRemoveKnowledgeSkill(event) {
    event.preventDefault();
    const userConsented = await Helpers.confirmDeletion();
    if (!userConsented) return;
    const [skillId, category3] = Helpers.listItemId(event).split(".");
    await this.actor.removeKnowledgeSkill(skillId, category3);
  }
  /** Add an active skill and show the matching edit application afterwards.
   *
   * @param event The HTML event from which the action resulted.
   */
  async _onAddActiveSkill(event) {
    event.preventDefault();
    const skillId = await this.actor.addActiveSkill();
    if (!skillId) return;
    await this._showSkillEditForm(SkillEditSheet, this.actor, { event }, skillId);
  }
  async _onRemoveActiveSkill(event) {
    event.preventDefault();
    const userConsented = await Helpers.confirmDeletion();
    if (!userConsented) return;
    const skillId = Helpers.listItemId(event);
    await this.actor.removeActiveSkill(skillId);
  }
  async _onRollAttribute(event) {
    event.preventDefault();
    const attribute = event.currentTarget.closest(".attribute").dataset.attribute;
    return this.actor.rollAttribute(attribute, { event });
  }
  /**
   * Handle interaction with a damage track title.
   * @param event
   */
  async _onRollCellInput(event) {
    event.preventDefault();
    let track = $(event.currentTarget).closest(".horizontal-cell-input").data().id;
    switch (track) {
      case "stun":
        await this.actor.rollGeneralAction("natural_recovery_stun", { event });
        break;
      case "physical":
        await this.actor.rollGeneralAction("natural_recovery_physical", { event });
        break;
      case "edge":
        await this.actor.rollAttribute("edge", { event });
        break;
    }
  }
  async _onShowHiddenSkills(event) {
    event.preventDefault();
    await this.actor.showHiddenSkills();
  }
  async _onOpenSource(event) {
    event.preventDefault();
    const field = $(event.currentTarget).parents(".list-item");
    const iid = $(field).data().itemId;
    const item = this.actor.items.get(iid);
    if (item) {
      await item.openSource();
    }
  }
  /**
   * Augment each item of the ListItem template partial with drag support.
   * @param i
   * @param item
   */
  _addDragSupportToListItemTemplatePartial(i2, item) {
    if (item.dataset && item.dataset.itemId) {
      item.setAttribute("draggable", true);
      item.addEventListener("dragstart", this._onDragStart.bind(this), false);
    }
  }
  /**
   * Change the quantity on an item shown within a sheet item list.
   *
   * @param event A DOM mouse/touch event
   */
  async _onListItemChangeQuantity(event) {
    const iid = Helpers.listItemId(event);
    const item = this.actor.items.get(iid);
    const quantity = parseInt(event.currentTarget.value);
    if (item?.system.technology === void 0 || !(item && quantity && item.system.technology)) {
      return console.error(`Shadowrun 6e | Tried alterting technology quantity on an item without technology data: ${item?.id}`, item);
    }
    await item.update({ "system.technology.quantity": quantity });
  }
  /**
   * Change the rating on an item shown within a sheet item list.
   */
  async _onListItemChangeRating(event) {
    const iid = Helpers.listItemId(event);
    const item = this.actor.items.get(iid);
    const rtg = parseInt(event.currentTarget.value);
    if (item && rtg) {
      await item.update({ "system.technology.rating": rtg });
    }
  }
  /**
   * Change the equipped status of an item shown within a sheet item list.
   */
  async _onListItemToggleEquipped(event) {
    event.preventDefault();
    const iid = Helpers.listItemId(event);
    const item = this.actor.items.get(iid);
    if (!item) return;
    if (item.isDevice) {
      await this.document.equipOnlyOneItemOfType(item);
    } else {
      await this.actor.updateEmbeddedDocuments("Item", [{
        "_id": iid,
        "system.technology.equipped": !item.isEquipped()
      }]);
    }
    this.actor.render(false);
  }
  /**
   * Show / hide the items description within a sheet item l ist.
   */
  async _onListItemToggleDescriptionVisibility(event) {
    event.preventDefault();
    const item = $(event.currentTarget).parents(".list-item");
    const iid = $(item).data().item;
    const field = item.find(".list-item-description");
    field.toggle();
    if (iid) {
      if (field.is(":visible")) this._shownDesc.push(iid);
      else this._shownDesc = this._shownDesc.filter((val) => val !== iid);
    }
  }
  /**
   * Create an inventory place on the actor for gear organization.
   */
  async _onInventoryCreate(event) {
    event.preventDefault();
    $("#input-inventory").val("");
    await this._onInplaceInventoryEdit(event, "create");
  }
  /**
   * Remove the currently selected inventory.
   * @param event
   */
  async _onInventoryRemove(event) {
    event.preventDefault();
    const userConsented = await Helpers.confirmDeletion();
    if (!userConsented) return;
    await this.actor.inventory.remove(this.selectedInventory);
    this.selectedInventory = this.actor.defaultInventory.name;
    this.render();
  }
  /**
   * Hide inventory selection and show inline editing instead.
   *
   * @param event
   * @param action What action to take during later saving event.
   */
  async _onInplaceInventoryEdit(event, action = "edit") {
    event.preventDefault();
    if (action === "edit" && this.actor.inventory.disallowRename(this.selectedInventory))
      return ui.notifications?.warn(game.i18n.localize("SR6.Warnings.CantEditDefaultInventory"));
    $(".selection-inventory").hide();
    $(".inline-input-inventory").show();
    $("#input-inventory").data("action", action).select();
  }
  /**
   * Hide inline inventory editing and show inventory selection instead.
   *
   * Cancel edit workflow and do nothing.
   *
   * @param event Can be an event of type click or keydown.
   */
  async _onInplaceInventoryEditCancel(event) {
    if (event.type === "keydown" && event.code !== "Escape") return;
    event.preventDefault();
    $(".selection-inventory").show();
    $(".inline-input-inventory").hide();
    $("#input-inventory").data("action", void 0).val(this.selectedInventory);
  }
  /**
   * Complete inline editing and either save changes or create a missing inventory.
   *
   * @param event Either a click or keydown event.
   */
  async _onInplaceInventoryEditSave(event) {
    if (event.type === "keydown" && event.code !== "Enter") return;
    event.preventDefault();
    const inputElement = $("#input-inventory");
    const action = inputElement.data("action");
    let inventory = String(inputElement.val());
    if (!inventory) return;
    switch (action) {
      case "edit":
        inventory = await this.actor.inventory.rename(this.selectedInventory, inventory);
        break;
      case "create":
        inventory = await this.actor.inventory.create(inventory);
        break;
    }
    await this._onInplaceInventoryEditCancel(event);
    if (!inventory) return;
    this.selectedInventory = inventory;
    this.render();
  }
  /**
   * Change selected inventory for this sheet.
   *
   * @param event
   */
  async _onSelectInventory(event) {
    event.preventDefault();
    const inventory = String($(event.currentTarget).val());
    if (inventory)
      this.selectedInventory = inventory;
    this.render();
  }
  /**
   * Move an item between two inventories.
   * @param event
   */
  async _onItemMoveToInventory(event) {
    event.preventDefault();
    const itemId = Helpers.listItemId(event);
    const item = this.actor.items.get(itemId);
    if (!item) return;
    const dialog = new MoveInventoryDialog(this.actor, item, this.selectedInventory);
    const inventory = await dialog.select();
    if (dialog.canceled) return;
    await this.actor.inventory.addItems(inventory, item);
  }
  /**
   * When editing an existing or new inventory on a new actor for the frist time,
   * the initial change event (by leaving the element focus, i.e. leaving or clicking on submit)
   * will cause a general form submit (Foundry FormApplication onChangeSubmit), causing a render
   * and removing the inventory input box.
   *
   * Note: This ONLY happens on new actors and NOT on inventory changes on old actors. The root cause
   * is unclear.
   *
   * As the inventory inpunt box lives outside of Foundries default form handling, prevent
   * this by stopping propagation into Foundries onChange listeners.
   *
   * @param event Any event
   */
  _onInventoryChangePreventSheetSubmit(event) {
    event.stopPropagation();
  }
  /**
   * Initiative a reload from a sheet event.
   *
   * @param event
   */
  async _onReloadAmmo(event, partialReload) {
    event.preventDefault();
    const iid = Helpers.listItemId(event);
    const item = this.actor.items.get(iid);
    if (item) return item.reloadAmmo(partialReload);
  }
  /**
   * Sync matrix attribute changes (order) made on the actor sheet into item data of the selected cyberdeck.
   *
   * This is done whenever a user changes matrix attribute order directly from the actor sheet matrix section.
   * Its intent is to also order matrix attribute order on the selected matrix device of that actor.
   *
   * @param event A mouse/pointer event
   */
  async _onMatrixAttributeSelected(event) {
    if (!("matrix" in this.actor.system)) return;
    let iid = this.actor.system.matrix.device;
    let item = this.actor.items.get(iid);
    if (!item) {
      console.error("could not find item");
      return;
    }
    let att = event.currentTarget.dataset.att;
    let deviceAtt = event.currentTarget.value;
    const deviceData = item.system;
    let oldVal = deviceData.atts[deviceAtt].att;
    let data = {
      _id: iid
    };
    for (let i2 = 1; i2 <= 4; i2++) {
      let tmp = `att${i2}`;
      let key = `system.atts.att${i2}.att`;
      if (tmp === deviceAtt) {
        data[key] = att;
      } else if (deviceData.atts[`att${i2}`].att === att) {
        data[key] = oldVal;
      }
    }
    await this.actor.updateEmbeddedDocuments("Item", [data]);
  }
  /**
   * Open the Chummer Character import handling.
   * @param event
   */
  _onShowImportCharacter(event) {
    event.preventDefault();
    const options = {
      name: "chummer-import",
      title: "Chummer Import"
    };
    new ChummerImportForm(this.actor, options).render(true);
  }
  _setupCustomCheckbox(html) {
    const setContent = /* @__PURE__ */ __name((el) => {
      const checkbox = $(el).children("input[type=checkbox]");
      const checkmark = $(el).children(".checkmark");
      if ($(checkbox).prop("checked")) {
        $(checkmark).addClass("fa-check-circle");
        $(checkmark).removeClass("fa-circle");
      } else {
        $(checkmark).addClass("fa-circle");
        $(checkmark).removeClass("fa-check-circle");
      }
    }, "setContent");
    html.find("label.checkbox").each(function() {
      setContent(this);
    });
    html.find("label.checkbox").click((event) => setContent(event.currentTarget));
    html.find(".submit-checkbox").change((event) => this._onSubmit(event));
  }
  /**
   * Prepare applied Situation Modifiers for display (read-only) on any actor sheet.
   *
   * Some modifiers might be hidden, when the document doesn't fullfill criterea for it.
   *
   * @returns List of prepare sit. mod data
   */
  _prepareSituationModifiers() {
    const modifiers = this.actor.getSituationModifiers();
    modifiers.applyAll();
    if (!modifiers) return [];
    return Object.entries(modifiers._modifiers).map(([category3, modifier]) => {
      const hidden = this._hideSituationModifier(category3);
      const label = SR6.modifierTypes[category3];
      return { category: category3, value: modifier.total, hidden, label };
    });
  }
  /**
   * Determine if a situation modifier category should be hidden from an actor sheet.
   *
   * @param category Modifier category to maybe hide
   * @returns true, hide this category from the actors sheet.
   */
  _hideSituationModifier(category3) {
    switch (category3) {
      case "background_count":
        return !this.actor.isAwakened;
      case "environmental":
        return this.actor.isSprite();
      // Defense modifier is already shown in general modifier section.
      case "defense":
        return true;
      case "recoil":
        return !this.actor.hasPhysicalBody;
      default:
        return false;
    }
  }
  /**
   * Show the situation modifiers application for this actor doucment
   *
   * @param event
   */
  _onShowSituationModifiersApplication(event) {
    new SituationModifiersApplication(this.actor).render(true);
  }
  /**
   * Toggle to isFreshImport property of importFlags for all items on the character sheet
   *
   * @param event
   */
  async _toggleAllFreshImportFlags(event, onOff) {
    const allItems = this.actor.items;
    console.debug("Toggling all importFlags on owned items to ->", onOff, event);
    for (const item of allItems) {
      if (item.system.importFlags) {
        await item.update({ "system.importFlags.isFreshImport": onOff });
      }
    }
  }
  /**
   * Trigger a full reset of all run related actor data.
   *
   * @param event
   */
  _onResetActorRunData(event) {
    this.actor.resetRunData();
  }
  /**
   * Prepare keybindings to be shown when hovering over a rolling icon
   * in any list item view that has rolls.
   */
  _prepareKeybindings() {
    return {
      skip: game.keybindings.get("shadowrun6-elysium", "hide-test-dialog").map((binding) => binding.key.replace("Key", "").toUpperCase()).join(", "),
      card: game.keybindings.get("shadowrun6-elysium", "show-item-card").map((binding) => binding.key.replace("Key", "").toUpperCase()).join(", ")
    };
  }
  /**
   * These effect apply to types are meant to be shown on the item effects section of the effects sheet.
   *
   * They are limited to those effects directly affecting this actor. Effects affecting other actors, aren't shown
   * on the actors own sheet.
   */
  get itemEffectApplyTos() {
    return ["actor", "item", "test_all", "test_item", "modifier"];
  }
};

// src/module/actor/sheets/SR6ICActorSheet.ts
var SR6ICActorSheet = class extends SR6BaseActorSheet {
  static {
    __name(this, "SR6ICActorSheet");
  }
  /**
   * IC actors will handle these item types specifically.
   *
   * All others will be collected within the gear tab.
   *
   * @returns An array of item types from the template.json Item section.
   */
  getHandledItemTypes() {
    return super.getHandledItemTypes();
  }
  async getData(options) {
    const data = await super.getData(options);
    data.host = this.actor.getICHost();
    data.markedDocuments = this.actor.getAllMarkedDocuments();
    data.disableMarksEdit = this.actor.hasHost();
    return data;
  }
  activateListeners(html) {
    super.activateListeners(html);
    html.find(".entity-remove").on("click", this._removeHost.bind(this));
  }
  /**
   * Remove a connected host from the shown IC actor type.
   * @param event
   */
  async _removeHost(event) {
    event.stopPropagation();
    await this.actor.removeICHost();
  }
  async _onDrop(event) {
    event.preventDefault();
    event.stopPropagation();
    if (!event.dataTransfer) return;
    const dropData = JSON.parse(event.dataTransfer.getData("text/plain"));
    switch (dropData.type) {
      case "Item":
        const item = await fromUuid(dropData.uuid);
        switch (item.type) {
          case "host":
            return await this.actor.addICHost(item);
        }
        const handledTypes = [...this.getHandledItemTypes(), ...this.getInventoryItemTypes()];
        if (!handledTypes.includes(item.type)) return;
    }
    return super._onDrop(event);
  }
};

// src/module/effect/SR6ActiveEffectConfig.ts
var SR6ActiveEffectConfig = class extends ActiveEffectConfig {
  static {
    __name(this, "SR6ActiveEffectConfig");
  }
  get template() {
    return "systems/shadowrun6-elysium/dist/templates/effect/active-effect-config.html";
  }
  async getData(options) {
    const data = await super.getData(options);
    data.modes = this.applyModifyLabelToCustomMode(data.modes);
    data.applyTo = this.document.applyTo;
    data.onlyForWireless = this.document.onlyForWireless;
    data.onlyForEquipped = this.document.onlyForEquipped;
    data.onlyForItemTest = this.document.onlyForItemTest;
    data.applyToOptions = this.prepareApplyToOptions();
    data.hasChanges = this.prepareEffectHasChanges();
    data.isv11 = game.version.startsWith("11.");
    return data;
  }
  activateListeners(html) {
    super.activateListeners(html);
    html.find('select[name="flags.shadowrun6-elysium.applyTo"]').on("change", this._onApplyToChange.bind(this));
    this._activateTagifyListeners(html);
  }
  /**
   * Handle adding a new change to the changes array.
   *
   * This overrides the Foundry default behavior of using ADD as default.
   * Shadowrun mostly uses MODIFY, so we use that as default.
   *
   * @private
   */
  async _addEffectChange() {
    const idx = this.document.changes.length;
    return this.submit({
      preventClose: true,
      updateData: {
        [`changes.${idx}`]: { key: "", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, value: "" }
      }
    });
  }
  /**
   * Assure both no changes are present before changing the applyTo type
   * and re-render the sheet to refresh prepared change value options.
   *
   * This is to avoid configured changes breaking when changing to other applyTo types
   * that do not support the same change keys.
   */
  async _onApplyToChange(event) {
    event.preventDefault();
    const select = event.currentTarget;
    if (this.object.getFlag(SYSTEM_NAME, "applyTo") === select.value) return;
    if (this.object.changes.length) {
      ui.notifications?.error("You must delete changes before changing the apply-to type.");
    } else {
      const updateData = { "flags.shadowrun6-elysium.applyTo": select.value };
      await this._onSubmit(event, { updateData, preventClose: true });
    }
  }
  /**
   * Foundry provides a custom mode for systems to implement behavior with.
   *
   * Shadowrun uses this mode to implement 'modify' mode, with complex behavior.
   * To give users better information about the mode, inject a 'modify' label.
   *
   * @param modes A object prepared for display using Foundry select handlebarjs helper.
   * @returns Copy of the original modes and labels.
   */
  applyModifyLabelToCustomMode(modes) {
    return { ...modes, 0: game.i18n.localize("SR6.ActiveEffect.Modes.Modify") };
  }
  /**
   * Depending on this effects source document being actor or item, some effect apply to
   * should not be available.
   */
  prepareApplyToOptions() {
    const effectApplyTo = foundry.utils.deepClone(SR6.effectApplyTo);
    if (this.object.parent instanceof SR6Actor) {
      delete effectApplyTo.test_item;
    }
    return effectApplyTo;
  }
  /**
   * Determine if the effect has changes applied already.
   *
   * This should be used to prohibit changing of applyTo selections.
   * @returns true if changes are present, false otherwise.
   */
  prepareEffectHasChanges() {
    return this.object.changes.length > 0;
  }
  _activateTagifyListeners(html) {
    switch (this.object.applyTo) {
      case "test_all":
        this._prepareTestSelectionTagify(html);
        this._prepareActionCategoriesSelectionTagify(html);
        this._prepareSkillSelectionTagify(html);
        this._prepareAttributesSelectionTagify(html);
        this._prepareLimitsSelectionTagify(html);
        break;
    }
  }
  _prepareTestSelectionTagify(html) {
    const inputElement = html.find("input#test-selection").get(0);
    const values = Object.values(game["shadowrun6-elysium"].tests).map((test) => ({
      label: test.label,
      id: test.name
    }));
    const maxItems = values.length;
    const value = this.object.getFlag(SYSTEM_NAME, "selection_tests");
    const selected = value ? JSON.parse(value) : [];
    createTagifyOnInput(inputElement, values, maxItems, selected);
  }
  /**
   * Action Categories multi selection via tagify element.
   *
   * @param html ActiveEffectConfig html
   */
  _prepareActionCategoriesSelectionTagify(html) {
    const inputElement = html.find("input#categories-selection").get(0);
    const values = Object.entries(SR6.actionCategories).map(([category3, label]) => ({ label, id: category3 }));
    const maxItems = values.length;
    const value = this.object.getFlag(SYSTEM_NAME, "selection_categories");
    const selected = value ? JSON.parse(value) : [];
    createTagifyOnInput(inputElement, values, maxItems, selected);
  }
  _prepareSkillSelectionTagify(html) {
    const inputElement = html.find("input#skill-selection").get(0);
    if (!this.object.parent) return console.error("Shadowrun 6e | SR6ActiveEffect unexpecedtly has no parent document", this.object, this);
    const actor = this.object.isOriginOwned ? this.object.parent.parent : this.object.parent;
    const actorOrNothing = !(actor instanceof SR6Actor) ? void 0 : actor;
    const skills = ActionFlow.sortedActiveSkills(actorOrNothing);
    const values = Object.entries(skills).map(([id, label]) => ({ label, id }));
    const maxItems = values.length;
    const value = this.object.getFlag(SYSTEM_NAME, "selection_skills");
    const selected = value ? JSON.parse(value) : [];
    createTagifyOnInput(inputElement, values, maxItems, selected);
  }
  _prepareAttributesSelectionTagify(html) {
    const inputElement = html.find("input#attribute-selection").get(0);
    const values = Object.entries(SR6.attributes).map(([attribute, label]) => ({ label, id: attribute }));
    const maxItems = values.length;
    const value = this.object.getFlag(SYSTEM_NAME, "selection_attributes");
    const selected = value ? JSON.parse(value) : [];
    createTagifyOnInput(inputElement, values, maxItems, selected);
  }
  _prepareLimitsSelectionTagify(html) {
    const inputElement = html.find("input#limit-selection").get(0);
    const values = Object.entries(SR6.limits).map(([limit, label]) => ({ label, id: limit }));
    const maxItems = values.length;
    const value = this.object.getFlag(SYSTEM_NAME, "selection_limits");
    const selected = value ? JSON.parse(value) : [];
    createTagifyOnInput(inputElement, values, maxItems, selected);
  }
};

// src/module/actor/sheets/SR6VehicleActorSheet.ts
var SR6VehicleActorSheet = class extends SR6BaseActorSheet {
  static {
    __name(this, "SR6VehicleActorSheet");
  }
  /**
   * Vehicle actors will handle these item types specifically.
   *
   * All others will be collected within the gear tab.
   *
   * @returns An array of item types from the template.json Item section.
   */
  getHandledItemTypes() {
    let itemTypes = super.getHandledItemTypes();
    return [
      ...itemTypes,
      "program"
    ];
  }
  /**
   * Vehicle actors will always show these item types.
   *
   * For more info see into super.getInventoryItemTypes jsdoc.
   *
   * @returns An array of item types from the template.json Item section.
   */
  getInventoryItemTypes() {
    const itemTypes = super.getInventoryItemTypes();
    return [
      ...itemTypes,
      "weapon",
      "ammo",
      "armor",
      "bioware",
      "cyberware",
      "device",
      "equipment",
      "modification"
    ];
  }
  async getData(options) {
    const data = await super.getData(options);
    data.vehicle = await this._prepareVehicleFields();
    return data;
  }
  activateListeners(html) {
    super.activateListeners(html);
    html.find(".driver-remove").on("click", this._handleRemoveVehicleDriver.bind(this));
    html.find(".origin-link").on("click", this._onOpenOriginLink.bind(this));
    html.find(".controller-remove").on("click", this._onControllerRemove.bind(this));
  }
  /**
   * Vehicle specific drop events
   * @param event A DataTransferEvent containing some form of FoundryVTT Document / Data
   */
  async _onDrop(event) {
    event.preventDefault();
    event.stopPropagation();
    if (!event.dataTransfer) return;
    const dropData = JSON.parse(event.dataTransfer.getData("text/plain"));
    switch (dropData.type) {
      case "Actor":
        return await this.actor.addVehicleDriver(dropData.uuid);
    }
    return super._onDrop(event);
  }
  async _prepareVehicleFields() {
    const driver = this.actor.getVehicleDriver();
    const networkControllerLink = this.actor.getNetworkController();
    const networkController = networkControllerLink ? await NetworkDeviceFlow.resolveItemLink(networkControllerLink) : void 0;
    return {
      driver,
      networkController
    };
  }
  async _handleRemoveVehicleDriver(event) {
    event.preventDefault();
    await this.actor.removeVehicleDriver();
  }
  async _onOpenOriginLink(event) {
    event.preventDefault();
    console.log("Shadowrun 6e | Opening PAN/WAN network controller");
    const originLink = event.currentTarget.dataset.originLink;
    const device = await fromUuid(originLink);
    if (!device) return;
    device.sheet.render(true);
  }
  async _onControllerRemove(event) {
    event.preventDefault();
    await NetworkDeviceFlow.removeDeviceFromController(this.actor);
  }
};

// src/module/actor/sheets/SR6CharacterSheet.ts
var SR6CharacterSheet = class extends SR6BaseActorSheet {
  static {
    __name(this, "SR6CharacterSheet");
  }
  /**
   * Character actors will handle these item types specifically.
   *
   * All others will be collected within the gear tab.
   *
   * @returns An array of item types from the template.json Item section.
   */
  getHandledItemTypes() {
    let itemTypes = super.getHandledItemTypes();
    return [
      ...itemTypes,
      "program",
      "sin",
      "lifestyle",
      "contact",
      "spell",
      "ritual_spells",
      "adept_power",
      "complex_form",
      "quality",
      "echo",
      "metamagic",
      "critter_power",
      "call_in_action",
      "ritual"
    ];
  }
  /**
   * Character actors will always show these item types.
   *
   * For more info see into super.getInventoryItemTypes jsdoc.
   *
   * @returns An array of item types from the template.json Item section.
   */
  getInventoryItemTypes() {
    const itemTypes = super.getInventoryItemTypes();
    return [
      ...itemTypes,
      "weapon",
      "ammo",
      "armor",
      "bioware",
      "cyberware",
      "device",
      "equipment",
      "modification"
    ];
  }
  async getData(options) {
    const data = await super.getData(options);
    super._prepareMatrixAttributes(data);
    data["markedDocuments"] = this.actor.getAllMarkedDocuments();
    return data;
  }
  /**
   * Inject special case handling for call in action items, only usable by character actors.
   */
  async _onItemCreate(event) {
    event.preventDefault();
    const type = event.currentTarget.closest(".list-header").dataset.itemId;
    if (type !== "summoning" && type !== "compilation") return await super._onItemCreate(event);
    await this._onCallInActionCreate(type);
  }
  /**
   * Create a call in action item with pre configured actor type.
   *
   * @param type The call in action sub type.
   */
  async _onCallInActionCreate(type) {
    const typeToActorType = {
      "summoning": "spirit",
      "compilation": "sprite"
    };
    const actor_type = typeToActorType[type];
    if (!actor_type) return console.error("Shadowrun 6e | Call In Action Unknown actor type during creation");
    const itemData = {
      name: `${game.i18n.localize("SR6.New")} ${Helpers.label(type)}`,
      type: "call_in_action",
      "system.actor_type": actor_type
    };
    await this.actor.createEmbeddedDocuments("Item", [itemData], { renderSheet: true });
  }
};

// src/module/actor/sheets/SR6SpiritActorSheet.ts
var SR6SpiritActorSheet = class extends SR6BaseActorSheet {
  static {
    __name(this, "SR6SpiritActorSheet");
  }
  /**
   * Spirit actors will handle these item types specifically.
   *
   * All others will be collected within the gear tab.
   *
   * @returns An array of item types from the template.json Item section.
   */
  getHandledItemTypes() {
    let itemTypes = super.getHandledItemTypes();
    return [
      ...itemTypes,
      "critter_power",
      "spell",
      "quality"
    ];
  }
  /**
   * Spirit actors sheets deviate from base actors around the summoning workflows.
   *
   * @param options
   * @returns
   */
  async getData(options) {
    const data = await super.getData(options);
    const spirit = this.document.asSpirit();
    if (spirit) {
      if (spirit.system.summonerUuid) {
        data["summoner"] = await fromUuid(this.document.system.summonerUuid);
      }
    }
    return data;
  }
  /**
   * Spirit actor sheets do provide some specific functionality.
   * @param html
   */
  activateListeners(html) {
    super.activateListeners(html);
    html.find(".summoner-remove").on("click", this._onRemoveSummoner.bind(this));
  }
  async _onDrop(event) {
    event.preventDefault();
    event.stopPropagation();
    if (!event.dataTransfer) return;
    const documents = await super._onDrop(event);
    const dropData = JSON.parse(event.dataTransfer.getData("text/plain"));
    await this._addSummonerOnDrop(dropData);
    return documents;
  }
  /**
   * Determine if a dropped actor should be used as a spirit summoner.
   * @param dropData Actor drop data.
   */
  async _addSummonerOnDrop(dropData) {
    if (dropData.type !== "Actor") return;
    const actor = await fromUuid(dropData.uuid);
    if (!actor.isCharacter()) return;
    await this.document.addSummoner(actor);
  }
  /**
   * Remove the summoner from this spirit actor.
   * @param event Any interaction event.
   */
  async _onRemoveSummoner(event) {
    event.preventDefault();
    event.stopPropagation();
    await this.document.removeSummoner();
  }
};

// src/module/actor/sheets/SR6SpriteActorSheet.ts
var SR6SpriteActorSheet = class extends SR6BaseActorSheet {
  static {
    __name(this, "SR6SpriteActorSheet");
  }
  /**
   * Sprite actors will handle these item types specifically.
   *
   * All others will be collected within the gear tab.
   *
   * @returns An array of item types from the template.json Item section.
   */
  getHandledItemTypes() {
    let itemTypes = super.getHandledItemTypes();
    return [
      ...itemTypes,
      "sprite_power"
    ];
  }
  activateListeners(html) {
    super.activateListeners(html);
    html.find(".technomancer-remove").on("click", this._onRemoveTechnomancer.bind(this));
  }
  async getData(options) {
    const data = await super.getData(options);
    const sprite = this.document.asSprite();
    if (sprite !== void 0) {
      if (sprite.system.technomancerUuid !== "") {
        data["technomancer"] = await fromUuid(sprite.system.technomancerUuid);
      }
    }
    return data;
  }
  /**
   * Sprites have support for dropping actors onto them.
   */
  async _onDrop(event) {
    event.preventDefault();
    event.stopPropagation();
    if (event.dataTransfer === null) return;
    const dropData = JSON.parse(event.dataTransfer.getData("text/plain"));
    await this._addTechnomancerOnDrop(dropData);
    return await super._onDrop(event);
  }
  /**
   * Determine if a dropped actor should be used as a technomancer.
   * @param dropData Drop Data of any kind
   */
  async _addTechnomancerOnDrop(dropData) {
    if (dropData.type !== "Actor") return;
    const actor = await fromUuid(dropData.uuid);
    if (!actor.isCharacter()) return;
    this.document.addTechnomancer(actor);
  }
  /**
   * Remove the technomancer from the sprite.
   */
  async _onRemoveTechnomancer(event) {
    event.preventDefault();
    event.stopPropagation();
    await this.document.removeTechnomancer();
  }
};

// src/module/actor/flows/TeamworkFlow.ts
var TeamworkTest = class {
  static {
    __name(this, "TeamworkTest");
  }
  static async chatLogListeners(chatLog, html) {
    html.find(".chat-message").each(async (index, element) => {
      element = $(element);
      const id = element.data("messageId");
      const message = game.messages?.get(id);
      if (!message) return;
      await this.chatMessageListeners(message, element);
    });
  }
  static async chatMessageListeners(message, html) {
    if (!html.find(".sr6-teamwork-addparticipant"))
      return;
    html.find(".sr6-teamwork-addparticipant").on("click", (_2) => this.addParticipant(message));
    html.find(".sr6-teamwork-start").on("click", (_2) => this.rollTeamworkTest(message));
  }
  /**
   * This method prompts the user to roll the skill chosen in the teamwork test from a chosen actor @see Helpers.chooseFromAvailableActors
   * The result is forwarded to @see addResultsToMessage to add text and flag data to the original message
   *
   * @param message
   * @returns
   */
  static async addParticipant(message) {
    let actor = await Helpers.chooseFromAvailableActors();
    if (actor == void 0) {
      ui.notifications?.error("SR6.Errors.NoAvailableActorFound", { localize: true });
      return;
    }
    let teamworkData = message.getFlag(SYSTEM_NAME, FLAGS.Test);
    let results = await actor?.rollSkill(teamworkData.skill);
    if (results.rolls.length > 0) {
      this.addResultsToMessage(message, actor, results, teamworkData);
    }
  }
  /**
   * This method analyses the roll result and adds the text and flag data to the original message
   * @param message to add text too
   * @param actor that made the roll
   * @param results of the roll
   * @param teamworkData flag data to add too
   */
  static async addResultsToMessage(message, actor, results, teamworkData) {
    const wrapper = document.createElement("d\xEDv");
    wrapper.innerHTML = message.content;
    let participantsRoot = wrapper.getElementsByClassName("sr6-teamwork-participants")[0];
    let roll = results.rolls[0];
    let netHits = results.data.values.netHits.value;
    console.log(results);
    let participant = document.createElement("div");
    participant.innerHTML += actor.name + ": " + netHits;
    if (roll.glitched == true) {
      participant.innerHTML += " " + game.i18n.localize("SR6.Skill.Teamwork.Glitched");
    }
    teamworkData.additionalDice = (teamworkData.additionalDice ?? 0) + netHits;
    if (roll.total != 0 && roll.glitched != true) {
      teamworkData.additionalLimit = (teamworkData.additionalLimit ?? 0) + 1;
    }
    if (roll.total === 0 && roll.glitched) {
      teamworkData.criticalGlitch = true;
    }
    participantsRoot.appendChild(participant);
    if (game.user?.isGM) {
      message.setFlag(SYSTEM_NAME, FLAGS.Test, teamworkData);
      message.update({ content: wrapper.innerHTML });
    } else {
      this._sendUpdateSocketMessage(message, wrapper.innerHTML, teamworkData);
    }
  }
  /**
   * This method prompts the roll of the final teamwork test of the leader
   * @param message
   */
  static async rollTeamworkTest(message) {
    let teamworkData = message.getFlag(SYSTEM_NAME, FLAGS.Test);
    let actor = game.actors?.get(message.speaker.actor);
    actor?.rollTeamworkTest(teamworkData.skill, teamworkData);
  }
  /**
   * Send out a socket message to a connected GM to update the message.
   * @param actor The actor to create the effects on.
   * @param effectsData The effects data to be applied;
   */
  static async _sendUpdateSocketMessage(message, content, teamworkData) {
    await SocketMessage.emitForGM(FLAGS.TeamworkTestFlow, { messageUuid: message.uuid, content, teamworkData });
  }
  /**
   * Handle a sent socket message to update the content and flags of a message.
   * @param {string} message.actorUuid Must contain the uuid of the actor to create the effects on.
   * @param {ActiveEffectData[]} message.effectsData Must contain a list of effects data to be applied.
   * @returns
   */
  static async _handleUpdateSocketMessage(socketMessage) {
    if (!socketMessage.data.hasOwnProperty("messageUuid") || !socketMessage.data.hasOwnProperty("content") || !socketMessage.data.hasOwnProperty("teamworkData")) {
      console.error(`Shadowrun 6e | Teamwork Socket Message is missing necessary properties`, socketMessage);
      return;
    }
    const message = fromUuidSync(socketMessage.data.messageUuid);
    message?.setFlag(SYSTEM_NAME, FLAGS.Test, socketMessage.data.teamworkData);
    message?.update({ content: socketMessage.data.content });
  }
};

// src/module/rules/WeaponRangeRules.ts
var WeaponRangeTestBehavior = class _WeaponRangeTestBehavior {
  static {
    __name(this, "WeaponRangeTestBehavior");
  }
  static prepareData(test, data) {
    data.ranges = {};
    data.range = 0;
    data.targetRanges = [];
    data.targetRangesSelected = 0;
    data.damage = data.damage || DataDefaults.damageData();
  }
  /**
   * Weapon range selection depends on the weapon alone.
   *
   * In case of selected targets, test will be overwritten.
   *
   */
  static prepareWeaponRanges(test, rangesAccessor) {
    const weapon = test.item?.asWeapon;
    if (!weapon) return;
    const ranges = rangesAccessor(weapon);
    const { range_modifiers } = SR.combat.environmental;
    const newRanges = {};
    for (const key of ["short", "medium", "long", "extreme"]) {
      const rangeValue = ranges[key];
      const distance = test.actor && !!ranges.attribute ? test.actor.getAttribute(ranges.attribute).value * rangeValue : rangeValue;
      newRanges[key] = Helpers.createRangeDescription(SR6.weaponRanges[key], distance, range_modifiers[key]);
    }
    test.data.ranges = newRanges;
    const actor = test.actor;
    if (!actor) return;
    const modifiers = actor.getSituationModifiers();
    modifiers.environmental.apply({ test });
    test.data.range = modifiers.environmental.applied.active.range || 0;
  }
  /**
   * Actual target range between attack and target.
   *
   * This will overwrite the default weapon range selection.
   */
  static prepareTargetRanges(test) {
    if (foundry.utils.isEmpty(test.data.ranges)) return;
    if (!test.actor) return;
    if (!test.hasTargets) return;
    const attacker = test.actor.getToken();
    if (!attacker) {
      ui.notifications?.warn(game.i18n.localize("SR6.TargetingNeedsActorWithToken"));
      return [];
    }
    test.data.targetRanges = test.targets.map((token) => {
      const distance = Helpers.measureTokenDistance(attacker, token);
      const range = RangedWeaponRules.getRangeForTargetDistance(distance, test.data.ranges);
      return {
        tokenUuid: token.uuid,
        name: token.name || "",
        unit: LENGTH_UNIT,
        range,
        distance
      };
    });
    test.data.targetRanges = test.data.targetRanges.sort((a2, b2) => {
      if (a2.distance < b2.distance) return -1;
      if (a2.distance > b2.distance) return 1;
      return 0;
    });
    const modifiers = test.actor.getSituationModifiers();
    modifiers.environmental.apply({ test });
    test.data.range = modifiers.environmental.applied.active.range || test.data.targetRanges[0].range.modifier;
  }
  static prepareDocumentData(test, rangesAccessor) {
    _WeaponRangeTestBehavior.prepareWeaponRanges(test, rangesAccessor);
    _WeaponRangeTestBehavior.prepareTargetRanges(test);
  }
  /**
   * Save selections made back to documents.
   * @returns
   */
  static async saveUserSelectionAfterDialog(test) {
    if (!test.actor) return;
    if (!test.item) return;
    const modifiers = test.actor.getSituationModifiers();
    modifiers.environmental.setActive("range", test.data.range);
    await test.actor.setSituationModifiers(modifiers);
  }
  /**
   * Apply test selections made by user in dialog.
   * @returns
   */
  static prepareBaseValues(test) {
    if (!test.actor) return;
    if (!test.item) return;
    if (test.hasTargets) {
      test.data.targetRangesSelected = Number(test.data.targetRangesSelected);
      const target = test.data.targetRanges[test.data.targetRangesSelected];
      test.data.range = target.range.modifier;
      const token = fromUuidSync(target.tokenUuid);
      if (!(token instanceof TokenDocument)) return console.error(`Shadowrun 6e | ${test.type} got a target that is no TokenDocument`, token);
      if (!token.actor) return console.error(`Shadowrun 6e | ${test.type} got a token that has no actor`, token);
      test.data.targetActorsUuid = [token.actor.uuid];
      test.targets = [token];
    }
    test.data.range = Number(test.data.range);
  }
  /**
   * Ranged attack tests allow for temporarily changing of modifiers without altering the document.
   */
  static prepareTestModifiers(test) {
    _WeaponRangeTestBehavior.prepareEnvironmentalModifier(test);
  }
  static prepareEnvironmentalModifier(test) {
    if (!test.actor) return;
    const poolMods = new PartsList(test.data.modifiers.mod);
    const range = test.hasTargets ? test.data.targetRanges[test.data.targetRangesSelected].range.modifier : test.data.range;
    const modifiers = DocumentSituationModifiers.getDocumentModifiers(test.actor);
    modifiers.environmental.setActive("range", Number(range));
    modifiers.environmental.apply({ reapply: true, test });
    poolMods.addUniquePart(SR6.modifierTypes.environmental, modifiers.environmental.total);
  }
  static async processResults(test) {
    await _WeaponRangeTestBehavior.markActionPhaseAsAttackUsed(test);
  }
  static async markActionPhaseAsAttackUsed(test) {
    if (!test.actor || !test.actor.combatActive) return;
    const combatant = test.actor.combatant;
    if (!combatant) return;
    await combatant.setFlag(SYSTEM_NAME, "turnsSinceLastAttack", 0);
  }
};

// src/module/tests/RangedAttackTest.ts
var RangedAttackTest = class extends SuccessTest {
  static {
    __name(this, "RangedAttackTest");
  }
  _prepareData(data, options) {
    data = super._prepareData(data, options);
    data.fireModes = [];
    data.fireMode = { value: 0, defense: 0, label: "" };
    WeaponRangeTestBehavior.prepareData(this, data);
    return data;
  }
  _testDialogListeners() {
    return [{
      query: "#reset-progressive-recoil",
      on: "click",
      callback: this._handleResetProgressiveRecoil
    }];
  }
  /**
   * User want's to manually reset progressive recoil before casting the attack test.
   */
  async _handleResetProgressiveRecoil(event, test) {
    if (!this.actor) return;
    await this.actor.clearProgressiveRecoil();
    this.prepareBaseValues();
    this.calculateBaseValues();
    test.render();
  }
  get canBeExtended() {
    return false;
  }
  get showSuccessLabel() {
    return this.success;
  }
  _selectFireMode(index) {
    this.data.fireMode = this.data.fireModes[index];
  }
  /**
   * Weapon fire modes will affect recoil during test.
   *
   * To show the user the effect of recoil, it's applied during selection but progressive recoil is only ever fully applied
   * after the test is executed.
   */
  _prepareFireMode() {
    const weapon = this.item.asWeapon;
    if (!weapon) return;
    this.data.fireModes = FireModeRules.availableFireModes(weapon.system.range.modes);
    if (this.data.fireModes.length === 0) {
      this.data.fireModes.push(SR6.fireModes[0]);
      ui.notifications?.warn("SR6.Warnings.NoFireModeConfigured", { localize: true });
    }
    const lastFireMode = this.item.getLastFireMode() || DataDefaults.fireModeData();
    this.data.fireModeSelected = this.data.fireModes.findIndex((available) => lastFireMode.label === available.label);
    if (this.data.fireModeSelected == -1) this.data.fireModeSelected = 0;
    this._selectFireMode(this.data.fireModeSelected);
  }
  get testCategories() {
    return ["attack", "attack_ranged"];
  }
  get testModifiers() {
    return ["global", "wounds", "environmental"];
  }
  async prepareDocumentData() {
    WeaponRangeTestBehavior.prepareDocumentData(this, (weapon) => weapon.system.range.ranges);
    this._prepareFireMode();
    await super.prepareDocumentData();
  }
  get _dialogTemplate() {
    return "systems/shadowrun6-elysium/dist/templates/apps/dialogs/ranged-attack-test-dialog.html";
  }
  /**
   * If a suppression fire mode is used, ignore action opposed test configuration.
   */
  get _opposedTestClass() {
    if (this.data.fireMode.suppression) return TestCreator._getTestClass(SR6.suppressionDefenseTest);
    return super._opposedTestClass;
  }
  /**
   * Save selections made back to documents.
   * @returns
   */
  async saveUserSelectionAfterDialog() {
    if (!this.actor) return;
    if (!this.item) return;
    await this.item.setLastFireMode(this.data.fireMode);
    await WeaponRangeTestBehavior.saveUserSelectionAfterDialog(this);
  }
  /**
   * Apply test selections made by user in dialog.
   * @returns
   */
  prepareBaseValues() {
    if (!this.actor) return;
    if (!this.item) return;
    this._selectFireMode(this.data.fireModeSelected);
    this.data.fireMode.defense = FireModeRules.fireModeDefenseModifier(this.data.fireMode, this.item.ammoLeft);
    WeaponRangeTestBehavior.prepareBaseValues(this);
    super.prepareBaseValues();
  }
  /**
   * Ranged attack tests allow for temporarily changing of modifiers without altering the document.
   */
  prepareTestModifiers() {
    WeaponRangeTestBehavior.prepareTestModifiers(this);
  }
  /**
   * Enough resources according to test configuration?
   *
   * Ranged weapons need ammunition in enough quantity.
   *
   * NOTE: In this case it's only checked if at least ONE bullet exists.
   *       It's done this way as no matter the fire mode, you can fire it.
   */
  canConsumeDocumentResources() {
    if (!this.item.isRangedWeapon) return true;
    const fireMode = this.data.fireMode;
    if (fireMode.value === 0) return true;
    if (!this.item.hasAmmo(1)) {
      ui.notifications?.error("SR6.MissingRessource.Ammo", { localize: true });
      return false;
    }
    return super.canConsumeDocumentResources();
  }
  /**
   * Ranged Attacks not only can consume edge but also reduce ammunition.
   *
   */
  async consumeDocumentRessources() {
    if (!await super.consumeDocumentRessources()) return false;
    if (!await this.consumeWeaponAmmo()) return false;
    return true;
  }
  /**
   * Reduce ranged weapon ammunition according to the fire mode used.
   */
  async consumeWeaponAmmo() {
    if (!this.item) return true;
    if (!this.item.isRangedWeapon) return true;
    const fireMode = this.data.fireMode;
    if (fireMode.value === 0) return true;
    if (!this.item.hasAmmo(fireMode.value)) {
      ui.notifications?.warn("SR6.MissingRessource.SomeAmmo", { localize: true });
    }
    await this.item.useAmmo(fireMode.value);
    await this.actor?.addProgressiveRecoil(fireMode);
    return true;
  }
  async processResults() {
    await super.processResults();
    await WeaponRangeTestBehavior.processResults(this);
  }
};

// src/module/actor/flows/SoakFlow.ts
var SoakFlow = class {
  static {
    __name(this, "SoakFlow");
  }
  knocksDown(damage, actor) {
    const gelRoundsEffect = this.isDamageFromGelRounds(damage) ? -2 : 0;
    const impactDispersionEffect = this.isDamageFromImpactDispersion(damage) ? -2 : 0;
    const knockedDown = damage.value > actor.getAttribute("body").value;
    console.log(`SR6: Elysium | Determined target ${actor.id} knocked down status as: ${knockedDown}`, damage, actor);
    return knockedDown;
  }
  isDamageFromGelRounds(damage) {
    if (damage.source && damage.source.actorId && damage.source.itemId) {
      const attacker = game.actors?.find((actor) => actor.id == damage.source?.actorId);
      if (attacker) {
        const item = attacker.items.find((item2) => item2.id == damage.source?.itemId);
        if (item) {
          return item.items.filter((mod) => mod.getTechnologyData()?.equipped).filter((tech) => tech.name == game.i18n.localize("SR6.AmmoGelRounds")).length > 0;
        }
      }
    }
    return false;
  }
  isDamageFromImpactDispersion(damage) {
    return false;
  }
};

// src/module/tests/PhysicalResistTest.ts
var PhysicalResistTest = class extends SuccessTest {
  constructor() {
    super(...arguments);
    this.successConditions = [
      {
        test: /* @__PURE__ */ __name(() => this.actor !== void 0 && CombatRules.isBlockedByHardenedArmor(this.data.incomingDamage, 0, 0, this.actor), "test"),
        label: "SR6.TestResults.SoakBlockedByHardenedArmor",
        effect: /* @__PURE__ */ __name(() => {
          this.data.autoSuccess = true;
        }, "effect")
      },
      {
        test: /* @__PURE__ */ __name(() => this.isFullySoaked(), "test")
      }
    ];
  }
  static {
    __name(this, "PhysicalResistTest");
  }
  _prepareData(data, options) {
    data = super._prepareData(data, options);
    if (data.following) {
      data.incomingDamage = foundry.utils.duplicate(data.following?.modifiedDamage || DataDefaults.damageData());
      data.modifiedDamage = foundry.utils.duplicate(data.incomingDamage);
    } else {
      data.incomingDamage = data.incomingDamage ?? DataDefaults.damageData();
      data.modifiedDamage = foundry.utils.duplicate(data.incomingDamage);
    }
    const armor3 = this.actor?.getArmor();
    if (armor3?.hardened) {
      data.hitsIcon = {
        icon: "systems/shadowrun6-elysium/dist/icons/bell-shield.svg",
        tooltip: "SR6.ArmorHardenedFull"
      };
    }
    return data;
  }
  get _chatMessageTemplate() {
    return "systems/shadowrun6-elysium/dist/templates/rolls/defense-test-message.html";
  }
  get _dialogTemplate() {
    return "systems/shadowrun6-elysium/dist/templates/apps/dialogs/physical-resist-test-dialog.html";
  }
  /**
   * This test type can't be extended.
   */
  get canBeExtended() {
    return false;
  }
  static _getDefaultTestAction() {
    return {
      "attribute": "body",
      "armor": true
    };
  }
  get testCategories() {
    return ["resist"];
  }
  get testModifiers() {
    return ["soak"];
  }
  applyPoolModifiers() {
    super.applyPoolModifiers();
    this.applyArmorPoolModifier();
  }
  /**
   * Resisting against damage on the physical plane includes the modified armor value.
   */
  applyArmorPoolModifier() {
    if (this.data.action.armor) {
      if (this.actor) {
        const armor3 = this.actor.getArmor(this.data.incomingDamage);
        this.data.pool.mod = PartsList.AddUniquePart(this.data.pool.mod, "SR6.Armor", armor3.value);
      }
    }
  }
  calculateBaseValues() {
    super.calculateBaseValues();
    Helpers.calcTotal(this.data.incomingDamage, { min: 0 });
    Helpers.calcTotal(this.data.incomingDamage.ap);
    this.data.modifiedDamage = foundry.utils.duplicate(this.data.incomingDamage);
    this.data.modifiedDamage.base = this.data.incomingDamage.value;
    this.data.modifiedDamage.mod = [];
    delete this.data.modifiedDamage.override;
    this.data.modifiedDamage.ap.base = this.data.incomingDamage.ap.value;
    this.data.modifiedDamage.ap.mod = [];
    delete this.data.modifiedDamage.ap.override;
    Helpers.calcTotal(this.data.modifiedDamage);
    Helpers.calcTotal(this.data.modifiedDamage.ap);
  }
  get canSucceed() {
    return true;
  }
  /**
   * Resist Test success means ALL damage has been soaked.
   */
  get success() {
    return !!this.getSuccessCondition();
  }
  isFullySoaked() {
    return this.data.incomingDamage.value <= this.hits.value;
  }
  getSuccessCondition() {
    return this.successConditions.find(({ test }) => test());
  }
  get showSuccessLabel() {
    return this.success;
  }
  get successLabel() {
    return this.getSuccessCondition()?.label || "SR6.TestResults.ResistedAllDamage";
  }
  get failureLabel() {
    return "SR6.TestResults.ResistedSomeDamage";
  }
  async processSuccess() {
    await super.processSuccess();
    this.getSuccessCondition()?.effect?.();
  }
  async evaluate() {
    await super.evaluate();
    const armor3 = this.actor?.getArmor(this.data.modifiedDamage);
    if (armor3?.hardened) {
      PartsList.AddUniquePart(this.hits.mod, "SR6.AppendedHits", Math.ceil(armor3.value / 2));
      Helpers.calcTotal(this.hits);
    }
    return this;
  }
  async processResults() {
    await super.processResults();
    if (!this.actor) return;
    this.data.modifiedDamage = CombatRules.modifyDamageAfterResist(this.actor, this.data.modifiedDamage, this.hits.value);
    this.data.knockedDown = new SoakFlow().knocksDown(this.data.modifiedDamage, this.actor);
  }
};

// src/module/tests/MeleeAttackTest.ts
var MeleeAttackTest = class extends SuccessTest {
  static {
    __name(this, "MeleeAttackTest");
  }
  _prepareData(data, options) {
    data = super._prepareData(data, options);
    data.damage = data.damage || DataDefaults.damageData();
    return data;
  }
  /**
   * This test type can't be extended.
   */
  get canBeExtended() {
    return false;
  }
  get testCategories() {
    return ["attack", "attack_melee"];
  }
  get testModifiers() {
    return ["global", "wounds", "environmental"];
  }
  get _dialogTemplate() {
    return "systems/shadowrun6-elysium/dist/templates/apps/dialogs/melee-attack-test-dialog.html";
  }
  get showSuccessLabel() {
    return this.success;
  }
  async prepareDocumentData() {
    if (!this.item || !this.item.isMeleeWeapon) return;
    this.data.reach = this.item.getReach();
    this.data.reach += this.actor?.system.modifiers.reach || 0;
    await super.prepareDocumentData();
  }
  /**
   * Remove unneeded environmental modifier categories for melee tests.
   *
   * See SR5#187 'Environmental Modifiers'
   *
   * @param actor
   * @param type
   */
  prepareActorModifier(actor, type) {
    if (type !== "environmental") return super.prepareActorModifier(actor, type);
    const modifiers = actor.getSituationModifiers();
    modifiers.environmental.apply({ applicable: ["light", "visibility"] });
    const name3 = this._getModifierTypeLabel(type);
    const value = modifiers.environmental.total;
    return { name: name3, value };
  }
  /**
   * Some Melee Weapons have ammo and can consume it.
   */
  canConsumeDocumentResources() {
    if (this.item === void 0) return true;
    if (!this.item.usesAmmo) return true;
    if (!this.item.hasAmmo(1)) {
      ui.notifications?.error("SR6.MissingRessource.SomeAmmoMelee", { localize: true });
      return false;
    }
    return super.canConsumeDocumentResources();
  }
  /**
   * Some Melee Weapons can consume ammo resources.
   */
  async consumeDocumentRessources() {
    if (!await super.consumeDocumentRessources()) return false;
    if (!await this.consumeWeaponAmmo()) return false;
    return true;
  }
  /**
   * Reduce the melee weapon ammunition for this attack.
   */
  async consumeWeaponAmmo() {
    if (this.item === void 0) return true;
    if (!this.item.usesAmmo) return true;
    if (!this.item.hasAmmo(1)) {
      ui.notifications?.warn("SR6.MissingRessource.SomeAmmoMelee", { localize: true });
    }
    await this.item.useAmmo(1);
    return true;
  }
};

// src/module/rules/SpellcastingRules.ts
var SpellcastingRules = class _SpellcastingRules {
  static {
    __name(this, "SpellcastingRules");
  }
  /**
   * Calculate spellcasting drain value without its damage type
   *
   * As defined in SR5#282 - Step 6 Resist Drain.
   *
   * @param force The force the spell is cast with.
   * @param drainModifier The drain modifier defined within the spells action configuration.
   * @param reckless Set this to true should the spell be cast recklessly as defined in SR5#281 Cast Spell.
   */
  static calculateDrain(force, drainModifier, reckless = false) {
    const recklessModifier = reckless ? this.recklessDrainModifier : 0;
    const drain = force + drainModifier + recklessModifier;
    return Math.max(this.minimalDrain, drain);
  }
  /**
   * As defined in SR5#282 - Step 6 Resist Drain
   */
  static get minimalDrain() {
    return 2;
  }
  /**
   * As defined in SR5#281 - Step 4 Cast Spell.
   *
   * Reckless spellcasting will alter drain damage.
   */
  static get recklessDrainModifier() {
    return 3;
  }
  /**
   * Based on the minimal drain value use this as the minimal usable force value.
   * @param drainModifier The drain modifier defined within the spells action configuration.
   */
  static calculateMinimalForce(drainModifier) {
    return Math.max(1, this.minimalDrain - drainModifier);
  }
  /**
   * Calculate spell casting limit based on the force chosen.
   *
   * As defined in SR5#281 - Step 3 Choose Spell Force
   * As defined in SR5#316-317 'Reagents'
   *
   * @param force The spell force chosen by test configuration.
   * @param reagents The amount of reagents / drams used for the spell.
   * @returns The limit value to be applied.
   */
  static calculateLimit(force, reagents = 0) {
    return _SpellcastingRules.limitIsReagentInsteadOfForce(reagents) ? reagents : force;
  }
  /**
   * As defined in SR5#316-317 'Reagents'
   * @param reagents The amount of drams used from reagents
   * @returns True if reagents should be used 
   */
  static limitIsReagentInsteadOfForce(reagents = 0) {
    return reagents > 0;
  }
};

// src/module/tests/SpellCastingTest.ts
var SpellCastingTest = class extends SuccessTest {
  static {
    __name(this, "SpellCastingTest");
  }
  _prepareData(data, options) {
    data = super._prepareData(data, options);
    data.force = data.force || 0;
    data.drain = data.drain || 0;
    data.reckless = data.reckless || false;
    data.drainDamage = data.drainDamage || DataDefaults.damageData();
    return data;
  }
  get _dialogTemplate() {
    return "systems/shadowrun6-elysium/dist/templates/apps/dialogs/spellcasting-test-dialog.html";
  }
  get _chatMessageTemplate() {
    return "systems/shadowrun6-elysium/dist/templates/rolls/spellcasting-test-message.html";
  }
  /**
   * This test type can't be extended.
   */
  get canBeExtended() {
    return false;
  }
  static _getDefaultTestAction() {
    return {
      skill: "spellcasting",
      attribute: "magic"
    };
  }
  /**
   * Spellcasting test category directly depends on the spell cast.
   */
  get testCategories() {
    const spell = this.item?.asSpell;
    if (!spell) return [];
    switch (spell.system.category) {
      case "combat":
        return ["spell_combat"];
      case "detection":
        return ["spell_detection"];
      case "health":
        return ["spell_healing"];
      case "illusion":
        return ["spell_illusion"];
      case "manipulation":
        return ["spell_manipulation"];
      case "ritual":
        return ["spell_ritual"];
    }
    return [];
  }
  get testModifiers() {
    return ["global", "wounds", "background_count"];
  }
  async prepareDocumentData() {
    this.prepareInitialForceValue();
    await super.prepareDocumentData();
  }
  /**
   * Set a force value based on the items history or viable suggestions.
   */
  prepareInitialForceValue() {
    if (!this.item) return;
    const lastUsedForce = this.item.getLastSpellForce();
    const suggestedForce = SpellcastingRules.calculateMinimalForce(this.item.getDrain);
    this.data.force = lastUsedForce.value || suggestedForce;
  }
  prepareBaseValues() {
    super.prepareBaseValues();
    this.prepareLimitValue();
  }
  prepareLimitValue() {
    const force = Number(this.data.force);
    this.data.limit.mod = PartsList.AddUniquePart(
      this.data.limit.mod,
      "SR6.Force",
      SpellcastingRules.calculateLimit(force)
    );
  }
  calculateBaseValues() {
    super.calculateBaseValues();
    this.calculateDrainValue();
  }
  /**
   * Precalculate drain for user display.
   */
  calculateDrainValue() {
    const force = Number(this.data.force);
    const drain = Number(this.item?.getDrain);
    const reckless = this.data.reckless;
    this.data.drain = SpellcastingRules.calculateDrain(force, drain, reckless);
  }
  /**
   * Derive the actual drain damage from spellcasting values.
   */
  calcDrainDamage() {
    if (!this.actor) return DataDefaults.damageData();
    const force = Number(this.data.force);
    const drain = Number(this.data.drain);
    const magic = this.actor.getAttribute("magic").value;
    this.data.drainDamage = DrainRules.calcDrainDamage(drain, force, magic, this.hits.value);
  }
  async processResults() {
    this.calcDrainDamage();
    await super.processResults();
  }
  /**
   * Allow the currently used force value of this spell item to be reused next time.
   */
  async saveUserSelectionAfterDialog() {
    if (!this.item) return;
    await this.item.setLastSpellForce({ value: this.data.force, reckless: false });
  }
};

// src/module/tests/DrainTest.ts
var DrainTest = class extends SuccessTest {
  static {
    __name(this, "DrainTest");
  }
  _prepareData(data, options) {
    data = super._prepareData(data, options);
    if (data.against) {
      data.incomingDrain = foundry.utils.duplicate(data.against.drainDamage);
      data.modifiedDrain = foundry.utils.duplicate(data.incomingDrain);
    } else {
      data.incomingDrain = data.incomingDrain ?? DataDefaults.damageData();
      data.modifiedDrain = foundry.utils.duplicate(data.incomingDrain);
    }
    return data;
  }
  get _dialogTemplate() {
    return "systems/shadowrun6-elysium/dist/templates/apps/dialogs/drain-test-dialog.html";
  }
  get _chatMessageTemplate() {
    return "systems/shadowrun6-elysium/dist/templates/rolls/drain-test-message.html";
  }
  static _getDefaultTestAction() {
    return {
      "attribute2": "willpower"
    };
  }
  /**
   * This test type can't be extended.
   */
  get canBeExtended() {
    return false;
  }
  get testCategories() {
    return ["drain"];
  }
  get testModifiers() {
    return ["global", "drain"];
  }
  static async _getDocumentTestAction(item, actor) {
    const documentAction = await super._getDocumentTestAction(item, actor);
    if (!actor.isAwakened) {
      console.error(`Shadowrun 6e | A ${this.name} expected an awakened actor but got this`, actor);
      return documentAction;
    }
    const attribute = actor.system.magic.attribute;
    foundry.utils.mergeObject(documentAction, { attribute });
    return documentAction;
  }
  /**
   * Re-calculate incomingDrain in case of user input
   */
  calculateBaseValues() {
    super.calculateBaseValues();
    Helpers.calcValue(this.data.incomingDrain.type);
    this.data.modifiedDrain = foundry.utils.duplicate(this.data.incomingDrain);
    this.data.modifiedDrain.base = Helpers.calcTotal(this.data.incomingDrain, { min: 0 });
    delete this.data.modifiedDrain.override;
  }
  /**
   * A drain test is successful whenever it has more hits than drain damage
   */
  get success() {
    return this.data.modifiedDrain.value <= 0;
  }
  get successLabel() {
    return "SR6.TestResults.ResistedAllDamage";
  }
  get failureLabel() {
    return "SR6.TestResults.ResistedSomeDamage";
  }
  async processResults() {
    this.data.modifiedDrain = DrainRules.modifyDrainDamage(this.data.modifiedDrain, this.hits.value);
    await super.processResults();
  }
};

// src/module/rules/CombatSpellRules.ts
var CombatSpellRules = class _CombatSpellRules {
  static {
    __name(this, "CombatSpellRules");
  }
  /**
   * Calculate combat spell damage as defined in SR5#283 Combat Spells Direct section.
   *
   * This includes only the attack portion of damage calculation.
   *
   * @param damage The DamageData so far.
   */
  static calculateDirectDamage(damage) {
    return foundry.utils.duplicate(damage);
  }
  /**
   * Calculate combat spell damage as defined in SR5#283 Combat Spells Indirect section.
   *
   * This includes only the attack portion of damage calculation.
   *
   * @param damage The DamageData so far.
   * @param force The force used during combat spell.
   */
  static calculateIndirectDamage(damage, force) {
    damage = foundry.utils.duplicate(damage);
    const ap = -force;
    damage.ap.mod = PartsList.AddUniquePart(damage.ap.mod, "SR6.Force", ap);
    damage.mod = PartsList.AddUniquePart(damage.mod, "SR6.Force", force);
    Helpers.calcTotal(damage.ap);
    Helpers.calcTotal(damage, { min: 0 });
    return damage;
  }
  /**
   * Modify incoming direct combat spell damage as defined in SR5#283 Combat Spell direct section.
   *
   * @param defender The active defender
   * @param damage Incoming damage including base damage values.
   * @param attackerHits The attackers hits achieved
   * @param defenderHits The defenders hits achieved
   */
  static modifyDirectDamageAfterHit(defender, damage, attackerHits, defenderHits) {
    return CombatRules.modifyDamageAfterHit(defender, attackerHits, defenderHits, damage);
  }
  static modifyIndirectDamageAfterHit(defender, damage, attackerHits, defenderHits) {
    return CombatRules.modifyDamageAfterHit(defender, attackerHits, defenderHits, damage);
  }
  static modifyDamageAfterMiss(damage) {
    return CombatRules.modifyDamageAfterMiss(damage);
  }
  /**
   * Should a damage resist test be allowed according to SR5#283 section 'Combat Spells'
   * @param type The general combat spell type.
   * @returns When true, a damage resist test should be cast.
   */
  static allowDamageResist(type) {
    return type === "indirect";
  }
  /**
   * Calculate base damage for all combat spell types.
   *
   * This will not include net hits after defense.
   *
   * @param type The combat spell type
   * @param damage The incoming damage
   * @param force Used force value during original spellcasting
   * @returns A modified damage resulting
   */
  static calculateBaseDamage(type, damage, force) {
    switch (type) {
      case "indirect":
        return _CombatSpellRules.calculateIndirectDamage(damage, force);
      case "direct":
        return _CombatSpellRules.calculateDirectDamage(damage);
    }
    return foundry.utils.duplicate(damage);
  }
  /**
   * Modify incoming damage for a combat spell after the spell hit the defending target according to SR5#283 Section 'Combat Defense'
   *
   * @param defender The active defender
   * @param spellType The general spell type.
   * @param combatType The combat spell type.
   * @param damage The incoming damage.
   * @param attackerHits Hits achieved by the spell attack aster.
   * @param defenderHits Hits achieved by the defender against the spell attack.
   */
  static modifyDamageAfterHit(defender, spellType, combatType, damage, attackerHits, defenderHits) {
    if (spellType === "mana" && combatType === "direct") {
      return _CombatSpellRules.modifyDirectDamageAfterHit(
        defender,
        damage,
        attackerHits,
        defenderHits
      );
    }
    if (spellType === "physical" && combatType === "direct") {
      return _CombatSpellRules.modifyDirectDamageAfterHit(
        defender,
        damage,
        attackerHits,
        defenderHits
      );
    }
    if (combatType === "indirect") {
      return _CombatSpellRules.modifyIndirectDamageAfterHit(
        defender,
        damage,
        attackerHits,
        defenderHits
      );
    }
    return foundry.utils.duplicate(damage);
  }
  /**
   * Return a testable action for combat spell defense based on SR5#283 Section 'Combat Defense'
   *
   * @param spellType The general spell type.
   * @param combatType The combat spell type.
   */
  static defenseTestAction(spellType, combatType) {
    if (spellType === "" || combatType === "")
      console.warn(`SR6: Elysium | The given spell or combat spell types are empty and won't form a complete defense test action`);
    const itemAction = DataDefaults.minimalActionData();
    if (spellType === "mana" && combatType === "direct") {
      itemAction.attribute = "willpower";
    }
    if (spellType === "physical" && combatType === "direct") {
      itemAction.attribute = "body";
    }
    if (combatType === "indirect") {
      itemAction.attribute = "reaction";
      itemAction.attribute2 = "intuition";
    }
    return itemAction;
  }
};

// src/module/tests/CombatSpellDefenseTest.ts
var CombatSpellDefenseTest = class extends DefenseTest {
  static {
    __name(this, "CombatSpellDefenseTest");
  }
  /**
   * A combat spell defense test changes it's behaviour based on the spell it's defending against.
   *
   * @param item A spell item.
   * @param actor The actor to defend with.
   */
  static async _getDocumentTestAction(item, actor) {
    const action = DataDefaults.minimalActionData(await super._getDocumentTestAction(item, actor));
    const spellData = item.asSpell;
    if (!spellData) return action;
    const itemAction = CombatSpellRules.defenseTestAction(spellData.system.type, spellData.system.combat.type);
    return TestCreator._mergeMinimalActionDataInOrder(action, itemAction);
  }
  prepareBaseValues() {
    super.prepareBaseValues();
    this.calculateCombatSpellDamage();
  }
  get testCategories() {
    const spell = this.item?.asSpell;
    if (!spell) return [];
    if (spell.system.type === "physical" && spell.system.combat.type === "indirect") {
      return ["defense"];
    }
    return [];
  }
  get testModifiers() {
    const spell = this.item?.asSpell;
    if (!spell) return ["global"];
    if (spell.system.type === "mana" && spell.system.combat.type === "direct") {
      return ["global"];
    }
    if (spell.system.type === "physical" && spell.system.combat.type === "direct") {
      return ["global"];
    }
    if (spell.system.combat.type === "indirect") {
      return ["global", "defense", "multi_defense", "wounds"];
    }
    return ["global"];
  }
  /**
   * A combat spells damage depends on
   */
  calculateCombatSpellDamage() {
    const spell = this.item?.asSpell;
    if (!spell) return;
    this.data.incomingDamage = CombatSpellRules.calculateBaseDamage(spell.system.combat.type, this.data.incomingDamage, this.data.against.force);
  }
  async processResults() {
    await super.processResults();
    await this.applyActorEffectsForDefense();
  }
  /**
   * A success on a defense test is a MISS on the initial attack.
   */
  async processSuccess() {
    this.data.modifiedDamage = CombatSpellRules.modifyDamageAfterMiss(this.data.incomingDamage);
    await super.processSuccess();
  }
  /**
   * A failure on a defense test is a HIT on the initial attack.
   */
  async processFailure() {
    const spell = this.item?.asSpell;
    if (!spell) return;
    if (!this.actor) return;
    this.data.modifiedDamage = CombatSpellRules.modifyDamageAfterHit(
      this.actor,
      spell.system.type,
      spell.system.combat.type,
      this.data.incomingDamage,
      this.against.hits.value,
      this.hits.value
    );
    await super.processFailure();
  }
  /**
   * Combat Spell Defense allows a resist test for the defending actor.
   */
  async afterFailure() {
    await super.afterFailure();
    const spell = this.item?.asSpell;
    if (!spell) return;
    if (CombatSpellRules.allowDamageResist(spell.system.combat.type)) {
      const test = await TestCreator.fromOpposedTestResistTest(this, this.data.options);
      if (!test) return;
      await test.execute();
    }
  }
  /**
   * Increase the actors multi defense modifier for indirect combat spells.
   */
  async applyActorEffectsForDefense() {
    if (!this.actor) return;
    const spell = this.item?.asSpell;
    if (!spell) return;
    if (spell.system.category !== "combat" || spell.system.combat.type === "direct") return;
    this.actor.calculateNextDefenseMultiModifier();
  }
};

// src/module/rules/ComplexFormRules.ts
var ComplexFormRules = {
  /**
   * As defined in SR5#251-252 section Fading.
   */
  minimalFade: 2,
  /**
   * Based on the minimal level value use this as the minimal usable level value.
   * @param fadeModifier The fade modifier defined within the complex forms action configuration.
   */
  calculateMinimalLevel: /* @__PURE__ */ __name(function(fadeModifier) {
    return Math.max(1, this.minimalFade - fadeModifier);
  }, "calculateMinimalLevel"),
  calculateLevel: /* @__PURE__ */ __name(function(level) {
    return Math.max(1, level);
  }, "calculateLevel"),
  /**
   * The threading test limit as defined in SR5#250 Thread Complex Form action.
   * @param level
   */
  calculateLimit: /* @__PURE__ */ __name(function(level) {
    return level;
  }, "calculateLimit"),
  /**
   * Calculate fade for complex forms based on SR5#250
   *
   * @param level The level chosen to thread this complex form.
   * @param fadeModifier The action modifier for fade damage.
   */
  calculateFade: /* @__PURE__ */ __name(function(level, fadeModifier) {
    const fade = level + fadeModifier;
    return Math.max(this.minimalFade, fade);
  }, "calculateFade")
};

// src/module/rules/FadeRules.ts
var FadeRules = {
  /**
   * Calculate fade damage according to SR5#251 section Fading
   *
   * @param fade The fade value after threading test
   * @param hits The amount of hits during threading
   * @param resonance The resonance attribute rating
   */
  calcFadeDamage: /* @__PURE__ */ __name(function(fade, hits, resonance) {
    if (hits < 0) hits = 0;
    if (resonance < 1) resonance = 1;
    const damage = DataDefaults.damageData();
    damage.base = fade;
    Helpers.calcTotal(damage, { min: 0 });
    damage.type.base = damage.type.value = FadeRules.calcFadeDamageType(hits, resonance);
    return damage;
  }, "calcFadeDamage"),
  /**
   * Calculate the damage type for fade damage according to threading hits according to SR5#251 section Fading
   * @param hits Threading test hits
   * @param resonance attribute rating
   */
  calcFadeDamageType: /* @__PURE__ */ __name(function(hits, resonance) {
    if (hits < 0) hits = 0;
    if (resonance < 0) resonance = 1;
    return hits > resonance ? "physical" : "stun";
  }, "calcFadeDamageType"),
  /**
   * Modify fade damage after a fade resist test according to SR5#251 section Fading
   */
  modifyFadeDamage: /* @__PURE__ */ __name(function(fadeDamage, hits) {
    if (hits < 0) hits = 0;
    fadeDamage = foundry.utils.duplicate(fadeDamage);
    PartsList.AddUniquePart(fadeDamage.mod, "SR6.Hits", -hits);
    Helpers.calcTotal(fadeDamage, { min: 0 });
    return fadeDamage;
  }, "modifyFadeDamage")
};

// src/module/tests/ComplexFormTest.ts
var ComplexFormTest = class extends SuccessTest {
  static {
    __name(this, "ComplexFormTest");
  }
  _prepareData(data, options) {
    data = super._prepareData(data, options);
    data.level = data.level || 0;
    data.fade = data.face || 0;
    data.fadeDamage = data.fadeDamage || DataDefaults.damageData();
    return data;
  }
  get _dialogTemplate() {
    return "systems/shadowrun6-elysium/dist/templates/apps/dialogs/complexform-test-dialog.html";
  }
  get _chatMessageTemplate() {
    return "systems/shadowrun6-elysium/dist/templates/rolls/complexform-test-message.html";
  }
  /**
   * This test type can't be extended.
   */
  get canBeExtended() {
    return false;
  }
  static _getDefaultTestAction() {
    return {
      skill: "software",
      attribute: "resonance"
    };
  }
  get testCategories() {
    return ["complex_form"];
  }
  // TODO: Add missing modifiers (gitter) // SR5#251
  get testModifiers() {
    return ["global", "wounds"];
  }
  async prepareDocumentData() {
    this.prepareInitialLevelValue();
    await super.prepareDocumentData();
  }
  /**
   * Set a level value based on the items history or viable suggestions.
   */
  prepareInitialLevelValue() {
    if (!this.item) return;
    const lastUsedLevel = this.item.getLastComplexFormLevel();
    const suggestedLevel = ComplexFormRules.calculateMinimalLevel(this.item.getFade());
    this.data.level = lastUsedLevel.value || suggestedLevel;
  }
  prepareBaseValues() {
    super.prepareBaseValues();
    this.prepareLevelValue();
    this.prepareLimitValue();
  }
  /**
   * Assert user input doesn't create unusable level values.
   */
  prepareLevelValue() {
    this.data.level = ComplexFormRules.calculateLevel(this.data.level);
  }
  /**
   * Derive limit value based on complex form rules.
   */
  prepareLimitValue() {
    const level = Number(this.data.level);
    this.data.limit.mod = PartsList.AddUniquePart(
      this.data.limit.mod,
      "SR6.Level",
      ComplexFormRules.calculateLimit(level)
    );
  }
  calculateBaseValues() {
    super.calculateBaseValues();
    this.calculateFadeValue();
  }
  calculateFadeValue() {
    const level = Number(this.data.level);
    const fade = Number(this.item?.getFade() || 0);
    this.data.fade = ComplexFormRules.calculateFade(level, fade);
  }
  calculateFadeDamage() {
    if (!this.actor) return DataDefaults.valueData();
    const fade = Number(this.data.fade);
    const resonance = this.actor.getAttribute("resonance").value;
    this.data.fadeDamage = FadeRules.calcFadeDamage(fade, this.hits.value, resonance);
  }
  async processResults() {
    this.calculateFadeDamage();
    await super.processResults();
  }
  async afterTestComplete() {
    await this.saveLastUsedLevel();
    await super.afterTestComplete();
  }
  /**
   * Allow the currently used level value for this complex form item to be reused next time.
   */
  async saveLastUsedLevel() {
    if (!this.item) return;
    await this.item.setLastComplexFormLevel({ value: this.data.level });
  }
};

// src/module/tests/NaturalRecoveryStunTest.ts
var NaturalRecoveryStunTest = class extends SuccessTest {
  static {
    __name(this, "NaturalRecoveryStunTest");
  }
  prepareBaseValues() {
    super.prepareBaseValues();
    this.prepareThreshold();
  }
  get testCategories() {
    return ["recovery", "recovery_stun"];
  }
  /**
   * A recovery test has its damage track as a threshold.
   */
  prepareThreshold() {
    if (!this.actor) return;
    const track = this.actor.getStunTrack();
    const boxes = track?.value || 0;
    const threshold = new PartsList(this.threshold.mod);
    threshold.addUniquePart("SR6.StunTrack", boxes);
  }
  /**
   * A recovery test will heal on each test iteration
   */
  async processResults() {
    await super.processResults();
    if (!this.actor) return;
    if (!this.actor.hasNaturalRecovery) return;
    if (this.hits.value === 0) return;
    await this.actor.healStunDamage(this.hits.value);
  }
};

// src/module/tests/NaturalRecoveryPhysicalTest.ts
var NaturalRecoveryPhysicalTest = class extends SuccessTest {
  static {
    __name(this, "NaturalRecoveryPhysicalTest");
  }
  async execute() {
    if (!this.actor) return this;
    if (!this.actor.canRecoverPhysicalDamage) {
      ui.notifications?.warn(game.i18n.localize("SR6.Warnings.CantRecoverPhysicalWithStunDamage"));
      return this;
    }
    return super.execute();
  }
  prepareBaseValues() {
    super.prepareBaseValues();
    this.prepareThreshold();
  }
  get testCategories() {
    return ["recovery", "recovery_physical"];
  }
  /**
   * A recovery test has its damage track as a threshold.
   */
  prepareThreshold() {
    if (!this.actor) return;
    const track = this.actor.getPhysicalTrack();
    const boxes = track?.value || 0;
    const threshold = new PartsList(this.threshold.mod);
    threshold.addUniquePart("SR6.PhysicalTrack", boxes);
  }
  /**
   * A recovery test will heal on each test iteration
   */
  async processResults() {
    await super.processResults();
    if (!this.actor) return;
    if (!this.actor.hasNaturalRecovery) return;
    if (this.hits.value === 0) return;
    await this.actor.healPhysicalDamage(this.hits.value);
  }
};

// src/module/tests/FadeTest.ts
var FadeTest = class extends SuccessTest {
  static {
    __name(this, "FadeTest");
  }
  _prepareData(data, options) {
    data = super._prepareData(data, options);
    if (data.against) {
      data.incomingFade = foundry.utils.duplicate(data.against.fadeDamage);
      data.modifiedFade = foundry.utils.duplicate(data.incomingFade);
    } else {
      data.incomingFade = data.incomingFade ?? DataDefaults.damageData();
      data.modifiedFade = foundry.utils.duplicate(data.incomingFade);
    }
    return data;
  }
  get _dialogTemplate() {
    return "systems/shadowrun6-elysium/dist/templates/apps/dialogs/fade-test-dialog.html";
  }
  get _chatMessageTemplate() {
    return "systems/shadowrun6-elysium/dist/templates/rolls/fade-test-message.html";
  }
  static _getDefaultTestAction() {
    return {
      "attribute2": "resonance"
    };
  }
  static async _getDocumentTestAction(item, actor) {
    const documentAction = await super._getDocumentTestAction(item, actor);
    const character = actor.asCharacter();
    if (!character || !actor.isEmerged) {
      console.error(`Shadowrun 6e | A ${this.name} expected an emerged actor but got this`, actor);
      return documentAction;
    }
    const attribute = character.system.technomancer.attribute;
    foundry.utils.mergeObject(documentAction, { attribute });
    return documentAction;
  }
  get testCategories() {
    return ["fade"];
  }
  get testModifiers() {
    return ["global", "fade"];
  }
  get canBeExtended() {
    return false;
  }
  /**
   * A drain test is successful whenever it has more hits than drain damage
   */
  get success() {
    return this.data.modifiedFade.value <= 0;
  }
  get successLabel() {
    return "SR6.TestResults.ResistedAllDamage";
  }
  get failureLabel() {
    return "SR6.TestResults.ResistedSomeDamage";
  }
  /**
   * Re-calculate incomingFade in case of user input
   */
  calculateBaseValues() {
    super.calculateBaseValues();
    this.data.modifiedFade.base = Helpers.calcTotal(this.data.incomingFade, { min: 0 });
  }
  async processResults() {
    this.data.modifiedFade = FadeRules.modifyFadeDamage(this.data.modifiedFade, this.hits.value);
    await super.processResults();
  }
};

// src/module/tests/ThrownAttackTest.ts
var ThrownAttackTest = class extends SuccessTest {
  static {
    __name(this, "ThrownAttackTest");
  }
  _prepareData(data, options) {
    data = super._prepareData(data, options);
    WeaponRangeTestBehavior.prepareData(this, data);
    return data;
  }
  get canBeExtended() {
    return false;
  }
  get showSuccessLabel() {
    return this.success;
  }
  get testCategories() {
    return ["attack", "attack_thrown"];
  }
  get testModifiers() {
    return ["global", "wounds", "environmental"];
  }
  async prepareDocumentData() {
    WeaponRangeTestBehavior.prepareDocumentData(this, (weapon) => weapon.system.thrown.ranges);
    await super.prepareDocumentData();
  }
  get _dialogTemplate() {
    return "systems/shadowrun6-elysium/dist/templates/apps/dialogs/thrown-attack-test-dialog.html";
  }
  /**
   * Save selections made back to documents.
   * @returns
   */
  async saveUserSelectionAfterDialog() {
    await WeaponRangeTestBehavior.saveUserSelectionAfterDialog(this);
  }
  /**
   * Apply test selections made by user in dialog.
   * @returns
   */
  prepareBaseValues() {
    WeaponRangeTestBehavior.prepareBaseValues(this);
    super.prepareBaseValues();
  }
  /**
   * Ranged attack tests allow for temporarily changing of modifiers without altering the document.
   */
  prepareTestModifiers() {
    WeaponRangeTestBehavior.prepareTestModifiers(this);
  }
  async processResults() {
    await super.processResults();
    await WeaponRangeTestBehavior.processResults(this);
  }
};

// src/module/tests/PilotVehicleTest.ts
var PilotVehicleTest = class extends SuccessTest {
  static {
    __name(this, "PilotVehicleTest");
  }
  /**
   * Piloting a vehicle will alter the kind of test that needs to be made based on a few factors.
   *
   * @param item The testing item to cast
   * @param actor The vehicle actor to be casting with
   */
  static async _getDocumentTestAction(item, actor) {
    if (!item || !actor) return {};
    const vehicleData = actor.asVehicle();
    if (!vehicleData) {
      await ui.notifications?.error(game.i18n.localize("SR6.Errors.TestExpectsVehicleOnly"));
      return {};
    }
    switch (vehicleData.system.controlMode) {
      case "autopilot": {
        const attribute = "pilot";
        const skill = actor.getVehicleTypeSkillName();
        const limit = { attribute: vehicleData.system.environment };
        return { attribute, skill, limit };
      }
      default:
        const skillId = actor.getVehicleTypeSkillName();
        return actor.skillActionData(skillId);
    }
  }
  get testCategories() {
    return ["rigging"];
  }
};

// src/module/tests/DronePerceptionTest.ts
var DronePerceptionTest = class extends SuccessTest {
  static {
    __name(this, "DronePerceptionTest");
  }
  static async _getDocumentTestAction(item, actor) {
    if (!item || !actor) return {};
    const vehicleData = actor.asVehicle();
    if (!vehicleData) {
      await ui.notifications?.error(game.i18n.localize("SR6.Errors.TestExpectsVehicleOnly"));
      return {};
    }
    switch (vehicleData.system.controlMode) {
      case "autopilot": {
        const attribute = "pilot";
        const skill = "perception";
        const limit = { attribute: "sensor" };
        return { attribute, skill, limit };
      }
      default:
        return actor.skillActionData("perception");
    }
  }
  get testCategories() {
    return ["rigging"];
  }
};

// src/module/tests/DroneInfiltrationTest.ts
var DroneInfiltrationTest = class extends SuccessTest {
  static {
    __name(this, "DroneInfiltrationTest");
  }
  static async _getDocumentTestAction(item, actor) {
    if (!item || !actor) return {};
    const vehicleData = actor.asVehicle();
    if (!vehicleData) {
      await ui.notifications?.error(game.i18n.localize("SR6.Errors.TestExpectsVehicleOnly"));
      return {};
    }
    switch (vehicleData.system.controlMode) {
      // See SR5#270 'Drone Infiltration'
      case "autopilot": {
        const attribute = "pilot";
        const skill = "sneaking";
        const limit = { attribute: "handling" };
        return { attribute, skill, limit };
      }
      case "rigger": {
        const attribute = "intuition";
        const skill = "sneaking";
        const limit = "handling";
        return { attribute, skill, limit };
      }
      default:
        return actor.skillActionData("perception");
    }
  }
  get testCategories() {
    return ["rigging"];
  }
};

// src/module/tests/SuppressionDefenseTest.ts
var SuppressionDefenseTest = class extends PhysicalDefenseTest {
  static {
    __name(this, "SuppressionDefenseTest");
  }
  static _getDefaultTestAction() {
    return {
      "attribute": "reaction",
      "attribute2": "edge"
    };
  }
  get testCategories() {
    return ["defense_suppression"];
  }
  async processFailure() {
    this.data.modifiedDamage = CombatRules.modifyDamageAfterSuppressionHit(this.data.incomingDamage);
  }
};

// src/module/tests/SummonSpiritTest.ts
var SummonSpiritTest = class extends SuccessTest {
  static {
    __name(this, "SummonSpiritTest");
  }
  _prepareData(data, options) {
    data = super._prepareData(data, options);
    this._prepareSummoningData(data);
    data.drain = data.drain || 0;
    data.drainDamage = data.drainDamage || DataDefaults.damageData();
    return data;
  }
  get _dialogTemplate() {
    return "systems/shadowrun6-elysium/dist/templates/apps/dialogs/summonspirit-test-dialog.html";
  }
  get testCategories() {
    return ["summoning"];
  }
  /**
   * A summoning test can't be extended.
   */
  get canBeExtended() {
    return false;
  }
  /**
   * Drain test is configured here but will be executed within the opposing tests context.
   */
  get autoExecuteFollowupTest() {
    return false;
  }
  /**
   * Skill + Attribute [Limit] as defined in SR5#300 'Attempt summoning'
   *
   * Limit 'force' is a dynamic test value, so it's missing here as it can't be taken from actor values.
   */
  static _getDefaultTestAction() {
    return {
      skill: "summoning",
      attribute: "magic"
    };
  }
  /**
   * Summoning actions are magic actions and get their modifiers.
   */
  get testModifiers() {
    const modifiers = super.testModifiers;
    modifiers.push("background_count");
    return modifiers;
  }
  /**
   * Summoning uses Force as limit, which needs to be injected into the normal test flow.
   */
  prepareBaseValues() {
    super.prepareBaseValues();
    this.prepareLimitValue();
  }
  /**
   * Validate user input during dialog or creation and inform user about invalid values.
   */
  validateBaseValues() {
    this.warnAboutInvalidForce();
  }
  /**
   * Notify summoners about incomplete summoning. To avoid pre mature drain tests.
   */
  async executeFollowUpTest() {
    if (!this.data.drainReady) ui.notifications?.warn("SR6.Warnings.SummoningNotConcluded", { localize: true });
    await super.executeFollowUpTest();
  }
  /**
   * Don't abort execution as there might be some reason users would want to allow 'invalid' values.
   */
  warnAboutInvalidForce() {
    const force = Number(this.data.force);
    const magic = Number(this.actor?.getAttribute("magic")?.value ?? 0);
    if (!ConjuringRules.validForce(force, magic)) {
      ui.notifications?.warn("SR6.Warnings.InvalidSummoningForce", { localize: true });
    }
  }
  /**
   * Calculate limit based on force selected by user.
   *
   * According to SR5#300 'Summoning' and SR5#316 'Reagents'.
   */
  prepareLimitValue() {
    const force = Number(this.data.force);
    const reagent = Number(this.data.reagent);
    const label = SpellcastingRules.limitIsReagentInsteadOfForce(reagent) ? "SR6.Reagent" : "SR6.Force";
    const limit = SpellcastingRules.calculateLimit(force, reagent);
    const limitParts = new PartsList(this.data.limit.mod);
    limitParts.removePart("SR6.Force");
    limitParts.removePart("SR6.Reagent");
    limitParts.addUniquePart(label, limit);
  }
  /**
   * TODO: Reduce all spirit types to those available to the Summoner according to tradition or validate against selection.
   * @returns A subset of all spirit types
   */
  _prepareSpiritTypes() {
    return SR6.spiritTypes;
  }
  /**
   * Take data from summoning item for test execution.
   * @param data Test data to be extended
   */
  _prepareSummoningData(data) {
    if (!this.item) return;
    const summoning = this.item.asCallInAction;
    if (!summoning || !this.item.isSummoning) return;
    data.spiritTypes = this._prepareSpiritTypes();
    data.force = Math.max(data.force || summoning.system.spirit.force || 1, 1);
    data.spiritTypeSelected = data.spiritTypeSelected || summoning.system.spirit.type;
    data.preparedSpiritUuid = data.preparedSpiritUuid || summoning.system.spirit.uuid;
    data.reagent = data.reagent || 0;
  }
  /**
   * Derive the actual drain damage from spellcasting values.
   *
   * NOTE: This will be called by the opposing test via a follow up test action.
   */
  calcDrain(opposingHits) {
    this.data.drainReady = true;
    this.data.drain = ConjuringRules.summoningDrainValue(opposingHits);
    this.data.drainDamage = this.calcDrainDamage(opposingHits);
  }
  calcDrainDamage(opposingHits) {
    if (!this.actor) return DataDefaults.damageData();
    const magic = this.actor.getAttribute("magic").value;
    const force = this.data.force;
    return ConjuringRules.calcDrainDamage(opposingHits, force, magic);
  }
  /**
   * Indicate the use of a prepared actor.
   */
  get preparedActorUsed() {
    return this.data.preparedSpiritUuid !== "";
  }
};

// src/unittests/sr5.SR5Roll.spec.ts
var shadowrunRolling = /* @__PURE__ */ __name((quench) => {
  const { describe, it, assert, before, after, expect } = quench;
  describe("SR5Roll", () => {
    it("Amount of dice to bethrown in shadowrun style pool, excluding explosions", async () => {
      const roll = new SR6Roll("100d6");
      await roll.evaluate({ async: true });
      assert.equal(roll.pool, 100);
      assert.equal(roll.poolThrown, 100);
    });
    it("Amount of dice thrown in shadowrun style pool, including explosions", async () => {
      const roll = new SR6Roll("100d6x6");
      await roll.evaluate({ async: true });
      assert.equal(roll.pool, 100);
      expect(roll.poolThrown).to.be.greaterThan(100);
    });
  });
}, "shadowrunRolling");

// src/unittests/utils.ts
var SR6TestingDocuments = class {
  constructor(documentClass) {
    this.documents = [];
    this.documentClass = documentClass;
  }
  static {
    __name(this, "SR6TestingDocuments");
  }
  async create(data) {
    const document2 = await this.documentClass.create({ name: `#QUENCH_TEST_DOCUMENT_SHOULD_HAVE_BEEN_DELETED`, ...data, ...{ folder: this.folder } });
    this.documents.push(document2);
    return document2;
  }
  // Register document created outside SR6TestingDocuments to be torn down at the end of testing
  register(document2) {
    this.documents.push(document2);
  }
  async teardown() {
    this.documents.forEach((document2) => document2.delete());
  }
};

// src/unittests/sr5.RangedWeapon.spec.ts
var shadowrunSR5RangedWeaponRules = /* @__PURE__ */ __name((context) => {
  const { describe, it, assert, before, after } = context;
  let testActor;
  let testItem;
  before(async () => {
    testActor = new SR6TestingDocuments(SR6Actor);
    testItem = new SR6TestingDocuments(SR6Item);
  });
  after(async () => {
    await testActor.teardown();
    await testItem.teardown();
  });
  const getWeaponWithEquippedAmmo = /* @__PURE__ */ __name(async (weaponAmmo, weaponAmmoMax, ammoQuantity) => {
    const item = await testItem.create({ type: "weapon", system: { category: "ranged", ammo: { current: { value: weaponAmmo, max: weaponAmmoMax } } } });
    const ammoItem = new SR6Item({ type: "ammo", name: "ammo", system: { technology: { quantity: ammoQuantity, equipped: true } } }, { parent: item });
    await item.createNestedItem(ammoItem.toObject());
    await item.equipAmmo(item.items[0].id);
    return item;
  }, "getWeaponWithEquippedAmmo");
  describe("Handle recoil, recoil compensation and recoil modifier", () => {
    it("Combine actor and item recoil compensation", async () => {
    });
    it("Reload weapon causes reduction in available clips", async () => {
      const item = await testItem.create({ type: "weapon", system: { category: "ranged", ammo: { current: { value: 0, max: 30 }, spare_clips: { value: 1, max: 1 } } } });
      assert.strictEqual(item.system.ammo?.spare_clips.value, 1);
      await item.reloadAmmo(true);
      assert.strictEqual(item.system.ammo?.spare_clips.value, 0);
    });
    it("Reloads weapon fully when no ammo is used", async () => {
      const item = await testItem.create({ type: "weapon", system: { category: "ranged", ammo: { current: { value: 0, max: 30 } } } });
      assert.strictEqual(item.system.ammo?.current.value, 0);
      await item.reloadAmmo(true);
      assert.strictEqual(item.system.ammo?.current.value, item.system.ammo?.current.max);
    });
    it("Reloads weapon fully when ammo is equipped and reduced ammo", async () => {
      const item = await getWeaponWithEquippedAmmo(15, 30, 30);
      const ammo = item.getEquippedAmmo();
      assert.strictEqual(item.system.ammo?.current.value, 15);
      assert.strictEqual(ammo.system.technology?.quantity, 30);
      await item.reloadAmmo(true);
      assert.strictEqual(item.system.ammo?.current.value, item.system.ammo?.current.max);
      assert.strictEqual(ammo.system.technology?.quantity, 15);
    });
    it("Does not reload when equipped ammo has no bullets left", async () => {
      const item = await getWeaponWithEquippedAmmo(15, 30, 0);
      const ammo = item.getEquippedAmmo();
      assert.strictEqual(item.system.ammo?.current.value, 15);
      assert.strictEqual(ammo.system.technology?.quantity, 0);
      await item.reloadAmmo(true);
      assert.strictEqual(item.system.ammo?.current.value, 15);
      assert.strictEqual(ammo.system.technology?.quantity, 0);
    });
    it("Does partially reload when equipped ammo has some bullets left", async () => {
      const item = await getWeaponWithEquippedAmmo(15, 30, 10);
      const ammo = item.getEquippedAmmo();
      assert.strictEqual(item.system.ammo?.current.value, 15);
      assert.strictEqual(ammo.system.technology?.quantity, 10);
      await item.reloadAmmo(true);
      assert.strictEqual(item.system.ammo?.current.value, 25);
      assert.strictEqual(ammo.system.technology?.quantity, 0);
    });
  });
}, "shadowrunSR5RangedWeaponRules");

// src/unittests/sr5.AttackTests.spec.ts
var shadowrunAttackTesting = /* @__PURE__ */ __name((context) => {
  const { describe, it, assert, before, after } = context;
  before(async () => {
  });
  after(async () => {
  });
  describe("Fire Mode Rules", () => {
    it("apply defense modifier per fire mode", () => {
      assert.strictEqual(FireModeRules.fireModeDefenseModifier({
        label: "SR6.Weapon.Mode.SingleShot",
        value: 1,
        recoil: false,
        defense: 0,
        suppression: false,
        action: "simple",
        mode: "single_shot"
      }), 0);
      assert.strictEqual(FireModeRules.fireModeDefenseModifier({
        label: "SR6.Weapon.Mode.SingleShot",
        value: 1,
        recoil: false,
        defense: 3,
        suppression: false,
        action: "simple",
        mode: "single_shot"
      }), 3);
      assert.strictEqual(FireModeRules.fireModeDefenseModifier({
        label: "SR6.Weapon.Mode.SingleShot",
        value: 1,
        recoil: false,
        defense: -3,
        suppression: false,
        action: "simple",
        mode: "single_shot"
      }), -3);
    });
    it("reduce defense modifier per firemode by ammo available", () => {
      assert.strictEqual(FireModeRules.fireModeDefenseModifier({
        label: "SR6.Weapon.Mode.SingleShot",
        value: 3,
        recoil: false,
        defense: -3,
        suppression: false,
        action: "simple",
        mode: "single_shot"
      }, 3), -3);
      assert.strictEqual(FireModeRules.fireModeDefenseModifier({
        label: "SR6.Weapon.Mode.SingleShot",
        value: 6,
        recoil: false,
        defense: -6,
        suppression: false,
        action: "simple",
        mode: "single_shot"
      }, 3), -3);
    });
    it("apply attack modifier per fire mode", () => {
      assert.strictEqual(FireModeRules.recoilModifierAfterAttack({
        label: "SR6.Weapon.Mode.BurstFireLong",
        value: 6,
        recoil: false,
        defense: -5,
        suppression: false,
        action: "complex",
        mode: "burst_fire"
      }, 0), 0);
      assert.strictEqual(FireModeRules.recoilModifierAfterAttack({
        label: "SR6.Weapon.Mode.BurstFireLong",
        value: 6,
        recoil: true,
        defense: -5,
        suppression: false,
        action: "complex",
        mode: "burst_fire"
      }, 0), -6);
      assert.strictEqual(FireModeRules.recoilModifierAfterAttack({
        label: "SR6.Weapon.Mode.BurstFireLong",
        value: 6,
        recoil: true,
        defense: -5,
        suppression: false,
        action: "complex",
        mode: "burst_fire"
      }, 3), -3);
      assert.strictEqual(FireModeRules.recoilModifierAfterAttack({
        label: "SR6.Weapon.Mode.BurstFireLong",
        value: -6,
        recoil: true,
        defense: -5,
        suppression: false,
        action: "complex",
        mode: "burst_fire"
      }, 3), 0);
    });
    it("reduce the available fire modes", () => {
      assert.lengthOf(FireModeRules.availableFireModes({
        single_shot: true,
        semi_auto: true,
        burst_fire: true,
        full_auto: true
      }), SR6.fireModes.length);
      assert.lengthOf(FireModeRules.availableFireModes({
        single_shot: true,
        semi_auto: false,
        burst_fire: false,
        full_auto: false
      }), 1);
      assert.lengthOf(FireModeRules.availableFireModes({
        single_shot: false,
        semi_auto: true,
        burst_fire: false,
        full_auto: false
      }), 2);
      assert.lengthOf(FireModeRules.availableFireModes({
        single_shot: false,
        semi_auto: false,
        burst_fire: true,
        full_auto: false
      }), 2);
      assert.lengthOf(FireModeRules.availableFireModes({
        single_shot: false,
        semi_auto: false,
        burst_fire: false,
        full_auto: true
      }), 3);
    });
  });
  describe("CombatRules", () => {
    let testActor;
    let testItem;
    let testScene;
    before(async () => {
      testActor = new SR6TestingDocuments(SR6Actor);
      testItem = new SR6TestingDocuments(SR6Item);
      testScene = new SR6TestingDocuments(Scene);
    });
    after(async () => {
      await testActor.teardown();
      await testItem.teardown();
      await testScene.teardown();
    });
    const getCharacterWithArmor = /* @__PURE__ */ __name(async (armorValue, {
      hardened = false
    } = {}) => {
      const characterActor = await testActor.create({
        type: "character"
      });
      const armor3 = await testItem.create({
        type: "armor",
        name: "Test Armor",
        system: {
          armor: {
            base: armorValue,
            value: armorValue,
            hardened,
            mod: null
            // Without this, the system defaults to an empty array for mod and thinks this is an armor accessory, therefore not applying hardened armor rules
          },
          technology: DataDefaults.technologyData({
            equipped: true
          })
        }
      });
      await characterActor.createEmbeddedDocuments("Item", [armor3]);
      return characterActor;
    }, "getCharacterWithArmor");
    const getVehicleWithArmor = /* @__PURE__ */ __name(async (armorValue) => {
      const armor3 = DataDefaults.actorArmor({
        value: armorValue,
        base: armorValue
      });
      return await testActor.create({
        type: "vehicle",
        system: {
          armor: armor3
        }
      });
    }, "getVehicleWithArmor");
    const getDamage = /* @__PURE__ */ __name((damageValue, {
      type = "physical",
      ap = 0,
      element
    } = {}) => {
      return DataDefaults.damageData({
        type: {
          value: type,
          base: type
        },
        value: damageValue,
        base: damageValue,
        ...ap && {
          ap: {
            base: ap,
            value: ap
          }
        },
        ...element && {
          element: {
            base: element,
            value: element
          }
        }
      });
    }, "getDamage");
    describe("isBlockedByVehicleArmor", () => {
      it("blocks damage due to vehicle armor", async () => {
        const vehicle = await getVehicleWithArmor(50);
        const damage = getDamage(4);
        const result = CombatRules.isBlockedByVehicleArmor(damage, 5, 2, vehicle);
        assert.strictEqual(result, true);
      });
      it("doesn't block damage for non-vehicle actors", async () => {
        const vehicleActor = await getVehicleWithArmor(50);
        const characterActor = await getCharacterWithArmor(50);
        const damage = getDamage(4);
        const characterResult = CombatRules.isBlockedByVehicleArmor(damage, 5, 2, characterActor);
        const vehicleResult = CombatRules.isBlockedByVehicleArmor(damage, 5, 2, vehicleActor);
        assert.isFalse(characterResult);
        assert.isTrue(vehicleResult);
      });
      it("takes net hits into account", async () => {
        const vehicle = await getVehicleWithArmor(6);
        const damage = getDamage(4);
        const blockedResult = CombatRules.isBlockedByVehicleArmor(damage, 5, 4, vehicle);
        const notBlockedResult = CombatRules.isBlockedByVehicleArmor(damage, 5, 3, vehicle);
        assert.isTrue(blockedResult);
        assert.isFalse(notBlockedResult);
      });
      it("takes AP into account", async () => {
        const vehicle = await getVehicleWithArmor(6);
        const highApDamage = getDamage(4, { ap: -5 });
        const lowApDamage = getDamage(4, { ap: 5 });
        const blockedResult = CombatRules.isBlockedByVehicleArmor(lowApDamage, 5, 3, vehicle);
        const notBlockedResult = CombatRules.isBlockedByVehicleArmor(highApDamage, 5, 3, vehicle);
        assert.isTrue(blockedResult);
        assert.isFalse(notBlockedResult);
      });
    });
    describe("isBlockedByHardenedArmor", () => {
      it("blocks damage due to hardened armor", async () => {
        const vehicle = await getCharacterWithArmor(50, { hardened: true });
        const damage = getDamage(4);
        const result = CombatRules.isBlockedByHardenedArmor(damage, 5, 2, vehicle);
        assert.strictEqual(result, true);
      });
      it("doesn't block damage for non-vehicle actors", async () => {
        const hardenedArmorActor = await getCharacterWithArmor(50, { hardened: true });
        const normalArmorActor = await getCharacterWithArmor(50);
        const damage = getDamage(4);
        const characterResult = CombatRules.isBlockedByHardenedArmor(damage, 5, 2, normalArmorActor);
        const vehicleResult = CombatRules.isBlockedByHardenedArmor(damage, 5, 2, hardenedArmorActor);
        assert.strictEqual(characterResult, false);
        assert.strictEqual(vehicleResult, true);
      });
      it("takes net hits into account", async () => {
        const actor = await getCharacterWithArmor(6, { hardened: true });
        const damage = getDamage(4);
        const blockedResult = CombatRules.isBlockedByHardenedArmor(damage, 5, 4, actor);
        const notBlockedResult = CombatRules.isBlockedByHardenedArmor(damage, 5, 3, actor);
        assert.strictEqual(blockedResult, true);
        assert.strictEqual(notBlockedResult, false);
      });
      it("takes AP into account", async () => {
        const actor = await getCharacterWithArmor(6, { hardened: true });
        const highApDamage = getDamage(4, { ap: -5 });
        const lowApDamage = getDamage(4, { ap: 5 });
        const blockedResult = CombatRules.isBlockedByHardenedArmor(lowApDamage, 5, 3, actor);
        const notBlockedResult = CombatRules.isBlockedByHardenedArmor(highApDamage, 5, 3, actor);
        assert.isTrue(blockedResult);
        assert.isFalse(notBlockedResult);
      });
    });
    describe("doesNoPhysicalDamageToVehicle", () => {
      it("blocks non-physical damage to vehicle", async () => {
        const vehicle = await testActor.create({ type: "vehicle" });
        const damage = getDamage(4, { type: "stun" });
        const result = CombatRules.doesNoPhysicalDamageToVehicle(damage, vehicle);
        assert.isTrue(result);
      });
      it("does not block physical damage to vehicle", async () => {
        const vehicle = await testActor.create({ type: "vehicle" });
        const damage = getDamage(4, { type: "physical" });
        const result = CombatRules.doesNoPhysicalDamageToVehicle(damage, vehicle);
        assert.isFalse(result);
      });
      it("does not block electric stun damage to vehicle", async () => {
        const vehicle = await testActor.create({ type: "vehicle" });
        const damage = getDamage(4, { type: "stun", element: "electricity" });
        const result = CombatRules.doesNoPhysicalDamageToVehicle(damage, vehicle);
        assert.isFalse(result);
      });
    });
  });
}, "shadowrunAttackTesting");

// src/unittests/sr5.Modifiers.spec.ts
var shadowrunRulesModifiers = /* @__PURE__ */ __name((context) => {
  const { describe, it, assert, before, after } = context;
  let testActor;
  let testItem;
  let testScene;
  before(async () => {
    testActor = new SR6TestingDocuments(SR6Actor);
    testItem = new SR6TestingDocuments(SR6Item);
    testScene = new SR6TestingDocuments(Scene);
  });
  after(async () => {
    await testActor.teardown();
    await testItem.teardown();
    await testScene.teardown();
  });
  const defaultSourceModifiers = {
    environmental: {
      active: {}
    },
    noise: {
      active: {}
    },
    background_count: {
      active: {}
    }
  };
  describe("SR5 Modifiers", () => {
    describe("class SituationalModifiers", () => {
      it("create valid applied modifiers without any input", () => {
        const sitMod = new SituationModifier();
        assert.deepEqual(sitMod.source, { active: {} });
        assert.equal(sitMod.hasActive, false);
        assert.equal(sitMod.total, 0);
      });
      it("determine if documents have been added to it", () => {
        assert.equal(new SituationModifier().hasDocuments, false);
        assert.equal(new SituationModifier(void 0, new DocumentSituationModifiers()).hasDocuments, true);
      });
      it("determine it has active modifiers", () => {
        assert.equal(new SituationModifier({ active: { a: 0 } }).hasActive, true);
      });
      it("apply source active values to a sum of all active modifiers", () => {
        const sitMod = new SituationModifier({
          active: {
            a: -1,
            b: -3
          }
        });
        assert.equal(sitMod.total, -4);
      });
      it("apply source fixed value instead of the sum of all active modifiers", () => {
        const sitMod = new SituationModifier({
          active: {
            a: -1,
            b: -3
          },
          fixed: 0
        });
        assert.equal(sitMod.total, 0);
        assert.equal(sitMod._calcActiveTotal(), -4);
      });
      it("correctly report the state of active modifier selections", () => {
        const sitMod = new SituationModifier({
          active: {
            a: -1
          }
        });
        assert.equal(sitMod.isActive("a"), true);
        assert.equal(sitMod.isActive("b"), false);
        assert.equal(sitMod.isActive(""), false);
      });
      it("correctly active a modifier selection", () => {
        const sitMod = new SituationModifier();
        assert.equal(sitMod.source.active["a"], void 0);
        sitMod.setActive("a", 1);
        assert.equal(sitMod.source.active["a"], 1);
      });
      it("correctly deactivate a modifier selection", () => {
        const sitMod = new SituationModifier({ active: { a: 1, b: 2 } });
        assert.equal(sitMod.isActive("a"), true);
        sitMod.setInactive("a");
        assert.equal(sitMod.isActive("a"), false);
        assert.equal(sitMod.isActive("b"), true);
      });
      it("correctly determine if a fixed modifier is set", () => {
        const sitMod = new SituationModifier();
        sitMod.apply({ source: { fixed: 0, active: {} } });
        assert.isTrue(sitMod.hasFixed);
        sitMod.apply({ source: { active: {} } });
        assert.isFalse(sitMod.hasFixed);
      });
      it("correctly determine if an active modifier selection matches", () => {
        const sitMod = new SituationModifier({ active: { a: 1, b: 2 } });
        sitMod.apply();
        assert.equal(sitMod.isMatching("a", 1), true);
        assert.equal(sitMod.isMatching("b", 1), false);
        assert.equal(sitMod.isMatching("c", 0), false);
      });
      it("correctly clear an active set of selections", () => {
        const sitMod = new SituationModifier({ active: { a: 1, b: 2 }, fixed: 0 });
        assert.equal(sitMod.hasActive, true);
        sitMod.clear();
        assert.equal(sitMod.hasActive, false);
      });
      it("use a fixed user selection instead of summing up", () => {
        const sitMod = new SituationModifier({ active: { value: 3, a: 1, b: 3 } });
        sitMod.apply();
        assert.equal(sitMod.total, 3);
      });
      it("use a fixed value before a fixed user selection", () => {
        const sitMod = new SituationModifier({ active: { value: 3, a: 1, b: 3 }, fixed: -3 });
        assert.equal(sitMod.total, -3);
      });
      it("should only apply applicable selections", () => {
        const sitMod = new SituationModifier({ active: { a: 1, b: 3, c: 4 } });
        sitMod.apply({ applicable: ["a", "c"] });
        assert.equal(sitMod.total, 5);
      });
    });
    describe("class EnvironmentalModifier", () => {
      it("apply higher level modifier for two same level selections", () => {
        const envMod = new EnvironmentalModifier();
        envMod.apply({ source: { active: { light: 0, wind: 0 } } });
        assert.equal(envMod.total, 0);
        envMod.apply({ source: { active: { light: -1, wind: -1 } } });
        assert.equal(envMod.total, -3);
        envMod.apply({ source: { active: { light: -3, wind: -3 } } });
        assert.equal(envMod.total, -6);
        envMod.apply({ source: { active: { light: -6, wind: -6 } } });
        assert.equal(envMod.total, -10);
      });
      it("apply fixed modifier values instead of level selections", () => {
        const envMod = new EnvironmentalModifier();
        envMod.apply({ source: { active: { light: 0, wind: 0, value: -3 } } });
        assert.equal(envMod.total, -3);
        envMod.apply({ source: { active: { light: -1, wind: -1, value: -1 } } });
        assert.equal(envMod.total, -1);
      });
    });
    describe("class DocumentSituationModifiers", () => {
      it("create default modifier values", () => {
        const modifiers = DocumentSituationModifiers._defaultModifiers;
        assert.deepEqual(modifiers, defaultSourceModifiers);
      });
      it("use default modifiers for faulty constructor params", () => {
        assert.deepEqual(new DocumentSituationModifiers({}).source, defaultSourceModifiers);
        assert.deepEqual(new DocumentSituationModifiers(void 0).source, defaultSourceModifiers);
        assert.deepEqual(new DocumentSituationModifiers(null).source, defaultSourceModifiers);
        assert.deepEqual(new DocumentSituationModifiers(0).source, defaultSourceModifiers);
        assert.deepEqual(new DocumentSituationModifiers(1).source, defaultSourceModifiers);
        assert.deepEqual(new DocumentSituationModifiers().source, defaultSourceModifiers);
      });
      it("Store data depending on document type", async () => {
        const actor = await testActor.create({ type: "character" });
        let modifiers = actor.getSituationModifiers();
        assert.deepEqual(modifiers.source, DocumentSituationModifiers._defaultModifiers);
        modifiers.source.noise.fixed = 1;
        await modifiers.updateDocument();
        assert.equal(modifiers.source.noise.fixed, 1);
        const scene = await testScene.create();
        modifiers = DocumentSituationModifiers.fromDocument(scene);
        assert.deepEqual(modifiers.source, DocumentSituationModifiers._defaultModifiers);
        modifiers.source.noise.fixed = 1;
        await modifiers.updateDocument();
        assert.equal(modifiers.source.noise.fixed, 1);
      });
      it("clear documents data to defaults", async () => {
        const actor = await testActor.create({
          type: "character"
        });
        const modifiers = actor.getSituationModifiers();
        modifiers.source.noise.fixed = 1;
        await modifiers.updateDocument();
        assert.notDeepEqual(modifiers.source, DocumentSituationModifiers._defaultModifiers);
        await modifiers.clearAll();
        assert.deepEqual(modifiers.source, DocumentSituationModifiers._defaultModifiers);
      });
    });
  });
}, "shadowrunRulesModifiers");

// src/unittests/sr5.SR5Item.spec.ts
var shadowrunSR5Item = /* @__PURE__ */ __name((context) => {
  const { describe, it, assert, before, after } = context;
  let testItem;
  before(async () => {
    testItem = new SR6TestingDocuments(SR6Item);
  });
  after(async () => {
    await testItem.teardown();
  });
  describe("SR5Items", () => {
    it("create a naked item of any type", async () => {
      const item = await testItem.create({ type: "action" });
      assert.notStrictEqual(item.id, "");
      assert.notStrictEqual(item.id, void 0);
      assert.notStrictEqual(item.id, null);
      const itemFromCollection = game.items?.get(item.id);
      assert.notStrictEqual(itemFromCollection, null);
      assert.strictEqual(item.id, itemFromCollection?.id);
    });
    it("update an item of any type", async () => {
      const item = await testItem.create({ type: "action" });
      assert.notProperty(item.system, "test");
      await item.update({ "system.test": true });
      assert.property(item.system, "test");
      assert.propertyVal(item.system, "test", true);
    });
    it("embedd a ammo into a weapon and not the global item collection", async () => {
      const weapon = await testItem.create({ type: "weapon" });
      const ammo = await testItem.create({ type: "ammo" });
      await weapon.createNestedItem(ammo.toObject());
      const embeddedItemDatas = weapon.getNestedItems();
      assert.isNotEmpty(embeddedItemDatas);
      assert.lengthOf(embeddedItemDatas, 1);
      const embeddedAmmoData = embeddedItemDatas[0];
      assert.strictEqual(embeddedAmmoData.type, ammo.type);
      const embeddedAmmoInCollection = game.items?.get(embeddedAmmoData._id);
      assert.strictEqual(embeddedAmmoInCollection, void 0);
    });
    it("update a nested ammunition item", async () => {
      const weapon = await testItem.create({ type: "weapon" });
      const ammo = await testItem.create({ type: "ammo" });
      await weapon.createNestedItem(ammo.toObject());
      const embeddedItemDatas = weapon.getNestedItems();
      assert.lengthOf(embeddedItemDatas, 1);
      const embeddedAmmoData = embeddedItemDatas[0];
      const embeddedAmmo = weapon.getOwnedItem(embeddedAmmoData._id);
      assert.notStrictEqual(embeddedAmmo, void 0);
      assert.instanceOf(embeddedAmmo, SR6Item);
      if (!embeddedAmmo) return;
      assert.notProperty(embeddedAmmo.system, "test");
      await embeddedAmmo.update({ "system.test": true });
      assert.property(embeddedAmmo.system, "test");
      assert.propertyVal(embeddedAmmo.system, "test", true);
    });
    describe("Testing related data injection", () => {
      it("Correctly add default test to spells", async () => {
      });
      it("Correctly add defense tests to spells", async () => {
        const item = await testItem.create({ type: "spell" });
        await item.update({ "system.category": "combat" });
        assert.equal(item.system.action.test, "SpellCastingTest");
        assert.equal(item.system.action.followed.test, "DrainTest");
        assert.equal(item.system.action.opposed.test, "CombatSpellDefenseTest");
        assert.equal(item.system.action.opposed.resist.test, "PhysicalResistTest");
        await item.update({ "system.category": "detection" });
        assert.equal(item.system.action.test, "SpellCastingTest");
        assert.equal(item.system.action.followed.test, "DrainTest");
        assert.equal(item.system.action.opposed.test, "OpposedTest");
        assert.equal(item.system.action.opposed.resist.test, "");
      });
      it("Correctly add default tests to melee weapons", async () => {
        const item = await testItem.create({ type: "weapon" });
        await item.update({ "system.category": "melee" });
        assert.equal(item.system.action.test, "MeleeAttackTest");
        assert.equal(item.system.action.followed.test, "");
        assert.equal(item.system.action.opposed.test, "PhysicalDefenseTest");
        assert.equal(item.system.action.opposed.resist.test, "PhysicalResistTest");
      });
      it("Correctly add default tests to range weapons", async () => {
        const item = await testItem.create({ type: "weapon" });
        await item.update({ "system.category": "range" });
        assert.equal(item.system.action.test, "RangedAttackTest");
        assert.equal(item.system.action.followed.test, "");
        assert.equal(item.system.action.opposed.test, "PhysicalDefenseTest");
        assert.equal(item.system.action.opposed.resist.test, "PhysicalResistTest");
      });
      it("Correctly add defense tests to complex forms", async () => {
        const item = await testItem.create({ type: "complex_form" });
        assert.equal(item.system.action.test, "ComplexFormTest");
        assert.equal(item.system.action.followed.test, "FadeTest");
        assert.equal(item.system.action.opposed.test, "OpposedTest");
        assert.equal(item.system.action.opposed.resist.test, "");
      });
      it("Correctly alter default test for weapon category changes", async () => {
        const item = await testItem.create({ type: "weapon" });
        await item.update({ "system.category": "range" });
        assert.equal(item.system.action.test, "RangedAttackTest");
        assert.equal(item.system.action.followed.test, "");
        assert.equal(item.system.action.opposed.test, "PhysicalDefenseTest");
        assert.equal(item.system.action.opposed.resist.test, "PhysicalResistTest");
        await item.update({ "system.category": "" });
        assert.equal(item.system.action.test, "");
        assert.equal(item.system.action.followed.test, "");
        assert.equal(item.system.action.opposed.test, "PhysicalDefenseTest");
        assert.equal(item.system.action.opposed.resist.test, "PhysicalResistTest");
      });
      it("Correctly stop injection when mergeOptions recursive or diff are set to false", async () => {
        const item = await testItem.create({ type: "complex_form" });
        await item.update({ "name": "Test" }, { recursive: false });
        assert.equal(item.system.action.skill, "");
        await item.update({ "name": "Test2" }, { diff: false });
        assert.equal(item.system.action.skill, "");
        await item.update({ "name": "Test" }, { recursive: true });
        assert.equal(item.system.action.skill, "");
      });
    });
  });
}, "shadowrunSR5Item");

// src/unittests/sr5.Matrix.spec.ts
var shadowrunMatrix = /* @__PURE__ */ __name((context) => {
  const { describe, it, assert, before, after } = context;
  describe("Matrix Rules", () => {
    it("calculate IC device rating", () => {
      let hostRating = 5;
      assert.strictEqual(MatrixRules.getICDeviceRating(hostRating), hostRating);
      hostRating = -1;
      assert.strictEqual(MatrixRules.getICDeviceRating(hostRating), 0);
    });
    it("calculate IC condition monitor", () => {
      assert.strictEqual(MatrixRules.getConditionMonitor(0), 8);
      assert.strictEqual(MatrixRules.getConditionMonitor(1), 9);
      assert.strictEqual(MatrixRules.getConditionMonitor(4), 10);
      assert.strictEqual(MatrixRules.getConditionMonitor(-1), 8);
    });
    it("calculate IC matrix initiative base", () => {
      assert.strictEqual(MatrixRules.getICInitiativeBase(0), 0);
      assert.strictEqual(MatrixRules.getICInitiativeBase(-3), 0);
      assert.strictEqual(MatrixRules.getICInitiativeBase(1), 2);
      assert.strictEqual(MatrixRules.getICInitiativeBase(2), 4);
      assert.strictEqual(MatrixRules.getICInitiativeBase(3), 6);
      assert.strictEqual(MatrixRules.getICInitiativeBase(12), 24);
    });
    it("calculate IC matrix initiative dice", () => {
      assert.strictEqual(MatrixRules.getICInitiativeDice(), 4);
    });
    it("calculate meat attribute base with the host rating", () => {
      assert.strictEqual(MatrixRules.getICMeatAttributeBase(0), 0);
      assert.strictEqual(MatrixRules.getICMeatAttributeBase(-3), 0);
      assert.strictEqual(MatrixRules.getICMeatAttributeBase(3), 3);
      assert.strictEqual(MatrixRules.getICMeatAttributeBase(27), 27);
    });
    it("disallow invalid marks counters", () => {
      assert.isTrue(MatrixRules.isValidMarksCount(0));
      assert.isTrue(MatrixRules.isValidMarksCount(1));
      assert.isTrue(MatrixRules.isValidMarksCount(2));
      assert.isTrue(MatrixRules.isValidMarksCount(3));
      assert.isFalse(MatrixRules.isValidMarksCount(-1));
      assert.isFalse(MatrixRules.isValidMarksCount(4));
      assert.isFalse(MatrixRules.isValidMarksCount(1.5));
    });
    it("return valid marks counts", () => {
      assert.strictEqual(MatrixRules.getValidMarksCount(-1), MatrixRules.minMarksCount());
      assert.strictEqual(MatrixRules.getValidMarksCount(0), 0);
      assert.strictEqual(MatrixRules.getValidMarksCount(1), 1);
      assert.strictEqual(MatrixRules.getValidMarksCount(2), 2);
      assert.strictEqual(MatrixRules.getValidMarksCount(3), 3);
      assert.strictEqual(MatrixRules.getValidMarksCount(4), MatrixRules.maxMarksCount());
    });
    it("return expected host matrix attribute ratings", () => {
      assert.deepEqual(MatrixRules.hostMatrixAttributeRatings(1), [1, 2, 3, 4]);
      assert.deepEqual(MatrixRules.hostMatrixAttributeRatings(2), [2, 3, 4, 5]);
      assert.deepEqual(MatrixRules.hostMatrixAttributeRatings(10), [10, 11, 12, 13]);
    });
  });
}, "shadowrunMatrix");

// src/unittests/sr5.SR5Actor.spec.ts
var shadowrunSR5Actor = /* @__PURE__ */ __name((context) => {
  const { describe, it, assert, before, after } = context;
  let testActor;
  let testItem;
  before(async () => {
    testActor = new SR6TestingDocuments(SR6Actor);
    testItem = new SR6TestingDocuments(SR6Item);
  });
  after(async () => {
    await testActor.teardown();
    await testItem.teardown();
  });
  describe("SR5Actor", () => {
    it("create a naked actor of any type", async () => {
      const actor = await testActor.create({ type: "character" });
      assert.notStrictEqual(actor.id, "");
      assert.notStrictEqual(actor.id, void 0);
      assert.notStrictEqual(actor.id, null);
      const fromCollection = game.actors?.get(actor.id);
      assert.isOk(fromCollection);
      assert.strictEqual(actor.id, fromCollection?.id);
    });
    it("update an actor of any type", async () => {
      const actor = await testActor.create({ type: "character" });
      assert.notProperty(actor.system, "test");
      await actor.update({ "system.test": true });
      assert.property(actor.system, "test");
      assert.propertyVal(actor.system, "test", true);
    });
    it("embedd a weapon into an actor and not the global item colection", async () => {
      const actor = await testActor.create({ type: "character" });
      const weapon = await testItem.create({ type: "weapon" });
      await actor.createEmbeddedDocuments("Item", [weapon.toObject()]);
      const ownedItems = Array.from(actor.items);
      assert.isNotEmpty(ownedItems);
      assert.lengthOf(ownedItems, 1);
      const ownedItem = ownedItems[0];
      assert.strictEqual(ownedItem.type, weapon.type);
      const ownedInCollection = game.items?.get(ownedItem.id);
      assert.isNotOk(ownedInCollection);
    });
  });
}, "shadowrunSR5Actor");

// src/unittests/sr5.CharacterDataPrep.spec.ts
var shadowrunSR5CharacterDataPrep = /* @__PURE__ */ __name((context) => {
  const { describe, it, assert, before, after } = context;
  let testActor;
  let testItem;
  before(async () => {
    testActor = new SR6TestingDocuments(SR6Actor);
    testItem = new SR6TestingDocuments(SR6Item);
  });
  after(async () => {
    await testActor.teardown();
    await testItem.teardown();
  });
  describe("CharacterDataPrep", () => {
    it("default attribute values", async () => {
      const character = await testActor.create({ type: "character", "system.metatype": "human" });
      console.log("Physical attributes");
      assert.strictEqual(character.system.attributes.body.value, SR.attributes.ranges["body"].min);
      assert.strictEqual(character.system.attributes.agility.value, SR.attributes.ranges["agility"].min);
      assert.strictEqual(character.system.attributes.reaction.value, SR.attributes.ranges["reaction"].min);
      assert.strictEqual(character.system.attributes.strength.value, SR.attributes.ranges["strength"].min);
      assert.strictEqual(character.system.attributes.willpower.value, SR.attributes.ranges["willpower"].min);
      assert.strictEqual(character.system.attributes.logic.value, SR.attributes.ranges["logic"].min);
      assert.strictEqual(character.system.attributes.intuition.value, SR.attributes.ranges["intuition"].min);
      assert.strictEqual(character.system.attributes.charisma.value, SR.attributes.ranges["charisma"].min);
      console.log("Common special attributes");
      assert.strictEqual(character.system.attributes.edge.value, SR.attributes.ranges["edge"].min);
      assert.strictEqual(character.system.attributes.essence.value, SR.attributes.defaults["essence"]);
      console.log("Special special attributes");
      assert.strictEqual(character.system.attributes.resonance.value, SR.attributes.ranges["resonance"].min);
      assert.strictEqual(character.system.attributes.magic.value, SR.attributes.ranges["magic"].min);
    });
    it("visibility checks", async () => {
      const actor = await testActor.create({ type: "character", "system.metatype": "human" });
      assert.strictEqual(actor.system.visibilityChecks.astral.hasAura, true);
      assert.strictEqual(actor.system.visibilityChecks.astral.astralActive, false);
      assert.strictEqual(actor.system.visibilityChecks.astral.affectedBySpell, false);
      assert.strictEqual(actor.system.visibilityChecks.meat.hasHeat, true);
      assert.strictEqual(actor.system.visibilityChecks.matrix.hasIcon, true);
      assert.strictEqual(actor.system.visibilityChecks.matrix.runningSilent, false);
    });
    it("monitor calculation", async () => {
      const actor = await testActor.create({ type: "character" });
      let character = actor.asCharacter();
      assert.strictEqual(character.system.track.stun.max, 9);
      assert.strictEqual(character.system.track.physical.max, 9);
      assert.strictEqual(character.system.track.physical.overflow.max, SR.attributes.ranges.body.min);
      await actor.update({
        "system.attributes.body.base": 6,
        "system.attributes.willpower.base": 6
      });
      character = actor.asCharacter();
      assert.strictEqual(character.system.track.stun.max, 11);
      assert.strictEqual(character.system.track.physical.max, 11);
      assert.strictEqual(character.system.track.physical.overflow.max, 6);
    });
    it("Matrix condition monitor track calculation with modifiers", async () => {
      const actor = await testActor.create({ type: "character", "system.modifiers.matrix_track": 1 });
      await actor.createEmbeddedDocuments("Item", [{
        "name": "Commlink",
        "type": "device",
        "system.category": "commlink",
        "system.technology.equipped": true
      }]);
      const character = actor.asCharacter();
      assert.equal(character.system.matrix.condition_monitor.max, 10);
    });
    it("initiative calculation", async () => {
      const actor = await testActor.create({ type: "character" });
      let character = actor.asCharacter();
      assert.strictEqual(character.system.initiative.meatspace.base.base, 2);
      assert.strictEqual(character.system.initiative.meatspace.dice.base, 1);
      assert.strictEqual(character.system.initiative.matrix.base.base, 1);
      assert.strictEqual(character.system.initiative.matrix.dice.base, 3);
      assert.strictEqual(character.system.initiative.astral.base.base, 2);
      assert.strictEqual(character.system.initiative.astral.dice.base, 2);
      await actor.update({
        // Meatspace ini
        "system.attributes.reaction.base": 6,
        "system.attributes.intuition.base": 6,
        "system.modifiers.meat_initiative": 2,
        "system.modifiers.meat_initiative_dice": 1,
        // Astral ini
        "system.modifiers.astral_initiative": 2,
        "system.modifiers.astral_initiative_dice": 1,
        // Matrix ini
        "system.modifiers.matrix_initiative": 2,
        "system.modifiers.matrix_initiative_dice": 1
      });
      await actor.createEmbeddedDocuments("Item", [{
        "name": "Commlink",
        "type": "device",
        "system.category": "commlink",
        "system.technology.equipped": true,
        "system.atts.att3.value": 6
      }]);
      assert.strictEqual(character.system.initiative.meatspace.base.value, 14);
      assert.strictEqual(character.system.initiative.meatspace.dice.value, 2);
      assert.strictEqual(character.system.initiative.matrix.base.value, 14);
      assert.strictEqual(character.system.initiative.matrix.dice.value, 4);
      assert.strictEqual(character.system.initiative.astral.base.value, 14);
      assert.strictEqual(character.system.initiative.astral.dice.value, 3);
      await actor.update({
        "system.matrix.hot_sim": true
      });
      assert.strictEqual(character.system.initiative.matrix.dice.value, 5);
      await actor.update({
        // Meatspace ini
        "system.modifiers.meat_initiative_dice": 6,
        // Astral ini
        "system.modifiers.astral_initiative_dice": 6,
        // Matrix ini
        "system.modifiers.matrix_initiative_dice": 6
      });
      assert.strictEqual(character.system.initiative.meatspace.dice.value, 5);
      assert.strictEqual(character.system.initiative.matrix.dice.value, 5);
      assert.strictEqual(character.system.initiative.astral.dice.value, 5);
    });
    it("limit calculation", async () => {
      const actor = await testActor.create({ type: "character" });
      let character = actor.asCharacter();
      assert.strictEqual(character.system.limits.physical.value, 2);
      assert.strictEqual(character.system.limits.mental.value, 2);
      assert.strictEqual(character.system.limits.social.value, 3);
      await actor.update({
        "system.attributes.strength.base": 6,
        "system.attributes.body.base": 6,
        "system.attributes.reaction.base": 6,
        "system.attributes.logic.base": 6,
        "system.attributes.intuition.base": 6,
        "system.attributes.willpower.base": 6,
        "system.attributes.charisma.base": 6,
        "system.attributes.essence.base": 6
      });
      character = actor.asCharacter();
      assert.strictEqual(character.system.limits.physical.value, 8);
      assert.strictEqual(character.system.limits.mental.value, 8);
      assert.strictEqual(character.system.limits.social.value, 8);
    });
    it("movement calculation", async () => {
      const actor = await testActor.create({ type: "character" });
      let character = actor.asCharacter();
      assert.strictEqual(character.system.movement.walk.value, 2);
      assert.strictEqual(character.system.movement.run.value, 4);
      await actor.update({
        "system.attributes.agility.base": 6
      });
      character = actor.asCharacter();
      assert.strictEqual(character.system.movement.walk.value, 12);
      assert.strictEqual(character.system.movement.run.value, 24);
    });
    it("skill calculation", async () => {
      const actor = await testActor.create({
        type: "character",
        "system.skills.active.arcana.base": 6,
        "system.skills.active.arcana.bonus": [{ key: "Test", value: 1 }],
        "system.skills.active.arcana.specs": ["Test"]
      });
      let character = actor.asCharacter();
      assert.strictEqual(character.system.skills.active.arcana.value, 7);
    });
    it("damage application to wounds", async () => {
      const actor = await testActor.create({ type: "character" });
      let character = actor.asCharacter();
      assert.strictEqual(character.system.track.stun.value, 0);
      assert.strictEqual(character.system.track.stun.wounds, 0);
      assert.strictEqual(character.system.track.physical.value, 0);
      assert.strictEqual(character.system.track.physical.wounds, 0);
      assert.strictEqual(character.system.wounds.value, 0);
      await actor.update({
        "system.track.stun.value": 3,
        "system.track.physical.value": 3
      });
      character = actor.asCharacter();
      assert.strictEqual(character.system.track.stun.value, 3);
      assert.strictEqual(character.system.track.stun.wounds, 1);
      assert.strictEqual(character.system.track.physical.value, 3);
      assert.strictEqual(character.system.track.physical.wounds, 1);
      assert.strictEqual(character.system.wounds.value, 2);
    });
    it("damage application with low pain/wound tolerance", async () => {
      const actor = await testActor.create({
        type: "character",
        "system.track.stun.value": 6,
        "system.track.physical.value": 6,
        "system.modifiers.wound_tolerance": -1
      });
      let character = actor.asCharacter();
      assert.strictEqual(character.system.track.stun.value, 6);
      assert.strictEqual(character.system.track.stun.wounds, 3);
      assert.strictEqual(character.system.track.physical.value, 6);
      assert.strictEqual(character.system.track.physical.wounds, 3);
    });
    it("damage application with high pain tolerance / damage compensators", async () => {
      const actor = await testActor.create({
        type: "character",
        "system.track.stun.value": 9,
        "system.track.physical.value": 9,
        "system.modifiers.pain_tolerance_stun": 3,
        "system.modifiers.pain_tolerance_physical": 6
      });
      let character = actor.asCharacter();
      assert.strictEqual(character.system.track.stun.value, 9);
      assert.strictEqual(character.system.track.stun.wounds, 2);
      assert.strictEqual(character.system.track.physical.value, 9);
      assert.strictEqual(character.system.track.physical.wounds, 1);
    });
    it("damage application with high AND low pain to lerance / damage compensators", async () => {
      const actor = await testActor.create({
        type: "character",
        "system.track.stun.value": 9,
        "system.track.physical.value": 9,
        "system.modifiers.pain_tolerance_stun": 3,
        "system.modifiers.pain_tolerance_physical": 6,
        "system.modifiers.wound_tolerance": -1
      });
      let character = actor.asCharacter();
      assert.strictEqual(character.system.track.stun.value, 9);
      assert.strictEqual(character.system.track.stun.wounds, 3);
      assert.strictEqual(character.system.track.physical.value, 9);
      assert.strictEqual(character.system.track.physical.wounds, 1);
    });
    it("Character recoil compensation", () => {
      let actor = new SR6Actor({ name: "Testing", type: "character", system: { attributes: { strength: { base: 5 } } } });
      let character = actor.asCharacter();
      if (!character) return assert.fail();
      assert.strictEqual(character.system.values.recoil_compensation.value, 3);
      actor = new SR6Actor({ name: "Testing", type: "character", system: { attributes: { strength: { base: 1 } } } });
      character = actor.asCharacter();
      if (!character) return assert.fail();
      assert.strictEqual(character.system.values.recoil_compensation.value, 2);
    });
    it("A NPC Grunt should only have physical track", async () => {
      const actor = await testActor.create({ type: "character", "system.is_npc": true, "system.npc.is_grunt": true, "system.attributes.willpower.base": 6 });
      const character = actor.asCharacter();
      assert.strictEqual(character.system.track.stun.value, 0);
      assert.strictEqual(character.system.track.stun.disabled, true);
      assert.strictEqual(character.system.track.physical.disabled, false);
    });
  });
}, "shadowrunSR5CharacterDataPrep");

// src/unittests/sr5.CritterDataPrep.spec.ts
var shadowrunSR5CritterDataPrep = /* @__PURE__ */ __name((context) => {
  const { describe, it, assert, before, after } = context;
  let testActor;
  let testItem;
  before(async () => {
    testActor = new SR6TestingDocuments(SR6Actor);
    testItem = new SR6TestingDocuments(SR6Item);
  });
  after(async () => {
    await testActor.teardown();
    await testItem.teardown();
  });
  describe("CritterDataPrep", () => {
    it("Critter character recoil compensation", () => {
      let actor = new SR6Actor({ name: "Testing", type: "critter", system: { attributes: { strength: { base: 5 } } } });
      let critter = actor.asCritter();
      if (!critter) return assert.fail();
      assert.strictEqual(critter.system.values.recoil_compensation.value, 3);
      actor = new SR6Actor({ name: "Testing", type: "critter", system: { attributes: { strength: { base: 1 } } } });
      critter = actor.asCritter();
      if (!critter) return assert.fail();
      assert.strictEqual(critter.system.values.recoil_compensation.value, 2);
    });
    it("visibility checks", async () => {
      let actor = new SR6Actor({ name: "Testing", type: "critter", system: { attributes: { strength: { base: 5 } } } });
      assert.strictEqual(actor.system.visibilityChecks.astral.hasAura, true);
      assert.strictEqual(actor.system.visibilityChecks.astral.astralActive, false);
      assert.strictEqual(actor.system.visibilityChecks.astral.affectedBySpell, false);
      assert.strictEqual(actor.system.visibilityChecks.meat.hasHeat, true);
      assert.strictEqual(actor.system.visibilityChecks.matrix.hasIcon, false);
      assert.strictEqual(actor.system.visibilityChecks.matrix.runningSilent, false);
    });
    it("A NPC Grunt should only have physical track", async () => {
      const actor = await testActor.create({ type: "critter", "system.is_npc": true, "system.npc.is_grunt": true, "system.attributes.willpower.base": 6 });
      const character = actor.asCritter();
      assert.strictEqual(character.system.track.stun.value, 0);
      assert.strictEqual(character.system.track.stun.disabled, true);
      assert.strictEqual(character.system.track.physical.disabled, false);
    });
  });
}, "shadowrunSR5CritterDataPrep");

// src/unittests/sr5.SpiritDataPrep.spec.ts
var shadowrunSR5SpiritDataPrep = /* @__PURE__ */ __name((context) => {
  const { describe, it, assert, before, after } = context;
  let testActor;
  let testItem;
  before(async () => {
    testActor = new SR6TestingDocuments(SR6Actor);
    testItem = new SR6TestingDocuments(SR6Item);
  });
  after(async () => {
    await testActor.teardown();
    await testItem.teardown();
  });
  describe("SpiritDataPrep", () => {
    it("Spirits are always magical", async () => {
      const character = await testActor.create({ type: "spirit" });
      assert.strictEqual(character.system.special, "magic");
    });
    it("visibility checks", async () => {
      const actor = await testActor.create({ type: "spirit" });
      assert.strictEqual(actor.system.visibilityChecks.astral.astralActive, true);
      assert.strictEqual(actor.system.visibilityChecks.astral.hasAura, true);
      assert.strictEqual(actor.system.visibilityChecks.astral.affectedBySpell, false);
      assert.strictEqual(actor.system.visibilityChecks.meat.hasHeat, false);
      assert.strictEqual(actor.system.visibilityChecks.matrix.hasIcon, false);
      assert.strictEqual(actor.system.visibilityChecks.matrix.runningSilent, false);
    });
    it("Spirit default/overrides by example type", async () => {
      const actor = await testActor.create({ type: "spirit", "system.spiritType": "air" });
      let spirit = actor.asSpirit();
      assert.strictEqual(spirit.system.attributes.body.base, -2);
      assert.strictEqual(spirit.system.attributes.agility.base, 3);
      assert.strictEqual(spirit.system.attributes.reaction.base, 4);
      assert.strictEqual(spirit.system.attributes.strength.base, -3);
      assert.strictEqual(spirit.system.attributes.intuition.base, 0);
      assert.strictEqual(spirit.system.initiative.meatspace.base.base, 4);
      assert.strictEqual(spirit.system.skills.active.assensing.base, 0);
      await actor.update({
        "system.force": 6
      });
      spirit = actor.asSpirit();
      assert.strictEqual(spirit.system.attributes.body.base, 4);
      assert.strictEqual(spirit.system.attributes.agility.base, 9);
      assert.strictEqual(spirit.system.attributes.reaction.base, 10);
      assert.strictEqual(spirit.system.attributes.strength.base, 3);
      assert.strictEqual(spirit.system.attributes.intuition.base, 6);
      assert.strictEqual(spirit.system.initiative.meatspace.base.base, 16);
      assert.strictEqual(spirit.system.skills.active.assensing.base, 6);
      assert.strictEqual(spirit.system.skills.active.arcana.base, 0);
    });
    it("Spirit recoil compensation", () => {
      let actor = new SR6Actor({ name: "Testing", type: "spirit", system: { attributes: { strength: { base: 5 } } } });
      let spirit = actor.asSpirit();
      if (!spirit) return assert.fail();
      assert.strictEqual(spirit.system.values.recoil_compensation.value, 3);
    });
    it("A NPC Grunt should only have physical track", async () => {
      const actor = await testActor.create({ type: "spirit", "system.is_npc": true, "system.npc.is_grunt": true });
      const character = actor.asSpirit();
      assert.strictEqual(character.system.track.stun.value, 0);
      assert.strictEqual(character.system.track.stun.disabled, true);
      assert.strictEqual(character.system.track.physical.disabled, false);
    });
  });
}, "shadowrunSR5SpiritDataPrep");

// src/unittests/sr5.SpriteDataPrep.spec.ts
var shadowrunSR5SpriteDataPrep = /* @__PURE__ */ __name((context) => {
  const { describe, it, assert, before, after } = context;
  let testActor;
  let testItem;
  before(async () => {
    testActor = new SR6TestingDocuments(SR6Actor);
    testItem = new SR6TestingDocuments(SR6Item);
  });
  after(async () => {
    await testActor.teardown();
    await testItem.teardown();
  });
  describe("SpriteDataPrep", () => {
    it("Sprites are always resonat", async () => {
      const sprite = await testActor.create({ type: "sprite" });
      assert.strictEqual(sprite.system.special, "resonance");
    });
    it("visibility checks", async () => {
      const actor = await testActor.create({ type: "sprite" });
      assert.strictEqual(actor.system.visibilityChecks.astral.hasAura, false);
      assert.strictEqual(actor.system.visibilityChecks.astral.astralActive, false);
      assert.strictEqual(actor.system.visibilityChecks.astral.affectedBySpell, false);
      assert.strictEqual(actor.system.visibilityChecks.meat.hasHeat, false);
      assert.strictEqual(actor.system.visibilityChecks.matrix.hasIcon, true);
      assert.strictEqual(actor.system.visibilityChecks.matrix.runningSilent, false);
    });
    it("Sprites default/override values by example type", async () => {
      const actor = await testActor.create({ type: "sprite", "system.spriteType": "courier" });
      let sprite = actor.asSprite();
      assert.strictEqual(sprite.system.matrix.sleaze.base, 3);
      assert.strictEqual(sprite.system.matrix.data_processing.base, 1);
      assert.strictEqual(sprite.system.matrix.firewall.base, 2);
      assert.strictEqual(sprite.system.matrix.sleaze.base, 3);
      assert.strictEqual(sprite.system.initiative.matrix.base.base, 1);
      assert.strictEqual(sprite.system.skills.active.hacking.base, 0);
      await actor.update({
        "system.level": 6
      });
      sprite = actor.asSprite();
      assert.strictEqual(sprite.system.level, 6);
      assert.strictEqual(sprite.system.matrix.sleaze.base, 9);
      assert.strictEqual(sprite.system.matrix.data_processing.base, 7);
      assert.strictEqual(sprite.system.matrix.firewall.base, 8);
      assert.strictEqual(sprite.system.matrix.sleaze.base, 9);
      assert.strictEqual(sprite.system.initiative.matrix.base.base, 13);
      assert.strictEqual(sprite.system.initiative.matrix.dice.base, 4);
      assert.strictEqual(sprite.system.skills.active.hacking.base, 6);
      assert.strictEqual(sprite.system.skills.active.computer.base, 6);
      assert.strictEqual(sprite.system.skills.active.electronic_warfare.base, 0);
    });
    it("Matrix condition monitor track calculation with modifiers", async () => {
      const actor = await testActor.create({ type: "sprite" });
      let sprite = actor.asSprite();
      assert.equal(sprite.system.matrix.condition_monitor.max, 8);
      await actor.update({ "system.modifiers.matrix_track": 1 });
      sprite = actor.asSprite();
      assert.equal(sprite.system.matrix.condition_monitor.max, 9);
    });
  });
}, "shadowrunSR5SpriteDataPrep");

// src/unittests/sr5.ICDataPrep.spec.ts
var shadowrunSR5ICDataPrep = /* @__PURE__ */ __name((context) => {
  const { describe, it, assert, before, after } = context;
  let testActor;
  let testItem;
  before(async () => {
    testActor = new SR6TestingDocuments(SR6Actor);
    testItem = new SR6TestingDocuments(SR6Item);
  });
  after(async () => {
    await testActor.teardown();
    await testItem.teardown();
  });
  describe("ICDataPrep", () => {
    it("Matrix condition monitor track calculation with modifiers", async () => {
      const actor = await testActor.create({ type: "ic" });
      let ic = actor.asIC();
      assert.equal(ic.system.matrix.condition_monitor.max, 8);
      await actor.update({ "system.modifiers.matrix_track": 1 });
      ic = actor.asIC();
      assert.equal(ic.system.matrix.condition_monitor.max, 9);
    });
    it("visibility checks", async () => {
      const actor = await testActor.create({ type: "ic" });
      assert.strictEqual(actor.system.visibilityChecks.astral.hasAura, false);
      assert.strictEqual(actor.system.visibilityChecks.astral.astralActive, false);
      assert.strictEqual(actor.system.visibilityChecks.astral.affectedBySpell, false);
      assert.strictEqual(actor.system.visibilityChecks.meat.hasHeat, false);
      assert.strictEqual(actor.system.visibilityChecks.matrix.hasIcon, true);
      assert.strictEqual(actor.system.visibilityChecks.matrix.runningSilent, false);
    });
    it("has meat attributes based on the host rating", async () => {
      const ic = await testActor.create({ type: "ic", "system.host.rating": 5 });
      assert.strictEqual(ic.system.attributes.agility.value, 5);
      assert.strictEqual(ic.system.attributes.reaction.value, 5);
      assert.strictEqual(ic.system.attributes.body.value, 5);
      assert.strictEqual(ic.system.attributes.strength.value, 5);
      assert.strictEqual(ic.system.attributes.logic.value, 5);
      assert.strictEqual(ic.system.attributes.willpower.value, 5);
      assert.strictEqual(ic.system.attributes.charisma.value, 5);
      assert.strictEqual(ic.system.attributes.intuition.value, 5);
    });
    it("has rating attribute based on the host rating", async () => {
      const ic = await testActor.create({ type: "ic", "system.host.rating": 5 });
      assert.strictEqual(ic.system.attributes.rating.value, 5);
    });
  });
}, "shadowrunSR5ICDataPrep");

// src/unittests/sr5.VehicleDataPrep.spec.ts
var shadowrunSR5VehicleDataPrep = /* @__PURE__ */ __name((context) => {
  const { describe, it, assert, before, after } = context;
  let testActor;
  let testItem;
  before(async () => {
    testActor = new SR6TestingDocuments(SR6Actor);
    testItem = new SR6TestingDocuments(SR6Item);
  });
  after(async () => {
    await testActor.teardown();
    await testItem.teardown();
  });
  describe("VehicleDataPrep", () => {
    it("Matrix condition monitor track calculation with modifiers", async () => {
      const actor = await testActor.create({ type: "vehicle" });
      let vehicle = actor.asVehicle();
      assert.equal(vehicle.system.matrix.condition_monitor.max, 8);
      await actor.update({ "system.modifiers.matrix_track": 1 });
      vehicle = actor.asVehicle();
      assert.equal(vehicle.system.matrix.condition_monitor.max, 9);
      console.log("visibility checks");
    });
    it("visibility checks", () => {
      let actor = new SR6Actor({ name: "Testing", type: "vehicle", system: { attributes: { body: { base: 5 } } } });
      assert.strictEqual(actor.system.visibilityChecks.astral.hasAura, false);
      assert.strictEqual(actor.system.visibilityChecks.astral.astralActive, false);
      assert.strictEqual(actor.system.visibilityChecks.astral.affectedBySpell, false);
      assert.strictEqual(actor.system.visibilityChecks.meat.hasHeat, true);
      assert.strictEqual(actor.system.visibilityChecks.matrix.hasIcon, true);
      assert.strictEqual(actor.system.visibilityChecks.matrix.runningSilent, false);
    });
    it("Recoil compensation", () => {
      let actor = new SR6Actor({ name: "Testing", type: "vehicle", system: { attributes: { body: { base: 5 } } } });
      let vehicle = actor.asVehicle();
      if (!vehicle) return assert.fail();
      assert.strictEqual(vehicle.system.values.recoil_compensation.value, 5);
    });
    it("Attributes based on pilot", async () => {
      const actor = await testActor.create({
        type: "vehicle",
        system: {
          vehicle_stats: { pilot: { base: 3 } },
          attributes: { body: { base: 5 } }
        }
      });
      const vehicle = actor.asVehicle();
      assert.strictEqual(vehicle?.system.attributes.willpower.value, 3);
      assert.strictEqual(vehicle?.system.attributes.logic.value, 3);
      assert.strictEqual(vehicle?.system.attributes.intuition.value, 3);
      assert.strictEqual(vehicle?.system.attributes.charisma.value, 3);
      assert.strictEqual(vehicle?.system.attributes.agility.value, 3);
      assert.strictEqual(vehicle?.system.attributes.charisma.value, 3);
      assert.strictEqual(vehicle?.system.attributes.strength.value, 5);
    });
  });
}, "shadowrunSR5VehicleDataPrep");

// src/module/tests/SkillTest.ts
var SkillTest = class extends SuccessTest {
  static {
    __name(this, "SkillTest");
  }
  constructor(data, documents, options) {
    super(data, documents, options);
    this.lastUsedAttribute = this.data.attribute;
  }
  /**
   * Allow users to alter detailed skill values.
   */
  get _dialogTemplate() {
    return "systems/shadowrun6-elysium/dist/templates/apps/dialogs/skill-test-dialog.html";
  }
  /**
   * Show skill label as title instead of the generic success test label.
   */
  get title() {
    if (!this.actor) return super.title;
    return `${game.i18n.localize(this.actor.getSkillLabel(this.data.action.skill))} ${game.i18n.localize("SR6.Test")}`;
  }
  /**
   * A SkillTest has the need to store attribute and limit selections
   */
  _prepareData(data, options) {
    data = super._prepareData(data, options);
    data.action = data.action || DataDefaults.actionRollData();
    data.attribute = data.action.attribute;
    data.limitSelection = data.action.limit.attribute;
    return data;
  }
  /**
   * Skill test provides a selection for attribute and limit during TestDialog.
   */
  prepareBaseValues() {
    super.prepareBaseValues();
    this.prepareAttributeSelection();
  }
  /**
   * Change out previous attribute with new selection.
   */
  prepareAttributeSelection() {
    if (!this.actor) return;
    const useSelection = this.data.attribute !== this.data.action.attribute;
    const selectedAttribute = useSelection ? this.data.attribute : this.data.action.attribute;
    const usedAttribute = this.actor.getAttribute(selectedAttribute);
    const lastUsedAttribute = this.actor.getAttribute(this.lastUsedAttribute);
    if (!usedAttribute || !lastUsedAttribute) return;
    const pool = new PartsList(this.pool.mod);
    pool.removePart(lastUsedAttribute.label);
    this.actor._removeMatrixParts(pool);
    pool.addPart(usedAttribute.label, usedAttribute.value);
    if (this.actor._isMatrixAttribute(selectedAttribute)) this.actor._addMatrixParts(pool, true);
    this.lastUsedAttribute = selectedAttribute;
  }
  /**
   * Change out previous limit with new selection.
   */
  prepareLimitSelection() {
    if (!this.actor) return;
    const useSelection = this.data.limitSelection !== this.data.action.limit.attribute;
    const selectedLimit = useSelection ? this.data.limitSelection : this.data.action.limit.attribute;
    const pool = new PartsList(this.pool.mod);
    this.actor._removeMatrixParts(pool);
    if (this.actor._isMatrixAttribute(selectedLimit)) this.actor._addMatrixParts(pool, true);
  }
};

// src/unittests/sr5.ActiveEffect.spec.ts
var shadowrunSR5ActiveEffect = /* @__PURE__ */ __name((context) => {
  const { describe, it, assert, before, after } = context;
  let testActor;
  let testItem;
  before(async () => {
    testActor = new SR6TestingDocuments(SR6Actor);
    testItem = new SR6TestingDocuments(SR6Item);
  });
  after(async () => {
    await testActor.teardown();
    await testItem.teardown();
  });
  describe("SR5ActiveEffect", () => {
    it("MODIFY mode: apply system custom mode to main and sub value-keys", async () => {
      const actor = await testActor.create({ type: "character" });
      const effect = await actor.createEmbeddedDocuments("ActiveEffect", [{
        origin: actor.uuid,
        disabled: false,
        label: "Test Effect",
        changes: [
          { key: "system.attributes.body.mod", value: 2, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM },
          { key: "system.attributes.body", value: 2, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM }
        ]
      }]);
      assert.deepEqual(actor.system.attributes.body.mod, [
        {
          name: "Test Effect",
          value: 2
        },
        {
          name: "Test Effect",
          value: 2
        }
      ]);
      assert.strictEqual(actor.system.attributes.body.value, 4);
    });
    it("MODIFY mode: check for add fallback when key points to none value property", async () => {
      const actor = await testActor.create({ type: "character" });
      await actor.createEmbeddedDocuments("ActiveEffect", [{
        origin: actor.uuid,
        disabled: false,
        label: "Test Effect",
        changes: [{
          key: "system.modifiers.global",
          // flat value field
          value: 3,
          mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM
        }]
      }]);
      assert.strictEqual(actor.system.modifiers.global, 3);
      assert.strictEqual(actor.system.modifiers.global.mod, void 0);
      assert.strictEqual(actor.system.modifiers.global.override, void 0);
    });
    it("OVERRIDE mode: apply the system override mode", async () => {
      const actor = await testActor.create({ type: "character" });
      await actor.createEmbeddedDocuments("ActiveEffect", [{
        origin: actor.uuid,
        disabled: false,
        label: "Test Effect",
        changes: [
          { key: "system.attributes.body", value: 3, mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE },
          { key: "system.attributes.agility.value", value: 4, mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE },
          { key: "system.skills.active.automatics.canDefault", value: false, mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE }
        ]
      }]);
      assert.deepEqual(actor.system.attributes.body.override, { name: "Test Effect", value: 3 });
      assert.strictEqual(actor.system.attributes.body.base, 0);
      assert.deepEqual(actor.system.attributes.body.mod, []);
      assert.strictEqual(actor.system.attributes.body.value, 3);
      assert.deepEqual(actor.system.attributes.agility.mod, []);
      assert.equal(actor.system.attributes.agility.override, void 0);
      assert.strictEqual(actor.system.attributes.agility.base, 0);
      assert.strictEqual(actor.system.attributes.agility.value, 1);
      assert.deepEqual(actor.system.skills.active.automatics.mod, []);
      assert.strictEqual(actor.system.skills.active.automatics.override, void 0);
      assert.strictEqual(actor.system.skills.active.automatics.canDefault, false);
    });
    it("OVERRIDE mode: override all existing .mod values", async () => {
      it("apply the custom override mode", async () => {
        const actor = await testActor.create({ type: "character" });
        await actor.createEmbeddedDocuments("ActiveEffect", [{
          origin: actor.uuid,
          disabled: false,
          label: "Test Effect",
          changes: [
            { key: "system.attributes.body", value: 5, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM },
            { key: "system.attributes.body", value: 3, mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE }
          ]
        }]);
        assert.strictEqual(actor.system.attributes.body.mod.length, 1);
        assert.deepEqual(actor.system.attributes.body.override, { name: "Test Effect", value: 3 });
        assert.deepEqual(actor.system.attributes.body.mod, [{ name: "Test Effect", value: 5 }]);
        assert.strictEqual(actor.system.attributes.body.value, 3);
      });
      it("apply custom override mode, none ModifiableValue should work without altering anything", async () => {
        const actor = await testActor.create({ type: "character" });
        const effect = await actor.createEmbeddedDocuments("ActiveEffect", [{
          origin: actor.uuid,
          disabled: false,
          label: "Test Effect"
        }]);
        await effect[0].update({
          "changes": [{
            key: "system.modifiers.global",
            value: 3,
            mode: CONST.ACTIVE_EFFECT_MODES.OVERRIDE
          }]
        });
        assert.strictEqual(actor.system.modifiers.global, 3);
        assert.strictEqual(actor.system.modifiers.global.mod, void 0);
        assert.strictEqual(actor.system.modifiers.global.override, void 0);
      });
    });
  });
  describe("SR5AdvancedEffect apply-to modes", () => {
    it("A default active effect should adhere to apply-to actor rules", async () => {
      const actor = await testActor.create({ type: "character" });
      const effects = await actor.createEmbeddedDocuments("ActiveEffect", [{
        label: "Test Effect",
        changes: [{ key: "system.attributes.body", value: 3, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM }]
      }]);
      const effect = effects.pop();
      assert.strictEqual(effect.applyTo, "actor");
    });
    it("Create an item effect and assert its not created on actor as until FoundryVTT v10", async () => {
      const actor = await testActor.create({ type: "character" });
      const items = await actor.createEmbeddedDocuments("Item", [{
        name: "Test Item",
        type: "weapon",
        system: {
          category: "range"
        }
      }]);
      const weapon = items[0];
      const effects = await weapon.createEmbeddedDocuments("ActiveEffect", [{
        origin: weapon.uuid,
        label: "Test Effect",
        transfer: true,
        // Foundry uses transfer to find item effects that should be transferred. This is disabled by the system.
        changes: [{ key: "system.limit", value: 3, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM }]
      }]);
      assert.lengthOf(effects, 1);
      assert.lengthOf(actor.effects.contents, 0);
      assert.lengthOf(weapon.effects.contents, 1);
    });
    it("ACTOR apply-to: Only actor and targeted_actor effects should apply onto an actor", async () => {
      const actor = await testActor.create({ type: "character" });
      const effects = await actor.createEmbeddedDocuments("ActiveEffect", [{
        label: "Actor Effect",
        flags: { "shadowrun6-elysium": { applyTo: "actor" } },
        changes: [{ key: "system.attributes.body", value: 3, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM }]
      }, {
        label: "Targeted Actor Effect",
        flags: { "shadowrun6-elysium": { applyTo: "targeted_actor" } },
        changes: [{ key: "system.attributes.body", value: 3, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM }]
      }, {
        label: "Test_All Effect",
        flags: { "shadowrun6-elysium": { applyTo: "test_all" } },
        changes: [{ key: "system.attributes.body", value: 3, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM }]
      }, {
        label: "Test_Item Effect",
        flags: { "shadowrun6-elysium": { applyTo: "test_item" } },
        changes: [{ key: "system.attributes.body", value: 3, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM }]
      }, {
        label: "Modifiers Effect",
        flags: { "shadowrun6-elysium": { applyTo: "modifiers" } },
        changes: [{ key: "system.attributes.body", value: 3, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM }]
      }]);
      assert.lengthOf(actor.effects.contents, 5);
      assert.lengthOf(actor.system.attributes.body.mod, 2);
      assert.equal(actor.system.attributes.body.value, 6);
    });
    it("TEST_ALL apply-to: Actor effect applies to test", async () => {
      const expectedFlags = {
        "shadowrun6-elysium": { applyTo: "test_all" }
      };
      const limitValue = 3;
      const poolValue = 3;
      const hitsValue = 3;
      const actor = await testActor.create({ type: "character" });
      await actor.createEmbeddedDocuments("ActiveEffect", [{
        origin: actor.uuid,
        label: "Test Effect",
        flags: expectedFlags,
        "changes": [
          // NOTE: test doesn't use system.
          { key: "data.limit", value: limitValue, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM },
          { key: "data.pool", value: poolValue, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM },
          { key: "data.values.hits", value: poolValue, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM }
        ]
      }]);
      const action = DataDefaults.actionRollData({ test: "SuccessTest" });
      const test = await TestCreator.fromAction(action, actor, { showDialog: false, showMessage: false });
      await test.execute();
      assert.deepEqual(test.limit.mod, [{ name: "Test Effect", value: limitValue }]);
      assert.equal(test.limit.value, limitValue);
      assert.deepEqual(test.pool.mod, [
        { name: "Test Effect", value: poolValue },
        { name: "SR5.ModifierTypes.Global", value: 0 },
        { name: "SR5.ModifierTypes.Wounds", value: 0 }
      ]);
      assert.equal(test.pool.value, poolValue);
      assert.deepEqual(test.hits.mod, [{ name: "Test Effect", value: hitsValue }]);
      assert.isAtLeast(test.hits.value, hitsValue);
    });
    it("TEST_ALL apply-to: Item effect applies to test", async () => {
      const expectedFlags = {
        "shadowrun6-elysium": { applyTo: "test_all" }
      };
      const limitValue = 3;
      const poolValue = 3;
      const hitsValue = 3;
      const actor = await testActor.create({ type: "character" });
      const items = await actor.createEmbeddedDocuments("Item", [{ type: "action", name: "Test Action" }]);
      const item = items.pop();
      await item.createEmbeddedDocuments("ActiveEffect", [{
        label: "Test Effect",
        flags: expectedFlags,
        "changes": [
          // NOTE: test doesn't use system.
          { key: "data.limit", value: limitValue, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM },
          { key: "data.pool", value: poolValue, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM },
          { key: "data.values.hits", value: poolValue, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM }
        ]
      }]);
      const test = await TestCreator.fromItem(item, actor, { showDialog: false, showMessage: false });
      await test.execute();
      assert.deepEqual(test.limit.mod, [{ name: "Test Effect", value: limitValue }]);
      assert.equal(test.limit.value, limitValue);
      assert.deepEqual(test.pool.mod, [
        { name: "Test Effect", value: poolValue },
        { name: "SR5.ModifierTypes.Global", value: 0 },
        { name: "SR5.ModifierTypes.Wounds", value: 0 }
      ]);
      assert.equal(test.pool.value, poolValue);
      assert.deepEqual(test.hits.mod, [{ name: "Test Effect", value: hitsValue }]);
      assert.isAtLeast(test.hits.value, hitsValue);
    });
    it("TEST_ITEM apply-to: Item effect applies only when on test item", async () => {
      const expectedFlags = {
        "shadowrun6-elysium": { applyTo: "test_item" }
      };
      const limitValue = 3;
      const poolValue = 3;
      const hitsValue = 3;
      const actor = await testActor.create({ type: "character" });
      await actor.createEmbeddedDocuments("ActiveEffect", [{
        label: "Test Effect Actor",
        flags: expectedFlags,
        changes: [
          { key: "data.limit", value: limitValue, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM },
          { key: "data.pool", value: poolValue, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM },
          { key: "data.values.hits", value: poolValue, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM }
        ]
      }]);
      const items = await actor.createEmbeddedDocuments(
        "Item",
        [
          { type: "action", name: "Test Action" },
          { type: "action", name: "Test Action 2" }
        ]
      );
      const item = items.pop();
      await item.createEmbeddedDocuments("ActiveEffect", [{
        label: "Test Effect Correct Item",
        flags: expectedFlags,
        changes: [
          { key: "data.limit", value: limitValue, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM },
          { key: "data.pool", value: poolValue, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM },
          { key: "data.values.hits", value: poolValue, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM }
        ]
      }]);
      const item2 = items.pop();
      await item2.createEmbeddedDocuments("ActiveEffect", [{
        label: "Test Effect Wrong Item",
        flags: expectedFlags,
        changes: [
          { key: "data.limit", value: limitValue, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM },
          { key: "data.pool", value: poolValue, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM },
          { key: "data.values.hits", value: poolValue, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM }
        ]
      }]);
      const test = await TestCreator.fromItem(item, actor, { showDialog: false, showMessage: false });
      await test.execute();
      assert.deepEqual(test.limit.mod, [{ name: "Test Effect Correct Item", value: limitValue }]);
      assert.equal(test.limit.value, limitValue);
      assert.deepEqual(test.pool.mod, [
        { name: "Test Effect Correct Item", value: poolValue },
        { name: "SR5.ModifierTypes.Global", value: 0 },
        { name: "SR5.ModifierTypes.Wounds", value: 0 }
      ]);
      assert.equal(test.pool.value, poolValue);
      assert.deepEqual(test.hits.mod, [{ name: "Test Effect Correct Item", value: hitsValue }]);
      assert.isAtLeast(test.hits.value, hitsValue);
    });
  });
  describe("AdvancedEffects suppress application", () => {
    it("A disabled effect should not apply", async () => {
      const actor = await testActor.create({ type: "character" });
      const effects = await actor.createEmbeddedDocuments("ActiveEffect", [{
        label: "Test Effect",
        disabled: true,
        changes: [{ key: "system.attributes.body", value: 3, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM }]
      }]);
      const effect = effects.pop();
      assert.isTrue(effect.disabled);
      assert.lengthOf(actor.effects.contents, 1);
      assert.lengthOf(actor.system.attributes.body.mod, 0);
    });
    it("A wireless only effect should not apply for a wireless item", async () => {
      const actor = await testActor.create({ type: "character" });
      const items = await actor.createEmbeddedDocuments("Item", [
        { type: "cyberware", name: "Wireless Item", system: { technology: { wireless: true } } },
        { type: "cyberware", name: "Wired Item", system: { technology: { wireless: false } } }
      ]);
      const item = items.pop();
      await item.createEmbeddedDocuments("ActiveEffect", [{
        label: "Test Effect",
        flags: { "shadowrun6-elysium": { onlyForWireless: true } },
        changes: [{ key: "system.attributes.body", value: 3, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM }]
      }]);
      const item2 = items.pop();
      await item2.createEmbeddedDocuments("ActiveEffect", [{
        label: "Test Effect",
        flags: { "shadowrun6-elysium": { onlyForWireless: true } },
        changes: [{ key: "system.attributes.body", value: 3, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM }]
      }]);
      assert.lengthOf(actor.system.attributes.body.mod, 1);
      assert.equal(actor.system.attributes.body.value, 3);
    });
    it("A equipped only effect should not apply for an  unequipped item", async () => {
      const actor = await testActor.create({ type: "character" });
      const items = await actor.createEmbeddedDocuments("Item", [
        { type: "cyberware", name: "Equipped Item", system: { technology: { equipped: true } } },
        { type: "cyberware", name: "Unequipped Item", system: { technology: { equipped: false } } }
      ]);
      const item = items.pop();
      await item.createEmbeddedDocuments("ActiveEffect", [{
        label: "Test Effect",
        flags: { "shadowrun6-elysium": { onlyForEquipped: true } },
        changes: [{ key: "system.attributes.body", value: 3, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM }]
      }]);
      const item2 = items.pop();
      await item2.createEmbeddedDocuments("ActiveEffect", [{
        label: "Test Effect",
        flags: { "shadowrun6-elysium": { onlyForEquipped: true } },
        changes: [{ key: "system.attributes.body", value: 3, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM }]
      }]);
      assert.lengthOf(actor.system.attributes.body.mod, 1);
      assert.equal(actor.system.attributes.body.value, 3);
    });
    it("A wireless and equipped only effect should not apply for a wired and unequipped item", async () => {
      const actor = await testActor.create({ type: "character" });
      const items = await actor.createEmbeddedDocuments("Item", [
        { type: "cyberware", name: "Wireless Equipped Item", system: { technology: { equipped: true, wireless: true } } },
        { type: "cyberware", name: "Wired Unequipped Item", system: { technology: { equipped: false, wireless: false } } }
      ]);
      const item = items.pop();
      await item.createEmbeddedDocuments("ActiveEffect", [{
        label: "Test Effect",
        flags: { "shadowrun6-elysium": { onlyForEquipped: true, onlyForWireless: true } },
        changes: [{ key: "system.attributes.body", value: 3, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM }]
      }]);
      const item2 = items.pop();
      await item2.createEmbeddedDocuments("ActiveEffect", [{
        label: "Test Effect",
        flags: { "shadowrun6-elysium": { onlyForEquipped: true, onlyForeWireless: false } },
        changes: [{ key: "system.attributes.body", value: 3, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM }]
      }]);
      assert.lengthOf(actor.system.attributes.body.mod, 1);
      assert.equal(actor.system.attributes.body.value, 3);
    });
    it("A wireless and equipped only effect should if it is disabled", async () => {
      const actor = await testActor.create({ type: "character" });
      const items = await actor.createEmbeddedDocuments("Item", [
        { type: "cyberware", name: "Wireless Equipped Item", system: { technology: { equipped: true, wireless: true } } }
      ]);
      const item = items.pop();
      await item.createEmbeddedDocuments("ActiveEffect", [{
        label: "Test Effect",
        disabled: true,
        flags: { "shadowrun6-elysium": { onlyForEquipped: true, onlyForWireless: true } },
        changes: [{ key: "system.attributes.body", value: 3, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM }]
      }]);
      assert.lengthOf(actor.system.attributes.body.mod, 0);
      assert.equal(actor.system.attributes.body.value, 1);
    });
    it("A extended test should not apply effects on extended rolls", async () => {
      const reduceModifiersByName = /* @__PURE__ */ __name((name3) => (acc, { name: n2, value }) => n2 === name3 ? acc + value : acc, "reduceModifiersByName");
      const actor = await testActor.create({ type: "character" });
      let actions = await actor.createEmbeddedDocuments("Item", [{ name: "Test Action", type: "action" }]);
      await actor.createEmbeddedDocuments("ActiveEffect", [{
        label: "Test Effect",
        flags: { "shadowrun6-elysium": { applyTo: "test_all", selection_tests: '[{"value":"Success Test","id":"SuccessTest"}]' } },
        changes: [{ key: "data.pool", value: 2, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM }]
      }]);
      let test = await TestCreator.fromItem(actions[0], actor, { showDialog: false, showMessage: false });
      await test.execute();
      assert.equal(test.pool.mod.reduce(reduceModifiersByName("Test Effect"), 0), 2);
      test = await test.executeAsExtended();
      assert.equal(test.pool.mod.reduce(reduceModifiersByName("Test Effect"), 0), 2);
      actions = await actor.createEmbeddedDocuments("Item", [{ name: "Test Action", type: "action", "system.action.extended": true }]);
      test = await TestCreator.fromItem(actions[0], actor, { showDialog: false, showMessage: false });
      await test.execute();
      assert.equal(test.pool.mod.reduce(reduceModifiersByName("Test Effect"), 0), 2);
    });
  });
  describe("AdvancedEffects with dynamic values", () => {
    it("ACTOR apply-to: Grab dynamic actor values", async () => {
      const actor = await testActor.create({ type: "character", system: { modifiers: { global: 6 } } });
      const effects = await actor.createEmbeddedDocuments("ActiveEffect", [{
        label: "Actor Effect",
        changes: [
          { key: "system.attributes.body", value: "@system.modifiers.global", mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM }
        ]
      }]);
      assert.lengthOf(actor.effects.contents, 1);
      assert.equal(actor.system.attributes.body.value, 6);
    });
  });
  describe("Advanced effects modify problematic test implementations", () => {
    it("TEST modify damage on RangedAttackTest", async () => {
      const actor = await testActor.create({ type: "character" });
      const weapon = await testItem.create({ type: "weapon", system: { category: "ranged" } });
      const effects = await actor.createEmbeddedDocuments("ActiveEffect", [{
        name: "Test Effect",
        flags: { "shadowrun6-elysium": { applyTo: "test_all" } },
        changes: [{ key: "data.damage", value: 3, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM }]
      }]);
      const test = await TestCreator.fromItem(weapon, actor, { showDialog: false, showMessage: false });
      await test.execute();
      assert.equal(test.data.damage.value, 3);
    });
    it("TEST modify attribute and limit on SkillTest", async () => {
      const actor = await testActor.create({ type: "character" });
      const effects = await actor.createEmbeddedDocuments("ActiveEffect", [{
        name: "Test Effect",
        flags: { "shadowrun6-elysium": { applyTo: "test_all" } },
        changes: [
          { key: "data.limit", value: 3, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM },
          { key: "data.pool", value: 3, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM }
        ]
      }]);
      const action = DataDefaults.actionRollData({ test: SkillTest.name, limit: { attribute: "social" } });
      const test = await TestCreator.fromAction(action, actor, { showDialog: false, showMessage: false });
      test.effects.applyAllEffects();
      test.prepareAttributeSelection();
      test.prepareLimitSelection();
      test.prepareBaseValues();
      test.calculateBaseValues();
      assert.strictEqual(test.limit.value, actor.getLimit("social").value + 3);
      assert.strictEqual(test.pool.value, 3);
      test.data.attribute = "body";
      test.data.limitSelection = "physical";
      test.prepareAttributeSelection();
      test.prepareLimitSelection();
      test.prepareBaseValues();
      test.calculateBaseValues();
      assert.strictEqual(test.limit.value, actor.getLimit("physical").value + 3);
    });
  });
  describe("AdvanceEffects apply modification based on test categories", () => {
    it("Should apply modifier to a single category only", async () => {
      const actor = await testActor.create({ type: "character" });
      const effects = await actor.createEmbeddedDocuments("ActiveEffect", [{
        name: "Test Effect",
        flags: { "shadowrun6-elysium": { applyTo: "test_all", selection_categories: '[{"value":"Social Actions","id":"social"}]' } },
        changes: [{ key: "data.pool", value: 3, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM }]
      }]);
      let action = DataDefaults.actionRollData({ test: "SkillTest", categories: ["social"] });
      let test = await TestCreator.fromAction(action, actor, { showDialog: false, showMessage: false });
      test.prepareTestCategories();
      test.effects.applyAllEffects();
      Helpers.calcTotal(test.pool);
      assert.strictEqual(test.pool.value, 3);
      action = DataDefaults.actionRollData({ test: "SkillTest", categories: ["matrix"] });
      test = await TestCreator.fromAction(action, actor, { showDialog: false, showMessage: false });
      test.prepareTestCategories();
      test.effects.applyAllEffects();
      Helpers.calcTotal(test.pool);
      assert.strictEqual(test.pool.value, 0);
      action = DataDefaults.actionRollData({ test: "SkillTest", categories: [] });
      test = await TestCreator.fromAction(action, actor, { showDialog: false, showMessage: false });
      test.prepareTestCategories();
      test.effects.applyAllEffects();
      Helpers.calcTotal(test.pool);
      assert.strictEqual(test.pool.value, 0);
    });
  });
}, "shadowrunSR5ActiveEffect");

// src/unittests/sr5.NetworkDevices.spec.ts
var shadowrunNetworkDevices = /* @__PURE__ */ __name((context) => {
  const { describe, it, assert, before, after } = context;
  let testActor;
  let testItem;
  let testScene;
  before(async () => {
    testActor = new SR6TestingDocuments(SR6Actor);
    testItem = new SR6TestingDocuments(SR6Item);
    testScene = new SR6TestingDocuments(Scene);
  });
  after(async () => {
    await testActor.teardown();
    await testItem.teardown();
    await testScene.teardown();
  });
  describe("Network Devices handling", () => {
    it("Handle PAN/WAN networks and device linking", () => {
      assert.fail("Test suite is deactivated");
    });
  });
}, "shadowrunNetworkDevices");

// src/unittests/sr5.Testing.spec.ts
var shadowrunTesting = /* @__PURE__ */ __name((context) => {
  const { describe, it, assert, before, after } = context;
  let testActor;
  let testItem;
  before(async () => {
    testActor = new SR6TestingDocuments(SR6Actor);
    testItem = new SR6TestingDocuments(SR6Item);
  });
  after(async () => {
    await testActor.teardown();
    await testItem.teardown();
  });
  describe("SuccessTest", () => {
    it("evaluate a roll from action data", async () => {
      const actionData = {
        "system.action.test": "SuccessTest",
        "type": "action",
        "system.action.type": "simple",
        "system.action.attribute": "body",
        "system.action.skill": "automatics",
        "system.action.spec": false,
        "system.action.limit": {
          base: 1,
          value: 1,
          attribute: "physical"
        },
        "system.action.threshold": {
          base: 1,
          value: 1
        },
        "system.action.damage": {
          ap: { value: 5, base: 5, mod: Array(0) },
          attribute: "",
          base: 5,
          base_formula_operator: "add",
          element: { value: "", base: "" },
          itemSource: { actorId: "", itemId: "", itemType: "", itemName: "" },
          mod: [],
          type: { value: "physical", base: "physical" },
          value: 5
        }
      };
      const action = await testItem.create(actionData);
      const actorData = {
        "type": "character",
        "system.attributes.body.base": 5,
        "system.skills.active.automatics.base": 45
      };
      const actor = await testActor.create(actorData);
      const test = await TestCreator.fromItem(action, actor, { showMessage: false, showDialog: false });
      if (!test) assert.strictEqual(true, false);
      if (test) {
        await test.evaluate();
        assert.strictEqual(test.pool.value, 50);
        assert.strictEqual(test.threshold.value, 1);
        assert.strictEqual(test.limit.value, 4);
      }
    });
    it("evaluate a roll from simple pool data", async () => {
      const test = TestCreator.fromPool({ pool: 10 }, { showMessage: false, showDialog: false });
      await test.evaluate();
      assert.strictEqual(test.pool.value, 10);
    });
    it("evaluate an opposed roll from a opposed action", async () => {
      const actionData = {
        "type": "action",
        "data.action.test": "SuccessTest",
        "data.action.type": "simple",
        "data.action.attribute": "body",
        "data.action.skill": "automatics",
        "data.action.spec": false,
        "data.action.limit": {
          base: 1,
          value: 1,
          attribute: "physical"
        },
        "data.action.threshold": {
          base: 1,
          value: 1
        },
        "data.action.opposed": {
          "type": "custom",
          // TODO: This could maybe simply be SuccessTest?
          "test": "OpposedTest",
          "attribute": "reaction",
          "attribute2": "intuition",
          "skill": "",
          "mod": 0,
          "description": ""
        }
      };
      const action = await testItem.create(actionData);
      const actorData = {
        "type": "character",
        "data.attributes.body.base": 5,
        "data.skills.active.automatics.base": 45
      };
      const actor = await testActor.create(actorData);
      const test = await TestCreator.fromItem(action, actor, { showMessage: false, showDialog: false });
      if (test) {
        await test.toMessage();
      }
    });
  });
  describe("OpposedTest", () => {
  });
}, "shadowrunTesting");

// src/unittests/sr5.Inventory.spec.ts
var shadowrunInventoryFlow = /* @__PURE__ */ __name((context) => {
  const { describe, it, assert, should, before, after } = context;
  let testActor;
  let testItem;
  before(async () => {
    testActor = new SR6TestingDocuments(SR6Actor);
    testItem = new SR6TestingDocuments(SR6Item);
  });
  after(async () => {
    await testActor.teardown();
    await testItem.teardown();
  });
  describe("InventoryFlow testing", () => {
    it("create a new inventory and know of its existance", async () => {
      const actor = await testActor.create({ type: "character" });
      await actor.inventory.create("test");
      assert.exists(actor.system.inventories["test"]);
      assert.deepEqual(actor.system.inventories["test"], {
        name: "test",
        label: "test",
        itemIds: []
      });
      assert.strictEqual(actor.inventory.exists("test"), true);
    });
    it("remove an inventory", async () => {
      const inventoriesData = { test: { name: "test", label: "test", itemIds: [] } };
      const actor = await testActor.create({ "type": "character", "system.inventories": inventoriesData });
      await actor.inventory.remove("test");
      assert.notExists(actor.system.inventories["test"]);
    });
    it("add and remove an item to and from an inventory", async () => {
      const inventoriesData = { test: { name: "test", label: "test", itemIds: [] } };
      const actor = await testActor.create({ "type": "character", "system.inventories": inventoriesData });
      const item = await actor.createEmbeddedDocuments("Item", [{ type: "weapon", name: "Test Weapon" }]);
      await actor.inventory.addItems("test", item);
      const itemIds = item.map((item2) => item2.id);
      assert.deepEqual(actor.system.inventories.test.itemIds, itemIds);
      await actor.inventory.removeItem(item[0]);
      assert.deepEqual(actor.system.inventories.test.itemIds, []);
    });
    it("rename an existing inventory", async () => {
      const inventoriesData = { test: { name: "test", label: "test", itemIds: ["notAnItemId"] } };
      const actor = await testActor.create({ "type": "character", "system.inventories": inventoriesData });
      const before2 = "test";
      const after2 = "betterTest";
      await actor.inventory.rename(before2, after2);
      assert.notExists(actor.system.inventories[before2]);
      assert.exists(actor.system.inventories[after2]);
      assert.deepEqual(actor.system.inventories[after2], {
        name: after2,
        label: after2,
        itemIds: ["notAnItemId"]
      });
    });
    it("create and rename an inventory including prohibited foundry chars", async () => {
      const actor = await testActor.create({ type: "character" });
      await actor.inventory.create("Test.");
      assert.exists(actor.system.inventories["Test"]);
      assert.notExists(actor.system.inventories["Test"][""]);
      assert.deepEqual(actor.system.inventories["Test"], {
        name: "Test",
        label: "Test",
        itemIds: []
      });
      await actor.inventory.rename("Test", "Test.");
      assert.exists(actor.system.inventories["Test"]);
      assert.notExists(actor.system.inventories["Test"][""]);
      assert.deepEqual(actor.system.inventories["Test"], {
        name: "Test",
        label: "Test",
        itemIds: []
      });
      await actor.inventory.remove("Test");
      assert.notExists(actor.system.inventories["Test"]);
      await actor.inventory.create("-=Fisch.");
      assert.exists(actor.system.inventories["Fisch"]);
      assert.deepEqual(actor.system.inventories["Fisch"], {
        name: "Fisch",
        label: "Fisch",
        itemIds: []
      });
    });
  });
}, "shadowrunInventoryFlow");

// src/unittests/sr5.WeaponParser.spec.ts
var TestWeaponParser = class extends WeaponParserBase {
  static {
    __name(this, "TestWeaponParser");
  }
  GetDamage(jsonData) {
    return super.GetDamage(jsonData);
  }
};
function mockXmlData(data) {
  return Object.fromEntries(Object.entries(data).map(([key, value]) => [key, { "_TEXT": value }]));
}
__name(mockXmlData, "mockXmlData");
function getData(damageString) {
  return mockXmlData({
    damage: damageString
  });
}
__name(getData, "getData");
var weaponParserBaseTesting = /* @__PURE__ */ __name((context) => {
  const { describe, it, assert, before, after } = context;
  let mut = new TestWeaponParser();
  before(async () => {
  });
  after(async () => {
  });
  describe("Weapon Damage Values", () => {
    it("Parses simple damage", () => {
      const output = mut.GetDamage(getData("12P"));
      assert.deepEqual(output, DataDefaults.damageData({
        base: 12,
        value: 12,
        type: {
          base: "physical",
          value: "physical"
        }
      }));
    });
    it("Parses elemental damage", () => {
      const output = mut.GetDamage(getData("8S(e)"));
      assert.deepEqual(output, DataDefaults.damageData({
        base: 8,
        value: 8,
        type: {
          base: "stun",
          value: "stun"
        },
        element: {
          base: "electricity",
          value: "electricity"
        }
      }));
    });
    it("Parses strength-based damage", () => {
      const output = mut.GetDamage(getData("({STR}+3)P"));
      assert.deepEqual(output, DataDefaults.damageData({
        base: 3,
        value: 3,
        type: {
          base: "physical",
          value: "physical"
        },
        attribute: "strength"
      }));
    });
    it("Parses damage without type as physical", () => {
      const output = mut.GetDamage(getData("11"));
      assert.deepEqual(output, DataDefaults.damageData({
        base: 11,
        value: 11,
        type: {
          base: "physical",
          value: "physical"
        }
      }));
    });
    it("Parses 0 damage", () => {
      const output = mut.GetDamage(getData("0"));
      assert.deepEqual(output, DataDefaults.damageData({
        base: 0,
        value: 0,
        type: {
          base: "physical",
          value: "physical"
        }
      }));
    });
    it("Parses basic matrix damage", () => {
      const output = mut.GetDamage(getData("7M"));
      assert.deepEqual(output, DataDefaults.damageData({
        base: 7,
        value: 7,
        type: {
          base: "matrix",
          value: "matrix"
        }
      }));
    });
    it("Parses strength-based damage without modifier", () => {
      const output = mut.GetDamage(getData("({STR})P"));
      assert.deepEqual(output, DataDefaults.damageData({
        base: 0,
        value: 0,
        type: {
          base: "physical",
          value: "physical"
        },
        attribute: "strength"
      }));
    });
  });
}, "weaponParserBaseTesting");

// src/unittests/actorImport/characterImporter/sr5.CharacterImporter.spec.ts
var characterImporterTesting = /* @__PURE__ */ __name((context) => {
  const { describe, it, assert, before, after } = context;
  let testActor;
  let importOptions = {};
  let chummerFile = {
    characters: {
      character: {}
    }
  };
  before(async () => {
    testActor = new SR6TestingDocuments(SR6Actor);
  });
  after(async () => {
    await testActor.teardown();
  });
  describe("Chummer Character Importer", () => {
    let testItem = new SR6TestingDocuments(SR6Item);
    it("Does nothing when no character found", async () => {
      const item = await testItem.create({ type: "weapon" });
      const character = await testActor.create({ "type": "character", "system.metatype": "human" });
      await character.createEmbeddedDocuments("Item", [item]);
      assert.lengthOf(character.items, 1);
      await new CharacterImporter().importChummerCharacter(character, {}, importOptions);
      assert.lengthOf(character.items, 1);
      assert.strictEqual(character.items.contents[0].name, item.name);
      assert.strictEqual(character.items.contents[0].type, item.type);
    });
    it("Clears all imported items", async () => {
      const item = await testItem.create({ type: "weapon" });
      await item.update({ "system.importFlags.isImported": true });
      const character = await testActor.create({ "type": "character", "system.metatype": "human" });
      await character.createEmbeddedDocuments("Item", [item]);
      assert.lengthOf(character.items, 1);
      await new CharacterImporter().importChummerCharacter(character, chummerFile, importOptions);
      assert.isEmpty(character.items);
    });
    it("Clears all items but not imported ones", async () => {
      const item = await testItem.create({ type: "weapon" });
      const character = await testActor.create({ "type": "character", "system.metatype": "human" });
      await character.createEmbeddedDocuments("Item", [item]);
      assert.lengthOf(character.items, 1);
      await new CharacterImporter().importChummerCharacter(character, chummerFile, importOptions);
      assert.lengthOf(character.items, 1);
    });
    it("Clears all items but actions", async () => {
      const item = await testItem.create({ type: "action" });
      const character = await testActor.create({ "type": "character", "system.metatype": "human" });
      await character.createEmbeddedDocuments("Item", [item]);
      assert.lengthOf(character.items, 1);
      await new CharacterImporter().importChummerCharacter(character, chummerFile, importOptions);
      assert.lengthOf(character.items, 1);
      assert.strictEqual(character.items.contents[0].name, item.name);
      assert.strictEqual(character.items.contents[0].type, item.type);
    });
    it("Clears all items but effects", async () => {
      let item = await testItem.create({ type: "weapon" });
      item.createEmbeddedDocuments("ActiveEffect", [{
        origin: item.uuid,
        disabled: false,
        label: "Test Effect",
        changes: [
          { key: "system.attributes.body.mod", value: 2, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM },
          { key: "system.attributes.body", value: 2, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM }
        ]
      }]);
      const character = await testActor.create({ "type": "character", "system.metatype": "human" });
      await character.createEmbeddedDocuments("Item", [item]);
      await new CharacterImporter().importChummerCharacter(character, chummerFile, importOptions);
      assert.lengthOf(character.items, 1);
      assert.strictEqual(character.items.contents[0].name, item.name);
      assert.strictEqual(character.items.contents[0].type, item.type);
    });
  });
}, "characterImporterTesting");

// src/unittests/actorImport/characterImporter/sr5.CharacterInfoUpdater.spec.ts
var characterInfoUpdaterTesting = /* @__PURE__ */ __name((context) => {
  const { describe, it, assert, before, after } = context;
  let testActorFactory;
  let importOptions = {};
  let chummerFile;
  before(async () => {
    testActorFactory = new SR6TestingDocuments(SR6Actor);
  });
  beforeEach(async () => {
    chummerFile = {
      characters: {
        character: {}
      }
    };
  });
  after(async () => {
    await testActorFactory.teardown();
  });
  describe("Chummer Character Info Updater handles alias correctly", () => {
    it("Imports name", async () => {
      chummerFile.characters.character = {
        alias: "ImportTester"
      };
      const character = await testActorFactory.create({ "type": "character", "system.metatype": "human" });
      await new CharacterImporter().importChummerCharacter(character, chummerFile, importOptions);
      assert.strictEqual(character.name, "ImportTester");
      assert.strictEqual(character.prototypeToken.name, "ImportTester");
    });
    it("Sets placeholder when no alias", async () => {
      const character = await testActorFactory.create({ "type": "character", "system.metatype": "human" });
      await new CharacterImporter().importChummerCharacter(character, chummerFile, importOptions);
      assert.strictEqual(character.name, "[Name not found]");
      assert.strictEqual(character.prototypeToken.name, "[Name not found]");
    });
  });
  describe("Chummer Character Info Updater handles attributes correctly", () => {
    it("Imports standard attributes", async () => {
      chummerFile.characters.character = {
        attributes: [
          "0",
          {
            attributecategory_english: "Standard",
            attribute: [
              {
                name_english: "BOD",
                name: "KON",
                base: "3",
                total: "3",
                min: "1",
                max: "6",
                aug: "10",
                bp: "0",
                metatypecategory: "Standard"
              },
              {
                name_english: "AGI",
                name: "GES",
                base: "3",
                total: "3",
                min: "1",
                max: "6",
                aug: "10",
                bp: "0",
                metatypecategory: "Standard"
              },
              {
                name_english: "REA",
                name: "REA",
                base: "5",
                total: "5",
                min: "1",
                max: "6",
                aug: "10",
                bp: "0",
                metatypecategory: "Standard"
              },
              {
                name_english: "STR",
                name: "STR",
                base: "1",
                total: "1",
                min: "1",
                max: "6",
                aug: "10",
                bp: "0",
                metatypecategory: "Standard"
              },
              {
                name_english: "CHA",
                name: "CHA",
                base: "2",
                total: "2",
                min: "1",
                max: "6",
                aug: "10",
                bp: "10",
                metatypecategory: "Standard"
              },
              {
                name_english: "INT",
                name: "INT",
                base: "6",
                total: "6",
                min: "1",
                max: "6",
                aug: "10",
                bp: "0",
                metatypecategory: "Standard"
              },
              {
                name_english: "LOG",
                name: "LOG",
                base: "4",
                total: "4",
                min: "1",
                max: "6",
                aug: "10",
                bp: "0",
                metatypecategory: "Standard"
              },
              {
                name_english: "WIL",
                name: "WIL",
                base: "5",
                total: "5",
                min: "1",
                max: "6",
                aug: "10",
                bp: "0",
                metatypecategory: "Standard"
              },
              {
                name_english: "EDG",
                name: "EDG",
                base: "3",
                total: "3",
                min: "2",
                max: "7",
                aug: "7",
                bp: "15",
                metatypecategory: "Special"
              },
              {
                name_english: "ESS",
                name: "ESS",
                base: "1",
                total: "1",
                min: "1",
                max: "6",
                aug: "6",
                bp: "0",
                metatypecategory: "Standard"
              }
            ]
          }
        ]
      };
      const character = await testActorFactory.create({ "type": "character", "system.metatype": "human" });
      await new CharacterImporter().importChummerCharacter(character, chummerFile, importOptions);
      assert.strictEqual(character.system.attributes.body.value, 3);
      assert.strictEqual(character.system.attributes.charisma.value, 2);
      assert.strictEqual(character.system.attributes.intuition.value, 6);
      assert.strictEqual(character.system.attributes.logic.value, 4);
      assert.strictEqual(character.system.attributes.reaction.value, 5);
      assert.strictEqual(character.system.attributes.strength.value, 1);
      assert.strictEqual(character.system.attributes.willpower.value, 5);
      assert.strictEqual(character.system.attributes.agility.value, 3);
      assert.strictEqual(character.system.attributes.edge.value, 3);
      assert.strictEqual(character.system.attributes.essence.value, 6);
    });
    it("Imports magic attribute", async () => {
      chummerFile.characters.character = {
        attributes: [
          "0",
          {
            attributecategory_english: "Standard",
            attribute: [
              {
                name_english: "MAG",
                name: "MAG",
                base: "7",
                total: "7",
                min: "6",
                max: "12",
                aug: "12",
                bp: "35",
                metatypecategory: "Special"
              }
            ]
          }
        ]
      };
      const character = await testActorFactory.create({ "type": "character", "system.metatype": "human" });
      await new CharacterImporter().importChummerCharacter(character, chummerFile, importOptions);
      assert.strictEqual(character.system.attributes.magic.value, 7);
      assert.strictEqual(character.system.attributes.resonance.value, 0);
    });
    it("Imports resonance attribute", async () => {
      chummerFile.characters.character = {
        attributes: [
          "0",
          {
            attributecategory_english: "Standard",
            attribute: [
              {
                name_english: "RES",
                name: "RES",
                base: "7",
                total: "7",
                min: "6",
                max: "12",
                aug: "12",
                bp: "35",
                metatypecategory: "Special"
              }
            ]
          }
        ]
      };
      const character = await testActorFactory.create({ "type": "character", "system.metatype": "human" });
      await new CharacterImporter().importChummerCharacter(character, chummerFile, importOptions);
      assert.strictEqual(character.system.attributes.magic.value, 0);
      assert.strictEqual(character.system.attributes.resonance.value, 7);
    });
  });
}, "characterInfoUpdaterTesting");

// src/unittests/actorImport/spiritImporter/spirits.ts
var emptySpirit = {
  characters: {
    character: {
      attributes: [
        0,
        {
          attributecategory_english: "Standard",
          attribute: [
            {
              name_english: "MAG",
              name: "MAG",
              base: 7,
              total: 7,
              min: 6,
              max: 12,
              aug: 12,
              bp: 35,
              metatypecategory: "Special"
            }
          ]
        }
      ]
    }
  }
};

// src/unittests/actorImport/spiritImporter/sr5.SpiritImporter.spec.ts
var spiritImporterTesting = /* @__PURE__ */ __name((context) => {
  const { describe, it, assert, before, after } = context;
  let testActor;
  const actorType = "spirit";
  const importOptions = {};
  let chummerFile;
  before(async () => {
    testActor = new SR6TestingDocuments(SR6Actor);
  });
  beforeEach(async () => {
    chummerFile = structuredClone(emptySpirit);
  });
  after(async () => {
    await testActor.teardown();
  });
  describe("Chummer Spirit Importer", () => {
    const testItem = new SR6TestingDocuments(SR6Item);
    it("Does nothing when no character found", async () => {
      const item = await testItem.create({ type: "weapon" });
      const character = await testActor.create({ type: actorType });
      await character.createEmbeddedDocuments("Item", [item]);
      assert.lengthOf(character.items, 1);
      assert.strictEqual(character.items.contents[0].name, item.name);
      assert.strictEqual(character.items.contents[0].type, item.type);
    });
    it("Clears all items no actions present", async () => {
      const item = await testItem.create({ type: "weapon" });
      const character = await testActor.create({ type: actorType });
      await character.createEmbeddedDocuments("Item", [item]);
      await new SpiritImporter().importChummerCharacter(character, chummerFile, importOptions);
      assert.isEmpty(character.items);
    });
    it("Clears all items but actions", async () => {
      const item = await testItem.create({ type: "action" });
      const character = await testActor.create({ type: actorType });
      await character.createEmbeddedDocuments("Item", [item]);
      await new SpiritImporter().importChummerCharacter(character, chummerFile, importOptions);
      assert.lengthOf(character.items, 1);
      assert.strictEqual(character.items.contents[0].name, item.name);
      assert.strictEqual(character.items.contents[0].type, item.type);
    });
  });
}, "spiritImporterTesting");

// src/unittests/actorImport/spiritImporter/sr5.SpiritInfoUpdater.spec.ts
var spiritInfoUpdaterTesting = /* @__PURE__ */ __name((context) => {
  const { describe, it, assert, before, after } = context;
  let testActorFactory;
  const actorType = "spirit";
  const importOptions = {};
  let chummerFile;
  before(async () => {
    testActorFactory = new SR6TestingDocuments(SR6Actor);
  });
  beforeEach(async () => {
    chummerFile = structuredClone(emptySpirit);
  });
  after(async () => {
    await testActorFactory.teardown();
  });
  describe("Chummer Info Updater handles alias correctly", () => {
    it("Imports name", async () => {
      chummerFile.characters.character.alias = "ImportTester";
      const character = await testActorFactory.create({ "type": actorType });
      await new SpiritImporter().importChummerCharacter(character, chummerFile, importOptions);
      assert.strictEqual(character.name, "ImportTester");
      assert.strictEqual(character.prototypeToken.name, "ImportTester");
    });
    it("Sets placeholder when no alias", async () => {
      const character = await testActorFactory.create({ "type": actorType });
      await new SpiritImporter().importChummerCharacter(character, chummerFile, importOptions);
      assert.strictEqual(character.name, "[Name not found]");
      assert.strictEqual(character.prototypeToken.name, "[Name not found]");
    });
  });
  describe("Chummer Info Updater handles attributes correctly", () => {
    it("Imports force attribute", async () => {
      chummerFile.characters.character = {
        attributes: [
          "0",
          {
            attributecategory_english: "Standard",
            attribute: [
              {
                name_english: "MAG",
                total: "3"
              }
            ]
          }
        ]
      };
      const character = await testActorFactory.create({ "type": actorType });
      await new SpiritImporter().importChummerCharacter(character, chummerFile, importOptions);
      assert.strictEqual(character.system.force, 3);
    });
  });
  describe("Chummer Info Updater handles spirit type correctly", () => {
    it("maps existing spirit type", async () => {
      chummerFile.characters.character.metatype_english = "Spirit of Fire";
      const character = await testActorFactory.create({ "type": actorType });
      await new SpiritImporter().importChummerCharacter(character, chummerFile, importOptions);
      assert.strictEqual(character.system.spiritType, "fire");
    });
    it("writes nothing when spirit type not found", async () => {
      chummerFile.characters.character.metatype_english = "Spirit of Bullshit";
      const character = await testActorFactory.create({ "type": actorType });
      await new SpiritImporter().importChummerCharacter(character, chummerFile, importOptions);
      assert.strictEqual(character.system.spiritType, "");
    });
  });
}, "spiritInfoUpdaterTesting");

// src/unittests/actorImport/itemImporter/weaponImport/sr5.WeaponImport.spec.ts
var weaponParserTesting = /* @__PURE__ */ __name((context) => {
  const { describe, it, assert, before, after } = context;
  let chummerCharacter;
  let chummerRangedWeapon = {
    guid: "8a88eb37-cf7b-4c0b-bb73-74f950e33fc8",
    sourceid: "61c59a89-3c51-46b7-880a-933b29394315",
    name: "Ruger Super Warhawk",
    fullname: "Ruger Super Warhawk",
    name_english: "Ruger Super Warhawk",
    category: "Heavy Pistols",
    category_english: "Heavy Pistols",
    type: "Ranged",
    reach: "0",
    accuracy: "5 (8)",
    accuracy_noammo: "5 (8)",
    rawaccuracy: "5",
    damage: "11S",
    damage_noammo: "9P",
    damage_english: "11S",
    damage_noammo_english: "9P",
    rawdamage: "9P",
    ap: "-2",
    ap_noammo: "-3",
    rawap: "-2",
    mode: "SS",
    mode_noammo: "SS",
    rc: "2",
    rc_noammo: "2",
    rawrc: "0",
    ammo: "6(cy)",
    ammo_english: "6(cy)",
    maxammo: "6(cy)",
    conceal: "-5",
    avail: "6R",
    cost: "4,775",
    owncost: "400",
    weight: "0",
    ownweight: "0",
    source: "SR5",
    page: "427",
    weaponname: null,
    location: null,
    attack: "0",
    sleaze: "0",
    dataprocessing: "2",
    firewall: "2",
    devicerating: "2",
    programlimit: "0",
    iscommlink: "False",
    isprogram: "False",
    active: "False",
    homenode: "False",
    conditionmonitor: "9",
    matrixcmfilled: "0",
    accessories: {
      accessory: [
        {
          guid: "f15e3860-c3c1-4eca-95ab-67c2b7eacfef",
          sourceid: "85b01b5c-c788-4b43-8190-9e0c18391436",
          name: "Personalized Grip",
          name_english: "Personalized Grip",
          mount: "None",
          extramount: "None",
          rc: null,
          conceal: "0",
          avail: "2",
          ratinglabel: "String_Rating",
          cost: "100",
          owncost: "100",
          weight: "0",
          ownweight: "0",
          included: "False",
          source: "HT",
          page: "182",
          accuracy: "+1",
          notes: "ANGEPASSTER GRIFF\nDurch diese Modikation kann der Besitzer einer Waffe diese exakt an Gr\xF6\xDFe und Form seiner Hand anpassen. Das ist besonders f\xFCr Metamenschen am oberen und unteren Ende der Gr\xF6\xDFenskala der Metamenschheit n\xFCtzlich. Die Modikation steigert die Pr\xE4zision der Waffe f\xFCr ihren Besitzer um 1."
        },
        {
          guid: "6e3b7028-299e-46cc-b140-6da3fb2d6ecd",
          sourceid: "ea64527d-0e1e-4248-957b-7c02d79dad30",
          name: "Concealed Quick-Draw Holster",
          name_english: "Concealed Quick-Draw Holster",
          mount: "None",
          extramount: "None",
          rc: null,
          conceal: "-1",
          avail: "6",
          ratinglabel: "String_Rating",
          cost: "275",
          owncost: "275",
          weight: "0",
          ownweight: "0",
          included: "False",
          source: "RG",
          page: "51",
          accuracy: "0",
          notes: null
        },
        {
          guid: "715bb07c-fbc4-4c2e-ae43-3dd5ca066eb7",
          sourceid: "d57d2c64-1f61-4f5f-a465-8ce0dfacec6a",
          name: "Smartgun System, Internal",
          name_english: "Smartgun System, Internal",
          mount: "None",
          extramount: "None",
          rc: null,
          conceal: "0",
          avail: "+2R",
          ratinglabel: "String_Rating",
          cost: "400",
          owncost: "400",
          weight: "0",
          ownweight: "0",
          included: "False",
          source: "SR5",
          page: "433",
          accuracy: "+2",
          gears: {
            gear: [
              {
                guid: "cf17ef4c-1535-4663-b64c-e1aedb53a996",
                sourceid: "3a79e046-8106-4089-a1ab-895eee956b86",
                name: "Laser Range Finder",
                name_english: "Laser Range Finder",
                category: "Sensor Functions",
                category_english: "Sensor Functions",
                ispersona: "False",
                isammo: "False",
                issin: "False",
                capacity: "[1]",
                armorcapacity: "[1]",
                maxrating: null,
                rating: "0",
                qty: "1",
                avail: "0",
                avail_english: "0",
                cost: "0",
                owncost: "1",
                weight: "0",
                ownweight: "0",
                extra: null,
                bonded: "False",
                equipped: "True",
                wirelesson: "False",
                location: null,
                gearname: null,
                source: "SR5",
                page: "446",
                attack: "0",
                sleaze: "0",
                dataprocessing: "0",
                firewall: "0",
                devicerating: "0",
                programlimit: "0",
                iscommlink: "False",
                isprogram: "False",
                active: "False",
                homenode: "False",
                conditionmonitor: "8",
                matrixcmfilled: "0",
                children: null,
                weaponbonusdamage: "+0",
                weaponbonusdamage_english: "+0",
                weaponbonusap: "+0",
                weaponbonusacc: "+0",
                weaponbonusrange: "0",
                flechetteweaponbonusdamage: "+0",
                flechetteweaponbonusdamage_english: "+0",
                flechetteweaponbonusap: "+0",
                flechetteweaponbonusacc: "+0",
                flechetteweaponbonusrange: "0",
                notes: "Laser-Entfernungsmesser: Dieser einfache Sensor sendet einen Laserstrahl aus, der von der Oberfi \xE4che eines Ziels re- fi ektiert und von einem Detektor erfasst wird, um die genaue Entfernung zum Ziel zu berechnen."
              },
              {
                guid: "77b8308d-40b6-4b3a-aa48-5244be279863",
                sourceid: "fa6fa434-107b-4f36-a138-f98b044dae76",
                name: "Camera, Micro",
                name_english: "Camera, Micro",
                category: "Vision Devices",
                category_english: "Vision Devices",
                ispersona: "False",
                isammo: "False",
                issin: "False",
                capacity: "1",
                armorcapacity: "[1]",
                maxrating: null,
                rating: "0",
                qty: "1",
                avail: "0",
                avail_english: "0",
                cost: "0",
                owncost: "1",
                weight: "0",
                ownweight: "0",
                extra: null,
                bonded: "False",
                equipped: "True",
                wirelesson: "False",
                location: null,
                gearname: null,
                source: "SR5",
                page: "443",
                attack: "0",
                sleaze: "0",
                dataprocessing: "0",
                firewall: "0",
                devicerating: "0",
                programlimit: "0",
                iscommlink: "False",
                isprogram: "False",
                active: "False",
                homenode: "False",
                conditionmonitor: "8",
                matrixcmfilled: "0",
                children: null,
                weaponbonusdamage: "+0",
                weaponbonusdamage_english: "+0",
                weaponbonusap: "+0",
                weaponbonusacc: "+0",
                weaponbonusrange: "0",
                flechetteweaponbonusdamage: "+0",
                flechetteweaponbonusdamage_english: "+0",
                flechetteweaponbonusap: "+0",
                flechetteweaponbonusacc: "+0",
                flechetteweaponbonusrange: "0",
                notes: null
              }
            ]
          },
          notes: null
        },
        {
          guid: "b5e5dd9f-7b96-4254-b78c-c7beb6002ae3",
          sourceid: "03243dcd-fe82-441c-bee7-971949e80a33",
          name: "Slumratte",
          name_english: "Slumratte",
          mount: "None",
          extramount: "None",
          rc: null,
          conceal: "-1",
          avail: "0",
          ratinglabel: "String_Rating",
          cost: "0",
          owncost: "0",
          weight: "0",
          ownweight: "0",
          included: "False",
          source: "HT",
          page: "184",
          accuracy: "0",
          notes: "SLUMRATTE\n(KOSTEN: 5 KARMA)\nDer Charakter ist auf der Stra\xDFe aufgewachsen und hat schnell gelernt, dass er das Wenige, das er besa\xDF, gut verbergen musste. Und dass er nach M\xF6glichkeit auch eine verborgene Waffe tragen sollte. Wenn der Charakter einen Gegenstand am eigenen K\xF6rper oder unter der Kleidung versteckt, wird dessen Tarnmodikator zus\xE4tzlich um 1 gesenkt. Der Charakter kann gleichzeitig h\xF6chstens eine Anzahl von [Geschicklichkeit \xF7 2] Gegenst\xE4nden (aufgerundet) verstecken, damit diese die Senkung ihres Tarnmodikators erhalten."
        },
        {
          guid: "e83a9839-6ee9-4e69-a207-795b250f3b14",
          sourceid: "a0d3e552-a575-42b0-a532-340a4d079ea5",
          name: "Markentreue",
          name_english: "Markentreue",
          mount: "None",
          extramount: "None",
          rc: null,
          conceal: "0",
          avail: "0",
          ratinglabel: "String_Rating",
          cost: "0",
          owncost: "0",
          weight: "0",
          ownweight: "0",
          included: "False",
          source: "RG",
          page: "127",
          accuracy: "0",
          notes: "MARKENTREUE\nKOSTEN: 3 KARMA\nMarkentreue wird in der Sechsten Welt ins Extreme \xFCbersteigert.\nPersonen werden von ihren Konzernherren gehirngewaschen, und das kommt besonders bei Feuerwaffen zum Tragen. Manchmal kann Markentreue aber auch von Vorteil sein. Charaktere, die markentreu sind, kennen die Produkte ihrer Lieblingsmarke in- und auswendig. Diesen Vorteil gibt es auf zwei Ebenen: Hersteller und Produkt. Auf der Hersteller-Ebene w\xE4hlt der Charakter einen Hersteller wie zum Beispiel Ares, Saeder-Krupp, Krime, H&K oder Novatech aus und erh\xE4lt einen W\xFCrfelpoolbonus von +1 f\xFCr jede Probe mit Ger\xE4ten dieses Herstellers. Auf der Produkt-Ebene erh\xE4lt er den Bonus nur f\xFCr ein bestimmtes Ger\xE4t, wie zum Beispiel eine Ares Predator V, einen S-K-Bentley Concordat, eine Krime Kannon, eine HK227 oder ein Novatech Airware. Der Nachteil ist, dass ein Charakter, der so sehr von einer Marke abh\xE4ngt, einen W\xFCrfelpoolmalus von -1 erh\xE4lt, wenn er Ger\xE4te anderer Hersteller benutzt. Auf der Produkt-Ebene erh\xE4lt er einen W\xFCrfelpoolmalus von -1 f\xFCr alle Ger\xE4te desselben Typs anderer Hersteller, wie zum Beispiel schwere Pistolen, Autos, Maschinenpistolen, Sturmkanonen oder Kommlinks."
        },
        {
          guid: "ac1e4eeb-2158-4f7e-a4d2-9d96a01ad759",
          sourceid: "5cc39a55-3973-4368-81ee-c7a5c0432323",
          name: "Chameleon Coating (Pistol)",
          name_english: "Chameleon Coating (Pistol)",
          mount: "Side",
          extramount: "None",
          rc: null,
          conceal: "-2",
          avail: "10R",
          ratinglabel: "String_Rating",
          cost: "1,000",
          owncost: "1,000",
          weight: "0",
          ownweight: "0",
          included: "False",
          source: "HT",
          page: "180",
          accuracy: "0",
          notes: null
        },
        {
          guid: "5c74273b-5d82-48b1-bf14-ba385733a31e",
          sourceid: "21bc8b85-3fd7-4bde-ac8d-35e1fa099f21",
          name: "Improved Range Finder",
          name_english: "Improved Range Finder",
          mount: "Barrel",
          extramount: "None",
          rc: null,
          conceal: "0",
          avail: "6",
          ratinglabel: "String_Rating",
          cost: "2,000",
          owncost: "2,000",
          weight: "0",
          ownweight: "0",
          included: "False",
          source: "RG",
          page: "52",
          accuracy: "0",
          notes: null
        },
        {
          guid: "4026928a-e7e8-4e95-ad9e-65657716744f",
          sourceid: "93be91c1-3f77-4e7b-9ac2-eb349b76d017",
          name: "Special Modification: Improved Concealment",
          name_english: "Special Modification: Improved Concealment",
          mount: "None",
          extramount: "None",
          rc: null,
          conceal: "-1",
          avail: "0",
          ratinglabel: "String_Rating",
          cost: "0",
          owncost: "0",
          weight: "0",
          ownweight: "0",
          included: "False",
          source: "BTB",
          page: "161",
          accuracy: "0",
          notes: null
        },
        {
          guid: "23e5f9b6-2038-4f50-92aa-09ad6d7c4b39",
          sourceid: "b741b729-106e-46f2-9143-0f745fd48789",
          name: "Special Modification: Improved AP",
          name_english: "Special Modification: Improved AP",
          mount: "None",
          extramount: "None",
          rc: null,
          conceal: "0",
          avail: "0",
          ratinglabel: "String_Rating",
          cost: "0",
          owncost: "0",
          weight: "0",
          ownweight: "0",
          included: "False",
          source: "BTB",
          page: "161",
          accuracy: "0",
          notes: null
        },
        {
          guid: "43ced279-1a49-427b-8ea8-1aa2eec0a78c",
          sourceid: "4c47baf0-6b34-4e00-8627-a0f605f84ba0",
          name: "Speed Loader",
          name_english: "Speed Loader",
          mount: "None",
          extramount: "None",
          rc: null,
          conceal: "0",
          avail: "2",
          ratinglabel: "String_Rating",
          cost: "25",
          owncost: "25",
          weight: "0",
          ownweight: "0",
          included: "False",
          source: "SR5",
          page: "433",
          accuracy: "0",
          notes: "Schnelllader: Der Schnelllader ist eine einfache Vorrich- tung, die einen Ring von Kugeln h\xE4lt, die dadurch schneller in die Trommel eines Revolvers geladen werden k\xF6nnen. Je- der Schnelllader ist speziell f\xFCr die Waffe angepasst, f\xFCr die er entwickelt wurde. Mit einem Schnelllader kann man einen Re- volver mittels einer Komplexen Handlung vollst\xE4ndig laden, statt eine Kugel nach der anderen reinschieben zu m\xFCssen (s. Tabelle Waffen Nachladen, S. 165)."
        },
        {
          guid: "277204e1-5a44-4d0f-af2a-94e6f6280b71",
          sourceid: "4c47baf0-6b34-4e00-8627-a0f605f84ba0",
          name: "Speed Loader",
          name_english: "Speed Loader",
          mount: "None",
          extramount: "None",
          rc: null,
          conceal: "0",
          avail: "2",
          ratinglabel: "String_Rating",
          cost: "25",
          owncost: "25",
          weight: "0",
          ownweight: "0",
          included: "False",
          source: "SR5",
          page: "433",
          accuracy: "0",
          notes: "Schnelllader: Der Schnelllader ist eine einfache Vorrich- tung, die einen Ring von Kugeln h\xE4lt, die dadurch schneller in die Trommel eines Revolvers geladen werden k\xF6nnen. Je- der Schnelllader ist speziell f\xFCr die Waffe angepasst, f\xFCr die er entwickelt wurde. Mit einem Schnelllader kann man einen Re- volver mittels einer Komplexen Handlung vollst\xE4ndig laden, statt eine Kugel nach der anderen reinschieben zu m\xFCssen (s. Tabelle Waffen Nachladen, S. 165)."
        },
        {
          guid: "2c78e5bd-2921-4605-b88f-130838ecd8d5",
          sourceid: "4c47baf0-6b34-4e00-8627-a0f605f84ba0",
          name: "Speed Loader",
          name_english: "Speed Loader",
          mount: "None",
          extramount: "None",
          rc: null,
          conceal: "0",
          avail: "2",
          ratinglabel: "String_Rating",
          cost: "25",
          owncost: "25",
          weight: "0",
          ownweight: "0",
          included: "False",
          source: "SR5",
          page: "433",
          accuracy: "0",
          notes: "Schnelllader: Der Schnelllader ist eine einfache Vorrich- tung, die einen Ring von Kugeln h\xE4lt, die dadurch schneller in die Trommel eines Revolvers geladen werden k\xF6nnen. Je- der Schnelllader ist speziell f\xFCr die Waffe angepasst, f\xFCr die er entwickelt wurde. Mit einem Schnelllader kann man einen Re- volver mittels einer Komplexen Handlung vollst\xE4ndig laden, statt eine Kugel nach der anderen reinschieben zu m\xFCssen (s. Tabelle Waffen Nachladen, S. 165)."
        },
        {
          guid: "8f08edfb-1465-4338-a73e-3600b2a3cbde",
          sourceid: "4c47baf0-6b34-4e00-8627-a0f605f84ba0",
          name: "Speed Loader",
          name_english: "Speed Loader",
          mount: "None",
          extramount: "None",
          rc: null,
          conceal: "0",
          avail: "2",
          ratinglabel: "String_Rating",
          cost: "25",
          owncost: "25",
          weight: "0",
          ownweight: "0",
          included: "False",
          source: "SR5",
          page: "433",
          accuracy: "0",
          notes: "Schnelllader: Der Schnelllader ist eine einfache Vorrich- tung, die einen Ring von Kugeln h\xE4lt, die dadurch schneller in die Trommel eines Revolvers geladen werden k\xF6nnen. Je- der Schnelllader ist speziell f\xFCr die Waffe angepasst, f\xFCr die er entwickelt wurde. Mit einem Schnelllader kann man einen Re- volver mittels einer Komplexen Handlung vollst\xE4ndig laden, statt eine Kugel nach der anderen reinschieben zu m\xFCssen (s. Tabelle Waffen Nachladen, S. 165)."
        },
        {
          guid: "84eb2269-929f-4d20-a31e-1c82b932fe54",
          sourceid: "806bfacc-095e-448d-a5b2-c271c569ae51",
          name: "Melee Hardening",
          name_english: "Melee Hardening",
          mount: "None",
          extramount: "None",
          rc: null,
          conceal: "0",
          avail: "6",
          ratinglabel: "String_Rating",
          cost: "500",
          owncost: "500",
          weight: "0",
          ownweight: "0",
          included: "False",
          source: "HT",
          page: "181",
          accuracy: "0",
          notes: null
        }
      ]
    },
    ranges: [
      {
        name: "Heavy Pistols",
        short: "0-5",
        medium: "6-20",
        long: "21-40",
        extreme: "41-60"
      },
      {
        name: "Heavy Pistols",
        short: "0-5",
        medium: "6-20",
        long: "21-40",
        extreme: "41-60"
      }
    ],
    alternateranges: [
      {
        name: null,
        short: null,
        medium: null,
        long: null,
        extreme: null
      },
      {
        name: null,
        short: null,
        medium: null,
        long: null,
        extreme: null
      }
    ],
    availableammo: "140",
    currentammo: "Ammo +DV: Gel Rounds",
    clips: {
      clip: [
        {
          name: "Ammo +DV: Gel Rounds",
          count: "6",
          location: "loaded",
          id: "b1b49412-d21c-4bbe-87fc-667f9f963422",
          ammotype: {
            weaponbonusdamage: "+2S",
            weaponbonusdamage_english: "+2S",
            weaponbonusap: "+1",
            weaponbonusacc: "+0",
            weaponbonusrange: "0",
            flechetteweaponbonusdamage: "+0",
            flechetteweaponbonusdamage_english: "+0",
            flechetteweaponbonusap: "+0",
            flechetteweaponbonusacc: "+0",
            flechetteweaponbonusrange: "0",
            DV: "+2S",
            BonusRange: "0"
          }
        },
        {
          name: "Ammo +DV: APDS",
          count: "6",
          location: "loaded",
          id: "7f937f11-bcdd-4472-a840-c645143ddfa8",
          ammotype: {
            weaponbonusdamage: "+1",
            weaponbonusdamage_english: "+1",
            weaponbonusap: "-4",
            weaponbonusacc: "+0",
            weaponbonusrange: "0",
            flechetteweaponbonusdamage: "+0",
            flechetteweaponbonusdamage_english: "+0",
            flechetteweaponbonusap: "+0",
            flechetteweaponbonusacc: "+0",
            flechetteweaponbonusrange: "0",
            DV: "+1",
            BonusRange: "0"
          }
        },
        {
          name: "Ammo: APDS",
          count: "6",
          location: "loaded",
          id: "2e466af5-71c9-4051-8c87-3059c5c9605c",
          ammotype: {
            weaponbonusdamage: "+0",
            weaponbonusdamage_english: "+0",
            weaponbonusap: "-4",
            weaponbonusacc: "+0",
            weaponbonusrange: "0",
            flechetteweaponbonusdamage: "+0",
            flechetteweaponbonusdamage_english: "+0",
            flechetteweaponbonusap: "+0",
            flechetteweaponbonusacc: "+0",
            flechetteweaponbonusrange: "0",
            DV: "+0",
            BonusRange: "0"
          }
        },
        {
          name: "Ammo +DV: Explosive Rounds",
          count: "6",
          location: "loaded",
          id: "172fa39f-ce43-4533-86a9-4a6ebf304b1c",
          ammotype: {
            weaponbonusdamage: "+2",
            weaponbonusdamage_english: "+2",
            weaponbonusap: "-1",
            weaponbonusacc: "+0",
            weaponbonusrange: "0",
            flechetteweaponbonusdamage: "+0",
            flechetteweaponbonusdamage_english: "+0",
            flechetteweaponbonusap: "+0",
            flechetteweaponbonusacc: "+0",
            flechetteweaponbonusrange: "0",
            DV: "+2",
            BonusRange: "0"
          }
        },
        {
          name: "Ammo: Tracker Rounds, Stealth Tag",
          count: "6",
          location: "loaded",
          id: "95deb6d2-db28-4d0c-bdae-39312468b184",
          ammotype: {
            weaponbonusdamage: "+0",
            weaponbonusdamage_english: "+0",
            weaponbonusap: "+0",
            weaponbonusacc: "+0",
            weaponbonusrange: "0",
            flechetteweaponbonusdamage: "+0",
            flechetteweaponbonusdamage_english: "+0",
            flechetteweaponbonusap: "+0",
            flechetteweaponbonusacc: "+0",
            flechetteweaponbonusrange: "0",
            DV: "+0",
            BonusRange: "0"
          }
        }
      ]
    },
    dicepool: "23",
    dicepool_noammo: "23",
    skill: "Pistols",
    wirelesson: "True",
    notes: null
  };
  let weaponParser = new WeaponParser();
  beforeEach(async () => {
    chummerCharacter = {};
  });
  describe("Weapon Parser can handle inputs", () => {
    it("has null in character", async () => {
      chummerCharacter = {
        weapons: null
      };
      let weapons3 = await weaponParser.parseWeapons(chummerCharacter);
      assert.lengthOf(weapons3, 0);
    });
    it("has empty array in character", async () => {
      chummerCharacter = {
        weapons: []
      };
      let weapons3 = await weaponParser.parseWeapons(chummerCharacter);
      assert.lengthOf(weapons3, 0);
    });
    it("is missing weapons in character", async () => {
      let weapons3 = await weaponParser.parseWeapons(chummerCharacter);
      assert.lengthOf(weapons3, 0);
    });
    it("has weapon in character", async () => {
      chummerCharacter = {
        weapons: {
          weapon: chummerRangedWeapon
        }
      };
      let weapons3 = await weaponParser.parseWeapons(chummerCharacter);
      assert.lengthOf(weapons3, 1);
    });
    it("weaponArray with empty array", async () => {
      let weapons3 = await weaponParser.parseWeaponArray([]);
      assert.lengthOf(weapons3, 0);
    });
    it("weaponArray with one weapon", async () => {
      let chummerWeapons = [chummerRangedWeapon];
      let weapons3 = await weaponParser.parseWeaponArray(chummerWeapons);
      assert.lengthOf(weapons3, 1);
    });
  });
  describe("Weapon Parser imports weapon", () => {
    it("weapon with values - english", async () => {
      chummerCharacter = {
        weapons: {
          weapon: chummerRangedWeapon
        }
      };
      let weapons3 = await weaponParser.parseWeapons(chummerCharacter);
      assert.lengthOf(weapons3, 1);
      let weapon = weapons3[0];
      assert.strictEqual(weapon.name, "Ruger Super Warhawk");
      assert.strictEqual(weapon.type, "weapon");
      assert.strictEqual(weapon.system.action.attribute, "agility");
      assert.strictEqual(weapon.system.action.damage.base, 9);
      assert.strictEqual(weapon.system.action.damage.ap.base, -2);
      assert.strictEqual(weapon.system.action.damage.type.base, "physical");
      assert.strictEqual(weapon.system.action.limit.base, 5);
      assert.strictEqual(weapon.system.action.type, "varies");
      assert.strictEqual(weapon.system.category, "range");
      assert.strictEqual(weapon.system.description.source, "SR5 427");
      assert.strictEqual(weapon.system.importFlags.isFreshImport, true);
      assert.strictEqual(weapon.system.range.ranges.extreme, 60);
      assert.strictEqual(weapon.system.range.ranges.long, 40);
      assert.strictEqual(weapon.system.range.ranges.medium, 20);
      assert.strictEqual(weapon.system.range.ranges.short, 5);
      assert.strictEqual(weapon.system.range.modes.single_shot, true);
    });
  });
}, "weaponParserTesting");

// src/unittests/actorImport/itemImporter/vehicleImport/drone.json
var drone_exports = {};
__export(drone_exports, {
  accel: () => accel,
  active: () => active,
  armor: () => armor,
  attack: () => attack,
  avail: () => avail,
  body: () => body,
  category: () => category,
  category_english: () => category_english,
  cost: () => cost,
  dataprocessing: () => dataprocessing,
  default: () => drone_default,
  devicerating: () => devicerating,
  firewall: () => firewall,
  fullname: () => fullname,
  gears: () => gears,
  guid: () => guid,
  handling: () => handling,
  homenode: () => homenode,
  iscommlink: () => iscommlink,
  isdrone: () => isdrone,
  isprogram: () => isprogram,
  location: () => location,
  maneuver: () => maneuver,
  matrixcm: () => matrixcm,
  matrixcmfilled: () => matrixcmfilled,
  mods: () => mods,
  name: () => name,
  name_english: () => name_english,
  owncost: () => owncost,
  page: () => page,
  physicalcm: () => physicalcm,
  physicalcmfilled: () => physicalcmfilled,
  pilot: () => pilot,
  programlimit: () => programlimit,
  seats: () => seats,
  sensor: () => sensor,
  sleaze: () => sleaze,
  source: () => source,
  sourceid: () => sourceid,
  speed: () => speed,
  vehiclename: () => vehiclename,
  weapons: () => weapons
});
var guid = "cb8dfbb8-33c1-437b-93b4-e1c19384e3ae";
var sourceid = "e338dcf9-3149-4519-9228-589354be5667";
var name = "SomeBrand Hunter Drone";
var name_english = "SomeBrand Hunter Drone";
var fullname = "SomeBrand Hunter Drone";
var category = "Gro\xDFe Drohnen";
var category_english = "Drones: Large";
var isdrone = "True";
var handling = "5";
var accel = "2";
var speed = "4";
var pilot = "3";
var body = "6";
var armor = "8";
var seats = "0";
var sensor = "3";
var avail = "10V";
var cost = "31.350";
var owncost = "28.800";
var source = "SAG";
var page = "69";
var physicalcm = "9";
var physicalcmfilled = "0";
var vehiclename = null;
var maneuver = "0";
var location = null;
var attack = "0";
var sleaze = "0";
var dataprocessing = "3";
var firewall = "3";
var devicerating = "3";
var programlimit = "3";
var iscommlink = "False";
var isprogram = "False";
var active = "False";
var homenode = "False";
var matrixcm = "10";
var matrixcmfilled = "0";
var mods = {
  mod: [
    {
      guid: "3cde5586-094c-488e-8379-782a73c3998e",
      sourceid: "518a5fdc-3b2c-42a6-a3fb-3cb88918fe72",
      name: "ECM",
      name_english: "ECM",
      fullname: "ECM (Stufe 3)",
      category: "Electromagnetic",
      category_english: "Electromagnetic",
      limit: null,
      slots: "2",
      rating: "3",
      ratinglabel: "String_Rating",
      avail: "9V",
      cost: "1.500",
      owncost: "1.500",
      source: "R5",
      wirelesson: "False",
      page: "173",
      included: "True",
      weapons: null,
      cyberwares: null
    },
    {
      guid: "f66fa2cf-dd5c-4a6e-a425-93290fffd18c",
      sourceid: "30099989-d8ca-4f9c-adf0-1de36b6f8ab6",
      source: "R5",
      name: "Riesig",
      name_english: "Huge (Drone)",
      fullname: "Riesig (Fest, Ferngesteuert, Extern)",
      category: "Size",
      category_english: "Size",
      limit: null,
      slots: "5",
      avail: "16V",
      cost: "1.950",
      owncost: "3.000",
      page: "132",
      location: null,
      included: "True",
      weapons: {
        weapon: {
          guid: "119bc767-e10c-4816-82b5-fac94f2c4291",
          sourceid: "23141cfc-e7c9-4af9-b4e0-a7f0443f1170",
          name: "Shiawase Arms Monsoon",
          fullname: "Shiawase Arms Monsoon",
          name_english: "Shiawase Arms Monsoon",
          category: "Sturmgewehre",
          category_english: "Assault Rifles",
          type: "Ranged",
          reach: "0",
          accuracy: "5 (7)",
          accuracy_noammo: "5 (7)",
          rawaccuracy: "5",
          damage: "10K",
          damage_noammo: "10K",
          damage_english: "10P",
          damage_noammo_english: "10P",
          rawdamage: "10P",
          ap: "-1",
          ap_noammo: "-1",
          rawap: "-1",
          mode: "HM/AM",
          mode_noammo: "HM/AM",
          rc: "2",
          rc_noammo: "2",
          rawrc: "0",
          ammo: "20(v)",
          ammo_english: "20(ml)",
          maxammo: "20(ml)",
          conceal: "+6",
          avail: "10V",
          cost: "1.900",
          owncost: "1.900",
          weight: "0",
          ownweight: "0",
          source: "GH3",
          page: "13",
          weaponname: null,
          location: null,
          attack: "0",
          sleaze: "0",
          dataprocessing: "2",
          firewall: "2",
          devicerating: "2",
          programlimit: "0",
          iscommlink: "False",
          isprogram: "False",
          active: "False",
          homenode: "False",
          conditionmonitor: "9",
          matrixcmfilled: "0",
          accessories: {
            accessory: [
              {
                guid: "ea8dde14-ef8a-4e7e-acc2-50f9478a353d",
                sourceid: "2da4f104-cf0c-4e0c-a001-4a6da4c2b46b",
                name: "Elektronisches Feuern",
                name_english: "Electronic Firing",
                mount: "Internal",
                extramount: "None",
                rc: "1",
                conceal: "0",
                avail: "10E",
                ratinglabel: "String_Rating",
                cost: "0",
                owncost: "0",
                weight: "0",
                ownweight: "0",
                included: "True",
                source: "HT",
                page: "172",
                accuracy: "0"
              },
              {
                guid: "bb716d62-cdfa-4f7d-9d20-02c6490d9779",
                sourceid: "d57d2c64-1f61-4f5f-a465-8ce0dfacec6a",
                name: "Smartgunsystem, intern",
                name_english: "Smartgun System, Internal",
                mount: "Internal",
                extramount: "None",
                rc: null,
                conceal: "0",
                avail: "+2E",
                ratinglabel: "String_Rating",
                cost: "0",
                owncost: "0",
                weight: "0",
                ownweight: "0",
                included: "True",
                source: "SR5",
                page: "435",
                accuracy: "+2",
                gears: {
                  gear: [
                    {
                      guid: "e17745b5-f978-4813-9116-fe93eda45142",
                      sourceid: "3a79e046-8106-4089-a1ab-895eee956b86",
                      name: "Laser-Entfernungsmesser",
                      name_english: "Laser Range Finder",
                      category: "Sensor-Funktionen",
                      category_english: "Sensor Functions",
                      ispersona: "False",
                      isammo: "False",
                      issin: "False",
                      capacity: "[1]",
                      armorcapacity: "[1]",
                      maxrating: null,
                      rating: "0",
                      qty: "1",
                      avail: "0",
                      avail_english: "0",
                      cost: "0",
                      owncost: "1",
                      weight: "0",
                      ownweight: "0",
                      extra: null,
                      bonded: "False",
                      equipped: "True",
                      wirelesson: "False",
                      location: null,
                      gearname: null,
                      source: "SR5",
                      page: "450",
                      attack: "0",
                      sleaze: "0",
                      dataprocessing: "0",
                      firewall: "0",
                      devicerating: "0",
                      programlimit: "0",
                      iscommlink: "False",
                      isprogram: "False",
                      active: "False",
                      homenode: "False",
                      conditionmonitor: "8",
                      matrixcmfilled: "0",
                      children: null,
                      weaponbonusdamage: "+0",
                      weaponbonusdamage_english: "+0",
                      weaponbonusap: "+0",
                      weaponbonusacc: "+0",
                      weaponbonusrange: "0",
                      flechetteweaponbonusdamage: "+0",
                      flechetteweaponbonusdamage_english: "+0",
                      flechetteweaponbonusap: "+0",
                      flechetteweaponbonusacc: "+0",
                      flechetteweaponbonusrange: "0"
                    },
                    {
                      guid: "2d57ce71-de31-4a95-b751-4b37a5609bac",
                      sourceid: "fa6fa434-107b-4f36-a138-f98b044dae76",
                      name: "Mikrokamera",
                      name_english: "Camera, Micro",
                      category: "Sichtger\xE4te",
                      category_english: "Vision Devices",
                      ispersona: "False",
                      isammo: "False",
                      issin: "False",
                      capacity: "1",
                      armorcapacity: "[1]",
                      maxrating: null,
                      rating: "0",
                      qty: "1",
                      avail: "0",
                      avail_english: "0",
                      cost: "0",
                      owncost: "1",
                      weight: "0",
                      ownweight: "0",
                      extra: null,
                      bonded: "False",
                      equipped: "True",
                      wirelesson: "False",
                      location: null,
                      gearname: null,
                      source: "SR5",
                      page: "447",
                      attack: "0",
                      sleaze: "0",
                      dataprocessing: "0",
                      firewall: "0",
                      devicerating: "0",
                      programlimit: "0",
                      iscommlink: "False",
                      isprogram: "False",
                      active: "False",
                      homenode: "False",
                      conditionmonitor: "8",
                      matrixcmfilled: "0",
                      children: null,
                      weaponbonusdamage: "+0",
                      weaponbonusdamage_english: "+0",
                      weaponbonusap: "+0",
                      weaponbonusacc: "+0",
                      weaponbonusrange: "0",
                      flechetteweaponbonusdamage: "+0",
                      flechetteweaponbonusdamage_english: "+0",
                      flechetteweaponbonusap: "+0",
                      flechetteweaponbonusacc: "+0",
                      flechetteweaponbonusrange: "0"
                    }
                  ]
                }
              }
            ]
          },
          ranges: [
            {
              name: "Sturmgewehre",
              short: "0-25",
              medium: "26-150",
              long: "151-350",
              extreme: "351-550"
            },
            {
              name: "Sturmgewehre",
              short: "0-25",
              medium: "26-150",
              long: "151-350",
              extreme: "351-550"
            }
          ],
          alternateranges: [
            {
              name: null,
              short: null,
              medium: null,
              long: null,
              extreme: null
            },
            {
              name: null,
              short: null,
              medium: null,
              long: null,
              extreme: null
            }
          ],
          availableammo: "60",
          currentammo: "-",
          clips: null,
          dicepool: "14",
          dicepool_noammo: "14",
          skill: "Automatics",
          wirelesson: "True"
        }
      },
      mods: {
        mod: {
          guid: "657a930c-8a11-4843-96f1-822090ec6cc3",
          sourceid: "c3f9f5a4-b8d4-11e6-80f5-76304dec7eb7",
          name: "Gr\xF6\xDFerer Munitionsvorrat (Zweiter Beh\xE4lter)",
          name_english: "Expanded Ammunition Bay (Second Bin) Weapon Mount Add-on (Drone)",
          fullname: "Gr\xF6\xDFerer Munitionsvorrat (Zweiter Beh\xE4lter)",
          category: "All",
          category_english: "All",
          limit: null,
          slots: "1",
          rating: "0",
          ratinglabel: "String_Rating",
          avail: "0",
          cost: "50",
          owncost: "50",
          source: "R5",
          wirelesson: "False",
          page: "132",
          included: "True",
          weapons: null,
          cyberwares: null
        }
      }
    }
  ]
};
var gears = {
  gear: [
    {
      guid: "70d28c3e-8689-4d52-8cd1-6d3b66278d6e",
      sourceid: "2ca81a10-d0f7-4b39-ac93-a84f2f69f9d9",
      name: "Sensorarray",
      name_english: "Sensor Array",
      category: "Sensorpakete",
      category_english: "Sensors",
      ispersona: "False",
      isammo: "False",
      issin: "False",
      capacity: "8/[0]",
      armorcapacity: "[0]",
      maxrating: "8",
      rating: "3",
      qty: "1",
      avail: "7",
      avail_english: "7",
      cost: "0",
      owncost: "1",
      weight: "0",
      ownweight: "0",
      extra: null,
      bonded: "False",
      equipped: "True",
      wirelesson: "False",
      location: null,
      gearname: null,
      source: "SR5",
      page: "445",
      attack: "0",
      sleaze: "0",
      dataprocessing: "0",
      firewall: "0",
      devicerating: "0",
      programlimit: "0",
      iscommlink: "False",
      isprogram: "False",
      active: "False",
      homenode: "False",
      conditionmonitor: "8",
      matrixcmfilled: "0",
      children: {
        gear: [
          {
            guid: "c1c7a346-954c-4de7-8236-746337a22632",
            sourceid: "07805498-75ea-441f-bd27-6536d4131b51",
            name: "Kamera",
            name_english: "Camera",
            category: "Sensor-Funktionen",
            category_english: "Sensor Functions",
            ispersona: "False",
            isammo: "False",
            issin: "False",
            capacity: "Rating/[1]",
            armorcapacity: "Rating/[1]",
            maxrating: "{Parent Rating}",
            rating: "3",
            qty: "1",
            avail: "0",
            avail_english: "0",
            cost: "0",
            owncost: "0",
            weight: "0",
            ownweight: "0",
            extra: null,
            bonded: "False",
            equipped: "True",
            wirelesson: "False",
            location: null,
            gearname: null,
            source: "SR5",
            page: "447",
            attack: "0",
            sleaze: "0",
            dataprocessing: "0",
            firewall: "0",
            devicerating: "0",
            programlimit: "0",
            iscommlink: "False",
            isprogram: "False",
            active: "False",
            homenode: "False",
            conditionmonitor: "8",
            matrixcmfilled: "0",
            children: null,
            weaponbonusdamage: "+0",
            weaponbonusdamage_english: "+0",
            weaponbonusap: "+0",
            weaponbonusacc: "+0",
            weaponbonusrange: "0",
            flechetteweaponbonusdamage: "+0",
            flechetteweaponbonusdamage_english: "+0",
            flechetteweaponbonusap: "+0",
            flechetteweaponbonusacc: "+0",
            flechetteweaponbonusrange: "0"
          },
          {
            guid: "ae6226c6-3f66-402e-8a01-f7029f7b5492",
            sourceid: "adf3533a-461c-46ae-9ee7-77dfd31c5d5a",
            name: "Sichtvergr\xF6\xDFerung",
            name_english: "Vision Magnification",
            category: "Sensor-Funktionen",
            category_english: "Sensor Functions",
            ispersona: "False",
            isammo: "False",
            issin: "False",
            capacity: "[1]",
            armorcapacity: "[1]",
            maxrating: null,
            rating: "0",
            qty: "1",
            avail: "0",
            avail_english: "0",
            cost: "0",
            owncost: "0",
            weight: "0",
            ownweight: "0",
            extra: null,
            bonded: "False",
            equipped: "True",
            wirelesson: "False",
            location: null,
            gearname: null,
            source: "SR5",
            page: "458",
            attack: "0",
            sleaze: "0",
            dataprocessing: "0",
            firewall: "0",
            devicerating: "0",
            programlimit: "0",
            iscommlink: "False",
            isprogram: "False",
            active: "False",
            homenode: "False",
            conditionmonitor: "8",
            matrixcmfilled: "0",
            children: null,
            weaponbonusdamage: "+0",
            weaponbonusdamage_english: "+0",
            weaponbonusap: "+0",
            weaponbonusacc: "+0",
            weaponbonusrange: "0",
            flechetteweaponbonusdamage: "+0",
            flechetteweaponbonusdamage_english: "+0",
            flechetteweaponbonusap: "+0",
            flechetteweaponbonusacc: "+0",
            flechetteweaponbonusrange: "0"
          },
          {
            guid: "43e69eb8-cc8d-4aa5-9106-bc22ff0a44d5",
            sourceid: "e853967a-a2b8-4d89-9a97-773034489a16",
            name: "Bewegungsmelder",
            name_english: "Motion Sensor",
            category: "Sensor-Funktionen",
            category_english: "Sensor Functions",
            ispersona: "False",
            isammo: "False",
            issin: "False",
            capacity: "[1]",
            armorcapacity: "[1]",
            maxrating: null,
            rating: "0",
            qty: "1",
            avail: "0",
            avail_english: "0",
            cost: "0",
            owncost: "0",
            weight: "0",
            ownweight: "0",
            extra: null,
            bonded: "False",
            equipped: "True",
            wirelesson: "False",
            location: null,
            gearname: null,
            source: "SR5",
            page: "450",
            attack: "0",
            sleaze: "0",
            dataprocessing: "0",
            firewall: "0",
            devicerating: "0",
            programlimit: "0",
            iscommlink: "False",
            isprogram: "False",
            active: "False",
            homenode: "False",
            conditionmonitor: "8",
            matrixcmfilled: "0",
            children: null,
            weaponbonusdamage: "+0",
            weaponbonusdamage_english: "+0",
            weaponbonusap: "+0",
            weaponbonusacc: "+0",
            weaponbonusrange: "0",
            flechetteweaponbonusdamage: "+0",
            flechetteweaponbonusdamage_english: "+0",
            flechetteweaponbonusap: "+0",
            flechetteweaponbonusacc: "+0",
            flechetteweaponbonusrange: "0"
          },
          {
            guid: "fb91dcb9-22bf-48ac-a88f-77a2bdb0a42a",
            sourceid: "4d12e4a1-edd3-4abf-830f-aa95874b7531",
            name: "Radiosignalscanner",
            name_english: "Radio Signal Scanner",
            category: "Sensor-Funktionen",
            category_english: "Sensor Functions",
            ispersona: "False",
            isammo: "False",
            issin: "False",
            capacity: "[1]",
            armorcapacity: "[1]",
            maxrating: null,
            rating: "0",
            qty: "1",
            avail: "0",
            avail_english: "0",
            cost: "0",
            owncost: "0",
            weight: "0",
            ownweight: "0",
            extra: null,
            bonded: "False",
            equipped: "True",
            wirelesson: "False",
            location: null,
            gearname: null,
            source: "SR5",
            page: "450",
            attack: "0",
            sleaze: "0",
            dataprocessing: "0",
            firewall: "0",
            devicerating: "0",
            programlimit: "0",
            iscommlink: "False",
            isprogram: "False",
            active: "False",
            homenode: "False",
            conditionmonitor: "8",
            matrixcmfilled: "0",
            children: null,
            weaponbonusdamage: "+0",
            weaponbonusdamage_english: "+0",
            weaponbonusap: "+0",
            weaponbonusacc: "+0",
            weaponbonusrange: "0",
            flechetteweaponbonusdamage: "+0",
            flechetteweaponbonusdamage_english: "+0",
            flechetteweaponbonusap: "+0",
            flechetteweaponbonusacc: "+0",
            flechetteweaponbonusrange: "0"
          },
          {
            guid: "77b66521-9295-4662-b3b6-cfafb4cb0abd",
            sourceid: "f25e4819-209c-4cbf-b24f-668359a7a2ad",
            name: "Lasermikrofon",
            name_english: "Laser Microphone",
            category: "Sensor-Funktionen",
            category_english: "Sensor Functions",
            ispersona: "False",
            isammo: "False",
            issin: "False",
            capacity: "Rating/[1]",
            armorcapacity: "Rating/[1]",
            maxrating: "{Parent Rating}",
            rating: "3",
            qty: "1",
            avail: "0",
            avail_english: "0",
            cost: "0",
            owncost: "0",
            weight: "0",
            ownweight: "0",
            extra: null,
            bonded: "False",
            equipped: "True",
            wirelesson: "False",
            location: null,
            gearname: null,
            source: "SR5",
            page: "449",
            attack: "0",
            sleaze: "0",
            dataprocessing: "0",
            firewall: "0",
            devicerating: "0",
            programlimit: "0",
            iscommlink: "False",
            isprogram: "False",
            active: "False",
            homenode: "False",
            conditionmonitor: "8",
            matrixcmfilled: "0",
            children: null,
            weaponbonusdamage: "+0",
            weaponbonusdamage_english: "+0",
            weaponbonusap: "+0",
            weaponbonusacc: "+0",
            weaponbonusrange: "0",
            flechetteweaponbonusdamage: "+0",
            flechetteweaponbonusdamage_english: "+0",
            flechetteweaponbonusap: "+0",
            flechetteweaponbonusacc: "+0",
            flechetteweaponbonusrange: "0"
          },
          {
            guid: "9ba219c5-cb2a-4d0d-85fa-9e11b023f14c",
            sourceid: "d98f419f-7625-4228-9723-0217950d8155",
            name: "Geigerz\xE4hler",
            name_english: "Geiger Counter",
            category: "Sensor-Funktionen",
            category_english: "Sensor Functions",
            ispersona: "False",
            isammo: "False",
            issin: "False",
            capacity: "[1]",
            armorcapacity: "[1]",
            maxrating: null,
            rating: "0",
            qty: "1",
            avail: "0",
            avail_english: "0",
            cost: "0",
            owncost: "0",
            weight: "0",
            ownweight: "0",
            extra: null,
            bonded: "False",
            equipped: "True",
            wirelesson: "False",
            location: null,
            gearname: null,
            source: "SR5",
            page: "450",
            attack: "0",
            sleaze: "0",
            dataprocessing: "0",
            firewall: "0",
            devicerating: "0",
            programlimit: "0",
            iscommlink: "False",
            isprogram: "False",
            active: "False",
            homenode: "False",
            conditionmonitor: "8",
            matrixcmfilled: "0",
            children: null,
            weaponbonusdamage: "+0",
            weaponbonusdamage_english: "+0",
            weaponbonusap: "+0",
            weaponbonusacc: "+0",
            weaponbonusrange: "0",
            flechetteweaponbonusdamage: "+0",
            flechetteweaponbonusdamage_english: "+0",
            flechetteweaponbonusap: "+0",
            flechetteweaponbonusacc: "+0",
            flechetteweaponbonusrange: "0"
          }
        ]
      },
      weaponbonusdamage: "+0",
      weaponbonusdamage_english: "+0",
      weaponbonusap: "+0",
      weaponbonusacc: "+0",
      weaponbonusrange: "0",
      flechetteweaponbonusdamage: "+0",
      flechetteweaponbonusdamage_english: "+0",
      flechetteweaponbonusap: "+0",
      flechetteweaponbonusacc: "+0",
      flechetteweaponbonusrange: "0"
    },
    {
      guid: "156b06ee-654b-4224-91a8-f459f4ef7037",
      sourceid: "0949997a-acb7-49d9-9905-5ae2cd35626f",
      name: "Zielerfassung [Waffe] Autosoft",
      name_english: "[Weapon] Targeting Autosoft",
      category: "Autosofts",
      category_english: "Autosofts",
      ispersona: "False",
      isammo: "False",
      issin: "False",
      capacity: "[0]",
      armorcapacity: "[0]",
      maxrating: "6",
      rating: "4",
      qty: "1",
      avail: "8",
      avail_english: "8",
      cost: "0",
      owncost: "1",
      weight: "0",
      ownweight: "0",
      extra: "Shiawase Arms Monsoon",
      bonded: "False",
      equipped: "True",
      wirelesson: "False",
      location: null,
      gearname: null,
      source: "SR5",
      page: "267",
      attack: "0",
      sleaze: "0",
      dataprocessing: "0",
      firewall: "0",
      devicerating: "0",
      programlimit: "0",
      iscommlink: "False",
      isprogram: "True",
      active: "False",
      homenode: "False",
      conditionmonitor: "8",
      matrixcmfilled: "0",
      children: null,
      weaponbonusdamage: "+0",
      weaponbonusdamage_english: "+0",
      weaponbonusap: "+0",
      weaponbonusacc: "+0",
      weaponbonusrange: "0",
      flechetteweaponbonusdamage: "+0",
      flechetteweaponbonusdamage_english: "+0",
      flechetteweaponbonusap: "+0",
      flechetteweaponbonusacc: "+0",
      flechetteweaponbonusrange: "0"
    },
    {
      guid: "1bfc2ff5-2c1b-4b7e-8abf-4ae2d9b30af8",
      sourceid: "149a8dd2-dfef-473f-94a4-1bdd77e4f855",
      name: "Clearsight Autosoft",
      name_english: "Clearsight Autosoft",
      category: "Autosofts",
      category_english: "Autosofts",
      ispersona: "False",
      isammo: "False",
      issin: "False",
      capacity: "[0]",
      armorcapacity: "[0]",
      maxrating: "6",
      rating: "4",
      qty: "1",
      avail: "8",
      avail_english: "8",
      cost: "0",
      owncost: "1",
      weight: "0",
      ownweight: "0",
      extra: null,
      bonded: "False",
      equipped: "True",
      wirelesson: "False",
      location: null,
      gearname: null,
      source: "SR5",
      page: "267",
      attack: "0",
      sleaze: "0",
      dataprocessing: "0",
      firewall: "0",
      devicerating: "0",
      programlimit: "0",
      iscommlink: "False",
      isprogram: "True",
      active: "False",
      homenode: "False",
      conditionmonitor: "8",
      matrixcmfilled: "0",
      children: null,
      weaponbonusdamage: "+0",
      weaponbonusdamage_english: "+0",
      weaponbonusap: "+0",
      weaponbonusacc: "+0",
      weaponbonusrange: "0",
      flechetteweaponbonusdamage: "+0",
      flechetteweaponbonusdamage_english: "+0",
      flechetteweaponbonusap: "+0",
      flechetteweaponbonusacc: "+0",
      flechetteweaponbonusrange: "0"
    },
    {
      guid: "625dfbaf-0bb3-409e-b895-29e73aa683b9",
      sourceid: "ef9c8aae-26df-4fe6-88b3-79fbb5eb77c5",
      name: "Munition: APDS",
      name_english: "Ammo: APDS",
      category: "Munition",
      category_english: "Ammunition",
      ispersona: "False",
      isammo: "True",
      issin: "False",
      capacity: null,
      armorcapacity: null,
      maxrating: null,
      rating: "0",
      qty: "30",
      avail: "12V",
      avail_english: "12F",
      cost: "360",
      owncost: "0,1",
      weight: "0",
      ownweight: "0",
      extra: "Sturmgewehre",
      bonded: "False",
      equipped: "True",
      wirelesson: "False",
      location: null,
      gearname: null,
      source: "SR5",
      page: "436",
      attack: "0",
      sleaze: "0",
      dataprocessing: "0",
      firewall: "0",
      devicerating: "0",
      programlimit: "0",
      iscommlink: "False",
      isprogram: "False",
      active: "False",
      homenode: "False",
      conditionmonitor: "8",
      matrixcmfilled: "0",
      children: null,
      weaponbonusdamage: "+0",
      weaponbonusdamage_english: "+0",
      weaponbonusap: "-4",
      weaponbonusacc: "+0",
      weaponbonusrange: "0",
      flechetteweaponbonusdamage: "+0",
      flechetteweaponbonusdamage_english: "+0",
      flechetteweaponbonusap: "+0",
      flechetteweaponbonusacc: "+0",
      flechetteweaponbonusrange: "0"
    },
    {
      guid: "efc5b9a0-7744-456e-ad52-bfd6f5a8cf45",
      sourceid: "d9f69780-93eb-41ff-9a9c-893f8c52794e",
      name: "Munition: Schocker",
      name_english: "Ammo: Stick-n-Shock",
      category: "Munition",
      category_english: "Ammunition",
      ispersona: "False",
      isammo: "True",
      issin: "False",
      capacity: null,
      armorcapacity: null,
      maxrating: null,
      rating: "0",
      qty: "30",
      avail: "6E",
      avail_english: "6R",
      cost: "240",
      owncost: "0,1",
      weight: "0",
      ownweight: "0",
      extra: "Assault Rifles",
      bonded: "False",
      equipped: "True",
      wirelesson: "False",
      location: null,
      gearname: null,
      source: "SR5",
      page: "437",
      attack: "0",
      sleaze: "0",
      dataprocessing: "0",
      firewall: "0",
      devicerating: "0",
      programlimit: "0",
      iscommlink: "False",
      isprogram: "False",
      active: "False",
      homenode: "False",
      conditionmonitor: "8",
      matrixcmfilled: "0",
      children: null,
      weaponbonusdamage: "-2G(e)",
      weaponbonusdamage_english: "-2S(e)",
      weaponbonusap: "-5",
      weaponbonusacc: "+0",
      weaponbonusrange: "0",
      flechetteweaponbonusdamage: "+0",
      flechetteweaponbonusdamage_english: "+0",
      flechetteweaponbonusap: "+0",
      flechetteweaponbonusacc: "+0",
      flechetteweaponbonusrange: "0"
    },
    {
      guid: "e4d2d1cc-dbfa-4990-aa50-ed6a8eaab291",
      sourceid: "0025f1c7-45a4-4ec5-a692-e18aab2f97a9",
      name: "Transportsitz (Halterung)",
      name_english: "Transportsitz (Halterung)",
      category: "Eigene",
      category_english: "Custom",
      ispersona: "False",
      isammo: "False",
      issin: "False",
      capacity: null,
      armorcapacity: null,
      maxrating: null,
      rating: "0",
      qty: "1",
      avail: "0",
      avail_english: "0",
      cost: "0",
      owncost: "1",
      weight: "0",
      ownweight: "0",
      extra: null,
      bonded: "False",
      equipped: "True",
      wirelesson: "False",
      location: null,
      gearname: null,
      source: "SR5",
      page: "1",
      attack: "0",
      sleaze: "0",
      dataprocessing: "0",
      firewall: "0",
      devicerating: "0",
      programlimit: "0",
      iscommlink: "False",
      isprogram: "False",
      active: "False",
      homenode: "False",
      conditionmonitor: "8",
      matrixcmfilled: "0",
      children: null,
      weaponbonusdamage: "+0",
      weaponbonusdamage_english: "+0",
      weaponbonusap: "+0",
      weaponbonusacc: "+0",
      weaponbonusrange: "0",
      flechetteweaponbonusdamage: "+0",
      flechetteweaponbonusdamage_english: "+0",
      flechetteweaponbonusap: "+0",
      flechetteweaponbonusacc: "+0",
      flechetteweaponbonusrange: "0"
    }
  ]
};
var weapons = null;
var drone_default = {
  guid,
  sourceid,
  name,
  name_english,
  fullname,
  category,
  category_english,
  isdrone,
  handling,
  accel,
  speed,
  pilot,
  body,
  armor,
  seats,
  sensor,
  avail,
  cost,
  owncost,
  source,
  page,
  physicalcm,
  physicalcmfilled,
  vehiclename,
  maneuver,
  location,
  attack,
  sleaze,
  dataprocessing,
  firewall,
  devicerating,
  programlimit,
  iscommlink,
  isprogram,
  active,
  homenode,
  matrixcm,
  matrixcmfilled,
  mods,
  gears,
  weapons
};

// src/unittests/actorImport/itemImporter/vehicleImport/sr5.VehicleImporterMountedWeapon.spec.ts
var mountedWeaponParserTesting = /* @__PURE__ */ __name((context) => {
  const { describe, it, assert, before, after } = context;
  let mountedWeaponParser = new MountedWeaponParser();
  describe("Mounted Weapon Parser", () => {
    it("parses weapons", async () => {
      let weapons3 = await mountedWeaponParser.parseWeapons(drone_exports);
      assert.lengthOf(weapons3, 1);
    });
  });
}, "mountedWeaponParserTesting");

// src/unittests/sr5.ItemDataPrep.spec.ts
var shadowrunSR5ItemDataPrep = /* @__PURE__ */ __name((context) => {
  const { describe, it, assert, before, after } = context;
  let testItem;
  let testActor;
  before(async () => {
    testItem = new SR6TestingDocuments(SR6Item);
    testActor = new SR6TestingDocuments(SR6Actor);
  });
  after(async () => {
    await testItem.teardown();
    await testActor.teardown();
  });
  describe("TechnologyData preparation", () => {
    it("Calculate the correct device item condition monitor", () => {
      const device = foundry.utils.duplicate(game.model.Item.device);
      device.technology.rating = 4;
      TechnologyPrep.prepareConditionMonitor(device.technology);
      assert.equal(device.technology.condition_monitor.max, 10);
    });
    it("Calculate the correct device item condition monitor for rounded values", () => {
      const device = foundry.utils.duplicate(game.model.Item.device);
      device.technology.rating = 5;
      TechnologyPrep.prepareConditionMonitor(device.technology);
      assert.equal(device.technology.condition_monitor.max, 11);
    });
    it("Calculate a condition monitor for devices with malformed technology data", () => {
      const device = foundry.utils.duplicate(game.model.Item.device);
      device.technology.rating = 4;
      device.technology.condition_monitor = void 0;
      TechnologyPrep.prepareConditionMonitor(device.technology);
      assert.equal(device.technology.condition_monitor.max, 10);
    });
    it("Calculate conceal data for a device", async () => {
      const device = foundry.utils.duplicate(game.model.Item.device);
      const mods3 = [];
      mods3.push(await testItem.create({ type: "modification", name: "UniqueNameA", system: { conceal: 2 } }));
      mods3.push(await testItem.create({ type: "modification", name: "UniqueNameB", system: { conceal: 4 } }));
      TechnologyPrep.prepareConceal(device.technology, mods3);
      assert.equal(device.technology.conceal.value, 6);
      assert.equal(device.technology.conceal.mod.length, 2);
    });
  });
  describe("ActionRollData preparation", () => {
    it("Check for damage base_formula_operator migration", () => {
      const action = foundry.utils.duplicate(game.model.Item.action);
      action.action.damage.base_formula_operator = "+";
      ActionPrep.prepareWithMods(action.action, []);
      assert.equal(action.action.damage.base_formula_operator, "add");
    });
    it("Setup damage source data", async () => {
      const actor = await testActor.create({ type: "character" });
      const documents = await actor.createEmbeddedDocuments("Item", [{ type: "action", name: "TestAction" }]);
      const action = documents[0];
      ActionPrep.prepareDamageSource(action.system.action, action);
      assert.deepEqual(action.system.action?.damage.source, {
        actorId: actor.id,
        itemId: action.id,
        itemName: action.name,
        itemType: action.type
      });
    });
    it("Check for weapon modification setting dice pool modifiers", async () => {
      const weapon = new SR6Item({ type: "weapon", name: "Test" });
      const mods3 = [];
      mods3.push(new SR6Item({ type: "modification", name: "TestModA", system: { type: "weapon", dice_pool: 2 } }));
      mods3.push(new SR6Item({ type: "modification", name: "TestModB", system: { type: "weapon", dice_pool: 4 } }));
      ActionPrep.prepareWithMods(weapon.system.action, mods3);
      ActionPrep.calculateValues(weapon.system.action);
      assert.strictEqual(weapon.system.action?.dice_pool_mod.length, 2);
    });
    it("Check for weapon modification setting limit modifiers", async () => {
      const weapon = new SR6Item({ type: "weapon", name: "Test" });
      const mods3 = [];
      mods3.push(new SR6Item({ type: "modification", name: "TestModA", system: { type: "weapon", accuracy: 2 } }));
      mods3.push(new SR6Item({ type: "modification", name: "TestModB", system: { type: "weapon", accuracy: 4 } }));
      ActionPrep.prepareWithMods(weapon.system.action, mods3);
      ActionPrep.calculateValues(weapon.system.action);
      assert.strictEqual(weapon.system.action?.limit.mod.length, 2);
    });
    it("Check for ammo to apply its damage to the weapon", async () => {
      const weapon = new SR6Item({ type: "weapon", name: "Test" });
      const ammo = new SR6Item({ type: "ammo", name: "TestModA", system: { damage: 2 } });
      ActionPrep.prepareWithAmmo(weapon.system.action, ammo);
      ActionPrep.calculateValues(weapon.system.action);
      assert.strictEqual(weapon.system.action?.damage.value, 2);
    });
    it("Check for ammo to modify the weapon armor piercing", async () => {
      const weapon = new SR6Item({ type: "weapon", name: "Test" });
      const ammo = new SR6Item({ type: "ammo", name: "TestModA", system: { ap: -2 } });
      ActionPrep.prepareWithAmmo(weapon.system.action, ammo);
      ActionPrep.calculateValues(weapon.system.action);
      assert.strictEqual(weapon.system.action?.damage.ap.value, -2);
    });
    it("Check for ammo to override the weapon damage info", async () => {
      const weapon = new SR6Item({ type: "weapon", name: "Test", system: { action: { damage: {
        element: { value: "fire" },
        base: 3,
        type: { base: "physical" }
      } } } });
      const ammo = new SR6Item({ type: "ammo", name: "TestModA", system: { replaceDamage: true, damage: 2, damageType: "stun", element: "cold" } });
      ActionPrep.prepareWithAmmo(weapon.system.action, ammo);
      ActionPrep.calculateValues(weapon.system.action);
      assert.strictEqual(weapon.system.action?.damage.base, 3);
      assert.strictEqual(weapon.system.action?.damage.value, 2);
      assert.strictEqual(weapon.system.action?.damage.type.base, "physical");
      assert.strictEqual(weapon.system.action?.damage.type.value, "stun");
      assert.strictEqual(weapon.system.action?.damage.element.base, "");
      assert.strictEqual(weapon.system.action?.damage.element.value, "cold");
    });
  });
  describe("RangeData preparation", () => {
    it("Check for weapon modification recoil modifiers", async () => {
      const weapon = new SR6Item({ type: "weapon", name: "Test", system: { range: { rc: { base: 2 } } } });
      const mods3 = [];
      mods3.push(new SR6Item({ type: "modification", name: "TestModA", system: { type: "weapon", rc: 2 } }));
      RangePrep.prepareRecoilCompensation(weapon.system.range, mods3);
      assert.strictEqual(weapon.system.range.rc.base, 2);
      assert.strictEqual(weapon.system.range.rc.mod.length, 1);
      assert.strictEqual(weapon.system.range.rc.value, 4);
    });
  });
}, "shadowrunSR5ItemDataPrep");

// src/unittests/actorImport/itemImporter/vehicleImport/vehicle.json
var vehicle_exports = {};
__export(vehicle_exports, {
  accel: () => accel2,
  active: () => active2,
  armor: () => armor2,
  attack: () => attack2,
  avail: () => avail2,
  body: () => body2,
  category: () => category2,
  category_english: () => category_english2,
  cost: () => cost2,
  dataprocessing: () => dataprocessing2,
  default: () => vehicle_default,
  devicerating: () => devicerating2,
  firewall: () => firewall2,
  fullname: () => fullname2,
  gears: () => gears2,
  guid: () => guid2,
  handling: () => handling2,
  homenode: () => homenode2,
  iscommlink: () => iscommlink2,
  isdrone: () => isdrone2,
  isprogram: () => isprogram2,
  location: () => location2,
  maneuver: () => maneuver2,
  matrixcm: () => matrixcm2,
  matrixcmfilled: () => matrixcmfilled2,
  mods: () => mods2,
  name: () => name2,
  name_english: () => name_english2,
  owncost: () => owncost2,
  page: () => page2,
  physicalcm: () => physicalcm2,
  physicalcmfilled: () => physicalcmfilled2,
  pilot: () => pilot2,
  programlimit: () => programlimit2,
  seats: () => seats2,
  sensor: () => sensor2,
  sleaze: () => sleaze2,
  source: () => source2,
  sourceid: () => sourceid2,
  speed: () => speed2,
  vehiclename: () => vehiclename2,
  weapons: () => weapons2
});
var guid2 = "3033d1f2-7eba-44a0-a1d3-99000193b109";
var sourceid2 = "56747364-dbd5-40e3-b4c1-5a361ec0c710";
var name2 = "SomeBrand Pickup Truck";
var name_english2 = "SomeBrand Pickup Truck";
var fullname2 = "SomeBrand Pickup Truck";
var category2 = "Trucks";
var category_english2 = "Trucks";
var isdrone2 = "False";
var handling2 = "5";
var accel2 = "2";
var speed2 = "4";
var pilot2 = "1";
var body2 = "14";
var armor2 = "10";
var seats2 = "3";
var sensor2 = "2";
var avail2 = "0";
var cost2 = "25,000";
var owncost2 = "25,000";
var source2 = "SR5";
var page2 = "463";
var physicalcm2 = "19";
var physicalcmfilled2 = "0";
var vehiclename2 = null;
var maneuver2 = "0";
var location2 = null;
var attack2 = "0";
var sleaze2 = "0";
var dataprocessing2 = "1";
var firewall2 = "1";
var devicerating2 = "1";
var programlimit2 = "1";
var iscommlink2 = "False";
var isprogram2 = "False";
var active2 = "False";
var homenode2 = "False";
var matrixcm2 = "9";
var matrixcmfilled2 = "0";
var mods2 = {
  mod: [
    {
      guid: "a84fe5c0-b5e9-43b4-92fd-420030625086",
      sourceid: "5acc99df-ffaf-4c43-93bc-07b552fc4c1c",
      name: "Off-Road Suspension",
      name_english: "Off-Road Suspension",
      fullname: "Off-Road Suspension",
      category: "Powertrain",
      category_english: "Powertrain",
      limit: null,
      slots: "2",
      rating: "0",
      ratinglabel: "String_Rating",
      avail: "4",
      cost: "6,250",
      owncost: "6,250",
      source: "R5",
      wirelesson: "False",
      page: "155",
      included: "True",
      weapons: null,
      cyberwares: null
    },
    {
      guid: "8cc340c1-e011-4833-9ae7-a871805d065e",
      sourceid: "60481326-e91c-4ace-863e-93799ba96064",
      name: "Special Equipment",
      name_english: "Special Equipment",
      fullname: "Special Equipment (Open Box Storage)",
      category: "Body",
      category_english: "Body",
      limit: null,
      slots: "0",
      rating: "0",
      ratinglabel: "String_Rating",
      avail: "0",
      cost: "0",
      owncost: "0",
      source: "R5",
      wirelesson: "False",
      page: "165",
      included: "True",
      weapons: null,
      cyberwares: null
    }
  ]
};
var gears2 = {
  gear: {
    guid: "7154156a-04b5-4a27-8683-7d913a9ffee8",
    sourceid: "2ca81a10-d0f7-4b39-ac93-a84f2f69f9d9",
    name: "Sensor Array",
    name_english: "Sensor Array",
    category: "Sensors",
    category_english: "Sensors",
    ispersona: "False",
    isammo: "False",
    issin: "False",
    capacity: "8/[0]",
    armorcapacity: "[0]",
    maxrating: "8",
    rating: "2",
    qty: "1",
    avail: "7",
    avail_english: "7",
    cost: "0",
    owncost: "1",
    weight: "0",
    ownweight: "0",
    extra: null,
    bonded: "False",
    equipped: "True",
    wirelesson: "False",
    location: null,
    gearname: null,
    source: "SR5",
    page: "445",
    attack: "0",
    sleaze: "0",
    dataprocessing: "0",
    firewall: "0",
    devicerating: "0",
    programlimit: "0",
    iscommlink: "False",
    isprogram: "False",
    active: "False",
    homenode: "False",
    conditionmonitor: "8",
    matrixcmfilled: "0",
    children: null
  }
};
var weapons2 = null;
var vehicle_default = {
  guid: guid2,
  sourceid: sourceid2,
  name: name2,
  name_english: name_english2,
  fullname: fullname2,
  category: category2,
  category_english: category_english2,
  isdrone: isdrone2,
  handling: handling2,
  accel: accel2,
  speed: speed2,
  pilot: pilot2,
  body: body2,
  armor: armor2,
  seats: seats2,
  sensor: sensor2,
  avail: avail2,
  cost: cost2,
  owncost: owncost2,
  source: source2,
  page: page2,
  physicalcm: physicalcm2,
  physicalcmfilled: physicalcmfilled2,
  vehiclename: vehiclename2,
  maneuver: maneuver2,
  location: location2,
  attack: attack2,
  sleaze: sleaze2,
  dataprocessing: dataprocessing2,
  firewall: firewall2,
  devicerating: devicerating2,
  programlimit: programlimit2,
  iscommlink: iscommlink2,
  isprogram: isprogram2,
  active: active2,
  homenode: homenode2,
  matrixcm: matrixcm2,
  matrixcmfilled: matrixcmfilled2,
  mods: mods2,
  gears: gears2,
  weapons: weapons2
};

// src/unittests/actorImport/itemImporter/vehicleImport/sr5.VehicleImporter.spec.ts
var vehicleImporterTesting = /* @__PURE__ */ __name((context) => {
  const { describe, it, assert, before, after } = context;
  let vehicleParser = new VehicleParser();
  let testActor;
  let testItem;
  before(async () => {
    testActor = new SR6TestingDocuments(SR6Actor);
    testItem = new SR6TestingDocuments(SR6Item);
  });
  after(async () => {
    await testActor.teardown();
    await testItem.teardown();
  });
  describe("Vehicle Parser", () => {
    it("parses vehicles", async () => {
      const actor = await testActor.create({ type: "character" });
      const parsedVehicles = await vehicleParser.parseVehicles(
        actor,
        { vehicles: { vehicle: [drone_exports, vehicle_exports] } },
        { vehicles: true }
      );
      if (!parsedVehicles) {
        assert.fail("Vehicle Parser failed to create vehicles!");
        return;
      }
      parsedVehicles.forEach(testActor.register.bind(testActor));
      parsedVehicles.forEach((vehicle2) => vehicle2.prepareDerivedData());
      const drone = parsedVehicles[0].asVehicle();
      const vehicle = parsedVehicles[1].asVehicle();
      assert.deepEqual(drone.system.vehicle_stats.seats.value, 0);
      assert.deepEqual(drone.system.vehicle_stats.seats.hidden, true);
      assert.deepEqual(vehicle.system.vehicle_stats.seats.value, 3);
      assert.deepEqual(vehicle.system.vehicle_stats.seats.hidden, false);
    });
  });
}, "vehicleImporterTesting");

// src/unittests/actorImport/itemImporter/vehicleImport/sr5.VehicleModImporter.spec.ts
var vehicleModParserTesting = /* @__PURE__ */ __name((context) => {
  const { describe, it, assert, before, after } = context;
  let parser = new VehicleModsParser();
  describe("Vehicle Mod Parser", () => {
    it("parses mods", async () => {
      let mods3 = await parser.parseMods(drone_exports, false);
      assert.lengthOf(mods3, 2);
      let ecm = mods3.find((mod) => mod.name === "ECM");
      assert.isNotNull(ecm);
      assert.strictEqual(ecm.name, "ECM");
      assert.strictEqual(ecm.type, "modification");
      assert.strictEqual(ecm.system.technology.availability, "9V");
      assert.strictEqual(ecm.system.description.source, "R5 173");
    });
  });
}, "vehicleModParserTesting");

// src/unittests/quench.ts
var quenchRegister = /* @__PURE__ */ __name((quench) => {
  if (!quench) return;
  console.info("Shadowrun 5e | Registering quench unittests");
  console.warn(
    "Shadowrun 5e | Be aware that FoundryVTT will tank in update performance when a lot of documents are in collections. This is the case if you have all Chummer items imported and might cause tests to cross the 2000ms quench timeout threshold. Clear those collections in a test world. :)"
  );
  quench.registerBatch("shadowrun6-elysium.rules.matrix", shadowrunMatrix, {
    displayName: "shadowrun6-elysium: Matrix Rules Test"
  });
  quench.registerBatch("shadowrun6-elysium.rules.modifiers", shadowrunRulesModifiers, {
    displayName: "shadowrun6-elysium: Modifiers Rules Test"
  });
  quench.registerBatch("shadowrun6-elysium.rules.ranged_weapon", shadowrunSR5RangedWeaponRules, {
    displayName: "shadowrun6-elysium: Ranged Weapon Rules Test"
  });
  quench.registerBatch("shadowrun6-elysium.characterImporter", characterImporterTesting, {
    displayName: "shadowrun6-elysium: Chummer Character Importer"
  });
  quench.registerBatch("shadowrun6-elysium.characterInfoUpdater", characterInfoUpdaterTesting, {
    displayName: "shadowrun6-elysium: Chummer Character Info Updater"
  });
  quench.registerBatch("shadowrun6-elysium.spiritImporter", spiritImporterTesting, {
    displayName: "shadowrun6-elysium: Chummer Spirit Importer"
  });
  quench.registerBatch("shadowrun6-elysium.spiritInfoUpdater", spiritInfoUpdaterTesting, {
    displayName: "shadowrun6-elysium: Chummer Spirit Info Updater"
  });
  quench.registerBatch("shadowrun6-elysium.importerWeapons", weaponParserTesting, {
    displayName: "shadowrun6-elysium: Chummer Actor Weapon Importer"
  });
  quench.registerBatch("shadowrun6-elysium.importerVehicles", vehicleImporterTesting, {
    displayName: "shadowrun6-elysium: Chummer Vehicle Importer"
  });
  quench.registerBatch("shadowrun6-elysium.importerVehicleMountedWeapons", mountedWeaponParserTesting, {
    displayName: "shadowrun6-elysium: Chummer Vehicle Mounted Weapon Importer"
  });
  quench.registerBatch("shadowrun6-elysium.importerVehicleMods", vehicleModParserTesting, {
    displayName: "shadowrun6-elysium: Chummer Vehicle Modification Importer"
  });
  quench.registerBatch("shadowrun6-elysium.entities.items", shadowrunSR5Item, { displayName: "shadowrun6-elysium: SR6Item Test" });
  quench.registerBatch("shadowrun6-elysium.entities.actors", shadowrunSR5Actor, {
    displayName: "shadowrun6-elysium: SR6Actor Test"
  });
  quench.registerBatch("shadowrun6-elysium.entities.effects", shadowrunSR5ActiveEffect, {
    displayName: "shadowrun6-elysium: SR6ActiveEffect Test"
  });
  quench.registerBatch("shadowrun6-elysium.data_prep.character", shadowrunSR5CharacterDataPrep, {
    displayName: "shadowrun6-elysium: SR5CharacterDataPreparation Test"
  });
  quench.registerBatch("shadowrun6-elysium.data_prep.critter", shadowrunSR5CritterDataPrep, {
    displayName: "shadowrun6-elysium: SR5CritterDataPreparation Test"
  });
  quench.registerBatch("shadowrun6-elysium.data_prep.sprite", shadowrunSR5SpriteDataPrep, {
    displayName: "shadowrun6-elysium: SR5CSpriteDataPreparation Test"
  });
  quench.registerBatch("shadowrun6-elysium.data_prep.spirit", shadowrunSR5SpiritDataPrep, {
    displayName: "shadowrun6-elysium: SR5SpiritDataPreparation Test"
  });
  quench.registerBatch("shadowrun6-elysium.data_prep.ic", shadowrunSR5ICDataPrep, {
    displayName: "shadowrun6-elysium: SR5ICDataPreparation Test"
  });
  quench.registerBatch("shadowrun6-elysium.data_prep.vehicle", shadowrunSR5VehicleDataPrep, {
    displayName: "shadowrun6-elysium: SR5VehicleDataPreparation Test"
  });
  quench.registerBatch("shadowrun6-elysium.data_prep.item", shadowrunSR5ItemDataPrep, {
    displayName: "shadowrun6-elysium: SR5ItemDataPreparation Test"
  });
  quench.registerBatch("shadowrun6-elysium.flow.networkDevices", shadowrunNetworkDevices, {
    displayName: "shadowrun6-elysium: Matrix Network Devices Test"
  });
  quench.registerBatch("shadowrun6-elysium.flow.inventory", shadowrunInventoryFlow, {
    displayName: "shadowrun6-elysium: InventoryFlow Test"
  });
  quench.registerBatch("shadowrun6-elysium.flow.tests", shadowrunTesting, { displayName: "shadowrun6-elysium: SuccessTest Test" });
  quench.registerBatch("shadowrun6-elysium.flow.tests_attack", shadowrunAttackTesting, {
    displayName: "shadowrun6-elysium: Attack Test"
  });
  quench.registerBatch("shadowrun6-elysium.flow.sr5roll", shadowrunRolling, { displayName: "shadowrun6-elysium: SR6Roll" });
  quench.registerBatch("shadowrun6-elysium.parser.weapon", weaponParserBaseTesting, {
    displayName: "shadowrun6-elysium: Data Importer Weapon Parsing"
  });
}, "quenchRegister");

// src/module/macros.ts
async function createItemMacro(dropData, slot) {
  if (!game || !game.macros) return;
  const item = await SR6Item.fromDropData(dropData);
  if (!(item instanceof SR6Item)) return console.error(`Shadowrun 6e | Macro Drop expected an item document but got a different document type`, item);
  const command = `game['shadowrun6-elysium'].rollItemMacro("${item.name}");`;
  let macro = game.macros.contents.find((m2) => m2.name === item.name);
  if (!macro) {
    macro = await Macro.create(
      {
        //@ts-expect-error
        name: item.name,
        type: "script",
        img: item.img,
        command,
        flags: { "shadowrun6-elysium.itemMacro": true }
      },
      { renderSheet: false }
    );
  }
  if (macro) game.user?.assignHotbarMacro(macro, slot);
}
__name(createItemMacro, "createItemMacro");
function rollItemMacro(itemName) {
  if (!game || !game.actors) return;
  const speaker = ChatMessage.getSpeaker();
  let actor;
  if (speaker.token) actor = game.actors.tokens[speaker.token];
  if (!speaker.actor) return;
  if (!actor) actor = game.actors.get(speaker.actor);
  const item = actor ? actor.items.find((i2) => i2.name === itemName) : null;
  if (!item) {
    return ui.notifications?.warn(`Your controlled Actor does not have an item named ${itemName}`);
  }
  return item.castAction();
}
__name(rollItemMacro, "rollItemMacro");
async function createSkillMacro(data, slot) {
  if (!game.macros || !game.user) return;
  const { skillId, skill } = data;
  const name3 = Helpers.getSkillLabelOrName(skill);
  const existingMacro = game.macros.contents.find((macro2) => macro2.name === name3);
  if (existingMacro) return;
  const command = `game['shadowrun6-elysium'].rollSkillMacro("${name3}");`;
  const macro = await Macro.create({
    name: name3,
    type: "script",
    command
    // TODO: Is flags needed here? See createItemMacro
  });
  if (macro) await game.user.assignHotbarMacro(macro, slot);
}
__name(createSkillMacro, "createSkillMacro");
async function rollSkillMacro(skillLabel) {
  if (!game || !game.actors) return;
  if (!skillLabel) return;
  const speaker = ChatMessage.getSpeaker();
  if (!speaker) return;
  const actor = game.actors.tokens[speaker.token] || game.actors.get(speaker.actor);
  if (!actor) return;
  return await actor.rollSkill(skillLabel, { byLabel: true });
}
__name(rollSkillMacro, "rollSkillMacro");

// src/module/keybindings.ts
var registerSystemKeybindings = /* @__PURE__ */ __name(() => {
  game.keybindings.register("shadowrun6-elysium", "show-situation-modifier-app", {
    name: "SR6.Keybinding.ShowSituationModifiers.Label",
    hint: "SR6.Keybinding.ShowSituationModifiers.Hint",
    editable: [{ key: "KeyM", modifiers: [] }],
    onDown: /* @__PURE__ */ __name(() => SituationModifiersApplication.openForKeybinding(), "onDown")
  });
  game.keybindings.register("shadowrun6-elysium", "show-overwatch-tracker-app", {
    name: "SR6.Keybinding.OverwatchScoreTracker.Label",
    hint: "SR6.Keybinding.OverwatchScoreTracker.Hint",
    editable: [{ key: "KeyO", modifiers: [] }],
    onDown: /* @__PURE__ */ __name(() => new OverwatchScoreTracker().render(true), "onDown")
  });
  game.keybindings.register("shadowrun6-elysium", "hide-test-dialog", {
    name: game.i18n.localize("SR6.Keybinding.HideTestDialog.Label"),
    hint: game.i18n.localize("SR6.Keybinding.HideTestDialog.Hint"),
    editable: [{ key: "shiftKey" }]
  });
  game.keybindings.register("shadowrun6-elysium", "show-item-card", {
    name: game.i18n.localize("SR6.Keybinding.ShowItemCard.Label"),
    hint: game.i18n.localize("SR6.Keybinding.ShowItemCard.Hint"),
    editable: [{ key: "ctrlKey" }]
  });
}, "registerSystemKeybindings");

// src/module/canvas.ts
var measureDistances = /* @__PURE__ */ __name(function(segments, options = {}) {
  if (!options.gridSpaces) return BaseGrid.prototype.measureDistances.call(this, segments, options);
  let nDiagonal = 0;
  const rule = this.diagonalRule;
  const d2 = canvas.dimensions;
  return segments.map((s2) => {
    let r2 = s2.ray;
    let nx = Math.abs(Math.ceil(r2.dx / d2.size));
    let ny = Math.abs(Math.ceil(r2.dy / d2.size));
    let nd = Math.min(nx, ny);
    let ns = Math.abs(ny - nx);
    nDiagonal += nd;
    if (rule === "1-2-1") {
      let nd10 = Math.floor(nDiagonal / 2) - Math.floor((nDiagonal - nd) / 2);
      let spaces = nd10 * 2 + (nd - nd10) + ns;
      return spaces * canvas.dimensions.distance;
    } else if (rule === "EUCL") {
      return Math.round(Math.hypot(nx, ny) * canvas.scene?.grid.distance);
    } else return (ns + nd) * canvas.scene?.grid.distance;
  });
}, "measureDistances");
function canvasInit() {
  canvas.grid.diagonalRule = game.settings.get(SYSTEM_NAME, FLAGS.DiagonalMovement);
  SquareGrid.prototype.measureDistances = measureDistances;
}
__name(canvasInit, "canvasInit");

// src/module/item/flows/ActionFollowupFlow.ts
var ActionFollowupFlow = {
  chatLogListeners: /* @__PURE__ */ __name(async (message, html, data) => {
    html.find(".chat-message").each(async (index, element) => {
      element = $(element);
      const id = element.data("messageId");
      const message2 = game.messages?.get(id);
      if (!message2) return;
      await ActionFollowupFlow.chatMessageListeners(message2, element, message2.toObject());
    });
  }, "chatLogListeners"),
  chatMessageListeners: /* @__PURE__ */ __name(async (message, html, data) => {
    html.find(".followup-action").on("click", ActionFollowupFlow.castFollowupAction);
  }, "chatMessageListeners"),
  castFollowupAction: /* @__PURE__ */ __name(async (event) => {
    event.preventDefault();
    const button = $(event.currentTarget);
    const card = button.closest(".chat-message");
    const messageId = card.data("messageId");
    const showDialog = TestCreator.shouldShowDialog(event);
    const test = await TestCreator.fromMessage(messageId, { showDialog });
    if (!test) return;
    await test.populateTests();
    await test.populateDocuments();
    test.executeFollowUpTest();
  }, "castFollowupAction")
};

// src/module/tests/OpposedCompileSpriteTest.ts
var OpposedCompileSpriteTest = class extends OpposedTest {
  static {
    __name(this, "OpposedCompileSpriteTest");
  }
  constructor(data, documents, options) {
    delete documents?.actor;
    delete data.sourceActorUuid;
    super(data, documents, options);
    this._assertCorrectAgainst();
  }
  _assertCorrectAgainst() {
    if (this.against.type !== "CompileSpriteTest") throw new Error(`${this.constructor.name} can only oppose CompileSpriteTest but is opposing a ${this.against.type}`);
  }
  _prepareData(data, options) {
    data = super._prepareData(data, options);
    data.compiledSpriteUuid = data.compiledSpriteUuid || "";
    return data;
  }
  get _chatMessageTemplate() {
    return "systems/shadowrun6-elysium/dist/templates/rolls/opposed-actor-creator-message.html";
  }
  /**
   * When compiling the opposing sprite test triggers the FadeTest from compilation.
   * Since we can expect this test to be within GM context, we can't auto cast.
   */
  get autoExecuteFollowupTest() {
    return false;
  }
  /**
   * To have an opposing actor, that's not on the map already, create the sprite actor.
   */
  async populateDocuments() {
    await this.createCompiledSprite();
    this.data.sourceActorUuid = this.data.compiledSpriteUuid || this.against.data.preparedSpriteUuid;
    await super.populateDocuments();
  }
  /**
   * Other than force there shouldn't be any other pool parts.
   */
  applyPoolModifiers() {
    PartsList.AddUniquePart(this.data.pool.mod, "SR6.Level", this.against.data.level);
  }
  /**
   * A failure for the sprite is a success for the summoner.
   */
  async processFailure() {
    await this.updateCompilationTestForFollowup();
    await this.finalizeSummonedSprite();
  }
  /**
   * A success of the sprite is a failure for the summoner.
   */
  async processSuccess() {
    await this.updateCompilationTestForFollowup();
    await this.cleanupAfterExecutionCancel();
  }
  get successLabel() {
    return "SR6.TestResults.SpriteCompilationFailure";
  }
  get failureLabel() {
    return "SR6.TestResults.SpriteCompilationSuccess";
  }
  /**
   * Cleanup created actors that aren't needed anymore.
   *
   * When user cancels the dialog, the sprite has been created. Remove it.
   */
  async cleanupAfterExecutionCancel() {
    if (!this.data.compiledSpriteUuid) return;
    const actor = await fromUuid(this.data.compiledSpriteUuid);
    await actor?.delete();
    delete this.actor;
  }
  /**
   * Update the triggering test to be ready for the followup fade test.
   */
  async updateCompilationTestForFollowup() {
    this.against.calcFade(this.hits.value);
    await this.against.saveToMessage();
  }
  /**
   * Finalize the existing sprite actor with context around it's summoning.
   *
   * This should be called as the last step in summoning.
   */
  async finalizeSummonedSprite() {
    if (!this.actor) return;
    const technomancer = this.against.actor;
    const updateData = {
      // 'system.services': this.deriveSpriteServices(),
      "system.technomancerUuid": technomancer.uuid
    };
    this._addOwnershipToUpdateData(updateData);
    await this.actor.update(updateData);
  }
  /**
   * Give all users with the summoning actor permissions of the created sprite actor.
   *
   * TODO: Doesn't adhere to naive DRY with OpposedSummonSpiritTest.
   *
   * @param updateData The update data to add the permission to, that's applied to the sprite actor.
   */
  _addOwnershipToUpdateData(updateData) {
    const summoner = this.against.actor;
    const users = game.users?.filter((user) => user.character?.uuid === summoner.uuid);
    if (!users) return;
    const ownership = {};
    users.forEach((user) => {
      if (user.isGM) return;
      ownership[user.id] = CONST.DOCUMENT_OWNERSHIP_LEVELS.OWNER;
    });
    updateData["ownership"] = ownership;
  }
  /**
   * Based on this tests selection, create a sprite actor
   */
  async createCompiledSprite() {
    if (!this.against) return;
    if (!this.against.actor) return;
    const technomancer = this.against.actor;
    if (this.against.data.preparedSpriteUuid) {
      const preparedActor = await this.getPreparedSpriteActor();
      if (!preparedActor) return console.error("Shadowrun 6e | Could not find prepared actor");
      await preparedActor.addTechnomancer(technomancer);
      console.error("Add compiler/mancer? reference to sprite");
    } else {
      const spriteType = this.against.data.spriteTypeSelected;
      const spriteTypeLabel = game.i18n.localize(SR6.spriteTypes[spriteType]);
      const name3 = `${technomancer.name} ${spriteTypeLabel} ${game.i18n.localize("TYPES.Actor.sprite")}`;
      const level = this.against.data.level;
      const system = { level, spriteType };
      const actor = await Actor.create({ name: name3, type: "sprite", system, prototypeToken: { actorLink: true } });
      if (!actor) return console.error("Shadowrun 6e | Could not create the compiled sprite actor");
      this.data.compiledSpriteUuid = actor.uuid;
    }
  }
  /**
   * Try getting a prepared sprite actor to reuse.
   *
   * @returns
   */
  async getPreparedSpriteActor() {
    return await fromUuid(this.data.compiledSpriteUuid);
  }
};

// src/module/item/sheets/SR6CallInActionSheet.ts
var SR6CallInActionSheet = class extends SR6ItemSheet {
  static {
    __name(this, "SR6CallInActionSheet");
  }
  async getData(options) {
    const data = await super.getData(options);
    const system = data.system;
    const spirit = await this.prepareSpirit(system);
    const sprite = await this.prepareSprite(system);
    const isForSpirit = system.actor_type === "spirit";
    const isForSprite = system.actor_type === "sprite";
    return {
      ...data,
      spirit,
      sprite,
      isForSpirit,
      isForSprite
    };
  }
  /**
   * Summoning Sheets allow dropping of spirits onto them.
   * These spirits will be used as pre-configured actors to summon.
   */
  async _onDrop(event) {
    event.preventDefault();
    event.stopPropagation();
    const data = parseDropData(event);
    if (!data) return;
    if (data.type !== "Actor") return;
    const actor = await fromUuid(data.uuid);
    if (actor.isSpirit()) await this.updatePreparedSpirit(actor);
    if (actor.isSprite()) await this.updatePreparedSprite(actor);
  }
  activateListeners(html) {
    super.activateListeners(html);
    html.find(".spirit-remove").click(this.handleSpiritRemove.bind(this));
    html.find(".sprite-remove").click(this.handleSpriteRemove.bind(this));
  }
  /**
   * Summoning sheets can be connected to a pre-prepared spirit.
   * Supply that actor if it's available.
   *
   * @returns null should the configured spirit not exist anymore.
   */
  async prepareSpirit(system) {
    if (!system.spirit.uuid) {
      return null;
    }
    return await fromUuid(system.spirit.uuid);
  }
  /**
   * Conjuring can be connected to a pre-prepared sprite.
   * Supply that actor if it's available.
   *
   * @returns null should the configured sprite not exist anymore.
   */
  async prepareSprite(system) {
    if (!system.sprite.uuid) {
      return null;
    }
    return await fromUuid(system.sprite.uuid);
  }
  /**
   * Handling the removal of a spirit by any sheet action.
   */
  async handleSpiritRemove(event) {
    await this.item.update({ "system.spirit.uuid": "" });
  }
  /**
   * User requested removal of the prepared sprite.
   */
  async handleSpriteRemove(event) {
    await this.item.update({ "system.sprite.uuid": "" });
  }
  /**
   * Updating the summoning items prepared spirit.
   *
   * @param actor The prepared actor
   */
  async updatePreparedSpirit(actor) {
    const spirit = actor.asSpirit();
    if (!spirit) return;
    await this.item.update({
      "system.spirit.uuid": actor.uuid,
      "system.spirit.type": spirit.system.spiritType,
      "system.spirit.force": spirit.system.force
    });
  }
  /**
   * Update the compilation items prepared sprite.
   *
   * @param actor The prepared actor
   */
  async updatePreparedSprite(actor) {
    const sprite = actor.asSprite();
    if (!sprite) return;
    await this.item.update({
      "system.sprite.uuid": actor.uuid,
      "system.sprite.type": sprite.system.spriteType,
      "system.sprite.level": sprite.system.level
    });
  }
};

// src/module/chatMessage/SR6ChatMessage.ts
var SR6ChatMessage = class extends ChatMessage {
  static {
    __name(this, "SR6ChatMessage");
  }
  /**
   * Return a SuccessTest implementation for this chat message instance, if there is one.
   */
  get test() {
    const flagData = this.getFlag(SYSTEM_NAME, FLAGS.Test);
    if (flagData === null || flagData === void 0) return;
    if (this.id === null || this.id === "") return;
    return TestCreator._fromMessageTestData(flagData);
  }
};

// src/module/vision/astralPerception/astralPerceptionFilter.ts
var AstralVisionFilter = class extends AbstractBaseFilter {
  static {
    __name(this, "AstralVisionFilter");
  }
  static {
    //@ts-expect-error
    this.defaultUniforms = {
      luminanceThreshold: 0.5,
      alphaThreshold: 0.1
    };
  }
  static {
    /**
     * fragment shader based on the following snippets:
     * @link https://gitlab.com/peginc/swade/-/blob/develop/src/module/vision/InfravisionFilter.ts?ref_type=heads
     */
    //@ts-expect-error
    this.fragmentShader = `
  varying vec2 vTextureCoord;
  uniform sampler2D uSampler;
  uniform float luminanceThreshold;
  uniform float alphaThreshold;

  #define RED vec4(0.8, 0.0, 0.0, 1.0)
  #define YELLOW vec4(0.8, 0.8, 0.0, 1.0)
  #define BLUE vec4(0.0, 0.0, 1.0, 1.0)
  #define GREEN vec4(0.0, 1.0, 0.0, 1.0)

  void main(void) {
    vec4 texColor = texture2D(uSampler, vTextureCoord);
    float luminance = dot(vec3(0.30, 0.59, 0.11), texColor.rgb);
    if ( texColor.a > alphaThreshold ) {
      gl_FragColor = (luminance < luminanceThreshold) ? mix(RED, mix(YELLOW, vec4(0.2, 0.0, 0.0, 1.0), luminance / 0.5), luminance * 1.0 ) : mix(vec4(0.2, 0.0, 0.0, 1.0), YELLOW, (luminance - 0.5) * 3.0);
      gl_FragColor.rgb *= 0.1 + 0.25 + 0.75 * pow( 16.0 * vTextureCoord.x * vTextureCoord.y * (1.0 - vTextureCoord.x) * (1.0 - vTextureCoord.y), 0.15 );
      gl_FragColor.a = texColor.a;
    } else {
      gl_FragColor = vec4(0.0);
    }
  }`;
  }
};

// src/module/vision/astralPerception/astralPerceptionDetectionMode.ts
var AstralPerceptionDetectionMode = class extends DetectionMode {
  static {
    __name(this, "AstralPerceptionDetectionMode");
  }
  //@ts-expect-error
  static getDetectionFilter() {
    return this._detectionFilter ??= AstralVisionFilter.create();
  }
  //@ts-expect-error
  _canDetect(visionSource, target) {
    const tgt = target?.document;
    const targetAstralActive = tgt instanceof TokenDocument && tgt.actor?.system.visibilityChecks.astral.astralActive;
    const targetHasAura = tgt instanceof TokenDocument && tgt.actor?.system.visibilityChecks.astral.hasAura;
    const targetAffectedBySpell = tgt.actor?.system.visibilityChecks.astral.affectedBySpell;
    const isAstralPerceiving = visionSource?.visionMode?.id === "astralPerception";
    return (targetHasAura || targetAstralActive || targetAffectedBySpell) && isAstralPerceiving;
  }
};

// src/module/vision/astralPerception/astralPerceptionBackgroundShader.ts
var AstralPerceptionBackgroundVisionShader = class extends AmplificationBackgroundVisionShader {
  static {
    __name(this, "AstralPerceptionBackgroundVisionShader");
  }
  static {
    this.COLOR_TINT = [1, 1, 0];
  }
  static {
    this.defaultUniforms = {
      ...super.defaultUniforms,
      colorTint: this.COLOR_TINT
    };
  }
};

// src/module/vision/thermographicVision/thermographicFilter.ts
var ThermographicVisionFilter = class extends AbstractBaseFilter {
  static {
    __name(this, "ThermographicVisionFilter");
  }
  static {
    //@ts-expect-error
    this.defaultUniforms = {
      luminanceThreshold: 0.5,
      alphaThreshold: 0.1
    };
  }
  static {
    /**
     * fragment shader based on the following snippets:
     * @link https://gitlab.com/peginc/swade/-/blob/develop/src/module/vision/InfravisionFilter.ts?ref_type=heads
     */
    //@ts-expect-error
    this.fragmentShader = `
  varying vec2 vTextureCoord;
  uniform sampler2D uSampler;
  uniform float luminanceThreshold;
  uniform float alphaThreshold;

  #define RED vec4(1.0, 0.0, 0.0, 1.0)
  #define YELLOW vec4(1.0, 1.0, 0.0, 1.0)
  #define BLUE vec4(0.0, 0.0, 1.0, 1.0)
  #define GREEN vec4(0.0, 1.0, 0.0, 1.0)

  void main(void) {
    vec4 texColor = texture2D(uSampler, vTextureCoord);
    float luminance = dot(vec3(0.30, 0.59, 0.11), texColor.rgb);
    if ( texColor.a > alphaThreshold ) {
      gl_FragColor = (luminance < luminanceThreshold) ? mix(BLUE, mix(YELLOW, GREEN, luminance / 0.5), luminance * 2.0 ) : mix(YELLOW, RED, (luminance - 0.5) * 2.0);
      gl_FragColor.rgb *= 0.1 + 0.25 + 0.75 * pow( 16.0 * vTextureCoord.x * vTextureCoord.y * (1.0 - vTextureCoord.x) * (1.0 - vTextureCoord.y), 0.15 );
      gl_FragColor.a = texColor.a;
    } else {
      gl_FragColor = vec4(0.0);
    }
  }`;
  }
};

// src/module/vision/thermographicVision/thermographicDetectionMode.ts
var ThermographicVisionDetectionMode = class extends DetectionMode {
  static {
    __name(this, "ThermographicVisionDetectionMode");
  }
  //@ts-expect-error
  static getDetectionFilter() {
    return this._detectionFilter ??= ThermographicVisionFilter.create();
  }
  //@ts-expect-error
  _canDetect(visionSource, target) {
    const tgt = target?.document;
    const targetHasHeat = tgt instanceof TokenDocument && tgt.actor?.system.visibilityChecks.meat.hasHeat;
    const targetIsVisible = tgt instanceof TokenDocument && !tgt.actor?.statuses.has(CONFIG.specialStatusEffects.INVISIBLE);
    const isAstralPerceiving = visionSource?.visionMode?.id === "astralPerception";
    return targetHasHeat && targetIsVisible && !isAstralPerceiving;
  }
};

// src/module/vision/lowlightVision/lowlightFilter.ts
var LowLightVisionFilter = class extends AbstractBaseFilter {
  static {
    __name(this, "LowLightVisionFilter");
  }
  static {
    //@ts-expect-error
    this.defaultUniforms = {
      luminanceThreshold: 0.5,
      alphaThreshold: 0.1
    };
  }
  static {
    /**
     * fragment shader based on the following snippets:
     * @link https://gitlab.com/peginc/swade/-/blob/develop/src/module/vision/InfravisionFilter.ts?ref_type=heads
     */
    //@ts-expect-error
    this.fragmentShader = `
  varying vec2 vTextureCoord;
  uniform sampler2D uSampler;
  uniform float luminanceThreshold;
  uniform float alphaThreshold;

  #define RED vec4(1.0, 0.0, 0.0, 1.0)
  #define YELLOW vec4(1.0, 1.0, 0.0, 1.0)
  #define BLUE vec4(0.0, 0.0, 1.0, 1.0)
  #define GREEN vec4(0.0, 1.0, 0.0, 1.0)

  void main(void) {
    vec4 texColor = texture2D(uSampler, vTextureCoord);
    float luminance = dot(vec3(0.30, 0.59, 0.11), texColor.rgb);
    if ( texColor.a > alphaThreshold ) {
      gl_FragColor = mix(vec4(0.2, 0.5, 0.2, 1), vec4(1, 1, 0.4, 1), (luminance - 0.5) * 2.0);;
      gl_FragColor.rgb *= 0.1 + 0.25 + 0.75 * pow( 16.0 * vTextureCoord.x * vTextureCoord.y * (1.0 - vTextureCoord.x) * (1.0 - vTextureCoord.y), 0.15 );
      gl_FragColor.a = texColor.a;
    } else {
      gl_FragColor = vec4(0.0);
    }
  }`;
  }
};

// src/module/vision/lowlightVision/lowlightDetectionMode.ts
var LowlightVisionDetectionMode = class extends DetectionMode {
  static {
    __name(this, "LowlightVisionDetectionMode");
  }
  //@ts-expect-error
  static getDetectionFilter() {
    return this._detectionFilter ??= LowLightVisionFilter.create();
  }
  //@ts-expect-error
  _canDetect(visionSource, target) {
    const tgt = target?.document;
    const targetIsVisible = tgt instanceof TokenDocument && !tgt.actor?.statuses.has(CONFIG.specialStatusEffects.INVISIBLE);
    const isAstralPerceiving = visionSource?.visionMode?.id === "astralPerception";
    return targetIsVisible && !isAstralPerceiving;
  }
};

// src/module/vision/augmentedReality/arFilter.ts
var AugmentedRealityVisionFilter = class extends AbstractBaseFilter {
  static {
    __name(this, "AugmentedRealityVisionFilter");
  }
  static {
    //@ts-expect-error
    this.defaultUniforms = {
      luminanceThreshold: 0.5,
      alphaThreshold: 0.1
    };
  }
  static {
    /**
     * fragment shader based on the following snippets:
     * @link https://gitlab.com/peginc/swade/-/blob/develop/src/module/vision/InfravisionFilter.ts?ref_type=heads
     */
    //@ts-expect-error
    this.fragmentShader = `
  varying vec2 vTextureCoord;
  uniform sampler2D uSampler;
  uniform float luminanceThreshold;
  uniform float alphaThreshold;

  #define RED vec4(1.0, 0.0, 0.0, 1.0)
  #define YELLOW vec4(1.0, 1.0, 0.0, 1.0)
  #define BLUE vec4(0.0, 0.0, 1.0, 1.0)
  #define GREEN vec4(0.0, 1.0, 0.0, 1.0)

  void main(void) {
    vec4 texColor = texture2D(uSampler, vTextureCoord);
    float luminance = dot(vec3(0.30, 0.59, 0.11), texColor.rgb);
    if ( texColor.a > alphaThreshold ) {
      gl_FragColor = mix(vec4(0.1, 0.1, 0.5, 1.0), vec4(0.4, 0.4, 0.8, 1.0), (luminance - 0.5) * 2.0);;
      gl_FragColor.rgb *= 0.1 + 0.25 + 0.75 * pow( 16.0 * vTextureCoord.x * vTextureCoord.y * (1.0 - vTextureCoord.x) * (1.0 - vTextureCoord.y), 0.15 );
      gl_FragColor.a = texColor.a;
    } else {
      gl_FragColor = vec4(0.0);
    }
  }`;
  }
};

// src/module/vision/augmentedReality/arDetectionMode.ts
var AugmentedRealityVisionDetectionMode = class extends DetectionMode {
  static {
    __name(this, "AugmentedRealityVisionDetectionMode");
  }
  //@ts-expect-error
  static getDetectionFilter() {
    return this._detectionFilter ??= AugmentedRealityVisionFilter.create();
  }
  //@ts-expect-error
  _canDetect(visionSource, target) {
    const tgt = target?.document;
    const targetHasIcon = tgt instanceof TokenDocument && tgt.actor?.system.visibilityChecks.matrix.hasIcon;
    const targetIsNotRunningSilent = !tgt.actor?.system.visibilityChecks.matrix.runningSilent;
    const isAstralPerceiving = visionSource?.visionMode?.id === "astralPerception";
    return targetHasIcon && targetIsNotRunningSilent && !isAstralPerceiving;
  }
};

// src/module/vision/visionConfigurator.ts
var VisionConfigurator = class {
  static {
    __name(this, "VisionConfigurator");
  }
  static configureAstralPerception() {
    CONFIG.Canvas.detectionModes.astralPerception = new AstralPerceptionDetectionMode({
      id: "astralPerception",
      label: "SR6.Vision.AstralPerception",
      //@ts-expect-error
      type: DetectionMode.DETECTION_TYPES.SIGHT
    });
    CONFIG.Canvas.visionModes.astralPerception = new VisionMode({
      id: "astralPerception",
      label: "SR6.Vision.AstralPerception",
      canvas: {
        //@ts-expect-error
        shader: ColorAdjustmentsSamplerShader,
        uniforms: {
          saturation: 5,
          tint: AstralPerceptionBackgroundVisionShader.COLOR_TINT
        }
      },
      lighting: {
        //@ts-expect-error
        background: { visibility: VisionMode.LIGHTING_VISIBILITY.DISABLED },
        //@ts-expect-error
        illumination: { visibility: VisionMode.LIGHTING_VISIBILITY.DISABLED },
        //@ts-expect-error
        coloration: { visibility: VisionMode.LIGHTING_VISIBILITY.DISABLED }
      },
      vision: {
        darkness: { adaptive: false },
        background: { shader: AstralPerceptionBackgroundVisionShader }
      }
    });
  }
  static configureThermographicVision() {
    CONFIG.Canvas.detectionModes.thermographic = new ThermographicVisionDetectionMode({
      id: "thermographic",
      label: "SR6.Vision.ThermographicVision",
      //@ts-expect-error
      type: DetectionMode.DETECTION_TYPES.SIGHT
    });
  }
  static configureLowlight() {
    CONFIG.Canvas.detectionModes.lowlight = new LowlightVisionDetectionMode({
      id: "lowlight",
      label: "SR6.Vision.LowLight",
      //@ts-expect-error
      type: DetectionMode.DETECTION_TYPES.SIGHT
    });
  }
  static configureAR() {
    CONFIG.Canvas.detectionModes.augmentedReality = new AugmentedRealityVisionDetectionMode({
      id: "augmentedReality",
      label: "SR6.Vision.AugmentedReality",
      //@ts-expect-error
      type: DetectionMode.DETECTION_TYPES.SIGHT
    });
  }
};

// src/module/effect/autoinline/AutocompleteInlineHooksFlow.ts
var AutocompleteInlineHooksFlow = {
  /**
   * Add support for https://github.com/schultzcole/FVTT-Autocomplete-Inline-Properties module
   * to give auto complete for active effect attribute keys.
   *
   * This is taken from: https://github.com/schultzcole/FVTT-Autocomplete-Inline-Properties/blob/master/CONTRIBUTING.md
   * It partially uses: https://github.com/schultzcole/FVTT-Autocomplete-Inline-Properties/blob/master/package-config.mjs#L141
   */
  setupHook: /* @__PURE__ */ __name(() => {
    const aipModule = game.modules.get("autocomplete-inline-properties");
    if (!aipModule) return;
    const api = aipModule.API;
    if (!api) return;
    console.debug("Shadowrun 6e | Registering support for autocomplete-inline-properties");
    const DATA_MODE = api.CONST.DATA_MODE;
    const config = {
      packageName: "shadowrun6-elysium",
      sheetClasses: [{
        name: "ActiveEffectConfig",
        fieldConfigs: [
          { selector: `.tab[data-tab="effects"] .autocomplete-key-actor input[type="text"]`, defaultPath: "system", showButton: true, allowHotkey: true, dataMode: DATA_MODE.OWNING_ACTOR_DATA },
          { selector: `.tab[data-tab="effects"] .autocomplete-key-targeted_actor input[type="text"]`, defaultPath: "system", showButton: true, allowHotkey: true, dataMode: DATA_MODE.OWNING_ACTOR_DATA },
          { selector: `.tab[data-tab="effects"] .autocomplete-key-test_all input[type="text"]`, defaultPath: "", showButton: true, allowHotkey: true, dataMode: DATA_MODE.CUSTOM, customDataGetter: AutocompleteInlineHooksFlow.keyGetterTestData },
          { selector: `.tab[data-tab="effects"] .autocomplete-key-test_item input[type="text"]`, defaultPath: "", showButton: true, allowHotkey: true, dataMode: DATA_MODE.CUSTOM, customDataGetter: AutocompleteInlineHooksFlow.keyGetterTestData },
          { selector: `.tab[data-tab="effects"] .autocomplete-key-modifier input[type="text"]`, defaultPath: "", showButton: true, allowHotkey: true, dataMode: DATA_MODE.CUSTOM, customDataGetter: AutocompleteInlineHooksFlow.keyGetterModifiersData },
          { selector: `.tab[data-tab="effects"] .autocomplete-value-actor input[type="text"]`, defaultPath: "system", inlinePrefix: "@", showButton: true, allowHotkey: true, dataMode: DATA_MODE.CUSTOM, customDataGetter: AutocompleteInlineHooksFlow.valueGetterActor },
          { selector: `.tab[data-tab="effects"] .autocomplete-value-targeted_actor input[type="text"]`, defaultPath: "", inlinePrefix: "@", showButton: true, allowHotkey: true, dataMode: DATA_MODE.CUSTOM, customDataGetter: AutocompleteInlineHooksFlow.valueGetterTargetedActorData },
          { selector: `.tab[data-tab="effects"] .autocomplete-value-test_all input[type="text"]`, defaultPath: "system", inlinePrefix: "@", showButton: true, allowHotkey: true, dataMode: DATA_MODE.CUSTOM, customDataGetter: AutocompleteInlineHooksFlow.valueGetterTestData },
          { selector: `.tab[data-tab="effects"] .autocomplete-value-test_item input[type="text"]`, defaultPath: "system", inlinePrefix: "@", showButton: true, allowHotkey: true, dataMode: DATA_MODE.CUSTOM, customDataGetter: AutocompleteInlineHooksFlow.valueGetterTestData }
        ]
      }]
    };
    api.PACKAGE_CONFIG.push(config);
  }, "setupHook"),
  /**
   * Getter to show values for apply-to actor.
   *
   * @param EffectConfig The effect config supplying the effect context.
   * @returns Either a SR6Actor or SR6Item source object.
   */
  valueGetterActor: /* @__PURE__ */ __name((EffectConfig) => {
    const effect = EffectConfig.object;
    if (!effect.parent) return {};
    return effect.parent?.toObject();
  }, "valueGetterActor"),
  /**
   * Getter to show keys for apply-to test_all and test_item
   *
   * @param EffectConfig The effect config supplying the effect context.
   * @returns A test object for the autocomplete module to use.
   */
  keyGetterTestData: /* @__PURE__ */ __name((EffectConfig) => {
    const effect = EffectConfig.object;
    if (effect.selectionTests.length > 0) {
      const actor = effect.actor;
      const testData = {};
      for (const TestClassName of effect.selectionTests) {
        if (!TestClassName) return {};
        const TestClass = TestCreator._getTestClass(TestClassName);
        if (!TestClass) return {};
        const test = new TestClass({}, { actor });
        foundry.utils.mergeObject(testData, test.data);
      }
      return { data: testData };
    }
    if (effect.isActorOwned) {
      return { data: new SuccessTest({}).data };
    }
    if (effect.isItemOwned) {
      const item = effect.parent;
      const action = item.getAction();
      if (!action) return {};
      const SuccessTestClass = TestCreator._getTestClass(action.test) || SuccessTest;
      return { data: new SuccessTestClass({}, { actor: item.actor, item }).data };
    }
  }, "keyGetterTestData"),
  /**
   * Getter to show values for apply-to test_all and test_item
   *
   * @param EffectConfig
   */
  valueGetterTestData: /* @__PURE__ */ __name((EffectConfig) => {
    const effect = EffectConfig.object;
    if (!effect.parent) return {};
    const values = effect.parent.toObject();
    if (effect.parent.parent) {
      values["actor"] = effect.parent.parent.toObject();
    }
    return values;
  }, "valueGetterTestData"),
  /**
   * Getter to show data for apply-to modifier.
   *
   * Modifier effects don't apply directly to data but allow the system to use keys to determine what rules
   * apply at any point in the system.
   *
   * environmental is applied during calculation of situational modifiers.
   * Others might be applied where ever.
   *
   * @param EffectConfig The effect config supplying the effect context.
   * @returns A simple object for autocomplete module to use.
   */
  keyGetterModifiersData: /* @__PURE__ */ __name((EffectConfig) => {
    return { environmental: {
      low_light_vision: "",
      image_magnification: "",
      tracer_rounds: "",
      smartlink: "",
      ultrasound: "",
      thermographic_vision: ""
    } };
  }, "keyGetterModifiersData"),
  /**
   * Getter to show as many fields available as possible as closely matching the parent item of the effect.
   *
   * When apply-to targeted Actor is used, the values can access all values in relation of the opposed test.
   * Effects for targeted actors are applied from within the opposed actor context.
   *
   * @param EffectConfig The effect config supplying the effect context.
   * @returns A opposed test instance for autocomplete module to use.
   */
  valueGetterTargetedActorData: /* @__PURE__ */ __name((EffectConfig) => {
    const effect = EffectConfig.object;
    if (effect.parent instanceof SR6Item) {
      const item = effect.parent;
      const action = item.getAction();
      if (!action) return {};
      const SuccessTestClass = TestCreator._getTestClass(action.test) || SuccessTest;
      const OpposedTestClass = TestCreator._getTestClass(action.opposed.test) || OpposedTest;
      const successTest = new SuccessTestClass({});
      const opposedTest = new OpposedTestClass({ against: successTest.data }, { actor: item.actor, item });
      return { data: opposedTest.data };
    }
  }, "valueGetterTargetedActorData")
};

// src/module/systemLinks.ts
var RenderSettings = {
  listen: /* @__PURE__ */ __name(() => {
    Hooks.on("renderSettings", async (_app, $html) => {
      const html = $html[0];
      const systemRow = html.querySelector(".settings-sidebar li.system");
      const systemInfo = systemRow?.cloneNode(false);
      if (!(systemInfo instanceof HTMLLIElement)) {
        throw Error("Unexpected error attach system information to settings sidebar");
      }
      systemInfo.classList.remove("system");
      systemInfo.classList.add("system-links");
      const links = [
        {
          url: "https://github.com/SR5-FoundryVTT/SR5-FoundryVTT/releases/latest/",
          label: "SR6.Labels.Sidebar.Changelog"
        },
        {
          url: "https://github.com/SR5-FoundryVTT/SR5-FoundryVTT/issues/",
          label: "SR6.Labels.Sidebar.Issues"
        },
        {
          url: "http://sr5-foundryvtt.privateworks.com/index.php/Main_Page",
          label: "SR6.Labels.Sidebar.Wiki"
        }
      ].map((data) => {
        const anchor = document.createElement("a");
        anchor.href = data.url;
        anchor.innerText = game.i18n.localize(data.label);
        anchor.target = "_blank";
        return anchor;
      });
      systemInfo.append(...links);
      systemRow?.after(systemInfo);
    });
  }, "listen")
};

// src/module/tours/sr6Tours.ts
var Sr5Tour = class extends Tour {
  static {
    __name(this, "Sr5Tour");
  }
  /** @override */
  async _preStep() {
    await super._preStep();
    if (this.actor == void 0) {
      this.actor = new SR6Actor.implementation({
        //@ts-expect-error
        name: "Tour " + this.id,
        // @ts-expect-error
        type: this.config.actorType,
        ownership: {
          default: 3
        }
      });
    }
    await this.actor.sheet?._render(true, { editable: false });
    if (this.config.tab) {
      this.actor?.sheet?.activateTab(this.config.tab);
    }
  }
  /** @override */
  async complete() {
    await this.actor?.sheet?.close();
    return super.complete();
  }
};

// src/module/tours/tours.ts
async function registerSR5Tours() {
  try {
    game.tours.register(
      "shadowrun6-elysium",
      "ConditionMonitor",
      // @ts-expect-error
      await Sr5Tour.fromJSON("/systems/shadowrun6-elysium/dist/tours/ConditionMonitor.json")
    );
  } catch (err) {
    console.log(err);
  }
}
__name(registerSR5Tours, "registerSR5Tours");

// src/module/journal/enricher.ts
var JournalEnrichers = class _JournalEnrichers {
  static {
    __name(this, "JournalEnrichers");
  }
  static get skillKeywords() {
    return ["Teamwork", "RollSkill"];
  }
  static get attributeKeywords() {
    return ["RollAttribute"];
  }
  static get actorKeywords() {
    return this.skillKeywords.concat(this.attributeKeywords);
  }
  static setEnrichers() {
    const opening = "(\\[|\\()";
    const closing = "(\\]|\\))";
    const threshold = "\\s*(\\d*)";
    CONFIG.TextEditor.enrichers.push(
      {
        pattern: new RegExp(`\\@(${_JournalEnrichers.actorKeywords.join("|")})${opening}([a-z]+)${threshold}${closing}`, "g"),
        enricher: /* @__PURE__ */ __name((match, options) => {
          const type = match[1];
          const rollEntity = match[3];
          const threshold2 = match[4];
          let rollEntityName = _JournalEnrichers.getRollEntityTranslation(type, rollEntity);
          return $(`<a class="sr6-roll-request" data-request="${type}" data-skill="${rollEntity}" data-threshold=${threshold2}><em class="fas fa-dice"></em>${rollEntityName} ${threshold2}</a>`)[0];
        }, "enricher")
      }
    );
  }
  /**
   * This hook listens to roll-request clicks, extracts the data and forwards it to create a chat message
   * @param journal The journal where the roll is triggered
   * @param html the triggering html
   * @param data
   */
  static async setEnricherHooks(journal, html, data) {
    const rolls = {
      "Teamwork": "startTeamworkTest",
      "RollSkill": "rollSkill",
      "RollAttribute": "rollAttribute"
    };
    html.on("click", ".sr6-roll-request", (ev) => {
      const element = ev.currentTarget;
      const rollType = element.dataset.request;
      const rollTypeName = "SR6.GMRequest." + rollType;
      const rollEntity = element.dataset.skill;
      let rollEntityName = _JournalEnrichers.getRollEntityTranslation(rollType, rollEntity);
      const threshold = element.dataset.threshold;
      const templateData = {
        rollType: rolls[rollType],
        rollTypeName,
        rollEntity,
        rollEntityName,
        threshold
      };
      _JournalEnrichers.createChatMessage(templateData);
    });
  }
  /**
   * This method provides translations respecting the rollType
   * @param type what rollType is requestd
   * @param rollEntity what should be rolled
   * @returns the translation or rollEntity when the keyword is unknown
   */
  static getRollEntityTranslation(type, rollEntity) {
    if (_JournalEnrichers.skillKeywords.includes(type)) {
      return Helpers.getSkillTranslation(rollEntity);
    }
    if (_JournalEnrichers.attributeKeywords.includes(type)) {
      return Helpers.getAttributeTranslation(rollEntity);
    }
    return rollEntity;
  }
  static async chatlogRequestHooks(html) {
    html.find(".chat-message").each(async (index, element) => {
      element = $(element);
      const id = element.data("messageId");
      const message = game.messages?.get(id);
      if (!message) return;
      await this.messageRequestHooks(element);
    });
  }
  static async messageRequestHooks(html) {
    html.find(".sr6-requestAnswer").on("click", async (ev) => {
      const element = ev.currentTarget;
      const rollType = element.dataset.request;
      const rollEntity = element.dataset.rollentity;
      const threshold = parseInt(element.dataset.threshold);
      let actor = await Helpers.chooseFromAvailableActors();
      if (actor == void 0) {
        ui.notifications?.error("SR6.Errors.NoAvailableActorFound", { localize: true });
        return;
      }
      actor[rollType](rollEntity, { threshold: { base: threshold, value: threshold } });
    });
  }
  static async createChatMessage(templateData) {
    const html = await renderTemplate("systems/shadowrun6-elysium/dist/templates/chat/rollRequest.html", templateData);
    const chatData = {
      user: game.user?.id,
      speaker: ChatMessage.getSpeaker(),
      content: html
    };
    await ChatMessage.create(chatData);
  }
};

// src/module/data/DataStorage.ts
var DataStorage = {
  /**
   * Assure a usable data storage, even if data is lost.
   */
  validate: /* @__PURE__ */ __name(async function() {
    console.debug("Shadowrun 6e | Validating global data storage.");
    const storage = DataStorage.storage();
    if (!storage || typeof storage !== "object") {
      ui.notifications?.error("Shadowrun 6e | Global data storage has been reset. Please check the console (F12) for more information.");
      console.error("Shadowrun 6e | Global data storage could not be loaded. Resetting to empty object. This might cause some game information to be deleted.", storage);
      await game.settings.set(SYSTEM_NAME, FLAGS.GlobalDataStorage, {});
    }
  }, "validate"),
  /**
   * Retrieve the top level storage object.
   *
   * @returns object
   */
  storage: /* @__PURE__ */ __name(function() {
    return game.settings.get(SYSTEM_NAME, FLAGS.GlobalDataStorage);
  }, "storage"),
  /**
   * Overwrite the global data storage with a new object.
   *
   * @param storage The complete global storage. This will fully overwrite the current storage.
   */
  save: /* @__PURE__ */ __name(async function(storage) {
    await game.settings.set(SYSTEM_NAME, FLAGS.GlobalDataStorage, storage);
  }, "save"),
  /**
   * Retrieve a storage key from the global data storage in a FoundryVTT typical way.
   * @param key A object property string 'key1.key2'
   * @returns any or undefined if not found
   */
  get: /* @__PURE__ */ __name(function(key) {
    return foundry.utils.getProperty(this.storage(), key);
  }, "get"),
  /**
   * Store a value in the global data storage.
   *
   * @param key A object property string 'key1.key2'
   * @param value Any value to store. Take care to not overwrite complete objects, if unwanted.
   */
  set: /* @__PURE__ */ __name(async function(key, value) {
    if (game.user?.isGM) await this._setAsGM(key, value);
    else await this._setAsPlayer(key, value);
  }, "set"),
  /**
   * Store a value in the global data storage as GM, as players lack the permission for it.
   */
  _setAsGM: /* @__PURE__ */ __name(async function(key, value) {
    const storage = this.storage();
    console.debug("Shadowrun 6e | Setting a value in global data storage.", key, value, storage);
    foundry.utils.setProperty(storage, key, value);
    await DataStorage.save(storage);
    console.debug("Shadowrun 6e | Value set in global data storage.", storage);
  }, "_setAsGM"),
  /**
   * Store a value in the global data storage as a player, by requesting the GM to do it.
   */
  _setAsPlayer: /* @__PURE__ */ __name(async function(key, value) {
    console.debug("Shadowrun 6e | Requesting GM to set a value in global data storage.", key, value);
    await SocketMessage.emitForGM(FLAGS.SetDataStorage, { key, value });
  }, "_setAsPlayer"),
  /**
   * Handle socket messages around setting data storage as GM only.
   * @param message.data.key The set method key param
   * @param message.data.value The set method value param
   */
  _handleSetDataStorageSocketMessage: /* @__PURE__ */ __name(async function(message) {
    if (!game.user?.isGM) return;
    await DataStorage._setAsGM(message.data.key, message.data.value);
  }, "_handleSetDataStorageSocketMessage")
};

// src/module/hooks.ts
var HooksManager = class _HooksManager {
  static {
    __name(this, "HooksManager");
  }
  static registerHooks() {
    console.log("Shadowrun 6e | Registering system hooks");
    Hooks.once("init", _HooksManager.init);
    Hooks.once("setup", AutocompleteInlineHooksFlow.setupHook);
    Hooks.on("canvasInit", canvasInit);
    Hooks.on("ready", _HooksManager.ready);
    Hooks.on("hotbarDrop", _HooksManager.hotbarDrop);
    Hooks.on("renderSceneControls", _HooksManager.renderSceneControls);
    Hooks.on("getSceneControlButtons", _HooksManager.getSceneControlButtons);
    Hooks.on("getCombatTrackerEntryContext", SR6Combat.addCombatTrackerContextOptions);
    Hooks.on("renderItemDirectory", _HooksManager.renderItemDirectory);
    Hooks.on("renderTokenHUD", SituationModifiersApplication.onRenderTokenHUD);
    Hooks.on("updateItem", _HooksManager.updateIcConnectedToHostItem);
    Hooks.on("deleteItem", _HooksManager.removeDeletedItemsFromNetworks);
    Hooks.on("getChatLogEntryContext", SuccessTest.chatMessageContextOptions);
    Hooks.on("renderChatLog", _HooksManager.chatLogListeners);
    Hooks.on("preUpdateCombatant", SR6Combat.onPreUpdateCombatant);
    Hooks.on("quenchReady", quenchRegister);
    RenderSettings.listen();
  }
  static init() {
    console.log(`Loading Shadowrun 5e System
___________________
 ___________ _____ 
/  ___| ___ \\  ___|
\\ \`--.| |_/ /___ \\ 
 \`--. \\    /    \\ \\
/\\__/ / |\\ \\/\\__/ /
\\____/\\_| \\_\\____/ 
===================
`);
    game["shadowrun6-elysium"] = {
      /**
       * System level Document implementations.
       */
      SR6Actor,
      SR6Item,
      SR6ActiveEffect,
      /**
       * Macro hooks used when something's dropped onto the hotbar.
       */
      rollItemMacro,
      rollSkillMacro,
      /**
       * Should you only really need dice handling, use this. If you need more complex testing behaviour,
       * check the Test implementations.
       */
      SR6Roll,
      /**
       * You want to create a test from whatever source?
       * Use this.
       */
      test: TestCreator,
      data: DataDefaults,
      /**
       * You want to access or alter situational modifiers on any document?
       * Use this.
       */
      modifiers: DocumentSituationModifiers,
      /**
       * .tests define what test implementation to use for each test type (key).
       * Should you want to override default behavior for SuccessTest types, overwrite
       * the SuccessTest class reference here
       */
      tests: {
        SuccessTest,
        OpposedTest,
        MeleeAttackTest,
        RangedAttackTest,
        ThrownAttackTest,
        PhysicalDefenseTest,
        SuppressionDefenseTest,
        PhysicalResistTest,
        SpellCastingTest,
        RitualSpellcastingTest,
        OpposedRitualTest,
        CombatSpellDefenseTest,
        DrainTest,
        FadeTest,
        ComplexFormTest,
        AttributeOnlyTest,
        SkillTest,
        NaturalRecoveryStunTest,
        NaturalRecoveryPhysicalTest,
        PilotVehicleTest,
        DronePerceptionTest,
        DroneInfiltrationTest,
        SummonSpiritTest,
        OpposedSummonSpiritTest,
        CompileSpriteTest,
        OpposedCompileSpriteTest
      },
      /**
       * Subset of tests meant to be used as the main, active test.
       *
       * These will show up on actions when defining the main test to be used.
       */
      activeTests: {
        SuccessTest,
        MeleeAttackTest,
        RangedAttackTest,
        ThrownAttackTest,
        PhysicalResistTest,
        SuppressionDefenseTest,
        SpellCastingTest,
        ComplexFormTest,
        PhysicalDefenseTest,
        NaturalRecoveryStunTest,
        NaturalRecoveryPhysicalTest,
        DrainTest,
        FadeTest,
        PilotVehicleTest,
        DronePerceptionTest,
        DroneInfiltrationTest,
        SummonSpiritTest,
        CompileSpriteTest,
        RitualSpellcastingTest
      },
      /**
       * Subset of tests meant to be used as opposed tests.
       *
       * These will show up on actions when defining an opposed test.
       */
      opposedTests: {
        OpposedTest,
        PhysicalDefenseTest,
        SuppressionDefenseTest,
        CombatSpellDefenseTest,
        OpposedSummonSpiritTest,
        OpposedCompileSpriteTest,
        OpposedRitualTest
      },
      /**
       * Subset of tests meant to be used as resist tests.
       *
       * Instead of showing on the action configuration these are connected to active or opposed test.
       */
      resistTests: {
        PhysicalResistTest
      },
      /**
       * Subset of tests meant to follow a main active test
       */
      followedTests: {
        DrainTest,
        FadeTest
      },
      /**
       * Amount of delay used on user filter inputs.
       * This came out of an unclear user issue regarding multi-char UTF symbol inputs, to allow
       * 'interactive' changing of the delay on the user side until a sweet spot could be found.
       */
      inputDelay: 300,
      /**
       * The global data storage for the system.
       */
      storage: DataStorage
    };
    CONFIG.Actor.documentClass = SR6Actor;
    CONFIG.Item.documentClass = SR6Item;
    CONFIG.Combat.documentClass = SR6Combat;
    CONFIG.ChatMessage.documentClass = SR6ChatMessage;
    CONFIG.ActiveEffect.documentClass = SR6ActiveEffect;
    CONFIG.ActiveEffect.legacyTransferral = false;
    CONFIG.Token.objectClass = SR6Token;
    CONFIG.Combat.initiative.formula = "@initiative.current.base.value[Base] + @initiative.current.dice.text[Dice] - @wounds.value[Wounds]";
    Combatant.prototype._getInitiativeFormula = _combatantGetInitiativeFormula;
    CONFIG.Dice.rolls.push(SR6Roll);
    CONFIG.Dice.SR6oll = SR6Roll;
    CONFIG.SR6 = SR6;
    registerSystemSettings();
    registerSystemKeybindings();
    Actors.unregisterSheet("core", ActorSheet);
    Actors.registerSheet(SYSTEM_NAME, SR6CharacterSheet, {
      label: "SR6.SheetActor",
      makeDefault: true,
      types: ["critter", "character"]
    });
    Actors.registerSheet(SYSTEM_NAME, SR6ICActorSheet, {
      label: "SR6.SheetActor",
      makeDefault: true,
      types: ["ic"]
    });
    Actors.registerSheet(SYSTEM_NAME, SR6VehicleActorSheet, {
      label: "SR6.SheetActor",
      makeDefault: true,
      types: ["vehicle"]
    });
    Actors.registerSheet(SYSTEM_NAME, SR6SpiritActorSheet, {
      label: "SR6.SheetActor",
      makeDefault: true,
      types: ["spirit"]
    });
    Actors.registerSheet(SYSTEM_NAME, SR6SpriteActorSheet, {
      label: "SR6.SheetActor",
      makeDefault: true,
      types: ["sprite"]
    });
    Items.unregisterSheet("core", ItemSheet);
    Items.registerSheet(SYSTEM_NAME, SR6ItemSheet, {
      label: "SR6.SheetItem",
      makeDefault: true
    });
    Items.registerSheet(SYSTEM_NAME, SR6CallInActionSheet, {
      label: "SR6.SheetItem",
      makeDefault: true,
      types: ["call_in_action"]
    });
    DocumentSheetConfig.unregisterSheet(ActiveEffect, "core", ActiveEffectConfig);
    DocumentSheetConfig.registerSheet(ActiveEffect, SYSTEM_NAME, SR6ActiveEffectConfig, {
      makeDefault: true
    });
    _HooksManager.configureVision();
    _HooksManager.configureTextEnrichers();
    HandlebarManager.loadTemplates();
    registerSR5Tours();
    DataStorage.validate();
  }
  static async ready() {
    if (game.user?.isGM) {
      if (Migrator.isEmptyWorld) {
        await Migrator.InitWorldForMigration();
        return;
      }
      await Migrator.BeginMigration();
      if (ChangelogApplication.showApplication) {
        await new ChangelogApplication().render(true);
      }
    }
    const diceIconSelector = "#chat-controls .roll-type-select .fa-dice-d20";
    $(document).on("click", diceIconSelector, async () => await TestCreator.promptSuccessTest());
    const diceIconSelectorNew = "#chat-controls .chat-control-icon .fa-dice-d20";
    $(document).on("click", diceIconSelectorNew, async () => await TestCreator.promptSuccessTest());
    Hooks.on("renderChatMessage", _HooksManager.chatMessageListeners);
    Hooks.on("renderJournalPageSheet", JournalEnrichers.setEnricherHooks);
    _HooksManager.registerSocketListeners();
  }
  /**
   * Handle drop events on the hotbar creating different macros.
   *
   * NOTE: FoundryVTT Hook callbacks won't be resolved when returning a promise.
   *       While this function calls async methods, it's order of operations isn't important.
   *
   * @param bar
   * @param dropData
   * @param slot
   * @return false when callback has been handled, otherwise let Foundry default handling kick in
   */
  static hotbarDrop(bar, dropData, slot) {
    switch (dropData.type) {
      case "Item":
        createItemMacro(dropData, slot);
        return false;
      case "Skill":
        createSkillMacro(dropData.data, slot);
        return false;
    }
  }
  static renderSceneControls(controls, html) {
    html.find('[data-tool="overwatch-score-tracker"]').on("click", (event) => {
      event.preventDefault();
      new OverwatchScoreTracker().render(true);
    });
  }
  static getSceneControlButtons(controls) {
    const tokenControls = controls.find((c2) => c2.name === "token");
    if (game.user?.isGM) {
      tokenControls.tools.push({
        name: "overwatch-score-tracker",
        title: "CONTROLS.SR6.OverwatchScoreTracker",
        icon: "fas fa-network-wired",
        button: true
      });
    }
    tokenControls.tools.push(SituationModifiersApplication.getControl());
  }
  /**
   * Register renderChatMessage Hooks using FoundryVTT Hooks.on for each registered test type.
   *
   * This will avoid calling the same method on different types twice.
   *
   * Must be called on 'ready' or after game.shadowrun is registered.
   */
  static renderChatMessage() {
    console.debug("SR6: Elysium | Registering new chat messages related hooks");
  }
  static renderItemDirectory(app, html) {
    if (!game.user?.isGM) {
      return;
    }
    const button = $('<button class="sr6 flex0">Import Chummer Data</button>');
    html.find("footer").before(button);
    button.on("click", (event) => {
      new Import().render(true);
    });
  }
  /**
   * On each
   * @param item
   * @param data
   * @param id
   */
  static async updateIcConnectedToHostItem(item, data, id) {
    if (!canvas.ready || !game.actors) return;
    if (item.isHost) {
      let connectedIC = [
        // All sidebar actors should also include tokens with linked actors.
        ...game.actors.filter((actor) => actor.isIC() && actor.hasHost()),
        // All token actors that aren't linked.
        // @ts-expect-error // TODO: foundry-vtt-types v10
        ...canvas.scene.tokens.filter((token) => !token.actorLink && token.actor?.isIC() && token.actor?.hasHost()).map((t2) => t2.actor)
      ];
      const host = item.asHost;
      if (!host) return;
      for (const ic of connectedIC) {
        if (!ic) continue;
        await ic._updateICHostData(host);
      }
    }
  }
  static async removeDeletedItemsFromNetworks(item, data, id) {
    await NetworkDeviceFlow.handleOnDeleteItem(item, data, id);
  }
  /**
   * This method is used as a simple place to register socket hook handlers for the system.
   *
   * You can use the SocketMessage for sending messages using a socket event message id and generic data object.
   */
  static registerSocketListeners() {
    if (!game.socket || !game.user) return;
    console.log("Registering shadowrun6-elysium system socket messages...");
    const hooks = {
      [FLAGS.addNetworkController]: [NetworkDeviceFlow._handleAddNetworkControllerSocketMessage],
      [FLAGS.DoNextRound]: [SR6Combat._handleDoNextRoundSocketMessage],
      [FLAGS.DoInitPass]: [SR6Combat._handleDoInitPassSocketMessage],
      [FLAGS.DoNewActionPhase]: [SR6Combat._handleDoNewActionPhaseSocketMessage],
      [FLAGS.CreateTargetedEffects]: [SuccessTestEffectsFlow._handleCreateTargetedEffectsSocketMessage],
      [FLAGS.TeamworkTestFlow]: [TeamworkTest._handleUpdateSocketMessage],
      [FLAGS.SetDataStorage]: [DataStorage._handleSetDataStorageSocketMessage]
    };
    game.socket.on(SYSTEM_SOCKET, async (message) => {
      console.log("Shadowrun 6e | Received system socket message.", message);
      const handlers = hooks[message.type];
      if (!handlers || handlers.length === 0) return console.warn("Shadowrun 6e | System socket message has no registered handler!", message);
      if (message.userId && game.user?.id !== message.userId) return;
      if (message.userId && game.user?.id) console.log("Shadowrun 6e | GM is handling system socket message");
      for (const handler of handlers) {
        console.debug(`Shadowrun 6e | Handover system socket message to handler: ${handler.name}`);
        await handler(message);
      }
    });
  }
  static async chatMessageListeners(message, html, data) {
    await SuccessTest.chatMessageListeners(message, html, data);
    await OpposedTest.chatMessageListeners(message, html, data);
    await ActionFollowupFlow.chatMessageListeners(message, html, data);
    await TeamworkTest.chatMessageListeners(message, html);
    await JournalEnrichers.messageRequestHooks(html);
  }
  static async chatLogListeners(chatLog, html, data) {
    await SuccessTest.chatLogListeners(chatLog, html, data);
    await OpposedTest.chatLogListeners(chatLog, html, data);
    await ActionFollowupFlow.chatLogListeners(chatLog, html, data);
    await TeamworkTest.chatLogListeners(chatLog, html);
    await JournalEnrichers.chatlogRequestHooks(html);
  }
  static configureVision() {
    VisionConfigurator.configureAstralPerception();
    VisionConfigurator.configureThermographicVision();
    VisionConfigurator.configureLowlight();
    VisionConfigurator.configureAR();
  }
  static async configureTextEnrichers() {
    await JournalEnrichers.setEnrichers();
  }
};

// src/module/main.ts
HooksManager.registerHooks();
HandlebarManager.registerHelpers();
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

sax/lib/sax.js:
  (*! http://mths.be/fromcodepoint v0.1.0 by @mathias *)
*/
//# sourceMappingURL=bundle.js.map
